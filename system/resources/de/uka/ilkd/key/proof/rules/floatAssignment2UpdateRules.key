// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2014 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


\schemaVariables {
  \modalOperator {diamond, box, diamond_transaction, box_transaction} #normalassign;

  \program JavaFloatExpression #seFloat, #seFloat0, #seFloat1 ;
  \program JavaLongExpression #seLong;

  \program Variable #loc ;

  \program Variable #v;

 \program NonSimpleExpression #nse;

  \formula post;
}



\rules(programRules:Java) {

  //------------- unary minus for float

  unaryMinusFloat { 
     \find (\modality{#normalassign}{.. 
                #loc = - #seFloat; 
            ...}\endmodality(post)) 
     \replacewith({#loc:=javaUnaryMinusFloat(#seFloat)}
                      \modality{#normalassign}{..  ...}\endmodality(post))
     \heuristics(executeFloatAssignment)
     \displayname "unaryMinus"
  };

  //------------- Arithmetic operations

  assignmentAdditionFloat  { 
      \find(\modality{#normalassign}{.. 
                #loc=#seFloat0 + #seFloat1; 
            ...}\endmodality(post)) 
     \replacewith(
         {#loc:=javaAddFloat(#seFloat0,#seFloat1)}
             \modality{#normalassign}{.. ...}\endmodality(post)) 
     \heuristics(executeFloatAssignment)
     \displayname "subtraction"
  };

  assignmentSubtractionFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 - #seFloat1; 
             ...}\endmodality(post)) 
      \replacewith (
          {#loc:=javaSubFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "multiplication"
  };

  assignmentMultiplicationFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 * #seFloat1; 
             ...}\endmodality(post)) 
      \replacewith (
          {#loc:=javaMulFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "multiplication"
  };

  assignmentDivisionFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 / #seFloat1; 
             ...}\endmodality(post)) 
      \replacewith (
          {#loc:=javaDivFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "division"
  };

  // Operations on combined float/int

  intLongToFloatAddition1  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seLong + #seFloat;
             ...}\endmodality(post)) 
      \replacewith ({#loc := javaAddFloat(castLongToFloat(#seLong), #seFloat)}
            \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "float addition"
  };

  castLongToFloatAddition2  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat + #seLong; 
             ...}\endmodality(post)) 
      \replacewith ({#loc := javaAddFloat(#seFloat, castLongToFloat(#seLong))}
            \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "float addition"
  };

  // Typecasts


  wideningCastIntToFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = (float) #seLong; 
             ...}\endmodality(post)) 
      \replacewith ( {#loc := castLongToFloat(#seLong)}
           \modality{#normalassign}{..  ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "cast"
  };

  identityCastFloat { 
      \find (\modality{#normalassign}{.. 
                 #loc = (float) #seFloat; 
             ...}\endmodality(post)) 
      \replacewith (\modality{#normalassign}{.. 
                 #loc = #seFloat; 
             ...}\endmodality(post)) 
      \heuristics(simplify_expression)
      \displayname "identity cast"
  };

  narrowingCastFloatToInt { 
      \find (\modality{#normalassign}{.. 
                 #loc = (int) #seFloat; 
             ...}\endmodality(post)) 
     \replacewith ({#loc := castFloatToLong(#seFloat)}
           \modality{#normalassign}{..  ...}\endmodality(post)) 
     \heuristics (executeFloatAssignment)
      \displayname "cast"
  };


  // Non-simple expressions

  compound_float_cast_expression { \find (\modality{#normalassign}{.. #loc = (float) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#normalassign}{.. #typeof(#nse) #v = #nse; #loc = (float) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast"
  };

}
