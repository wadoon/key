// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2014 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


\schemaVariables {
  \modalOperator {diamond, box, diamond_transaction, box_transaction} #normalassign;

  \program JavaFloatExpression #seFloat, #seFloat0, #seFloat1 ;
  \program JavaCharByteShortIntExpression #seCharByteShortInt;

  \program Variable #loc ;

  \formula post;
}



\rules(programRules:Java) {

  //------------- unary minus for float

  unaryMinusFloat { 
     \find (\modality{#normalassign}{.. 
                #loc = - #seFloat; 
            ...}\endmodality(post)) 
     \replacewith({#loc:=javaUnaryMinusFloat(#seFloat)}
                      \modality{#normalassign}{..  ...}\endmodality(post))
     \heuristics(executeFloatAssignment)
     \displayname "unaryMinus"
  };

  //------------- Arithmetic operations

  assignmentAdditionFloat  { 
      \find(\modality{#normalassign}{.. 
                #loc=#seFloat0 + #seFloat1; 
            ...}\endmodality(post)) 
     \replacewith(
         {#loc:=javaAddFloat(#seFloat0,#seFloat1)}
             \modality{#normalassign}{.. ...}\endmodality(post)) 
     \heuristics(executeFloatAssignment)
     \displayname "subtraction"
  };

  assignmentSubtractionFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 - #seFloat1; 
             ...}\endmodality(post)) 
      \replacewith (
          {#loc:=javaSubFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "multiplication"
  };

  assignmentMultiplicationFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 * #seFloat1; 
             ...}\endmodality(post)) 
      \replacewith (
          {#loc:=javaMulFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "multiplication"
  };

  assignmentDivisionFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 / #seFloat1; 
             ...}\endmodality(post)) 
      \replacewith (
          {#loc:=javaDivFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "division"
  };

  // Operations on combined float/int

  promoteIntToFloatAddition1  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seCharByteShortInt + #seFloat; 
             ...}\endmodality(post)) 
      \replacewith ( \modality{#normalassign}{..
                 #loc = (float) #seCharByteShortInt + #seFloat;
            ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "add cast"
  };

  promoteIntToFloatAddition2  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat + #seCharByteShortInt; 
             ...}\endmodality(post)) 
      \replacewith ( \modality{#normalassign}{..
                 #loc = #seFloat + (float) #seCharByteShortInt;
            ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "add cast"
  };


  // Typecasts


  wideningCastIntToFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = (float) #seCharByteShortInt; 
             ...}\endmodality(post)) 
      \replacewith ( {#loc := castIntToFloat(#seCharByteShortInt)}
           \modality{#normalassign}{..  ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "cast"
  };
}
