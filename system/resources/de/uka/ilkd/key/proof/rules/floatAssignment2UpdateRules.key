// This file is part of KeY - Integrated Deductive Software Design 
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany 
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2014 Karlsruhe Institute of Technology, Germany 
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General 
// Public License. See LICENSE.TXT for details.
// 


\schemaVariables {
  \modalOperator {diamond, box, diamond_transaction, box_transaction} #normalassign;

  \program JavaFloatExpression #seFloat, #seFloat0, #seFloat1 ;
  \program JavaDoubleExpression #seDouble, #seDouble0, #seDouble1 ;
  \program JavaCharByteShortIntExpression #seCharByteShortInt;
  \program JavaLongExpression #seLong;

  \program Variable #loc ;

  \program Variable #v;

 \program NonSimpleExpression #nse;

  \formula post;

  \term float f1, f2;
}



\rules(programRules:Java) {

  //------------- unary minus for float

  unaryMinusFloat { 
     \find (\modality{#normalassign}{.. 
                #loc = - #seFloat; 
            ...}\endmodality(post)) 
     \replacewith({#loc:=javaUnaryMinusFloat(#seFloat)}
                      \modality{#normalassign}{..  ...}\endmodality(post))
     \heuristics(executeFloatAssignment)
     \displayname "unaryMinus"
  };

  unaryMinusDouble { 
     \find (\modality{#normalassign}{.. 
                #loc = - #seDouble; 
            ...}\endmodality(post)) 
     \replacewith({#loc:=javaUnaryMinusDouble(#seDouble)}
                      \modality{#normalassign}{..  ...}\endmodality(post))
     \heuristics(executeFloatAssignment)
     \displayname "unaryMinus"
  };

  //------------- Arithmetic operations with strictfp

  assignmentAdditionFloatStrictFP  { 
      \find(\modality{#normalassign}{.. 
                #loc=#seFloat0 + #seFloat1; 
            ...}\endmodality(post)) 
     \varcond(\isInStrictFp)
     \replacewith(
         {#loc:=addFloatIEEE(RNE, #seFloat0, #seFloat1)}
             \modality{#normalassign}{.. ...}\endmodality(post)) 
     \heuristics(executeFloatAssignment)
     \displayname "addition"
  };

  assignmentSubtractionFloatStrictFP  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 - #seFloat1; 
             ...}\endmodality(post)) 
      \varcond(\isInStrictFp)
      \replacewith (
         {#loc:=subFloatIEEE(RNE, #seFloat0, #seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "subtraction"
  };

  assignmentMultiplicationFloatStrictFP  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 * #seFloat1; 
             ...}\endmodality(post)) 
      \varcond(\isInStrictFp)
      \replacewith (
         {#loc:=mulFloatIEEE(RNE, #seFloat0, #seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "multiplication"
  };

  assignmentDivisionFloatStrictFP  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 / #seFloat1; 
             ...}\endmodality(post)) 
      \varcond(\isInStrictFp)
      \replacewith (
         {#loc:=divFloatIEEE(RNE, #seFloat0, #seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "division"
  };

  //------------- Arithmetic operations without strictfp

  assignmentAdditionFloat  { 
      \find(\modality{#normalassign}{.. 
                #loc=#seFloat0 + #seFloat1; 
            ...}\endmodality(post)) 
     \varcond(\not \isInStrictFp)
     \replacewith(
         {#loc:=javaAddFloat(#seFloat0,#seFloat1)}
             \modality{#normalassign}{.. ...}\endmodality(post)) 
     \heuristics(executeFloatAssignment)
     \displayname "addition"
  };

  assignmentAdditionDouble  { 
      \find(\modality{#normalassign}{.. 
                #loc=#seDouble0 + #seDouble1; 
            ...}\endmodality(post)) 
     \varcond(\not \isInStrictFp)
     \replacewith(
         {#loc:=javaAddDouble(#seDouble0,#seDouble1)}
             \modality{#normalassign}{.. ...}\endmodality(post)) 
     \heuristics(executeFloatAssignment)
     \displayname "addition"
  };

  assignmentSubtractionFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 - #seFloat1; 
             ...}\endmodality(post)) 
      \varcond(\not \isInStrictFp)
      \replacewith (
          {#loc:=javaSubFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "subtraction"
  };

  assignmentSubtractionDouble  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seDouble0 - #seDouble1; 
             ...}\endmodality(post)) 
      \varcond(\not \isInStrictFp)
      \replacewith (
          {#loc:=javaSubDouble(#seDouble0,#seDouble1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "subtraction"
  };

  assignmentMultiplicationFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 * #seFloat1; 
             ...}\endmodality(post)) 
      \varcond(\not \isInStrictFp)
      \replacewith (
          {#loc:=javaMulFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "multiplication"
  };

  assignmentMultiplicationDouble  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seDouble0 * #seDouble1; 
             ...}\endmodality(post)) 
      \varcond(\not \isInStrictFp)
      \replacewith (
          {#loc:=javaMulDouble(#seDouble0,#seDouble1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "multiplication"
  };

  assignmentDivisionFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat0 / #seFloat1; 
             ...}\endmodality(post)) 
      \varcond(\not \isInStrictFp)
      \replacewith (
          {#loc:=javaDivFloat(#seFloat0,#seFloat1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "division"
  };

  assignmentDivisionDouble  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seDouble0 / #seDouble1; 
             ...}\endmodality(post)) 
      \varcond(\not \isInStrictFp)
      \replacewith (
          {#loc:=javaDivDouble(#seDouble0,#seDouble1)}
              \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "division"
  };

  // Operations on combined float/int

  intLongToFloatAddition1  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seLong + #seFloat;
             ...}\endmodality(post)) 
      \replacewith ({#loc := javaAddFloat(castLongToFloat(#seLong), #seFloat)}
            \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "float addition"
  };

  //For int/short/char/byte, converting to float is the same as
  //converting to long first, then float
  intToFloatAddition  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seCharByteShortInt + #seFloat;
             ...}\endmodality(post)) 
      \replacewith ({#loc := javaAddFloat(castLongToFloat(#seCharByteShortInt), #seFloat)}
            \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "float addition"
  };

  castLongToFloatAddition2  { 
      \find (\modality{#normalassign}{.. 
                 #loc = #seFloat + #seLong; 
             ...}\endmodality(post)) 
      \replacewith ({#loc := javaAddFloat(#seFloat, castLongToFloat(#seLong))}
            \modality{#normalassign}{.. ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "float addition"
  };

  // Typecasts


  //KeY integers are not bounded in size, but ints fit inside long
  wideningCastLongToFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = (float) #seLong; 
             ...}\endmodality(post)) 
      \replacewith ( {#loc := castLongToFloat(#seLong)}
           \modality{#normalassign}{..  ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "cast"
  };

  wideningCastIntToFloat  { 
      \find (\modality{#normalassign}{.. 
                 #loc = (float) #seCharByteShortInt; 
             ...}\endmodality(post)) 
      \replacewith ( {#loc := castLongToFloat(#seCharByteShortInt)}
           \modality{#normalassign}{..  ...}\endmodality(post)) 
      \heuristics(executeFloatAssignment)
      \displayname "cast"
  };

  identityCastFloat { 
      \find (\modality{#normalassign}{.. 
                 #loc = (float) #seFloat; 
             ...}\endmodality(post)) 
      \replacewith (\modality{#normalassign}{.. 
                 #loc = #seFloat; 
             ...}\endmodality(post)) 
      \heuristics(simplify_expression)
      \displayname "identity cast"
  };

  identityCastDouble { 
      \find (\modality{#normalassign}{.. 
                 #loc = (double) #seDouble; 
             ...}\endmodality(post)) 
      \replacewith (\modality{#normalassign}{.. 
                 #loc = #seDouble; 
             ...}\endmodality(post)) 
      \heuristics(simplify_expression)
      \displayname "identity cast"
  };

  narrowingCastFloatToInt { 
      \find (\modality{#normalassign}{.. 
                 #loc = (int) #seFloat; 
             ...}\endmodality(post)) 
     \replacewith ({#loc := castFloatToLong(#seFloat)}
           \modality{#normalassign}{..  ...}\endmodality(post)) 
     \heuristics (executeFloatAssignment)
      \displayname "cast"
  };

  narrowingCastFloatToLong { 
      \find (\modality{#normalassign}{.. 
                 #loc = (long) #seFloat; 
             ...}\endmodality(post)) 
     \replacewith ({#loc := castFloatToLong(#seFloat)}
           \modality{#normalassign}{..  ...}\endmodality(post)) 
     \heuristics (executeFloatAssignment)
      \displayname "cast"
  };


  // Non-simple expressions

  compound_float_cast_expression { \find (\modality{#normalassign}{.. #loc = (float) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#normalassign}{.. #typeof(#nse) #v = #nse; #loc = (float) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast"
  };

  compound_double_cast_expression { \find (\modality{#normalassign}{.. #loc = (double) #nse; ...}\endmodality(post))
            \varcond (\new(#v, \typeof(#nse)))
            \replacewith (\modality{#normalassign}{.. #typeof(#nse) #v = #nse; #loc = (double) #v;  ...}\endmodality(post)) 
	 \heuristics (simplify_prog)
         \displayname "cast"
  };

}
