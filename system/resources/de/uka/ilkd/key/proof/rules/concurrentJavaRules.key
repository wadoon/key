// rules c/p from javaRules.key

\sorts{
  \generic G;
  \generic H;
  \generic J \extends G;
  \generic GOS \extends Object;
  \generic alphaObj \extends Object;
  \generic betaObj \extends Object;
}

\schemaVariables {
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
 \modalOperator { diamond, diamond_transaction } #diamond;
 \modalOperator { box, box_transaction } #box;


 \formula post, inv, post1;
 \program Type #t, #t2 ;
 \program NonPrimitiveType #npit ;  

 \term G q ;
 \skolemTerm G sk ;

 \program ArrayLength #length ;
 
 \program MultipleVariableDeclaration #multvardecl ;
 \program ArrayPostDeclaration #arraypost ;
 \program SimpleExpression #se, #se0, #se1, #se2 ;
 \program SimpleExpression #src, #dest, #srcOff, #destOff, #arlength;

 \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2 ;
 \program LeftHandSide #attribute ;
 \program Variable #loc ;
 \program StaticVariable #sv, #sv0, #sv1 ;

 \program Variable #v, #v0, #v1, #v2, #boolv, #a, #a0, #a1 ;

 \program ConstantPrimitiveTypeVariable #cv ;   // variables that are compile-time constants
 \program Variable #b0, #ar1 ;
 \program VariableInitializer #vi ;
 \program SimpleExpression #seBool,#seBool0,#seBool1,#seBool2 ;
 \program JavaBooleanExpression #exBool,#exBool0,#exBool1,#exBool2 ;

 \program NonSimpleExpression #nseBool,#nseBool0,#nseBool1,#nseBool2 ;
 \program Statement #s, #s0, #s1 ;
 \program LoopInit #loopInit ;
 \program Guard #guard ;
 \program ForUpdates #forupdates ;
 \program ForLoop #forloop ;
 \program Expression #e, #e0, #e1, #e2 ;
 \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv ;

 \program[list] Statement #slist, #slist1, #slist2, #slist3 ;
 \program[list] Expression #elist ;
 \program[list] SimpleExpression #selist ;
 \program[list] Catch #cs ;

 \program Switch #sw ;
 \program Label #lb, #lb0, #lb1, #innerLabel, #outerLabel;
 \program NonSimpleMethodReference #nsmr;
 \program NonModelMethodBody #mb;
 \program MethodName #mn;

 \program ExecutionContext #ex, #ex1 ; 
 \program ProgramMethod #pm ; 

 \formula anon1, anon2, anon3;
 
 \formula for1,for2;
 
 \variables int iv, iv2, iv3 ;
 \term int idx;

 // generic sorts
 \term G variant ;
 \term GOS array;
 \term H obj ;

 \variables G x ;
 \term H then, else ;
 
 \term G updatedTerm1, updatedTerm2;
}

\programVariables {
  Seq heaps;
}

/*

\rules(programRules:Java, concurrency:RG) {

  emptyModality { \schemaVar \modalOperator { diamond, box } #normal;
                  \find (==> \modality{#normal}{}\endmodality(post)) 
                  \replacewith(==> post) 
                  \heuristics(simplify_prog) 
                };
}

*/

/*
\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_to_reference_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (\modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normal}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#normal}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };

}


\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_to_reference_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (==> \modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post))
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>)
			;
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(==> false)
                        \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_to_reference_array_component { 
    \schemaVar \modalOperator { diamond, box } #normal; 
    \find (\modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post))
		 \varcond(\isReferenceArray(#v))
    \replacewith({heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_to_primitive_array_component {
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normal}{..
			throw new java.lang.NullPointerException(); 
			...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_to_primitive_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
			;
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_to_primitive_array_component { 
    \schemaVar \modalOperator { diamond, box } #normal; 
    \find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
    \varcond(\not \isReferenceArray(#v))
    \replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

		    
\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_array2{\find (\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
                  \varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
		   \add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(\modality{#allmodal}{..
			throw new java.lang.NullPointerException();
			    ...}\endmodality(post))
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(\modality{#allmodal}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_array2{\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
                  \varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		   \replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
		   //\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
		   ; 
		"Null Reference (#v0 = null)":
		   \replacewith(==> false)
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(==> false)
		   \add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_array2{
    \find (\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
    \varcond(\hasSort(\elemSort(#v0), G))
    \replacewith({#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_read_attribute { 
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this {
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
		\find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
		\find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isThisReference(#v))
		"Normal Execution":
		      \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_read_attribute { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_read_attribute { 
    \find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
    \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
    \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this { 
    \find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
    \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
    \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
    \find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
    \varcond(\not\isThisReference(#v))
    \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
    \find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
    \varcond(\isThisReference(#v))
    \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };  
}

*/

/*

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {

  assignment_write_attribute { 
		\find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  

  assignment_write_attribute_this { 
		\find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };  


}

*/

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {

  assignment_write_attribute { 
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se)}{heaps:=seqConcat(heaps,seqSingleton(heap))}
                                   \modality{#allmodal}{.. ...}\endmodality(post))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  

  assignment_write_attribute_this { 
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se)}{heaps:=seqConcat(heaps,seqSingleton(heap))}
                                   \modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };  

}

/*
\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {

  assignment_write_attribute { 
    \find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
    \varcond(\not \static(#a), \not\isThisReference(#v))
    \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignment"
  };  

  assignment_write_attribute_this { 
    \find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
    \varcond(\not \static(#a), \isThisReference(#v))
    \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignmentThis"
  };  

}

*/

\rules(programRules:Java, concurrency:RG) {
  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any exception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes 
  assignment_write_static_attribute {
	\find (\modality{#allmodal}{.. @(#sv) = #se; ...}\endmodality(post))
	\replacewith(
             {heap := store(heap, null, #memberPVToField(#sv), #se)} 
             {heaps:=seqConcat(heaps,seqSingleton(heap))}
             \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };

  // constant case cannot occur as no static initialisation handling happens
  assignment_write_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. @(#v.#sv) = #se; ...}\endmodality(post))
	\replacewith(
             {heap := store(heap, #v, #memberPVToField(#sv), #se)} 
             {heaps:=seqConcat(heaps,seqSingleton(heap))}
             \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
  };

/*
  assignment_read_static_attribute { 
               \find (\modality{#allmodal}{.. #v0 = @(#sv); ...}\endmodality(post)) \sameUpdateLevel
               \varcond(\hasSort(#sv, G))
               \replacewith({#v0 := G::select(heap, null, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
               \heuristics(simplify_prog, simplify_prog_subset)
  };

  // constant case cannot occur as no static initilisation handling happens
  assignment_read_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. #loc = @(#v.#sv); ...}\endmodality(post))
	\varcond(\hasSort(#sv, G))
        \replacewith({#loc := G::select(heap,#v,#memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
	\heuristics(simplify_prog)
        \displayname "assignment"
  };
*/

}



