// rules c/p from javaRules.key

\rules(programRules:Java, concurrency:RG) {

  emptyModality { \schemaVar \modalOperator { diamond, box } #normal;
                  \find (\modality{#normal}{}\endmodality(post)) 
                  \replacewith(post) 
                  \heuristics(simplify_prog) 
                };
}

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_to_reference_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (\modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normal}{.. throw new java.lang.NullPointerException(); ...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(\modality{#normal}{.. throw new java.lang.ArrayStoreException(); ...}\endmodality(post))
                        \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };

}


\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_to_reference_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (==> \modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post))
		 \varcond(\isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & arrayStoreValid(#v, #se0)==>)
			;
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>);
                 "Array Store Exception (incompatible dynamic element type of #v and #se0)":
                        \replacewith(==> false)
                        \add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0) & !arrayStoreValid(#v, #se0) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_to_reference_array_component { 
    \schemaVar \modalOperator { diamond, box } #normal; 
    \find (\modality{#normal}{.. #v[#se]=#se0; ...}\endmodality(post))
		 \varcond(\isReferenceArray(#v))
    \replacewith({heap:=store(heap,#v,arr(#se),#se0)} \modality{#normal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_to_primitive_array_component {
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
		 "Null Reference (#v = null)":
			\replacewith(\modality{#normal}{..
			throw new java.lang.NullPointerException(); 
			...}\endmodality(post))
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_to_primitive_array_component { 
                 \schemaVar \modalOperator { diamond, box } #normal; 
                 \find (==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
			;
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_to_primitive_array_component { 
    \schemaVar \modalOperator { diamond, box } #normal; 
    \find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
    \varcond(\not \isReferenceArray(#v))
    \replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

		    
\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_array2{\find (\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post)) \sameUpdateLevel
                  \varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		   \replacewith({#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
		   \add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0)); 
		"Null Reference (#v0 = null)":
		   \replacewith(\modality{#allmodal}{..
			throw new java.lang.NullPointerException();
			    ...}\endmodality(post))
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(\modality{#allmodal}{..
			throw new java.lang.ArrayIndexOutOfBoundsException();
		    ...}\endmodality(post))
		   \add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_array2{\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
                  \varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		   \replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
		   //\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
		   ; 
		"Null Reference (#v0 = null)":
		   \replacewith(==> false)
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(==> false)
		   \add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
    	         \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_array2{
    \find (\modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
    \varcond(\hasSort(\elemSort(#v0), G))
    \replacewith({#v:=G::select(heap, #v0, arr(#se))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
}

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_read_attribute { 
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this {
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
		\find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
		\find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\isThisReference(#v))
		"Normal Execution":
		      \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_read_attribute { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_read_attribute { 
    \find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
    \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
    \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute_this { 
    \find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
    \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
    \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };
  
  assignment_read_length { 
    \find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
    \varcond(\not\isThisReference(#v))
    \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_read_length_this { 
    \find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
    \varcond(\isThisReference(#v))
    \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
  };  
}

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {

  assignment_write_attribute { 
		\find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  

  assignment_write_attribute_this { 
		\find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };  


}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {

  assignment_write_attribute { 
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  

  assignment_write_attribute_this { 
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };  

}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {

  assignment_write_attribute { 
    \find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
    \varcond(\not \static(#a), \not\isThisReference(#v))
    \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignment"
  };  

  assignment_write_attribute_this { 
    \find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
    \varcond(\not \static(#a), \isThisReference(#v))
    \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignmentThis"
  };  

}

\rules(programRules:Java, concurrency:RG) {
  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any exception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes 
  assignment_write_static_attribute {
	\find (\modality{#allmodal}{.. @(#sv) = #se; ...}\endmodality(post))
	\replacewith({heap := store(heap, null, #memberPVToField(#sv), #se)} \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };

  // constant case cannot occur as no static initialisation handling happens
  assignment_write_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. @(#v.#sv) = #se; ...}\endmodality(post))
	\replacewith({heap := store(heap, #v, #memberPVToField(#sv), #se)} \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
  };


  assignment_read_static_attribute { 
               \find (\modality{#allmodal}{.. #v0 = @(#sv); ...}\endmodality(post)) \sameUpdateLevel
               \varcond(\hasSort(#sv, G))
               \replacewith({#v0 := G::select(heap, null, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
               \heuristics(simplify_prog, simplify_prog_subset)
  };

  // constant case cannot occur as no static initilisation handling happens
  assignment_read_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. #loc = @(#v.#sv); ...}\endmodality(post))
	\varcond(\hasSort(#sv, G))
        \replacewith({#loc := G::select(heap,#v,#memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
	\heuristics(simplify_prog)
        \displayname "assignment"
  };

}


