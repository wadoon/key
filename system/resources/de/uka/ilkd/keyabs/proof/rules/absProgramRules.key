\sorts {
  ABS.StdLib.Bool;
}

\predicates {
  CInv(any);
}

\functions {
  ABS.StdLib.Bool ABS.StdLib.Bool::True;
  ABS.StdLib.Bool ABS.StdLib.Bool::False;
}


\rules{
  variableDeclarationWithInitializer {
      \schemaVar \program ABSTypeRef TypeRef;
      \schemaVar \program Variable lhs;
      \schemaVar \program PureExp exp1;

      \schemaVar \formula post;
      
      \find (\[{.. TypeRef lhs = exp1; ...}\]post)
      \replacewith (\[{.. lhs = exp1; ...}\]post)
      \addprogvars(lhs)

      \heuristics(simplify_prog) 
  };

  variableDeclaration {
      \schemaVar \program ABSInterfaceTypeRef TypeRef;
      \schemaVar \program Variable lhs;

      \schemaVar \formula post;
      
      \find (\[{.. TypeRef lhs; ...}\]post)
      \replacewith (\[{.. lhs = null; ...}\]post)
      \addprogvars(lhs)

      \heuristics(simplify_prog) 
  };


  assignment {
      \schemaVar \program Variable lhs;
      \schemaVar \program PureExp exp1;

      \schemaVar \formula post;
      
      \find (\[{.. lhs = exp1; ...}\]post) 
      \replacewith ({lhs:=exp1}\[{.. ...}\]post)

      \heuristics(simplify_prog)
  };

  ifThenElseAntec {
      \schemaVar \program PureExp cond;

      \schemaVar \program Statement thenB;
      \schemaVar \program Statement elseB;

      \schemaVar \formula post;
  	     
     \find (\[{.. if ( cond ) thenB; else elseB; ...}\]post ==> )
     "if-condition true": \replacewith(\[{.. thenB; ...}\]post ==>) \add((boolean) cond = TRUE ==>);
     "if-condition false": \replacewith(\[{.. elseB; ...}\]post ==>) \add((boolean)cond = FALSE ==>)
     \heuristics(split_if) 

  };

  ifThenElseSucc {
      \schemaVar \program PureExp cond;

      \schemaVar \program Statement thenB;
      \schemaVar \program Statement elseB;

      \schemaVar \formula post;
  	     
     \find (==> \[{.. if ( cond ) thenB; else elseB; ...}\]post)
      "if-condition true": \replacewith(==> \[{.. thenB; ...}\]post) \add((boolean)cond = TRUE ==>);
      "if-condition false":\replacewith(==> \[{.. elseB; ...}\]post) \add((boolean)cond = FALSE ==>)
     \heuristics(split_if) 

  };


  ifThenAntec {
      \schemaVar \program PureExp cond;
      \schemaVar \program Statement thenB;
      \schemaVar \formula post;
  	     
      \find (\[{.. if ( cond ) thenB; ...}\]post ==> )
      "if-condition true": \replacewith(\[{.. thenB; ...}\]post ==>) \add((boolean)cond = TRUE ==>);
      "if-condition false": \replacewith(\[{.. ...}\]post ==>) \add((boolean)cond = FALSE ==>)
      
      \heuristics(split_if) 

  };

  ifThenSucc {
      \schemaVar \program PureExp cond;
      \schemaVar \program Statement thenB;
      \schemaVar \formula post;
  	     
      \find (==> \[{.. if ( cond ) thenB; ...}\]post)
      "if-condition true": \replacewith(==> \[{.. thenB; ...}\]post) \add((boolean)cond = TRUE ==>);
      "if-condition false": \replacewith(==> \[{.. ...}\]post) \add((boolean)cond = FALSE ==>)
      \heuristics(split_if) 

  };
  
  unwindWhile {
      \schemaVar \program PureExp condition;
      \schemaVar \program Statement body;
      \schemaVar \formula post;
      

      \find (\[{.. while (condition) body; ...}\]post) 
      \replacewith (\[{.. if ( condition ) { body; while (condition) body; }  ...}\]  post)
  };

  emptyBlock {
      \schemaVar \formula post;
      
      \find (\[{.. {} ...}\]post) 
      \replacewith (\[{.. ...}\]  post)
      \heuristics(simplify_prog)
  };

  emptyBox {
      \schemaVar \formula post;
      
      \find (\[{ }\]post) 
      \replacewith (post)
      \heuristics(simplify_prog)
  };


  boxTrue {      
      \schemaVar \program[list] Statement s;

      \find (\[{ s; }\]true) 
      \replacewith (true)
      \heuristics(concrete)
  };

  ABSTrueToTRUE {      
      \find (ABS.StdLib.Bool::True) 
      \replacewith (TRUE)
      \heuristics(concrete)
  };

  ABSFalseToFALSE {      
      \find (ABS.StdLib.Bool::False) 
      \replacewith (FALSE)
      \heuristics(concrete)
  };

  BoolEncoding2Fml {      
      \schemaVar \formula phi;
      \find (\if (phi) \then (TRUE) \else (FALSE) = TRUE) 
      \replacewith (phi)
      \heuristics(concrete)
  };
  
    asyncCall {
        \schemaVar \program MethodName m;
        \schemaVar \program[list] PureExp args;
      	\schemaVar \program ABSTypeRef TypeRef;
        \schemaVar \program Variable callee;
        \schemaVar \program Variable fut;
        \schemaVar \formula phi;
    	\schemaVar \skolemTerm Future futC;
        
  	\find (==> \[{.. TypeRef fut = callee!m(args); ...}\]phi)
  	\varcond(\new(futC, \dependingOn(phi)), \new(fut, \typeof(futC)))

  	"check wellformedness":
  	    \replacewith (==> wfHist(history) & callee != null);

  	"async call":
  	    \replacewith (==> !containsFuture(futC, fid(history)) -> {fut:=futC ||
  		     history:=seqConcat(history, seqSingleton(invocEv(#this,
  		        callee,
  		 	    futC,
  		 	    #methodInvoc2MethodLabel(callee, args),
  		 	    #methodArgsToSeq(args))))}(wfHist(history) -> \[{.. ...}\]phi))

  	//\addprogvars(fut)
  };



  awaitExp{
        \schemaVar \program PureExp exp;
        \schemaVar \formula phi;
        \schemaVar \skolemTerm Heap newHeap; 
        \schemaVar \skolemTerm Seq newHistory; 
        
        
  	\find (==> \[{.. await exp; ...}\]phi)
  	\varcond(\new(newHeap, \dependingOn(phi)),
  		     \new(newHistory, \dependingOn(phi)))
    \replacewith (==> CInv(#this) & wfHist(history));
  	\replacewith (==> {heap:=newHeap || 
  		history:=seqConcat(history, newHistory)}
  		      (CInv(#this) & wfHist(history) & exp = TRUE -> \[{.. ...}\]phi))
  };

  awaitClaim {
        \schemaVar \program PureExp exp;
        \schemaVar \formula phi;
        \schemaVar \skolemTerm Heap newHeap; 
        \schemaVar \skolemTerm Seq newHistory; 
        \schemaVar \skolemTerm any result; 
        
  	\find (==> \[{.. await exp?; ...}\]phi)
  	\varcond(\new(newHeap, \dependingOn(phi)),
  		 \new(newHistory, \dependingOn(phi)),
  		 \new(result, \dependingOn(phi)))
    "Check invariant and wellformedness":
        \replacewith (==> CInv(#this) & wfHist(history));
  	"await success": \replacewith (==> {heap:=newHeap || 
  		history:=seqConcat(history, seqConcat(newHistory, seqSingleton(compREv(#this, exp, result))))}
  		      (CInv(#this) & wfHist(history) -> \[{.. ...}\]phi))
  };

  
}
