\sorts {
  ABS.StdLib.Unit;
}

\predicates {
 CInv(Seq/*History*/, Heap, any);
 Pre(Seq, Heap, any);
}

\functions {
  boolean ABS.StdLib.Bool::True;
  boolean ABS.StdLib.Bool::False;
  ABS.StdLib.Unit ABS.StdLib.Unit::Unit;
}

\schemaVariables {
          \program MethodLabel methodLabelMF;
          \program PureExp resultMF;
          \program PureExp futureMF;
          \program[list] Statement rest, rest2;

}


\rules{
/*  variableDeclarationWithInitializer {
      \schemaVar \program ABSTypeRef TypeRef;
      \schemaVar \program Variable lhs;
      \schemaVar \program PureExp exp1;

      \schemaVar \formula post;
      
      \find (\[{.. TypeRef lhs = exp1; ...}\]post)
      \replacewith (\[{.. lhs = exp1; ...}\]post)
      \addprogvars(lhs)

      \heuristics(simplify_prog) 
  };


  variableDeclaration {
      \schemaVar \program ABSInterfaceTypeRef TypeRef;
      \schemaVar \program Variable lhs;

      \schemaVar \formula post;
      
      \find (\[{.. TypeRef lhs; ...}\]post)
      \replacewith (\[{.. lhs = null; ...}\]post)
      \addprogvars(lhs)

      \heuristics(simplify_prog) 
  };


  assignment {
      \schemaVar \program Variable lhs;
      \schemaVar \program PureExp exp1;

      \schemaVar \formula post;
      
      \find (\[{.. lhs = exp1; ...}\]post) 
      \replacewith ({lhs:=exp1}\[{.. ...}\]post)

      \heuristics(simplify_prog)
  };

  assignmentField {
      \schemaVar \program Field lhs;
      \schemaVar \program PureExp exp1;

      \schemaVar \formula post;

      \find (\[{.. lhs = exp1; ...}\]post)
      \replacewith ({heap:=store(heap,#this,#memberPVToField(lhs),exp1)}\[{.. ...}\]post)

      \heuristics(simplify_prog)
  };
*/

  variableDeclarationWithInitializer {
      \schemaVar \program ABSTypeRef TypeRef;
      \schemaVar \program Variable lhs;
      \schemaVar \program PureExp exp1;

      \schemaVar \formula post;

      \find (\[{methodframe(source <- methodLabelMF,
                            return <- (var: resultMF, fut: futureMF)):{ TypeRef lhs = exp1; rest; } }\]post)
      \replacewith ({lhs:=exp1}\[{methodframe(source <- methodLabelMF,
                                   return <- (var: resultMF, fut: futureMF)):{ rest; } }\]post)
      \addprogvars(lhs)

      \heuristics(simplify_prog)
  };


  variableDeclaration {
      \schemaVar \program ABSInterfaceTypeRef TypeRef;
      \schemaVar \program Variable lhs;

      \schemaVar \formula post;

      \find (\[{methodframe(source <- methodLabelMF,
                            return <- (var: resultMF, fut: futureMF)):{ TypeRef lhs; rest; }}\]post)
      \replacewith (\[{methodframe(source <- methodLabelMF,
                                   return <- (var: resultMF, fut: futureMF)):{ lhs = null; rest; }}\]post)
      \addprogvars(lhs)

      \heuristics(simplify_prog)
  };


  assignment {
      \schemaVar \program Variable lhs;
      \schemaVar \program PureExp exp1;

      \schemaVar \formula post;

      \find (\[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ lhs = exp1; rest;} }\]post)
      \replacewith ({lhs:=exp1}\[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ rest; }}\]post)

      \heuristics(simplify_prog)
  };

  assignmentFieldMF {
      \schemaVar \program Field lhs;
      \schemaVar \program PureExp exp1;

      \schemaVar \formula post;

      \find (\[{methodframe(source <- methodLabelMF,
                            return <- (var: resultMF, fut: futureMF)):{ lhs = exp1; rest; } }\]post)
      \replacewith ({heap:=store(heap,#this,#memberPVToField(lhs),exp1)}\[{
                methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{
                    rest;
                }
       }\]post)

      \heuristics(simplify_prog)
  };


  ifThenElseAntec {
      \schemaVar \program PureExp cond;

      \schemaVar \program Statement thenB;
      \schemaVar \program Statement elseB;

      \schemaVar \formula post;
  	     
     \find (\[{methodframe(source <- methodLabelMF,
                           return <- (var: resultMF, fut: futureMF)):{
                     if ( cond ) thenB;
                     else elseB;
                     rest;
               } }\]post ==> )
     "if-condition true": \replacewith(\[{methodframe(source <- methodLabelMF,
                                                      return <- (var: resultMF, fut: futureMF)):{
                                            thenB;
                                            rest;
                                         } }\]post ==>) \add(#bool2Fml(cond) ==>);
     "if-condition false": \replacewith(\[{ methodframe(source <- methodLabelMF,
                                                       return <- (var: resultMF, fut: futureMF)):{
                                                          elseB;
                                                          rest;
                                          } }\]post ==>) \add(!#bool2Fml(cond) ==>)
     \heuristics(split_if) 

  };


  ifThenElseSucc {
      \schemaVar \program PureExp cond;

      \schemaVar \program Statement thenB;
      \schemaVar \program Statement elseB;

      \schemaVar \formula post;

     \find (==> \[{methodframe(source <- methodLabelMF,
                           return <- (var: resultMF, fut: futureMF)):{
                     if ( cond ) thenB;
                     else elseB;
                     rest;
               } }\]post)
     "if-condition true": \replacewith(==> \[{
                                              methodframe(source <- methodLabelMF,
                                                         return <- (var: resultMF, fut: futureMF)):{
                                                 thenB;
                                                 rest;
                                             } }\]post)
                         \add(#bool2Fml(cond) ==>);
     "if-condition false": \replacewith(==> \[{ methodframe(source <- methodLabelMF,
                                                       return <- (var: resultMF, fut: futureMF)):{
                                                          elseB;
                                                          rest;
                                          } }\]post)
                          \add(!#bool2Fml(cond) ==>)
     \heuristics(split_if)

  };

    ifThenAntec {
        \schemaVar \program PureExp cond;
        \schemaVar \program Statement thenB;
        \schemaVar \formula post;

        \find (\[{methodframe(source <- methodLabelMF,
                              return <- (var: resultMF, fut: futureMF)):{ if ( cond ) thenB; rest; }}\]post ==>)
        "if-condition true": \replacewith(
                 \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ thenB; rest; } }\]post ==>) \add(#bool2Fml(cond) ==>);
        "if-condition false": \replacewith(\[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ rest; }}\]post ==>)
                              \add(!#bool2Fml(cond) ==>)
        \heuristics(split_if)

    };

  /*ifThenSucc {
      \schemaVar \program PureExp cond;
      \schemaVar \program Statement thenB;
      \schemaVar \formula post;
  	     
      \find (==> \[{.. if ( cond ) thenB; ...}\]post)
      "if-condition true": \replacewith(==> \[{.. thenB; ...}\]post) \add(#bool2Fml(cond) ==>);
      "if-condition false": \replacewith(==> \[{.. ...}\]post) \add(!#bool2Fml(cond) ==>)
      \heuristics(split_if) 

  };*/

    ifThenSucc {
        \schemaVar \program PureExp cond;
        \schemaVar \program Statement thenB;
        \schemaVar \formula post;

        \find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ if ( cond ) thenB; rest; }}\]post)
        "if-condition true": \replacewith(==>
                 \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ thenB; rest; } }\]post) \add(#bool2Fml(cond) ==>);
        "if-condition false": \replacewith(==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ rest; }}\]post) \add(!#bool2Fml(cond) ==>)
        \heuristics(split_if)

    };

  unwindWhile {
      \schemaVar \program PureExp condition;
      \schemaVar \program Statement body;
      \schemaVar \formula post;
      

      \find (\[{.. while (condition) body; ...}\]post) 
      \replacewith (\[{.. if ( condition ) { body; while (condition) body; }  ...}\]  post)
  };

  emptyBlock {
      \schemaVar \formula post;
      
      \find (\[{ methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ {rest;} rest2; } }\]post)
      \replacewith (\[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ rest; rest2; }}\]  post)
      \heuristics(simplify_prog)
  };

  emptyBox {
      \schemaVar \formula post;
      
      \find (\[{ }\]post) 
      \replacewith (post)
      \heuristics(simplify_prog)
  };


  boxTrue {      
      \schemaVar \program[list] Statement s;

      \find (\[{ s; }\]true) 
      \replacewith (true)
      \heuristics(concrete)
  };

  ABSTrueToTRUE {
      \find (ABS.StdLib.Bool::True) 
      \replacewith (TRUE)
      \heuristics(concrete)
  };


  ABSFalseToFALSE {
      \find (ABS.StdLib.Bool::False) 
      \replacewith (FALSE)
      \heuristics(concrete)
  };


  BoolEncoding2Fml {      
      \schemaVar \formula phi;
      \find (\if (phi) \then (TRUE) \else (FALSE) = TRUE) 
      \replacewith (phi)
      \heuristics(concrete)
  };
  
    asyncCall {
        \schemaVar \program MethodName m;
        \schemaVar \program[list] PureExp args;
      	\schemaVar \program ABSTypeRef TypeRef;
        \schemaVar \program Variable callee;
        \schemaVar \program Variable fut;
        \schemaVar \formula phi;
    	\schemaVar \skolemTerm Future futC;
        
  	\find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{  TypeRef fut = callee!m(args); rest; }}\]phi)
  	\varcond(\new(futC, \dependingOn(phi)), \new(fut, \typeof(futC)))

  	"check wellformedness":
  	    \replacewith (==> wfHist(history) & callee != null);

  	"async call":
  	    \replacewith (==> !containsFuture(futC, fid(history)) -> {fut:=futC ||
  		     history:=seqConcat(history, seqSingleton(invocEv(#this,
  		        callee,
  		 	    futC,
  		 	    #methodInvoc2MethodLabel(callee, args),
  		 	    #methodArgsToSeq(args))))}(wfHist(history) ->
  		 	    \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ rest; }}\]phi))
        \heuristics(userTaclets1)
  	//\addprogvars(fut)
  };



    asyncSelfCall {
        \schemaVar \program MethodName m;
        \schemaVar \program[list] PureExp args;
      	\schemaVar \program ABSTypeRef TypeRef;
        \schemaVar \program Variable fut;
        \schemaVar \formula phi;
    	\schemaVar \skolemTerm Future futC;

  	\find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ TypeRef fut = this!m(args); rest; }}\]phi)
  	\varcond(\new(futC, \dependingOn(phi)), \new(fut, \typeof(futC)))

  	"check wellformedness":
  	    \replacewith (==> wfHist(history) & #this != null);

  	"async call":
  	    \replacewith (==> !containsFuture(futC, fid(history)) -> {fut:=futC ||
  		     history:=seqConcat(history, seqSingleton(invocEv(#this,
  		        #this,
  		 	    futC,
  		 	    #methodInvoc2MethodLabel(#this, args),
  		 	    #methodArgsToSeq(args))))}(wfHist(history) -> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ rest; } }\]phi))

    \displayname "asyncCall"
        \heuristics(userTaclets1)

  	//\addprogvars(fut)
  };

    asyncSelfCallWOFut {
          \schemaVar \program MethodName m;
          \schemaVar \program[list] PureExp args;
        	\schemaVar \program ABSTypeRef TypeRef;
          \schemaVar \formula phi;
      	\schemaVar \skolemTerm Future futC;

    	\find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ this!m(args); rest; }}\]phi)
    	\varcond(\new(futC, \dependingOn(phi)))

    	"check wellformedness":
    	    \replacewith (==> wfHist(history) & #this != null);

    	"async call":
    	    \replacewith (==> !containsFuture(futC, fid(history)) ->
    	           {history:=seqConcat(history, seqSingleton(invocEv(#this,
    		        #this,
    		 	    futC,
    		 	    #methodInvoc2MethodLabel(#this, args),
    		 	    #methodArgsToSeq(args))))}(wfHist(history) ->
    		 	       \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{rest;} }\]phi))

      \displayname "asyncCall"
          \heuristics(userTaclets1)

    };

    asyncSelfCallOnField {
        \schemaVar \program MethodName m;
        \schemaVar \program[list] PureExp args;
      	\schemaVar \program ABSTypeRef TypeRef;
      	\schemaVar \program Field callee;
        \schemaVar \program Variable fut;
        \schemaVar \formula phi;
    	\schemaVar \skolemTerm Future futC;

  	\find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ TypeRef fut = callee!m(args); rest;} }\]phi)
  	\varcond(\new(futC, \dependingOn(phi)), \new(fut, \typeof(futC)))

  	"check wellformedness":
  	    \replacewith (==> wfHist(history) & callee != null);

  	"async call":
  	    \replacewith (==> !containsFuture(futC, fid(history)) -> {fut:=futC ||
  		     history:=seqConcat(history, seqSingleton(invocEv(#this,
  		        callee,
  		 	    futC,
  		 	    #methodInvoc2MethodLabel(callee, args),
  		 	    #methodArgsToSeq(args))))}(wfHist(history) -> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{rest;}}\]phi))

    \displayname "asyncCall"
        \heuristics(userTaclets1)

  	//\addprogvars(fut)
  };

  asyncCallOnFieldWOFut {
        \schemaVar \program MethodName m;
        \schemaVar \program[list] PureExp args;
      	\schemaVar \program ABSTypeRef TypeRef;
      	\schemaVar \program Field callee;
        \schemaVar \formula phi;
    	\schemaVar \skolemTerm Future futC;

  	\find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ callee!m(args); rest; } }\]phi)
  	\varcond(\new(futC, \dependingOn(phi)))

  	"check wellformedness":
  	    \replacewith (==> wfHist(history) & callee != null);

  	"async call":
  	    \replacewith (==> !containsFuture(futC, fid(history)) ->
  	        {history:=seqConcat(history, seqSingleton(invocEv(#this,
  		     callee,
  		 	 futC,
  		 	 #methodInvoc2MethodLabel(callee, args),
  		 	 #methodArgsToSeq(args))))}(wfHist(history) -> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{rest;}}\]phi))

    \displayname "asyncCall"
        \heuristics(userTaclets1)

  };


/* asyncCallAlt {
        \schemaVar \program MethodName m;
        \schemaVar \program[list] PureExp args;
      	\schemaVar \program ABSTypeRef TypeRef;
        \schemaVar \program Variable callee;
        \schemaVar \program Variable fut;
        \schemaVar \formula phi;
    	\schemaVar \variable Future futC;
        
  	\find (==> \[{.. TypeRef fut = callee!m(args); ...}\]phi)
  	\varcond(\new(fut, \typeof(futC)), \notFreeIn(futC, phi) )

  	"check wellformedness":
  	    \replacewith (==> wfHist(history) & callee != null);

  	"async call":
  	    \replacewith (==> \forall futC; (!containsFuture(futC, fid(history)) -> {fut:=futC ||
  		     history:=seqConcat(history, seqSingleton(invocEv(#this,
  		        callee,
  		 	    futC,
  		 	    #methodInvoc2MethodLabel(callee, args),
  		 	    #methodArgsToSeq(args))))}(wfHist(history) -> \[{.. ...}\]phi)))
 };*/


  awaitExp{
        \schemaVar \program PureExp exp;
        \schemaVar \formula phi;
        \schemaVar \skolemTerm Heap newHeap; 
        \schemaVar \skolemTerm Seq newHistory; 
        
        
  	\find (==> \[{ methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{
  	               await exp; rest; } }\]phi)
  	\varcond(\new(newHeap, \dependingOn(phi)),
  		     \new(newHistory, \dependingOn(phi)))
    \replacewith (==> CInv(history, heap, #this) & wfHist(history));
  	\replacewith (==> {heap:=newHeap || 
  		history:=seqConcat(history, newHistory)}
  		      (CInv(history, heap, #this) & wfHist(history) & #bool2Fml(exp) ->
  		            \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ rest; }}\]phi))
            \heuristics(userTaclets1)

  };

  awaitClaim {
        \schemaVar \program PureExp exp;
        \schemaVar \formula phi;
        \schemaVar \variables any callee;
        \schemaVar \variables MethodLabel l;

        \schemaVar \skolemTerm Heap newHeap; 
        \schemaVar \skolemTerm Seq newHistory; 
        \schemaVar \skolemTerm any result; 
        
  	\find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ await exp?; rest; }}\]phi)
  	\varcond(\new(newHeap, \dependingOn(phi)),
  	         \new(newHistory, \dependingOn(phi)),
  		     \new(result, \dependingOn(phi)),
  		     \notFreeIn(callee, phi),
  		     \notFreeIn(l, phi))

    "Check invariant and wellformedness":
        \replacewith (==> CInv(history, heap, #this) & wfHist(history));

  	"await success": \replacewith (==> {heap:=newHeap || history:=seqConcat(history, newHistory)}
  		      (CInv(history, heap, #this) & wfHist(history) &
  		      (\exists callee; \exists l;
  		         containsEvent(compEv((ABSAnyInterface)callee, (Future) exp, l, result), history))
  		      -> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{rest;}}\]phi))
  		              \heuristics(userTaclets1)

  };

  getExpWithVarInit {
        \schemaVar \program PureExp exp;
        \schemaVar \formula phi;
        \schemaVar \program ABSTypeRef TypeRef;
        \schemaVar \program Variable result;

      	\find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ TypeRef result = exp.get; rest; } }\] phi)

        \varcond(\new(result, \typeof(TypeRef)))
        \replacewith(==>{history:=seqConcat(history, seqSingleton(compREv(#this, exp, result)))}
                            (wfHist(history) -> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ rest; } }\]phi))

        \addprogvars(result)
	\heuristics (simplify_prog)
  };


    getExp {
        \schemaVar \program PureExp exp;
        \schemaVar \formula phi;
        \schemaVar \program Variable result;

      	\find (==> \[{methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{ result = exp.get; rest; } }\] phi)

        \replacewith(==>{history:=seqConcat(history, seqSingleton(compREv(#this, exp, result)))}
                            (wfHist(history) -> \[{ methodframe(source <- methodLabelMF, return <- (var: resultMF, fut: futureMF)):{  rest; } }\]phi))

	\heuristics (simplify_prog)
  };


  methodReturn {

          \schemaVar \program MethodLabel methodLabel;
          \schemaVar \program PureExp result;
          \schemaVar \program PureExp future;

          \schemaVar \program PureExp exp;
          \schemaVar \formula phi;

          \find (\[{methodframe(source <- methodLabel,
                                return <- (var: result, fut: future)):{ return exp; } }\]phi)
          \replacewith({history:=seqConcat(history, seqSingleton(compEv(#this, future, methodLabel, exp)))}\[{  }\]phi)

          \heuristics (simplify_prog)
    };

  methodImplicitReturnUnit {


          \schemaVar \program PureExp exp;
          \schemaVar \formula phi;

          \find (\[{methodframe(source <- methodLabelMF,
                                return <- (var: resultMF, fut: futureMF)):{ } }\]phi)
          \replacewith({history:=seqConcat(history, seqSingleton(compEv(#this, futureMF, methodLabelMF,
                                                                        ABS.StdLib.Unit::Unit)))}\[{  }\]phi)
          \heuristics (simplify_prog)

          \displayname "methodReturn"
    };

}
