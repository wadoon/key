package de.uka.ilkd.key.testgeneration.xmlparser;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.LinkedList;
import java.util.List;

import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.XMLEvent;

import de.uka.ilkd.key.testgeneration.XMLHandler;

/**
 * Instances of this class are used in order to create JUnit4 test suites from the internal XML
 * representation generated by KeYTestGen2.
 * 
 * @author christopher
 */
public class JUnitParser
        extends XMLHandler
        implements ITestCaseParser<String> {

    /**
     * The singleton instance of this class. Lazily instantiated.
     */
    private static JUnitParser instance;

    private JUnitParser() {

    }

    /**
     * @return the singleton instance of this class.
     */
    public static JUnitParser getInstance() {

        if (instance == null) {
            instance = new JUnitParser();
        }

        return instance;
    }

    /**
     * Create a set of Test classes from an XML test suite.
     * 
     * @throws XMLParserException
     */
    @Override
    public String generateTestCaseFromXML(String representation)
            throws XMLParserException {

        try {

            JUnitMediator result =
                    new JUnitGenerationWorker(representation).generateJUnitTestSuite();

            return null;
        }
        catch (XMLStreamException xme) {
            throw new XMLParserException(xme.getMessage());
        }
    }

    /**
     * Worker class which processes an XML document in order to produce a concrete JUnit test suite.
     * 
     * @author christopher
     */
    private static class JUnitGenerationWorker {

        /**
         * Used for creating XML related utility classes.
         */
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();

        /**
         * The stream from the target XML document.
         */
        private InputStream inputStream;

        /**
         * Used for parsing {@link XMLEvent} instances from the XML document.
         */
        XMLEventReader eventReader;

        public JUnitGenerationWorker(String xmlDocument) throws XMLStreamException {

            inputStream = new ByteArrayInputStream(xmlDocument.getBytes());
            eventReader = inputFactory.createXMLEventReader(inputStream);
        }

        public JUnitMediator generateJUnitTestSuite() throws XMLStreamException {

            /*
             * The main parse loop. Identify the nature of each XML element, and process the tree
             * accordingly.
             */
            while (eventReader.hasNext()) {

                XMLEvent event = eventReader.nextTag();

                if (event.isStartElement()) {
                    if (getEventName(event).equals(TESTCASE_ROOT)) {
                        System.out.println(event);
                    }
                }
            }
            return null;
        }

        /**
         * Processes an XML tree corresponding to a test case
         * 
         * @param inputStream
         *            the {@link InputStream} for this session
         * @param eventReader
         *            the {@link XMLEventReader} for this session
         */
        private void processTestCase(InputStream inputStream, XMLEventReader eventReader) {

        }

        private String getEventName(XMLEvent event) {

            if (event.isStartElement()) {
                return event.asStartElement().getName().getLocalPart();
            }

            if (event.isEndElement()) {
                return event.asEndElement().getName().getLocalPart();
            }

            return "";
        }

    }

    /**
     * Mediating class which encapsulates JUnit data generated during the parsing of an XML test
     * suite.
     * 
     * @author christopher
     */
    private static class JUnitMediator {

        private final List<String> imports = new LinkedList<String>();

        public void addImport(String importString) {

            imports.add(importString);
        }

        /**
         * @return the imports
         */
        public List<String> getImports() {

            return imports;
        }
    }

    /**
     * Represents a simple view of a JUnit test method, i.e. a method annotated with @Test.
     * 
     * @author christopher
     */
    private static class TestMethod {

        /**
         * Object instances declared in this particular method.
         */
        private final List<ObjectInstance> objectInstances =
                new LinkedList<ObjectInstance>();

        /**
         * The oracle for this method
         */
        private String oracle;

        /**
         * @return the objectInstances
         */
        public List<ObjectInstance> getObjectInstances() {

            return objectInstances;
        }

        public void addObjectInstance(ObjectInstance instance) {

            objectInstances.add(instance);
        }
    }

    /**
     * Represents a very simple view of an Object instance, based on the metadata available in the
     * XML document.
     * 
     * @author christopher
     */
    private static class ObjectInstance {

        /**
         * The static type of this object.
         */
        private String type;

        /**
         * The name of this object.
         */
        private String name;

        /**
         * Indicates whether this object is declared final or not.
         */
        private boolean isFinal = false;

        /**
         * Arguments to the constructor of this object
         */
        private List<ObjectInstance> constructorArguments =
                new LinkedList<ObjectInstance>();

        /**
         * @return the type
         */
        public String getType() {

            return type;
        }

        /**
         * @param type
         *            the type to set
         */
        public void setType(String type) {

            this.type = type;
        }

        /**
         * @return the name
         */
        public String getName() {

            return name;
        }

        /**
         * @param name
         *            the name to set
         */
        public void setName(String name) {

            this.name = name;
        }

        /**
         * @return the isFinal
         */
        public boolean isFinal() {

            return isFinal;
        }

        /**
         * @param isFinal
         *            the isFinal to set
         */
        public void setFinal(boolean isFinal) {

            this.isFinal = isFinal;
        }

        /**
         * @return the constructorArguments
         */
        public List<ObjectInstance> getConstructorArguments() {

            return constructorArguments;
        }

        /**
         * @param constructorArguments
         *            the constructorArguments to set
         */
        public void addConstructorArgument(ObjectInstance argument) {

            constructorArguments.add(argument);
        }
    }
}