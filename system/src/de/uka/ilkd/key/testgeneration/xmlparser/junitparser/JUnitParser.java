package de.uka.ilkd.key.testgeneration.xmlparser.junitparser;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.XMLEvent;

import de.uka.ilkd.key.testgeneration.XMLHandler;
import de.uka.ilkd.key.testgeneration.xmlparser.ITestCaseParser;
import de.uka.ilkd.key.testgeneration.xmlparser.XMLParserException;

/**
 * Instances of this class are used in order to create JUnit4 test suites from the internal XML
 * representation generated by KeYTestGen2.
 * 
 * @author christopher
 */
public class JUnitParser
        extends XMLHandler
        implements ITestCaseParser<String> {

    /**
     * The singleton instance of this class. Lazily instantiated.
     */
    private static JUnitParser instance;

    private JUnitParser() {

    }

    /**
     * @return the singleton instance of this class.
     */
    public static JUnitParser getInstance() {

        if (instance == null) {
            instance = new JUnitParser();
        }
        return instance;
    }

    /**
     * Create a set of Test classes from an XML test suite.
     * 
     * @throws XMLParserException
     */
    @Override
    public String generateTestCaseFromXML(String representation)
            throws XMLParserException {

        try {

            JUnitMediator result =
                    new JUnitGenerationWorker(representation).generateJUnitTestSuite();

            return null;
        }
        catch (XMLStreamException xme) {
            throw new XMLParserException(xme.getMessage());
        }
    }

    /**
     * Worker which services a single invocation of
     * {@link JUnitParser#generateTestCaseFromXML(String)}.
     * 
     * @author christopher
     */
    private static class JUnitGenerationWorker {

        /**
         * Used for creating XML related utility classes.
         */
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();

        /**
         * Used for parsing {@link XMLEvent} instances from the XML document.
         */
        XMLEventReader eventReader;

        /**
         * The stream from the target XML document.
         */
        private InputStream inputStream;

        /**
         * The {@link JUnitMediator} instance generated by this worker.
         */
        JUnitMediator mediator = new JUnitMediator();

        public JUnitGenerationWorker(String xmlDocument) throws XMLStreamException {

            inputStream = new ByteArrayInputStream(xmlDocument.getBytes());
            eventReader = inputFactory.createXMLEventReader(inputStream);
        }

        public JUnitMediator generateJUnitTestSuite() throws XMLStreamException {

            /*
             * The main parse loop. Identify the nature of each XML element, and its corresponding
             * XML subtree accordingly.
             */
            while (eventReader.hasNext()) {

                XMLEvent event = eventReader.nextEvent();

                /*
                 * Select only elements corresponding to opening tags, i.e. <testcase>, <method>
                 * etc. Other elements will form elements of these primary components, and are
                 * handled by methods specific to such components.
                 */
                if (event.isStartElement()) {

                    /*
                     * Process a test case
                     */
                    if (getEventName(event).equals(TESTCASE_ROOT)) {
                        processTestCase();
                    }
                }
            }
            return null;
        }

        /**
         * Processes an XML subtree corresponding to a test case. A test case will have the
         * following form:
         * 
         * <pre>
         *      {@literal <method>}
         *              {@literal <name>}
         *                      The name of the method
         *              {@literal </name>}
         *                            
         *              {@literal <parameters>}
         *                      identifiers for parameters to the method
         *              {@literal </parameters>}
         *      {@literal </method>}
         * </pre>
         * 
         * @param inputStream
         *            the {@link InputStream} for this session
         * @param eventReader
         *            the {@link XMLEventReader} for this session
         * @throws XMLStreamException
         */
        private void processTestCase() throws XMLStreamException {

            /*
             * Create a new instance of TestMethod, which will encapsulate all JUnit statements
             * generated by this method as well as its helpers.
             */
            MethodDeclaration methodDeclaration = processMethod();

            /*
             * Set up the mediator for this test case.
             */
            TestCaseMediator testCaseMediator = new TestCaseMediator();

            /*
             * Set up the preliminary fixture mapping.
             */
            generateFixtureMapping(testCaseMediator);
        }

        /**
         * Processes an XML subtree corresponding to a method definition. The method described here
         * will be a single method in the the original Java file for which we will be generating a
         * test case.
         * 
         * @param testMethod
         * @throws XMLStreamException
         */
        private MethodDeclaration processMethod() throws XMLStreamException {

            // Validates and discards the opening tag
            XMLEvent startTag = eventReader.nextTag();

            MethodDeclaration methodDeclaration = new MethodDeclaration();

            /*
             * Get and encode the method name.
             */
            String name = getMethodName();
            methodDeclaration.setName(name);

            /*
             * Get and encode method parameters.
             */
            List<String> methodParameters = getMethodParameters();

            methodDeclaration.setName(name);
            methodDeclaration.setParameterNames(methodParameters);

            // Discard the end tag
            eventReader.nextTag();

            return methodDeclaration;
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <name>}
         *      Some name
         * {@literal </name>}
         * </pre>
         * 
         * this method return the name enclosed between the tags, and moves the stream pointer to
         * the end of the subtree.
         * 
         * @return the name
         * @throws XMLStreamException
         */
        private String getMethodName() throws XMLStreamException {

            // Validates and discards the opening tag
            XMLEvent startTag = eventReader.nextTag();
            // validateXMLTag(startTag, NAME_ROOT);

            XMLEvent event = eventReader.nextEvent();
            String identifier = event.asCharacters().getData().trim();

            // Discard the closing tag.
            eventReader.nextTag();

            return identifier;
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <parameters>}
         *      parameter1
         *      parameter2
         *      ...
         *      parameterN
         * {@literal </parameters>}
         * </pre>
         * 
         * this method will extract and return the identifier for each such parameter. The
         * parameters are prefixed by "this." in order to avoid name clashes.
         * 
         * @return list of identifiers
         * @throws XMLStreamException
         */
        private List<String> getMethodParameters() throws XMLStreamException {

            // Discards the opening tag
            XMLEvent startTag = eventReader.nextTag();

            List<String> identifiers = new LinkedList<String>();

            /*
             * Extract all parameters. Discards the closing tag upon finishing.
             */
            while (!eventReader.peek().isEndElement()) {

                XMLEvent event = eventReader.nextEvent();
                identifiers.add(event.toString().trim());
            }
            eventReader.nextTag();

            return identifiers;
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <fixture>}
         *      {@literal <variables>}
         *              variable1
         *              variable2
         *              ...
         *              variableN
         *      {@literal </variables>}
         *      {@literal <instances>}
         *              instances1
         *              instances2
         *              ...
         *              instancesN
         *      {@literal </instances>}
         * {@literal </fixture>}
         * </pre>
         * 
         * this method constructs a context mapping between instances of {@link ObjectVariable} and
         * {@link ObjectInstance} instances, representing a set of variable declarations and the
         * actual object instances they point to (if any).
         * 
         * @param testCaseMediator
         * @return the variable -> instance mapping.
         * @throws XMLStreamException
         */
        private void generateFixtureMapping(TestCaseMediator testCaseMediator)
                throws XMLStreamException {

            // Discards the opening tag
            XMLEvent startTag = eventReader.nextTag();

            extractVariables(testCaseMediator);
            extractInstances(testCaseMediator);
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <variables>}
         *      variable1
         *      variable2
         *      ...
         *      variableN
         *  {@literal </variables>}
         * </pre>
         * 
         * this method will extract an {@link ObjectVariable} instance for each variable, and return
         * a list of these.
         * 
         * @param testCaseMediator
         * @return a list of {@link ObjectVariable} instances
         * @throws XMLStreamException
         */
        private void extractVariables(TestCaseMediator testCaseMediator)
                throws XMLStreamException {

            // Discards the opening tag
            XMLEvent startTag = eventReader.nextTag();

            /*
             * Extract all variables, stop when the </variables> tag is encountered, and discard it.
             */
            while (!eventReader.nextTag().isEndElement()) {

                ObjectVariable variable = extractVariable();
                testCaseMediator.addVariable(variable.getIdentifier(), variable);
            }
            eventReader.nextTag();

        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <variable>}
         *      {@literal <identifier>}
         *              The identifier for the variable
         *      {@literal <\identifier>}
         *      {@literal <type>}
         *              The type of this variable
         *      {@literal <\type>}
         *      {@literal <value>}
         *              the object instance referred by this variable
         *      {@literal <\type>}
         * {@literal </variable>}
         * </pre>
         * 
         * this method constructs an {@link ObjectVariable} instance the variable represented in
         * this XML subtree.
         * 
         * @return a list of {@link ObjectInstance} instances
         * @throws XMLStreamException
         */
        private ObjectVariable extractVariable() throws XMLStreamException {

            ObjectVariable variable = new ObjectVariable();

            /*
             * Extract the variables identifier.
             */
            eventReader.nextTag();
            String identifier = eventReader.nextEvent().asCharacters().getData().trim();
            eventReader.nextTag();

            /*
             * Extract the type of the variable.
             */
            eventReader.nextTag();
            String type = eventReader.nextEvent().asCharacters().getData().trim();
            eventReader.nextTag();

            /*
             * Extract the referenece ID for the variable.
             */
            eventReader.nextTag();
            String reference = eventReader.nextEvent().asCharacters().getData().trim();
            eventReader.nextTag();

            variable.setIdentifier(identifier);
            variable.setType(type);
            variable.setReference(reference);

            eventReader.nextTag();

            return variable;
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <instances>}
         *      instance1
         *      instance2
         *      ...
         *      instanceN
         *  {@literal </instances>}
         * </pre>
         * 
         * this method will extract an {@link ObjectInstance} instance for each variable, and return
         * a list of these.
         * 
         * @param testCaseMediator
         * @return a list of {@link ObjectInstance} instances
         * @throws XMLStreamException
         */
        private List<ObjectInstance> extractInstances(TestCaseMediator testCaseMediator)
                throws XMLStreamException {

            // Discards the opening tag
            XMLEvent startTag = eventReader.nextTag();

            List<ObjectInstance> instances = new LinkedList<ObjectInstance>();

            while (!eventReader.nextTag().isEndElement()) {

                ObjectInstance instance = extractInstance(testCaseMediator);
                testCaseMediator.addInstance(instance.getIdentifier(), instance);
            }
            eventReader.nextTag();

            return null;
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <instance>}
         *      {@literal <identifier>}
         *              The identifier for the variable
         *      {@literal <\identifier>}
         *      {@literal <type>}
         *              The type of this variable
         *      {@literal <\type>}
         *      {@literal <value>}
         *              the object instance referred by this variable
         *      {@literal <\type>}
         * {@literal </instance>}
         * </pre>
         * 
         * this method constructs an {@link ObjectVariable} instance the variable represented in
         * this XML subtree.
         * 
         * @param testCaseMediator
         * @return a list of {@link ObjectInstance} instances
         * @throws XMLStreamException
         */
        private ObjectInstance extractInstance(TestCaseMediator testCaseMediator)
                throws XMLStreamException {

            ObjectInstance instance = new ObjectInstance();

            /*
             * Extract the identifier for this instance.
             */
            eventReader.nextTag();
            String identifier = eventReader.nextEvent().asCharacters().getData().trim();
            eventReader.nextTag();

            /*
             * Extract the type of this instance.
             */
            eventReader.nextTag();
            String type = eventReader.nextEvent().asCharacters().getData().trim();
            eventReader.nextTag();

            instance.setIdentifier(identifier);
            instance.setType(type);

            /*
             * Extract the field identifiers of this instance, and map each field to an
             * ObjectVariabel instance.
             */
            for (String fieldIdentifier : extractFieldIdentifiers()) {
                instance.addField(testCaseMediator.getVariable(fieldIdentifier));
            }

            return instance;
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <instances>}
         *      instance1
         *      instance2
         *      ...
         *      instanceN
         *  {@literal </instances>}
         * </pre>
         * 
         * this method will extract the identifier for each field, and return a list of these.
         * 
         * @return a list of variable identifiers.
         * @throws XMLStreamException
         */
        private List<String> extractFieldIdentifiers() throws XMLStreamException {

            // Discards the opening tag
            XMLEvent startTag = eventReader.nextTag();

            List<String> fields = new LinkedList<String>();

            while (!eventReader.peek().isEndElement()) {

                XMLEvent event = eventReader.nextEvent();
                fields.add(event.toString().trim());
            }
            eventReader.nextTag();

            return fields;
        }
    }

    /**
     * Retrieves the identifier for an {@link XMLEvent}. For example, in:
     * 
     * <pre>
     *      {@literal <testcase>}
     * </pre>
     * 
     * The identifier will be "testcase".
     * 
     * @param event
     *            the event to get the identifier for
     * @return the identifier
     */
    private static String getEventName(XMLEvent event) {

        if (event.isStartElement()) {
            return event.asStartElement().getName().getLocalPart();
        }

        if (event.isEndElement()) {
            return event.asEndElement().getName().getLocalPart();
        }

        return "";
    }

    /**
     * Validates an XML tag by
     * <ul>
     * <li>asserting that the {@link XMLEvent} passed is indeed a tag, and</li>
     * <li>asserting that the identifier associated with the tag is of the expected type.</li>
     * </ul>
     * 
     * @param event
     *            the {@link XMLEvent} to validate
     * @param expectedIdentifier
     *            the expected type of the tags identifier
     * @throws XMLStreamException
     *             if validation fails
     */
    private void validateXMLTag(XMLEvent event, String expectedIdentifier)
            throws XMLStreamException {

        if (!event.isStartElement() && !event.isEndElement()) {
            throw new XMLStreamException("Bad XML structure: " + event
                    + " is not a valid tag");
        }

        if (!event.asStartElement().getName().getLocalPart().equals(expectedIdentifier)) {
            throw new XMLStreamException("Bad XML structure: expected " + "<"
                    + expectedIdentifier + ">" + " but saw: " + event);
        }
    }

    /**
     * Mediating class which encapsulates JUnit data generated during the parsing of an XML test
     * suite.
     * 
     * @author christopher
     */
    private static class JUnitMediator {

        /**
         * Imports needed for this particular JUnit test suite
         */
        private final List<String> imports = new LinkedList<String>();

        public void addImport(String importString) {

            imports.add(importString);
        }

        /**
         * @return the imports
         */
        public List<String> getImports() {

            return imports;
        }
    }

    /**
     * Mediator for processing individual test cases.
     * 
     * @author christopher
     */
    private static class TestCaseMediator {

        /**
         * Variables related to this particular test case.
         */
        Map<String, ObjectVariable> variables = new HashMap<String, ObjectVariable>();

        /**
         * Object instances related to this particular test case.
         */
        Map<String, ObjectInstance> instances = new HashMap<String, ObjectInstance>();

        /**
         * Retrieves a variable corresponding to a given identifier.
         * 
         * @param identifier
         *            the identifier
         * @return the variable
         */
        public ObjectVariable getVariable(String identifier) {

            return variables.get(identifier);
        }

        /**
         * Add a variable.
         * 
         * @param identifier
         *            String identifier for the variable
         * @param variable
         *            the variable
         */
        public void addVariable(String identifier, ObjectVariable variable) {

            this.variables = variables;
        }

        /**
         * Retrieves an instance corresponding to a given identifier.
         * 
         * @param identifier
         *            the identifier
         * @return the instance
         */
        public ObjectVariable getInstance(String identifier) {

            return variables.get(identifier);
        }

        /**
         * Add an instance.
         * 
         * @param identifier
         *            String identifier for the instance
         * @param variable
         *            the instance
         */
        public void addInstance(String identifier, ObjectInstance instance) {

            instances.put(identifier, instance);
        }
    }
}