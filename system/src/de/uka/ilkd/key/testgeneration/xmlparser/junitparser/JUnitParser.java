package de.uka.ilkd.key.testgeneration.xmlparser.junitparser;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.LinkedList;
import java.util.List;

import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.XMLEvent;

import de.uka.ilkd.key.testgeneration.XMLHandler;
import de.uka.ilkd.key.testgeneration.xmlparser.ITestCaseParser;
import de.uka.ilkd.key.testgeneration.xmlparser.XMLParserException;

/**
 * Instances of this class are used in order to create JUnit4 test suites from the internal XML
 * representation generated by KeYTestGen2.
 * 
 * @author christopher
 */
public class JUnitParser
        extends XMLHandler
        implements ITestCaseParser<String> {

    /**
     * The singleton instance of this class. Lazily instantiated.
     */
    private static JUnitParser instance;

    private JUnitParser() {

    }

    /**
     * @return the singleton instance of this class.
     */
    public static JUnitParser getInstance() {

        if (instance == null) {
            instance = new JUnitParser();
        }
        return instance;
    }

    /**
     * Create a set of Test classes from an XML test suite.
     * 
     * @throws XMLParserException
     */
    @Override
    public String generateTestCaseFromXML(String representation)
            throws XMLParserException {

        try {

            JUnitMediator result =
                    new JUnitGenerationWorker(representation).generateJUnitTestSuite();

            return null;
        }
        catch (XMLStreamException xme) {
            throw new XMLParserException(xme.getMessage());
        }
    }

    /**
     * Worker which services a single invocation of
     * {@link JUnitParser#generateTestCaseFromXML(String)}.
     * 
     * @author christopher
     */
    private static class JUnitGenerationWorker {

        /**
         * Used for creating XML related utility classes.
         */
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();

        /**
         * Used for parsing {@link XMLEvent} instances from the XML document.
         */
        XMLEventReader eventReader;

        /**
         * The stream from the target XML document.
         */
        private InputStream inputStream;

        /**
         * The {@link JUnitMediator} instance generated by this worker.
         */
        JUnitMediator mediator = new JUnitMediator();

        public JUnitGenerationWorker(String xmlDocument) throws XMLStreamException {

            inputStream = new ByteArrayInputStream(xmlDocument.getBytes());
            eventReader = inputFactory.createXMLEventReader(inputStream);
        }

        public JUnitMediator generateJUnitTestSuite() throws XMLStreamException {

            /*
             * The main parse loop. Identify the nature of each XML element, and its corresponding
             * XML subtree accordingly.
             */
            while (eventReader.hasNext()) {

                XMLEvent event = eventReader.nextEvent();

                /*
                 * Select only elements corresponding to opening tags, i.e. <testcase>, <method>
                 * etc. Other elements will form elements of these primary components, and are
                 * handled by methods specific to such components.
                 */
                if (event.isStartElement()) {

                    /*
                     * Process a test case
                     */
                    if (getEventName(event).equals(TESTCASE_ROOT)) {
                        processTestCase();
                    }
                }
            }
            return null;
        }

        /**
         * Processes an XML subtree corresponding to a test case. A test case will have the
         * following form:
         * 
         * <pre>
         *      {@literal <method>}
         *              {@literal <name>}
         *                      The name of the method
         *              {@literal </name>}
         *                            
         *              {@literal <parameters>}
         *                      identifiers for parameters to the method
         *              {@literal </parameters>}
         *      {@literal </method>}
         * </pre>
         * 
         * @param inputStream
         *            the {@link InputStream} for this session
         * @param eventReader
         *            the {@link XMLEventReader} for this session
         * @throws XMLStreamException
         */
        private void processTestCase() throws XMLStreamException {

            /*
             * Create a new instance of TestMethod, which will encapsulate all JUnit statements
             * generated by this method as well as its helpers.
             */
            TestMethod testMethod = new TestMethod();

            /*
             * Process and encode the method definition
             */
            processMethod(testMethod);
        }

        /**
         * Processes an XML subtree corresponding to a method definition. The method described here
         * will be a single method in the the original Java file for which we will be generating a
         * test case.
         * 
         * @param testMethod
         * @throws XMLStreamException
         */
        private void processMethod(TestMethod testMethod) throws XMLStreamException {

            // Discards the opening tag
            eventReader.nextTag();

            /*
             * Get and encode the method name.
             */
            String name = getMethodName();
            testMethod.setName(name);

            /*
             * Get and encode method parameters.
             */
            List<String> methodParameters = getMethodParameters();
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <name>}
         *      Some name
         * {@literal </name>}
         * </pre>
         * 
         * this method return the name enclosed between the tags, and moves the stream pointer to
         * the end of the subtree.
         * 
         * @return the name
         * @throws XMLStreamException
         */
        private String getMethodName() throws XMLStreamException {

            // Discards the opening tag
            eventReader.nextTag();

            XMLEvent event = eventReader.nextEvent();
            String identifier = event.asCharacters().getData().trim();

            // Discard the closing tag.
            eventReader.nextTag();

            return identifier;
        }

        /**
         * Given that the stream pointer in the {@link XMLEventReader} is currently pointing to the
         * start of an XML subtree of the form:
         * 
         * <pre>
         * {@literal <parameters>}
         *      parameter1
         *      parameter2
         *      parameter3
         *      ...
         *      parameterN
         * {@literal </parameters>}
         * </pre>
         * 
         * this method will extract and return the identifier for each such parameter. The
         * parameters are prefixed by "this." in order to avoid name clashes.
         * 
         * @return list of identifiers
         * @throws XMLStreamException
         */
        private List<String> getMethodParameters() throws XMLStreamException {

            // Discards the opening tag
            eventReader.nextTag();

            List<String> identifiers = new LinkedList<String>();

            /*
             * Extract all parameters. Discards the closing tag upon finishing.
             */
            while (true) {

                XMLEvent event = eventReader.nextEvent();
                identifiers.add(event.toString().trim());

                if (event.isEndElement()) {
                    break;
                }
            }

            return identifiers;
        }

        /**
         * Retrieves the identifier for an {@link XMLEvent}. For example, in:
         * 
         * <pre>
         *      {@literal <testcase>}
         * </pre>
         * 
         * The identifier will be "testcase".
         * 
         * @param event
         *            the event to get the identifier for
         * @return the identifier
         */
        private String getEventName(XMLEvent event) {

            if (event.isStartElement()) {
                return event.asStartElement().getName().getLocalPart();
            }

            if (event.isEndElement()) {
                return event.asEndElement().getName().getLocalPart();
            }

            return "";
        }
    }

    /**
     * Mediating class which encapsulates JUnit data generated during the parsing of an XML test
     * suite.
     * 
     * @author christopher
     */
    private static class JUnitMediator {

        /**
         * Imports needed for this particular JUnit test suite
         */
        private final List<String> imports = new LinkedList<String>();

        public void addImport(String importString) {

            imports.add(importString);
        }

        /**
         * @return the imports
         */
        public List<String> getImports() {

            return imports;
        }
    }
}