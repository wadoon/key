package de.uka.ilkd.key.testgeneration.parsers;

import de.uka.ilkd.key.java.JavaInfo;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.abstraction.Type;
import de.uka.ilkd.key.java.declaration.ClassDeclaration;
import de.uka.ilkd.key.java.declaration.MemberDeclaration;
import de.uka.ilkd.key.java.declaration.Modifier;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.Operator;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.logic.op.SortDependingFunction;
import de.uka.ilkd.key.testgeneration.model.implementation.Model;
import de.uka.ilkd.key.testgeneration.model.implementation.ModelInstance;
import de.uka.ilkd.key.testgeneration.model.implementation.ModelMediator;
import de.uka.ilkd.key.testgeneration.model.implementation.ModelVariable;
import de.uka.ilkd.key.testgeneration.visitors.KeYTestGenTermVisitor;

public class PathToTermParser {
    
    /**
     * Creates a skeletal {@link Model} instance from a {@link Term}. The Term
     * will be parsed, and all representations of program variables (along with
     * their relationships to one another) will be used to construct a
     * "skeletal" Model instance (i.e. no concrete primitive values).
     * 
     * @param term
     *            the Term to process
     * @param services
     *            {@link Services} associated with the Term
     * @param mediator
     *            session mediator
     * @return the Model instance built from the Term
     */
    public static Model createModel(Term term, Services services,
            ModelMediator mediator) {

        Model model = new Model();

        /*
         * Construct the initial Model, containing representation of all the
         * variables and values found in the Term. Done postorder to eliminate
         * buffering penalties in the Model.
         */
        ContextVisitor modelVisitor = new ContextVisitor(model, services,
                mediator);
        term.execPostOrder(modelVisitor);

        /*
         * Setup all reference relationships expressed in the Term. Done
         * preorder to correctly handle non-assigning operations, such as
         * not-equals.
         */
        ReferenceVisitor referenceVisitor = new ReferenceVisitor(model);
        term.execPreOrder(referenceVisitor);

        return modelVisitor.getModel();
    }

    /**
     * This Visitor walks a {@link Term} and extracts information related to the
     * program variables represented in the term. The goal of this procedure is
     * to provide sufficient information for later constructing a {@link Model}
     * including the extracted variables.
     * 
     * @author christopher
     */
    private static class ContextVisitor extends KeYTestGenTermVisitor {

        private final ModelMediator mediator;

        /**
         * Stores Java specific information related to the {@link Term} we are
         * working with.
         */
        private final JavaInfo javaInfo;

        /**
         * The default root variable, representing a reference to the class
         * instance of which the tested method is part.
         */
        private final LocationVariable default_self;

        /**
         * The {@link Model} to be populated by visiting the associated Term.
         */
        Model model;

        public ContextVisitor(Model model, Services services,
                ModelMediator mediator) {

            if (mediator == null) {
                this.mediator = new ModelMediator();
            } else {
                this.mediator = mediator;
            }

            this.model = model;
            javaInfo = services.getJavaInfo();

            /*
             * Construct the default base class
             */
            ProgramElementName name = null;
            if (mediator == null || mediator.getMainClass() == null) {
                name = new ProgramElementName("UnitTestingClass");
            } else {
                name = new ProgramElementName(mediator.getMainClass().getName());
            }

            ClassDeclaration baseType = new ClassDeclaration(new Modifier[0],
                    name, null, name, null, new MemberDeclaration[0], false,
                    false);

            default_self = new LocationVariable(
                    new ProgramElementName("$SELF$"), new KeYJavaType(baseType));

            /*
             * Add the root variable and instance to the Model
             */
            ModelInstance selfInstance = new ModelInstance(
                    default_self.getKeYJavaType());

            ModelVariable self = new ModelVariable(default_self, "self",
                    selfInstance);
            model.add(self, selfInstance);
        }

        /**
         * Returns the model generated by the visitationprocess
         * 
         * @return
         */
        public Model getModel() {

            return model;
        }

        /**
         * Visit a {@link Term} node, extracting any data related to
         * {@link ProgramVariable} instances in this node, if any. If such data
         * is found, it will be encoded in a {@link ModelVariable} format.
         * <p>
         * <strong>IMPORTANT:</strong> Due to how {@link Term} ASTs are
         * implemented, this method will only have the desired effect if the
         * visitation is carried out in postorder. Preorder will cause the Model
         * to be constructed with wrong parent-child relationships.
         * <p>
         * To achieve correct results, thus, please only pass this visitor as a
         * parameter to
         * {@link Term#execPostOrder(de.uka.ilkd.key.logic.Visitor)}
         * <p>
         */
        @Override
        public void visit(Term visited) {

            if (isVariable(visited)) {
                parseVariableTerm(visited);
            }
        }

        /**
         * Parse a {@link Term} representing a program variable. Such a Term can
         * be either a plain local declaration (i.e. a {@link LocationVariable}
         * ), or it can be part of a nested hierarchy (i.e. a
         * {@link SortDependingFunction}). We treat both cases here.
         * 
         * @param term
         *            the term to parse
         */
        private void parseVariableTerm(Term term) {

            /*
             * If the program variable instance resolves to null, it does not
             * correspond to a variable type recognized by KeYTestGen (this is
             * likely to change in the future).
             * 
             * Also, if the variable corresponds to the root type, we do not
             * process it (since it is already part of the model by default.
             * 
             * FIXME: There must be a cleaner way of checking if the root
             * variable has been found - this is a terribly ugly hack. Check if
             * sort is null instead? What other variables (if any) may have
             * nulled sorts?
             */
            ProgramVariable programVariable = getVariable(term);
            if (programVariable == null
                    || programVariable.toString().equals("$SELF$")) {
                return;
            }

            /*
             * Create the variable itself, together with its corresponding
             * instance. If the variable is a primitive type, a corresponding
             * wrapper class has to be generated in order to represent its
             * value. If it is not primitive, we simply create a new
             * ModelInstance to hold any reference object.
             */
            String identifier = resolveIdentifierString(term);

            ModelVariable variable = new ModelVariable(programVariable,
                    identifier);

            Object instance = null;
            if (isPrimitiveType(term)) {
                instance = resolvePrimitiveType(programVariable);
            } else {
                instance = new ModelInstance(programVariable.getKeYJavaType());
            }

            /*
             * Add the variable and its instance to the Model. This might seem
             * premature, but must be done to preserve referential integrity and
             * avoiding extra work.
             */
            model.add(variable, instance);

            /*
             * If the term is a SortDependingFunction, we are faced with two
             * possibilities:
             * 
             * 1. the variable in question may be a field of some instance. In
             * this case, we attempt to resolve the variable pointing to this
             * instance, in order to add the our newly created variable as a
             * field of that instance.
             * 
             * 2. the variable is null, in which case this variable must be a
             * static field of its declaring class. In this case, it is not part
             * of any instance, and we let the parent remain null.
             */
            if (term.op().getClass() == SortDependingFunction.class) {

                ProgramVariable parentVariable = getVariable(term.sub(1));

                /*
                 * The parent is not null, and this variable is hence an
                 * instance variable of some class. Connect it to the parent.
                 */
                if (parentVariable != null) {
                    String parentIdentifier = resolveIdentifierString(term
                            .sub(1));
                    ModelVariable parentModelVariable = new ModelVariable(
                            parentVariable, parentIdentifier);

                    model.assignField(variable, parentModelVariable);
                } else if (!programVariable.isStatic()) {

                    ModelVariable self = new ModelVariable(default_self, "self");
                    model.assignField(variable, self);
                }
            }

            /*
             * Finally, if the variable was not a SortDependentFunction (i.e.
             * did not have an explicitly declared parent), we check if its name
             * corresponds to the names of any of the parameters for the method
             * we are currently dealing with. If that is not the case, we deduce
             * that it is a locally declared variable, and hence set its parent
             * to be the root class.
             * 
             * If the variable indeed is a parameter, we create a separate
             * variable and instance for it.
             */
            else {

                /*
                 * The case where the variable is a parameter.
                 */
                if (mediator.getMethodParameterNames().contains(
                        variable.getIdentifier())) {

                    variable.setParameter(true);

                    /*
                     * The case where it is not.
                     */
                } else {
                    ModelVariable self = new ModelVariable(default_self, "self");
                    model.assignField(variable, self);
                }
            }
        }

        /**
         * Retrieve the {@link ProgramVariable} represented by a given
         * {@link Term}, if any.
         * 
         * @param term
         *            the term to process
         * @return the {@link ProgramVariable} corresponding to the Term, iff.
         *         the Term represents a variable.
         */
        private ProgramVariable getVariable(Term term) {

            Operator operator = term.op();

            /*
             * Process an instance of ProgramVariable (most often, this will be
             * a LocationVariable). Such an object will represent a non-static
             * field of some class, and its parent is as such simply an instance
             * of that class.
             */
            if (operator instanceof ProgramVariable) {

                /*
                 * KeY represents the heap as a LocationVariable as well. We
                 * cannot(?) do anything useful with it, so we ignore it.
                 * However, if the LocationVariable correspons to "self" (i.e.
                 * the root variable), we return the default root, although we
                 * first properly set the type (which is not needed, but nice to
                 * have).
                 */
                if (!operator.toString().equalsIgnoreCase("heap")) {

                    if (operator.toString().equalsIgnoreCase("self")) {

                        ProgramVariable variable = (ProgramVariable) operator;
                        Type realType = variable.getKeYJavaType().getJavaType();
                        default_self.getKeYJavaType().setJavaType(realType);

                        return default_self;
                    } else {
                        return (ProgramVariable) operator;
                    }
                }
            }

            /*
             * Process a normal Function. This step is necessary since the root
             * instance of the class holding the method under test (i.e. "self")
             * will be of this type. If self is encountered, insert a placebo
             * variable for it (since KeY does not always create a native
             * variable for it).
             */
            if (operator.getClass() == Function.class) {

                if (operator.toString().equalsIgnoreCase("self")) {

                    ProgramVariable variable = (ProgramVariable) operator;
                    Type realType = variable.getKeYJavaType().getJavaType();
                    default_self.getKeYJavaType().setJavaType(realType);

                    return default_self;
                }
            }

            /*
             * Process a SortDependingFunction. A Term of this sort represents a
             * recursively defined variable (i.e. a variable at the end of a
             * nested hiearchy, such as
             * self.nestedObject.anotherNestedObject.variable).
             */
            if (operator.getClass() == SortDependingFunction.class) {

                return getProgramVariableForField(term.sub(2));
            }
            return null;
        }

        /**
         * Works around the fact that KeY inserts the "$" sign into {@link Term}
         * s, which messes with the variable lookup of the {@link JavaInfo}
         * instance.
         * 
         * @param term
         *            a {@link Term} with a sort of type Field
         * @return the {@link ProgramVariable} instance corresponding to the
         *         field represented by the Term
         */
        private ProgramVariable getProgramVariableForField(Term term) {

            if (!term.sort().name().toString().equalsIgnoreCase("Field")) {
                return null;
            }

            String[] split = term.op().toString().split("::\\$");
            return javaInfo.getAttribute(split[1], split[0]);
        }

        /**
         * Returns a wrapper representation of the primitive type of a variable
         * 
         * @param variable
         *            the variable
         * @return the primitive type of the variable
         */
        private Object resolvePrimitiveType(ProgramVariable variable) {

            /*
             * FIXME: Horrible. Do not do String comparison here, find a
             * convenient way to compare based on types.
             */
            String typeName = variable.getKeYJavaType().getFullName();
            if (typeName.equals("int")) {
                return new Integer(0);
            }
            if (typeName.equals("boolean")) {
                return new Boolean(false);
            }
            if (typeName.equals("long")) {
                return new Long(0L);
            }
            if (typeName.equals("byte")) {
                return new Byte("0xe0");
            }
            if (typeName.equals("char")) {
                return new Character('0');
            } else {
                return null;
            }
        }
    }

    /**
     * Looks for junctors in a {@link Term}, and reflects their semantic meaning
     * in the {@link Model} corresponding to the term.
     * 
     * @author christopher
     */
    private static class ReferenceVisitor extends KeYTestGenTermVisitor {

        /**
         * Flag to indicate if we have seen a Not operator.
         */
        private boolean sawNot;

        /**
         * The {@link Model} instance associated with the Term being visited.
         * Constructed separately by an instance of {@link ContextVisitor}.
         */
        private final Model model;

        public ReferenceVisitor(Model model) {

            this.model = model;
        }

        @Override
        public void visit(Term visited) {

            if (isNot(visited)) {
                sawNot = true;
            } else if (isEquals(visited) && !sawNot) {
                parseEquals(visited);
                sawNot = false;
            } else if (isBinaryFunction2(visited) && sawNot) {
                sawNot = false;
            }
        }

        /**
         * Equality has to be dealt with depending on the type of the
         * <strong>left-hand</strong> variable, since this is the operand which
         * will determine the meaning of the equality.
         * <p>
         * If the variable is <strong>primitve</strong>, equality, in our
         * abstraction, implies a value assignment: equals(a,b) simply means
         * that the value of b is copied into a. There is no need to do this
         * explicitly here, since the SMT interface will taking care of this,
         * and we would thus only be performing the same work twice.
         * <p>
         * If the variable is a <strong>reference</strong> type, things get more
         * interesting, since equality in this case implies that the operands
         * are pointing to a common object in memory. To represent this in our
         * abstraction, we need to cross-reference to Value property of both
         * operands, making them point to each other. We do this by making sure
         * that whatever Value is assigned to both operands has the same unique
         * identifier.
         * 
         * @param term
         *            the term to process
         */
        private void parseEquals(Term term) {

            Term leftOperand = term.sub(0);
            Term rightOperand = term.sub(1);

            /*
             * The left-hand operator is a reference type
             */
            if (!isPrimitiveType(term)) {

                String leftOperandIdentifier = resolveIdentifierString(leftOperand);
                String rightOperandIdentifier = resolveIdentifierString(rightOperand);

                ModelVariable leftModelVariable = model
                        .getVariableByReference(leftOperandIdentifier);

                ModelVariable rightModelVariable = model
                        .getVariableByReference(rightOperandIdentifier);

                model.assignPointer(leftModelVariable, rightModelVariable);
            }
        }
    }
}
