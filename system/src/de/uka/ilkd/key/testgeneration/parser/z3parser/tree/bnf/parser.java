
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Fri Oct 12 19:44:47 CEST 2012
//----------------------------------------------------

package de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf;


/** CUP v0.11a beta 20060608 generated parser.
  * @version Fri Oct 12 19:44:47 CEST 2012
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\023\000\002\002\004\000\002\002\005\000\002\003" +
    "\002\000\002\003\004\000\002\004\010\000\002\005\005" +
    "\000\002\006\003\000\002\006\003\000\002\007\003\000" +
    "\002\007\004\000\002\007\003\000\002\010\003\000\002" +
    "\010\003\000\002\011\002\000\002\011\004\000\002\012" +
    "\003\000\002\012\003\000\002\013\003\000\002\013\003" +
    "" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\035\000\004\004\004\001\002\000\006\005\uffff\006" +
    "\uffff\001\002\000\004\002\006\001\002\000\004\002\001" +
    "\001\002\000\006\005\011\006\010\001\002\000\004\017" +
    "\013\001\002\000\004\002\000\001\002\000\006\005\ufffe" +
    "\006\ufffe\001\002\000\004\007\014\001\002\000\016\005" +
    "\ufff4\010\ufff4\011\ufff4\013\ufff4\015\ufff4\016\ufff4\001\002" +
    "\000\006\012\020\014\017\001\002\000\016\007\014\010" +
    "\024\011\023\013\021\015\032\016\031\001\002\000\016" +
    "\007\ufff0\010\ufff0\011\ufff0\013\ufff0\015\ufff0\016\ufff0\001" +
    "\002\000\016\007\uffef\010\uffef\011\uffef\013\uffef\015\uffef" +
    "\016\uffef\001\002\000\016\005\ufff5\010\ufff5\011\ufff5\013" +
    "\ufff5\015\ufff5\016\ufff5\001\002\000\004\005\ufffa\001\002" +
    "\000\004\016\ufff1\001\002\000\004\016\ufff2\001\002\000" +
    "\004\005\034\001\002\000\004\005\ufffb\001\002\000\016" +
    "\005\ufff7\010\ufff7\011\ufff7\013\ufff7\015\ufff7\016\ufff7\001" +
    "\002\000\004\016\033\001\002\000\016\005\ufff9\010\ufff9" +
    "\011\ufff9\013\ufff9\015\ufff9\016\ufff9\001\002\000\016\005" +
    "\ufff6\010\ufff6\011\ufff6\013\ufff6\015\ufff6\016\ufff6\001\002" +
    "\000\016\005\ufff8\010\ufff8\011\ufff8\013\ufff8\015\ufff8\016" +
    "\ufff8\001\002\000\006\005\ufffd\006\ufffd\001\002\000\016" +
    "\005\036\010\024\011\023\013\021\015\032\016\031\001" +
    "\002\000\010\005\ufffc\012\ufffc\014\ufffc\001\002\000\016" +
    "\005\ufff3\010\ufff3\011\ufff3\013\ufff3\015\ufff3\016\ufff3\001" +
    "\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\035\000\004\002\004\001\001\000\004\003\006\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\004\011" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\005\014\001\001\000\004\011\034\001\001" +
    "\000\004\013\015\001\001\000\014\005\021\006\024\007" +
    "\025\010\026\012\027\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\007\036\010\026\012\027\001\001\000\002\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



  public de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Modl pModel() throws Exception
  {
	java_cup.runtime.Symbol res = parse();
	return (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Modl) res.value;
  }

public <B,A extends java.util.LinkedList<? super B>> A cons_(B x, A xs) { xs.addFirst(x); return xs; }

public void syntax_error(java_cup.runtime.Symbol cur_token)
{
	report_error("Syntax Error, trying to recover and continue parse...", cur_token);
}

public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws java.lang.Exception
{
	throw new Exception("Unrecoverable Syntax Error");
}


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {
  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // Type ::= _SYMB_6 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Type RESULT =null;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.TBool(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",9, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // Type ::= _SYMB_8 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Type RESULT =null;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.TInt(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Type",9, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // Op ::= _SYMB_5 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Op RESULT =null;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.SPos(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Op",8, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // Op ::= _SYMB_4 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Op RESULT =null;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.SNeg(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Op",8, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ListExp ::= ListExp Exp 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListExp RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListExp p_1 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListExp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Exp p_2 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = p_1; p_1.addLast(p_2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ListExp",7, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ListExp ::= 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListExp RESULT =null;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListExp(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ListExp",7, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // Bool ::= _SYMB_7 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Bool RESULT =null;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.BFalse(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Bool",6, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // Bool ::= _SYMB_9 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Bool RESULT =null;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.BTrue(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Bool",6, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // Exp ::= Bool 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Exp RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Bool p_1 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Bool)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.EBool(p_1); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Exp",5, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // Exp ::= Op _INTEGER_ 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Exp RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Op p_1 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Op)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		Integer p_2 = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ESInt(p_1,p_2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Exp",5, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // Exp ::= _INTEGER_ 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Exp RESULT =null;
		Integer p_1 = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.EInt(p_1); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Exp",5, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // Val ::= Block 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Val RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Block p_1 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Block)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ENVal(p_1); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Val",4, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // Val ::= Exp 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Val RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Exp p_1 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.EVal(p_1); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Val",4, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Block ::= _SYMB_3 ListExp _SYMB_1 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Block RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListExp p_2 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListExp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Blck(p_2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Block",3, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Fun ::= _SYMB_2 _IDENT_ Block Type Val _SYMB_1 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Fun RESULT =null;
		String p_2 = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Block p_3 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Block)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Type p_4 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Type)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Val p_5 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Val)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Function(p_2,p_3,p_4,p_5); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Fun",2, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // ListFun ::= ListFun Fun 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListFun RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListFun p_1 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListFun)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Fun p_2 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Fun)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = p_1; p_1.addLast(p_2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ListFun",1, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ListFun ::= 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListFun RESULT =null;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListFun(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ListFun",1, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // Model ::= _SYMB_0 ListFun _SYMB_1 
            {
              de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Modl RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListFun p_2 = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ListFun)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Mod(p_2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Model",0, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= Model EOF 
            {
              Object RESULT =null;
		de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Modl start_val = (de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Modl)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

