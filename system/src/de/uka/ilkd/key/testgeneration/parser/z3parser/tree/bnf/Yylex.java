// This JLex file was machine-generated by the BNF converter
package de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf;

import java_cup.runtime.*;

public class Yylex
        implements java_cup.runtime.Scanner {

    private final int YY_BUFFER_SIZE = 512;
    private final int YY_F = -1;
    private final int YY_NO_STATE = -1;
    private final int YY_NOT_ACCEPT = 0;
    private final int YY_START = 1;
    private final int YY_END = 2;
    private final int YY_NO_ANCHOR = 4;
    private final int YY_BOL = 65536;
    private final int YY_EOF = 65537;

    String pstring = new String();

    public int line_num() {

        return (yyline + 1);
    }

    public String buff() {

        return new String(yy_buffer, yy_buffer_index, 10).trim();
    }

    private java.io.BufferedReader yy_reader;
    private int yy_buffer_index;
    private int yy_buffer_read;
    private int yy_buffer_start;
    private int yy_buffer_end;
    private char yy_buffer[];
    private int yyline;
    private boolean yy_at_bol;
    private int yy_lexical_state;

    public Yylex(java.io.Reader reader) {

        this();
        if (null == reader) {
            throw (new Error("Error: Bad input stream initializer."));
        }
        yy_reader = new java.io.BufferedReader(reader);
    }

    public Yylex(java.io.InputStream instream) {

        this();
        if (null == instream) {
            throw (new Error("Error: Bad input stream initializer."));
        }
        yy_reader =
                new java.io.BufferedReader(new java.io.InputStreamReader(instream));
    }

    private Yylex() {

        yy_buffer = new char[YY_BUFFER_SIZE];
        yy_buffer_read = 0;
        yy_buffer_index = 0;
        yy_buffer_start = 0;
        yy_buffer_end = 0;
        yyline = 0;
        yy_at_bol = true;
        yy_lexical_state = YYINITIAL;
    }

    private boolean yy_eof_done = false;
    private final int STRING = 5;
    private final int ESCAPED = 6;
    private final int YYINITIAL = 0;
    private final int COMMENT = 1;
    private final int CHAREND = 4;
    private final int CHARESC = 3;
    private final int CHAR = 2;
    private final int yy_state_dtrans[] = { 0, 32, 32, 32, 32, 32, 32 };

    private void yybegin(int state) {

        yy_lexical_state = state;
    }

    private int yy_advance() throws java.io.IOException {

        int next_read;
        int i;
        int j;

        if (yy_buffer_index < yy_buffer_read) {
            return yy_buffer[yy_buffer_index++];
        }

        if (0 != yy_buffer_start) {
            i = yy_buffer_start;
            j = 0;
            while (i < yy_buffer_read) {
                yy_buffer[j] = yy_buffer[i];
                ++i;
                ++j;
            }
            yy_buffer_end = yy_buffer_end - yy_buffer_start;
            yy_buffer_start = 0;
            yy_buffer_read = j;
            yy_buffer_index = j;
            next_read =
                    yy_reader.read(yy_buffer, yy_buffer_read, yy_buffer.length
                            - yy_buffer_read);
            if (-1 == next_read) {
                return YY_EOF;
            }
            yy_buffer_read = yy_buffer_read + next_read;
        }

        while (yy_buffer_index >= yy_buffer_read) {
            if (yy_buffer_index >= yy_buffer.length) {
                yy_buffer = yy_double(yy_buffer);
            }
            next_read =
                    yy_reader.read(yy_buffer, yy_buffer_read, yy_buffer.length
                            - yy_buffer_read);
            if (-1 == next_read) {
                return YY_EOF;
            }
            yy_buffer_read = yy_buffer_read + next_read;
        }
        return yy_buffer[yy_buffer_index++];
    }

    private void yy_move_end() {

        if (yy_buffer_end > yy_buffer_start
                && '\n' == yy_buffer[yy_buffer_end - 1])
            yy_buffer_end--;
        if (yy_buffer_end > yy_buffer_start
                && '\r' == yy_buffer[yy_buffer_end - 1])
            yy_buffer_end--;
    }

    private boolean yy_last_was_cr = false;

    private void yy_mark_start() {

        int i;
        for (i = yy_buffer_start; i < yy_buffer_index; ++i) {
            if ('\n' == yy_buffer[i] && !yy_last_was_cr) {
                ++yyline;
            }
            if ('\r' == yy_buffer[i]) {
                ++yyline;
                yy_last_was_cr = true;
            }
            else
                yy_last_was_cr = false;
        }
        yy_buffer_start = yy_buffer_index;
    }

    private void yy_mark_end() {

        yy_buffer_end = yy_buffer_index;
    }

    private void yy_to_mark() {

        yy_buffer_index = yy_buffer_end;
        yy_at_bol =
                (yy_buffer_end > yy_buffer_start)
                        && ('\r' == yy_buffer[yy_buffer_end - 1]
                                || '\n' == yy_buffer[yy_buffer_end - 1]
                                || 2028/* LS */== yy_buffer[yy_buffer_end - 1] || 2029/* PS */== yy_buffer[yy_buffer_end - 1]);
    }

    private java.lang.String yytext() {

        return (new java.lang.String(yy_buffer, yy_buffer_start, yy_buffer_end
                - yy_buffer_start));
    }

    private int yylength() {

        return yy_buffer_end - yy_buffer_start;
    }

    private char[] yy_double(char buf[]) {

        int i;
        char newbuf[];
        newbuf = new char[2 * buf.length];
        for (i = 0; i < buf.length; ++i) {
            newbuf[i] = buf[i];
        }
        return newbuf;
    }

    private final int YY_E_INTERNAL = 0;
    private final int YY_E_MATCH = 1;
    private java.lang.String yy_error_string[] = { "Error: Internal error.\n",
            "Error: Unmatched input.\n" };

    private void yy_error(int code, boolean fatal) {

        java.lang.System.out.print(yy_error_string[code]);
        java.lang.System.out.flush();
        if (fatal) {
            throw new Error("Fatal Error.\n");
        }
    }

    private int[][] unpackFromString(int size1, int size2, String st) {

        int colonIndex = -1;
        String lengthString;
        int sequenceLength = 0;
        int sequenceInteger = 0;

        int commaIndex;
        String workString;

        int res[][] = new int[size1][size2];
        for (int i = 0; i < size1; i++) {
            for (int j = 0; j < size2; j++) {
                if (sequenceLength != 0) {
                    res[i][j] = sequenceInteger;
                    sequenceLength--;
                    continue;
                }
                commaIndex = st.indexOf(',');
                workString =
                        (commaIndex == -1) ? st : st.substring(0, commaIndex);
                st = st.substring(commaIndex + 1);
                colonIndex = workString.indexOf(':');
                if (colonIndex == -1) {
                    res[i][j] = Integer.parseInt(workString);
                    continue;
                }
                lengthString = workString.substring(colonIndex + 1);
                sequenceLength = Integer.parseInt(lengthString);
                workString = workString.substring(0, colonIndex);
                sequenceInteger = Integer.parseInt(workString);
                res[i][j] = sequenceInteger;
                sequenceLength--;
            }
        }
        return res;
    }

    private int yy_acpt[] = {
    /* 0 */YY_NOT_ACCEPT,
    /* 1 */YY_NO_ANCHOR,
    /* 2 */YY_NO_ANCHOR,
    /* 3 */YY_NO_ANCHOR,
    /* 4 */YY_NO_ANCHOR,
    /* 5 */YY_NO_ANCHOR,
    /* 6 */YY_NO_ANCHOR,
    /* 7 */YY_NO_ANCHOR,
    /* 8 */YY_NO_ANCHOR,
    /* 9 */YY_NO_ANCHOR,
    /* 10 */YY_NO_ANCHOR,
    /* 11 */YY_NO_ANCHOR,
    /* 12 */YY_NO_ANCHOR,
    /* 13 */YY_NO_ANCHOR,
    /* 14 */YY_NO_ANCHOR,
    /* 15 */YY_NOT_ACCEPT,
    /* 16 */YY_NO_ANCHOR,
    /* 17 */YY_NOT_ACCEPT,
    /* 18 */YY_NO_ANCHOR,
    /* 19 */YY_NOT_ACCEPT,
    /* 20 */YY_NO_ANCHOR,
    /* 21 */YY_NOT_ACCEPT,
    /* 22 */YY_NO_ANCHOR,
    /* 23 */YY_NOT_ACCEPT,
    /* 24 */YY_NOT_ACCEPT,
    /* 25 */YY_NOT_ACCEPT,
    /* 26 */YY_NOT_ACCEPT,
    /* 27 */YY_NOT_ACCEPT,
    /* 28 */YY_NOT_ACCEPT,
    /* 29 */YY_NOT_ACCEPT,
    /* 30 */YY_NOT_ACCEPT,
    /* 31 */YY_NOT_ACCEPT,
    /* 32 */YY_NOT_ACCEPT,
    /* 33 */YY_NO_ANCHOR,
    /* 34 */YY_NO_ANCHOR,
    /* 35 */YY_NO_ANCHOR,
    /* 36 */YY_NO_ANCHOR,
    /* 37 */YY_NO_ANCHOR,
    /* 38 */YY_NO_ANCHOR,
    /* 39 */YY_NO_ANCHOR,
    /* 40 */YY_NO_ANCHOR };
    private int yy_cmap[] =
            unpackFromString(
                    1,
                    65538,
                    "0:9,25:2,0,25:2,0:18,25,0:6,24,1,7,0,13,0,11,0:2,22:10,0:7,23,14,23:3,15,23"
                            + ":2,18,23:10,20,23:6,0:4,24,0,16,23:2,4,5,8,23:2,9,23:2,6,2,10,3,23:2,21,17,"
                            + "19,12,23:5,0:69,23:23,0,23:31,0,23:8,0:65280,26:2")[0];

    private int yy_rmap[] = unpackFromString(
            1, 41,
            "0,1,2,3:3,4,3:2,2:4,3:2,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"
                    + ",24,25,26,27,28,29,30")[0];

    private int yy_nxt[][] =
            unpackFromString(
                    31,
                    27,
                    "-1,1,2:5,3,2:3,4,2,5,37,40,2:2,33,2,38,2,6,2,-1,7,8,-1:2,15,-1,17,-1:24,2:5"
                            + ",-1,2:3,-1,2,-1,2:11,-1:51,6,-1:7,19,-1:25,2:5,-1,2:3,-1,2,-1,2:5,9,2:5,-1:"
                            + "7,21,-1:23,2:4,10,-1,2:3,-1,2,-1,2:11,-1:6,23,-1:24,2:3,11,2,-1,2:3,-1,2,-1"
                            + ",2:11,-1:10,24,-1:20,2:3,12,2,-1,2:3,-1,2,-1,2:11,-1:7,25,-1:30,26,-1:23,13"
                            + ",-1:30,27,-1:21,28,-1:32,29,-1:23,30,-1:30,31,-1:24,14,-1:42,8,-1:2,2:5,-1,"
                            + "2:2,16,-1,2,-1,2:11,-1:4,2,18,2:3,-1,2:3,-1,2,-1,2:11,-1:4,2:5,-1,2:3,-1,20"
                            + ",-1,2:11,-1:4,2:5,-1,2:3,-1,2,-1,2:3,22,2:7,-1:4,2,34,2:3,-1,2:3,-1,2,-1,2:"
                            + "11,-1:4,2:5,-1,2:3,-1,2,-1,2:7,35,2:3,-1:4,2:4,36,-1,2:3,-1,2,-1,2:11,-1:4,"
                            + "2:5,-1,2:3,-1,2,-1,2:2,39,2:8,-1:2");

    public java_cup.runtime.Symbol next_token() throws java.io.IOException {

        int yy_lookahead;
        int yy_anchor = YY_NO_ANCHOR;
        int yy_state = yy_state_dtrans[yy_lexical_state];
        int yy_next_state = YY_NO_STATE;
        int yy_last_accept_state = YY_NO_STATE;
        boolean yy_initial = true;
        int yy_this_accept;

        yy_mark_start();
        yy_this_accept = yy_acpt[yy_state];
        if (YY_NOT_ACCEPT != yy_this_accept) {
            yy_last_accept_state = yy_state;
            yy_mark_end();
        }
        while (true) {
            if (yy_initial && yy_at_bol)
                yy_lookahead = YY_BOL;
            else
                yy_lookahead = yy_advance();
            yy_next_state = YY_F;
            yy_next_state = yy_nxt[yy_rmap[yy_state]][yy_cmap[yy_lookahead]];
            if (YY_EOF == yy_lookahead && true == yy_initial) {
                return null;
            }
            if (YY_F != yy_next_state) {
                yy_state = yy_next_state;
                yy_initial = false;
                yy_this_accept = yy_acpt[yy_state];
                if (YY_NOT_ACCEPT != yy_this_accept) {
                    yy_last_accept_state = yy_state;
                    yy_mark_end();
                }
            }
            else {
                if (YY_NO_STATE == yy_last_accept_state) {
                    throw (new Error("Lexical Error: Unmatched Input."));
                }
                else {
                    yy_anchor = yy_acpt[yy_last_accept_state];
                    if (0 != (YY_END & yy_anchor)) {
                        yy_move_end();
                    }
                    yy_to_mark();
                    switch (yy_last_accept_state) {
                        case 1: {
                            return new Symbol(sym._SYMB_3);
                        }
                        case -2:
                            break;
                        case 2: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -3:
                            break;
                        case 3: {
                            return new Symbol(sym._SYMB_1);
                        }
                        case -4:
                            break;
                        case 4: {
                            return new Symbol(sym._SYMB_4);
                        }
                        case -5:
                            break;
                        case 5: {
                            return new Symbol(sym._SYMB_5);
                        }
                        case -6:
                            break;
                        case 6: {
                            return new Symbol(sym._INTEGER_,
                                    new Integer(yytext()));
                        }
                        case -7:
                            break;
                        case 7: { /* ignore white space. */}
                        case -8:
                            break;
                        case 8:

                        case -9:
                            break;
                        case 9: {
                            return new Symbol(sym._SYMB_8);
                        }
                        case -10:
                            break;
                        case 10: {
                            return new Symbol(sym._SYMB_6);
                        }
                        case -11:
                            break;
                        case 11: {
                            return new Symbol(sym._SYMB_9);
                        }
                        case -12:
                            break;
                        case 12: {
                            return new Symbol(sym._SYMB_7);
                        }
                        case -13:
                            break;
                        case 13: {
                            return new Symbol(sym._SYMB_0);
                        }
                        case -14:
                            break;
                        case 14: {
                            return new Symbol(sym._SYMB_2);
                        }
                        case -15:
                            break;
                        case 16: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -16:
                            break;
                        case 18: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -17:
                            break;
                        case 20: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -18:
                            break;
                        case 22: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -19:
                            break;
                        case 33: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -20:
                            break;
                        case 34: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -21:
                            break;
                        case 35: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -22:
                            break;
                        case 36: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -23:
                            break;
                        case 37: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -24:
                            break;
                        case 38: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -25:
                            break;
                        case 39: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -26:
                            break;
                        case 40: {
                            return new Symbol(sym._IDENT_, yytext().intern());
                        }
                        case -27:
                            break;
                        default:
                            yy_error(YY_E_INTERNAL, false);
                        case -1:
                    }
                    yy_initial = true;
                    yy_state = yy_state_dtrans[yy_lexical_state];
                    yy_next_state = YY_NO_STATE;
                    yy_last_accept_state = YY_NO_STATE;
                    yy_mark_start();
                    yy_this_accept = yy_acpt[yy_state];
                    if (YY_NOT_ACCEPT != yy_this_accept) {
                        yy_last_accept_state = yy_state;
                        yy_mark_end();
                    }
                }
            }
        }
    }
}
