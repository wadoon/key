package de.uka.ilkd.key.testgeneration.parser.z3parser.api;

import java.util.HashMap;

import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.BFalse;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.BTrue;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Blck;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Block;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Bool;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.EBool;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.EInt;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ENVal;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.ESInt;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.EVal;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Exp;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Fun;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Function;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Mod;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Op;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.SNeg;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.SPos;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.TBool;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.TInt;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Type;
import de.uka.ilkd.key.testgeneration.parser.z3parser.tree.bnf.Absyn.Val;

public class Z3Visitor {

    public static ModelVisitor getInstance() {

        return new ModelVisitor();
    }

    private static class ModelVisitor
            implements Mod.Visitor<Void, HashMap<String, ValueContainer>> {

        @Override
        public Void visit(
                Mod model,
                HashMap<String, ValueContainer> valueContainers) {

            for (Fun fun : model.listfun_) {

                /*
                 * Extract the value assignments present in each subtree, and
                 * place them in separate value containers. Store each such
                 * container in the HashMap which is then returned as a
                 * representation of the model as a whole.
                 */
                ValueContainer container = new ValueContainer();
                fun.accept(new FunVisitor(), container);
                valueContainers.put(container.getName(), container);
            }

            return null;
        }
    }

    private static class FunVisitor
            implements Fun.Visitor<Void, ValueContainer> {

        @Override
        public Void visit(Function func, ValueContainer container) {

            /*
             * Set the name here - strip away the tags generated by the SMT
             * interface
             */
            String name = func.ident_.substring(0, func.ident_.length() - 2);
            container.setName(name);

            func.block_.accept(new BlockVisitor(), container);
            func.type_.accept(new TypeVisitor(), container);
            func.val_.accept(new ValVisitor(), container);

            return null;
        }
    }

    private static class BlockVisitor
            implements Block.Visitor<Void, ValueContainer> {

        @Override
        public Void visit(Blck block, ValueContainer container) {

            /* Code For Block Goes Here */

            for (Exp exp : block.listexp_) {

                exp.accept(new ExpVisitor(), container);
            }

            return null;
        }
    }

    private static class ValVisitor
            implements Val.Visitor<Void, ValueContainer> {

        public Void visit(EVal val, ValueContainer container) {

            val.exp_.accept(new ExpVisitor(), container);

            return null;
        }

        public Void visit(ENVal blockVal, ValueContainer container) {

            blockVal.block_.accept(new BlockVisitor(), container);

            return null;
        }
    }

    private static class ExpVisitor
            implements Exp.Visitor<Void, ValueContainer> {

        public Void visit(EInt integer, ValueContainer container) {

            /* Code For EInt Goes Here */

            container.setValue(integer.integer_);

            return null;
        }

        public Void visit(ESInt signedInt, ValueContainer container) {

            Character sign = signedInt.op_.accept(new OpVisitor(), null);

            if (sign.equals('+')) {
                container.setValue(signedInt.integer_);
            }
            container.setValue(signedInt.integer_ * (-1));

            return null;
        }

        public Void visit(EBool bool, ValueContainer container) {

            bool.bool_.accept(new BoolVisitor(), container);

            return null;
        }

    }

    private static class BoolVisitor
            implements Bool.Visitor<Void, ValueContainer> {

        public Void visit(BTrue trueBool, ValueContainer container) {

            container.setValue(new Boolean(true));

            return null;
        }

        public Void visit(BFalse falseBool, ValueContainer container) {

            container.setValue(new Boolean(false));

            return null;
        }

    }

    private static class OpVisitor
            implements Op.Visitor<Character, Void> {

        public Character visit(SNeg sign, Void Nothing) {

            return '-';
        }

        public Character visit(SPos sign, Void Nothing) {

            return '+';
        }
    }

    private static class TypeVisitor
            implements Type.Visitor<Void, ValueContainer> {

        public Void visit(TInt integerType, ValueContainer container) {

            container.setType(ValueContainer.Type.INTEGER);

            return null;
        }

        public Void visit(TBool boolType, ValueContainer container) {

            container.setType(ValueContainer.Type.BOOLEAN);

            return null;
        }
    }

    public static class ValueContainer {

        private String name;
        private Type type;
        private Object value;

        public enum Type {
            INTEGER, BOOLEAN;
        }

        public String getName() {

            return name;
        }

        public void setName(String name) {

            this.name = name;
        }

        public Type getType() {

            return type;
        }

        public void setType(Type type) {

            this.type = type;
        }

        public Object getValue() {

            return value;
        }

        public void setValue(Object value) {

            this.value = value;
        }
    }
}
