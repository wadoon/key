
//----------------------------------------------------
// The following code was generated by CUP v0.12joho 20110608
// Wed May 30 16:23:40 CEST 2012
//----------------------------------------------------

package de.uni_freiburg.informatik.ultimate.smtinterpol.dimacs;

import de.uni_freiburg.informatik.ultimate.logic.*;
import de.uni_freiburg.informatik.ultimate.logic.Script.LBool;
import de.uni_freiburg.informatik.ultimate.smtinterpol.smtlib2.SMTInterpol;
import org.apache.log4j.Logger;
import java_cup.runtime.Symbol;
import de.uni_freiburg.informatik.ultimate.smtinterpol.util.MySymbolFactory;

/** CUP v0.12joho 20110608 generated parser.
  * @version Wed May 30 16:23:40 CEST 2012
  */
public class Parser extends java_cup.runtime.LRParser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}
  /** Return action table */
  protected String[] action_table() { 
    return new String[] {
    "\026\000\002\004\003\003\004\002\001\002\002" +
    "\001\002\006\000\005\002\010\000\007\001\007" +
    "\002\024\040\040\040\030\056\054\024\024\024" +
    "\026\046\052\024\052\024\024\024\024\024\024" +
    "\076\000\000\000\000\000\000\010\000\024\000" +
    "\000\000\002\000\012\004\020\014\026\006\024" +
    "\001\007\037\011\037\003\031\007\013\007\022" +
    "\007\015\002\016\000\003\001\011\002\013\002" +
    "\022\002\015\012\013\012\043\012\015\013\043" +
    "\015\047\005\035\004\033\024\001\030\000\001" +
    "\007\002\003\022\001\017\007\010\003\001\007" +
    "\011\012\013\020\010\001\001\001\001\012\013"
    };
  }

  /** Instance of action encapsulation class. */
  protected Action$ action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new Action$(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java.util.ArrayList<java_cup.runtime.Symbol> stack)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, stack);
  }


  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return getScanner().next_token(); 
    }


	String filename;
	SMTInterpol solver;
	
	public void init(String filename) {
		this.filename = filename;
		solver = new SMTInterpol(Logger.getRootLogger(), true);
		solver.setOption(":produce-models", true);
		solver.setLogic(Logics.CORE);
	}
	
	public void report_error(String s, Object sym) {
		String location;
		if (sym instanceof MySymbolFactory.LineColumnSymbol) {
			MySymbolFactory.LineColumnSymbol bsym = (MySymbolFactory.LineColumnSymbol) sym;
			location = bsym.getLocation();
	    } else if ((sym instanceof Symbol) 
	    	       && ((Symbol)sym).sym == LexerSymbols.EOF) {
	    	location = "EOF";
	    } else
	        location = "UNKNOWN";
	    
		Logger.getRootLogger().error(filename+":"+location+": "+s);
	}

	public void report_error(String s) {	
		report_error(s, cur_token);
	}
	
	public SMTInterpol getSolver() {
		return solver;
	}


/** Cup generated class to encapsulate user supplied action code.*/
static class Action$ {


	long m_NumCls;
	long m_NumVars;
	
	public void declareVars(String numVars) {
		m_NumVars = Long.parseLong(numVars);
		Sort bool = parser.solver.sort("Bool");
		Sort[] empty = new Sort[0];
		for (long i = 1; i <= m_NumVars; ++i)
			parser.solver.declareFun("" + i, empty, bool);
	}
	
	public void setNumCls(String ncls) {
		m_NumCls = Long.parseLong(ncls);
	}
	
	public void newCls() {
		--m_NumCls;
	}
	
	public long checkCNF() {
		if (m_NumCls != 0)
			return m_NumCls;
		LBool isSat = parser.solver.checkSat();
		switch (isSat) {
		case SAT: {
			System.out.println("s SATISFIABLE");
			Model m = parser.solver.getModel();
			Term trueTerm = parser.solver.term("true");
			for (long i = 1; i <= m_NumVars; ++i) {
				if ((i % 8) == 1)
					System.out.print("\nv ");
				else
					System.out.print(" ");
				Term var = parser.solver.term(""+i);
				Term val = m.evaluate(var);
				System.out.print(val == trueTerm ? i : -i);
			}
			System.out.println(" 0");
			break; 
		}
		case UNSAT:
			System.out.println("s UNSATISFIABLE");
			break;
		case UNKNOWN:
			System.out.println("s UNKNOWN");
			break;
		}
		return 0;
	}

  private final Parser parser;

  /** Constructor */
  Action$(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  @SuppressWarnings({ "unused", "unchecked" })
  public final java_cup.runtime.Symbol CUP$do_action(
    int                        CUP$act_num,
    java.util.ArrayList<java_cup.runtime.Symbol> CUP$stack)
    throws java.lang.Exception
    {
      /* Stack size for peeking into the stack */
      int CUP$size = CUP$stack.size();

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          // $START ::= problemdesc EOF 
          case 0:
            {
              Object RESULT;
RESULT = null;
/* ACCEPT */
parser.done_parsing();
              return parser.getSymbolFactory().newSymbol("$START", 0, CUP$stack.get(CUP$size - 2), CUP$stack.get(CUP$size - 1), RESULT);
            }

          // problemdesc ::= header clause* EOF 
          case 1:
            {
 long diff = checkCNF();
									if (diff > 0)
										parser.report_error(diff + " clauses missing");
									else if (diff < 0)
										parser.report_error(-diff + " clauses too much");
									
              return parser.getSymbolFactory().newSymbol("problemdesc", 4, CUP$stack.get(CUP$size - 3), CUP$stack.get(CUP$size - 1));
            }

          // header ::= PROBLEM CNF NUMBER NUMBER 
          case 2:
            {
              java_cup.runtime.Symbol c$ = CUP$stack.get(CUP$size - 1);
              String c = (String) c$.value;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 2);
              String v = (String) v$.value;
 declareVars(v); setNumCls(c); 
              return parser.getSymbolFactory().newSymbol("header", 3, CUP$stack.get(CUP$size - 4), c$);
            }

          // literal ::= NUMBER 
          case 3:
            {
              Term RESULT;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 1);
              String a = (String) a$.value;
 try {
							RESULT = parser.solver.term(a);
						} catch (SMTLIBException se) {
							parser.report_error("Variable index out of bounds: " + a);
							System.exit(1);
							RESULT = null;
						}
						
              return parser.getSymbolFactory().newSymbol("literal", 2, a$, a$, RESULT);
            }

          // literal ::= NOT NUMBER 
          case 4:
            {
              Term RESULT;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 1);
              String a = (String) a$.value;
 try {
							RESULT = parser.solver.term("not", parser.solver.term(a));
						} catch (SMTLIBException se) {
							parser.report_error("Variable index out of bounds: " + a);
							System.exit(1);
							RESULT = null;
						}
		  				
              return parser.getSymbolFactory().newSymbol("literal", 2, CUP$stack.get(CUP$size - 2), a$, RESULT);
            }

          // clause ::= literal* EOC 
          case 5:
            {
              java_cup.runtime.Symbol lts$ = CUP$stack.get(CUP$size - 2);
              java.util.ArrayList<Term> CUP$list$lts = (java.util.ArrayList<Term>) lts$.value;
              Term[] lts = CUP$list$lts.toArray(new Term[CUP$list$lts.size()]);
 newCls();
								if (lts.length == 0)
									parser.solver.assertTerm(parser.solver.term("false"));
								else if (lts.length == 1)
									parser.solver.assertTerm(lts[0]);
								else
									parser.solver.assertTerm(parser.solver.term("or", lts)); 
              return parser.getSymbolFactory().newSymbol("clause", 1, lts$, CUP$stack.get(CUP$size - 1));
            }

          // clause* ::= 
          case 6:
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("clause*", 6, CUP$sym, CUP$sym);
            }

          // clause+ ::= clause+ clause 
          case 7:
            {
              return parser.getSymbolFactory().newSymbol("clause+", 5, CUP$stack.get(CUP$size - 2), CUP$stack.get(CUP$size - 1));
            }

          // literal* ::= 
          case 8:
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("literal*", 8, CUP$sym, CUP$sym, new java.util.ArrayList<Term>());
            }

          // literal+ ::= literal 
          case 9:
            {
              java_cup.runtime.Symbol CUP$0 = CUP$stack.get(CUP$size - 1);
              java.util.ArrayList<Term> RESULT = new java.util.ArrayList<Term>();
              RESULT.add((Term) CUP$0.value);
              return parser.getSymbolFactory().newSymbol("literal+", 7, CUP$0, CUP$0, RESULT);
            }

          // literal+ ::= literal+ literal 
          case 10:
            {
              java_cup.runtime.Symbol CUP$1 = CUP$stack.get(CUP$size - 1);
              java_cup.runtime.Symbol CUP$0 = CUP$stack.get(CUP$size - 2);
              java.util.ArrayList<Term> RESULT = (java.util.ArrayList<Term>) CUP$0.value;
              RESULT.add((Term) CUP$1.value);
              return parser.getSymbolFactory().newSymbol("literal+", 7, CUP$0, CUP$1, RESULT);
            }

          /* . . . . . .*/
          default:
            throw new InternalError(
               "Invalid action number found in internal parse table");

        }
    }
}

}
