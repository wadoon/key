\sorts {
    Nat \extends java.lang.Object;
    /*! @defaultValue(nil) */
    NatList;
}
\functions {
    \unique Nat Nat(int);
    \unique NatList nil;
    \unique NatList cons(Nat, NatList);
    NatList append(NatList, NatList);
    NatList reverse(NatList);
    int len(NatList);
    Nat get(NatList, int);
    NatList remove(NatList, int);
}
\axioms {
    natlist_induction {
        \schemaVar \formula phi;
        \schemaVar \variable NatList base;
        \schemaVar \variable Nat first;

        \find( ==> \forall base; phi )
        \varcond( \notFreeIn(first,phi) )

        "base case": \replacewith( ==>  {\subst base; nil} phi );
        "1. case": \replacewith( ==> \forall first; \forall base;  ( phi -> {\subst base; cons(first, base)} phi ) )
    };
    natlist_ctor_split {
        \schemaVar \term NatList natlist;
        \schemaVar \skolemTerm Nat first;
        \schemaVar \skolemTerm NatList rest;
        \find(natlist) \sameUpdateLevel
        \varcond(\new(first, \dependingOn(natlist)), \new(rest, \dependingOn(natlist)))
        \replacewith(nil) \add(natlist = nil ==>);
        \replacewith(cons(first, rest)) \add(natlist = cons(first, rest) ==>)
    };
    append_nil_l {
        \schemaVar \term NatList l;
        \find( append(nil, l) )
        \replacewith( l )
    };
    append_cons_e_l1_l2 {
        \schemaVar \term NatList l1;
        \schemaVar \term NatList l2;
        \schemaVar \term Nat e;
        \find( append(cons(e, l1), l2) )
        \replacewith( cons(e, append(l1, l2)) )
    };
    reverse_nil {
        \find( reverse(nil) )
        \replacewith( nil )
    };
    reverse_cons_e_l {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \find( reverse(cons(e, l)) )
        \replacewith( append(reverse(l), cons(e, nil)) )
    };
    len_nil {
        \find( len(nil) )
        \replacewith( 0 )
    };
    len_cons_e_l {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \find( len(cons(e, l)) )
        \replacewith( 1+len(l) )
    };
    get_cons_e_l_0 {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \find( get(cons(e, l), 0) )
        \replacewith( e )
    };
    get_cons_e_l_i {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \schemaVar \term int i;
        \find( get(cons(e, l), i) )
        \replacewith( get(l, i-1) )
    };
    remove_cons_e_l_0 {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \find( remove(cons(e, l), 0) )
        \replacewith( l )
    };
    remove_cons_e_l_j {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \schemaVar \term int j;
        \find( remove(cons(e, l), j) )
        \replacewith( cons(e, remove(l, j-1)) )
    };

    rev_natlist_induction {
        \schemaVar \formula phi;
        \schemaVar \variable NatList base;
        \schemaVar \variable Nat first;

        \find( ==> \forall base; phi )
        \varcond( \notFreeIn(first, phi) )

        "base case": \replacewith( ==>  {\subst base; nil} phi );
        "1. case": \replacewith( ==> \forall first; ( {\subst base; nil} phi -> {\subst base; cons(first, nil)} phi ) );
	"2. case": \replacewith( ==> \forall first; \forall base;  ( {\subst base; cons(first, nil) } phi -> {\subst base; cons(first, reverse(base))}phi ) )
    };

	get_ind {
    		\schemaVar \formula phi;
			\schemaVar \variable int idx;
	\schemaVar \variable NatList base;
	\schemaVar \variable Nat first;

	\find( ==> \forall idx; \forall base; phi )
	\varcond( \notFreeIn(first, phi) )

	\replacewith( ==> \forall idx; {\subst base;nil}phi );
	\replacewith( ==> \forall first; {\subst base;cons(first,nil)}{\subst idx;0}phi );
	\replacewith( ==> \forall idx; \forall first; \forall base; {\subst base;cons(first,base)}{\subst idx;idx}phi )
	\add( \forall first; {\subst base;cons(first,nil)}{\subst idx;0}phi ==> )
    };


    get_last_l {
    	       \schemaVar \term NatList l;
	       \schemaVar \term Nat i;
    	       \find( get(append(l, cons(i, nil)), len(l)) )
	       \replacewith( i )
    };

    get_last_n {
    	       \schemaVar \term NatList l1,l2;
       	       \schemaVar \term Nat i;
	       \schemaVar \term int j;

	       \find( get(append(l1,l2), j) )
	       \replacewith( get(l1, j) ) \add( j < len(l1) ==> );
	       \replacewith( get(l2, j-len(l1) ) ) \add( j >= len(l1) ==> )

    };

    len_reverse {
    		\schemaVar \term NatList l;
		\find( len(reverse(l)) )
		\replacewith( len(l) )
    };

    len_append {
    	       \schemaVar \term NatList l1,l2;
	       \find( len(append(l1,l2)) )
	       \replacewith( len(l1) + len(l2) )
    };

    append_append {
    		  \schemaVar \term NatList l1,l2,l3;
		  \find( append(append(l1,l2),l3) )
		  \replacewith( append(l1, append(l2,l3)) )
    };

    rev_rev {
    	    \schemaVar \term NatList l;
	    \find( reverse(reverse(l)) )
	    \replacewith( l )
    };
}



\problem {

	 \forall NatList l; \forall int i; ((len(l) >= 1 & i >= 0 & i < len(l)) -> (get(reverse(l), len(l) - i - 1) = get(l, i)))

	 // \forall NatList l; \forall int i; \forall Nat f; (len(l) >= 1 -> (get(reverse(l), len(l) - i - 1) = get(l, i) -> get(reverse(cons(f,l)), len(l) - i) = get(cons(f,l),i + 1) ))

// \forall int i; ( get(cons(Nat(1), cons(Nat(2), cons(Nat(3), cons(Nat(4), nil)))), i) = get(reverse(cons(Nat(1), cons(Nat(2), cons(Nat(3), cons(Nat(4), nil))))), len(cons(Nat(1), cons(Nat(2), cons(Nat(3), cons(Nat(4), nil))))) - (i + 1)))
}
