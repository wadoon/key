<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns2:aeRelationalModel xmlns:ns2="http://www.key-project.org/abstractexecution" preCondition="(\forall any valLeft;&#10;  (\forall any valRight; (&#10;    (loopExitedLeft  &amp;&amp; inv(valLeft) &amp;&amp;&#10;     loopExitedRight &amp;&amp; inv(valRight)) ==&gt;&#10;      valLeft == valRight))) &amp;&amp;&#10;oldFootprintQ == \value(footprintQ)" postCondition="\result_1 == \result_2">
    <programOne>/*@ ae_constraint
  @   \disjoint(frameQ, footprintE) &amp;&amp;
  @   \disjoint(frameQ, frameP) &amp;&amp;
  @   \disjoint(frameP, footprintQ) &amp;&amp;
  @   \disjoint(footprintE, footprintQ);
  @*/
{ ; }

/*@ ae_constraint guardIsTrue(\value(footprintE)); */
{ ; }












/*@ ae_constraint
  @   inv(\value(frameP)) &amp;&amp; decrExpr(\value(frameP)) &gt;= 0;
  @*/
{ ; }

/*@ loop_invariant
  @   decrExpr(\value(frameP)) &gt;= 0 &amp;&amp;
  @   inv(\value(frameP)) &amp;&amp;
  @   (!guardIsTrue(\value(footprintE)) ==&gt;
  @     \value(frameQ) == resultQ(oldFootprintQ));
  @ assignable frameP, footprintE, frameQ;
  @ decreases decrExpr(\value(frameP));
  @*/
while (
   /*@ assignable \nothing;
     @ accessible footprintE;
     @ normal_behavior ensures (boolean) \result &lt;==&gt;
     @   guardIsTrue(\value(footprintE));
     @ exceptional_behavior requires false;
     @*/
   \abstract_expression boolean e
) {
    //@ ghost int oldVariantLeft;

    /*@ ae_constraint
      @   \disjoint(frameP, oldVariantLeft) &amp;&amp;
      @   \disjoint(footprintE, oldVariantLeft) &amp;&amp;
      @   \disjoint(frameQ, oldVariantLeft);
      @*/
    { ; }

    // Hacky ghost setter
    /*@ assignable \hasTo(oldVariantLeft);
      @ accessible frameP;
      @ normal_behavior ensures oldVariantLeft == decrExpr(\value(frameP));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement VariantHack;

    /*@ assignable frameQ;
      @ accessible footprintQ;
      @ normal_behavior ensures \value(frameQ) == resultQ(oldFootprintQ);
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement Q;

    /*@ assignable frameP, footprintE;
      @ accessible footprintP;
      @ normal_behavior ensures
      @   inv(\value(frameP)) &amp;&amp;
      @   decrExpr(\value(frameP)) &gt;= 0 &amp;&amp;
      @   decrExpr(\value(frameP)) &lt; oldVariantLeft;
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement P;
}

/*@ assume loopExitedLeft == true; */
{ ; }</programOne>
    <programTwo>/*@ ae_constraint
  @   \disjoint(frameQ, footprintE) &amp;&amp;
  @   \disjoint(frameQ, frameP) &amp;&amp;
  @   \disjoint(frameP, footprintQ) &amp;&amp;
  @   \disjoint(footprintE, footprintQ);
  @*/
{ ; }

/*@ ae_constraint guardIsTrue(\value(footprintE)); */
{ ; }


/*@ assignable frameQ;
  @ accessible footprintQ;
  @ normal_behavior ensures \value(frameQ) == resultQ(oldFootprintQ);
  @ exceptional_behavior requires false;
  @ return_behavior requires false;
  @ break_behavior requires false;
  @ continue_behavior requires false;
  @*/
\abstract_statement Q;

/*@ ae_constraint
  @   inv(\value(frameP)) &amp;&amp; decrExpr(\value(frameP)) &gt;= 0;
  @*/
{ ; }

/*@ loop_invariant
  @   decrExpr(\value(frameP)) &gt;= 0 &amp;&amp;
  @   inv(\value(frameP)) &amp;&amp;
  @
  @   \value(frameQ) == resultQ(oldFootprintQ);
  @ assignable frameP, footprintE;
  @ decreases decrExpr(\value(frameP));
  @*/
while (
   /*@ assignable \nothing;
     @ accessible footprintE;
     @ normal_behavior ensures (boolean) \result &lt;==&gt;
     @   guardIsTrue(\value(footprintE));
     @ exceptional_behavior requires false;
     @*/
   \abstract_expression boolean e
) {
    //@ ghost int oldVariantRight;

    /*@ ae_constraint
      @   \disjoint(frameP, oldVariantRight) &amp;&amp;
      @   \disjoint(footprintE, oldVariantRight) &amp;&amp;
      @   \disjoint(frameQ, oldVariantRight);
      @*/
    { ; }

    // Hacky ghost setter
    /*@ assignable \hasTo(oldVariantRight);
      @ accessible frameP;
      @ normal_behavior ensures oldVariantRight == decrExpr(\value(frameP));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement VariantHack;











    /*@ assignable frameP, footprintE;
      @ accessible footprintP;
      @ normal_behavior ensures
      @   inv(\value(frameP)) &amp;&amp;
      @   decrExpr(\value(frameP)) &gt;= 0 &amp;&amp;
      @   decrExpr(\value(frameP)) &lt; oldVariantRight;
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement P;
}

/*@ assume loopExitedRight == true; */
{ ; }</programTwo>
    <methodLevelContext></methodLevelContext>
    <locationSets>
        <locationSet funcName="frameP">
            <relevantOne>0</relevantOne>
            <relevantTwo>0</relevantTwo>
        <resultSortName>LocSet</resultSortName></locationSet>
        <locationSet funcName="footprintP">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
        <resultSortName>LocSet</resultSortName></locationSet>
        <locationSet funcName="footprintE">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
        <resultSortName>LocSet</resultSortName></locationSet>
        <locationSet funcName="frameQ">
            <relevantOne>1</relevantOne>
            <relevantTwo>1</relevantTwo>
        <resultSortName>LocSet</resultSortName></locationSet>
        <locationSet funcName="footprintQ">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
        <resultSortName>LocSet</resultSortName></locationSet>
    </locationSets>
    <functions>
        <function funcName="decrExpr">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
            <resultSortName>int</resultSortName>
            <argSort>any</argSort>
        </function>
        <function funcName="resultQ">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
            <resultSortName>any</resultSortName>
            <argSort>any</argSort>
        </function>
        <function funcName="oldFootprintQ">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
            <resultSortName>any</resultSortName>
        </function>
        <function funcName="loopExitedLeft">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
            <resultSortName>boolean</resultSortName>
        </function>
        <function funcName="loopExitedRight">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
            <resultSortName>boolean</resultSortName>
        </function>
    </functions>
    <predicates>
        <predicate predName="inv">
            <argSort>any</argSort>
        </predicate>
        <predicate predName="Post">
            <argSort>any</argSort>
            <argSort>any</argSort>
        </predicate>
        <predicate predName="guardIsTrue">
            <argSort>any</argSort>
        </predicate>
    </predicates>
    <programVariables/>
</ns2:aeRelationalModel>
