<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns2:aeRelationalModel xmlns:ns2="http://www.key-project.org/abstractexecution" preCondition="(\exists any _frL; (\exists int _I; (&#10;  (\forall any frL; (\forall int I; (&#10;     (&#10;       decrExpr(frL) &gt;= 0 &amp;&amp;&#10;       loopInv(frL) &amp;&amp;&#10;       !(!doneCondition(frL, I) &amp;&amp; guardVal(frL))&#10;     ) &lt;==&gt; (_frL == frL &amp;&amp; _I == I)&#10;))))))" postCondition="\result_1==\result_2">
    <programOne>/*@ ae_constraint
  @   \disjoint(loopLocs, done);
  @*/
{ ; }

done = false;
i = 0;

/*@ ae_constraint
  @   decrExpr(\value(loopLocs)) &gt;= 0 &amp;&amp;
  @   loopInv(\value(loopLocs)) &amp;&amp;
  @   !doneCondition(\value(loopLocs), 0);
  @*/
{ ; }

/*@ loop_invariant
  @   decrExpr(\value(loopLocs)) &gt;= 0 &amp;&amp;
  @   (done &lt;==&gt; doneCondition(\value(loopLocs), i)) &amp;&amp;
  @   loopInv(\value(loopLocs));
  @ assignable loopLocs;
  @ decreases decrExpr(\value(loopLocs));
  @*/
while (!done &amp;&amp;
   (/*@ assignable \nothing;
      @ accessible loopLocs;
      @ normal_behavior ensures
      @   (boolean) \result &lt;==&gt; guardVal(\value(loopLocs));
      @ exceptional_behavior requires false;
      @*/
    \abstract_expression boolean g)) {
    
    /*@ ae_constraint
      @   \disjoint(loopLocs, done) &amp;&amp;
      @   \disjoint(loopLocs, i);
      @*/
    { ; }
    
    //@ ghost int oldDecrExpr; // = decrExpr(\value(loopLocs));

    /*@ ae_constraint
      @   \disjoint(loopLocs, oldDecrExpr);
      @*/
    { ; }

    /*@ assignable \hasTo(oldDecrExpr);
      @ accessible loopLocs;
      @ normal_behavior ensures oldDecrExpr == decrExpr(\value(loopLocs));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement GhostSetter;
     
    if (
        /*@ assignable \nothing;
          @ accessible loopLocs;
          @ normal_behavior ensures (boolean) \result &lt;==&gt;
          @   doneCondition(\value(loopLocs), i+1);
          @ exceptional_behavior requires false;
          @*/
        \abstract_expression boolean cond
    ) {
        /*@ assignable loopLocs, done;
          @ accessible loopLocs;
          @ normal_behavior ensures
          @   done == true &amp;&amp;
          @   doneCondition(\value(loopLocs), i+1) &amp;&amp;
          @   loopInv(\value(loopLocs));
          @
          @ exceptional_behavior requires false;
          @ return_behavior requires false;
          @ break_behavior requires false;
          @ continue_behavior requires false;
          @*/
        \abstract_statement P;
    }
    
    /*@ assignable loopLocs;
      @ accessible loopLocs;
      @ normal_behavior ensures 
      @   (done &lt;==&gt; doneCondition(\value(loopLocs), i+1)) &amp;&amp;
      @   loopInv(\value(loopLocs)) &amp;&amp;
      @   decrExpr(\value(loopLocs)) &gt;= 0 &amp;&amp;
      @   oldDecrExpr &gt; decrExpr(\value(loopLocs));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement Q;

    i++;
}</programOne>
    <programTwo>





i = 0;

/*@ ae_constraint
  @   decrExpr(\value(loopLocs)) &gt;= 0 &amp;&amp;
  @   loopInv(\value(loopLocs)) &amp;&amp;
  @   !doneCondition(\value(loopLocs), 0);
  @*/
{ ; }

/*@ loop_invariant
  @   decrExpr(\value(loopLocs)) &gt;= 0 &amp;&amp;
  @   !doneCondition(\value(loopLocs), i) &amp;&amp;
  @   loopInv(\value(loopLocs));
  @ assignable loopLocs;
  @ decreases decrExpr(\value(loopLocs));
  @*/
while (
    /*@ assignable \nothing;
      @ accessible loopLocs;
      @ normal_behavior ensures
      @   (boolean) \result &lt;==&gt; guardVal(\value(loopLocs));
      @ exceptional_behavior requires false;
      @*/
    \abstract_expression boolean g) {
    
    /*@ ae_constraint
      @   \disjoint(loopLocs, i);
      @*/
    { ; }

    
    //@ ghost int oldDecrExpr; // = decrExpr(\value(loopLocs));

    /*@ ae_constraint
      @   \disjoint(loopLocs, oldDecrExpr);
      @*/
    { ; }

    /*@ assignable \hasTo(oldDecrExpr);
      @ accessible loopLocs;
      @ normal_behavior ensures oldDecrExpr == decrExpr(\value(loopLocs));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement GhostSetter;
     
    if (
        /*@ assignable \nothing;
          @ accessible loopLocs;
          @ normal_behavior ensures (boolean) \result &lt;==&gt;
          @   doneCondition(\value(loopLocs), i+1);
          @ exceptional_behavior requires false;
          @*/
        \abstract_expression boolean cond
    ) {
        /*@ assignable loopLocs, i;
          @ accessible loopLocs;
          @ exceptional_behavior requires false;
          @ return_behavior requires false;
          @ break_behavior requires true;
          @ ensures
          @   i == i + 1 &amp;&amp;
          @   doneCondition(\value(loopLocs), i+1) &amp;&amp;
          @   loopInv(\value(loopLocs)) &amp;&amp;
          @   decrExpr(\value(loopLocs)) &gt;= 0;
          @ continue_behavior requires false;
          @*/
        \abstract_statement R;
    }
    
    /*@ assignable loopLocs;
      @ accessible loopLocs;
      @ normal_behavior ensures 
      @   !doneCondition(\value(loopLocs), i+1) &amp;&amp;
      @   loopInv(\value(loopLocs)) &amp;&amp;
      @   decrExpr(\value(loopLocs)) &gt;= 0 &amp;&amp;
      @   oldDecrExpr &gt; decrExpr(\value(loopLocs));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement Q;

    i++;
}</programTwo>
    <methodLevelContext></methodLevelContext>
    <locationSets>
        <locationSet locsetName="relevant">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
        </locationSet>
        <locationSet locsetName="loopLocs">
            <relevantOne>0</relevantOne>
            <relevantTwo>0</relevantTwo>
        </locationSet>
    </locationSets>
    <functions>
        <function funcName="decrExpr" resultSortName="int">
            <argSort>any</argSort>
        </function>
    </functions>
    <predicates>
        <predicate predName="loopInv">
            <argSort>any</argSort>
        </predicate>
        <predicate predName="doneExpr">
            <argSort>any</argSort>
        </predicate>
        <predicate predName="guardVal">
            <argSort>any</argSort>
        </predicate>
        <predicate predName="doneCondition">
            <argSort>any</argSort>
            <argSort>int</argSort>
        </predicate>
    </predicates>
    <programVariables>
        <programVariable typeName="int" varName="i">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
        </programVariable>
        <programVariable typeName="boolean" varName="done">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
        </programVariable>
    </programVariables>
</ns2:aeRelationalModel>
