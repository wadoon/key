<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns2:aeRelationalModel xmlns:ns2="http://www.key-project.org/abstractexecution" preCondition="(\exists any _frP, _fpP, _fpG;&#10;  (\forall any frP, fpP, fpG; (&#10;         (variant(fpG) &gt;= 0 &amp;&amp;&#10;          loopInvP(frP, fpP, fpG) &amp;&amp;&#10;          loopInvG(fpG) &amp;&amp;&#10;          !guardIsTrue(fpG))&#10;    &lt;==&gt; (_frP == frP &amp;&amp; _fpP == fpP &amp;&amp; _fpG == fpG)&#10;))) &amp;&amp;&#10;(\exists any _frQ, _fpQ, _fpG;&#10;  (\forall any frQ, fpQ, fpG; (&#10;         (variant(fpG) &gt;= 0 &amp;&amp;&#10;          loopInvQ(frQ, fpQ, fpG) &amp;&amp;&#10;          loopInvG(fpG) &amp;&amp;&#10;          !guardIsTrue(fpG))&#10;    &lt;==&gt; (_frQ == frQ &amp;&amp; _fpQ == fpQ &amp;&amp; _fpG == fpG)&#10;)))" postCondition="\result_1==\result_2">
    <programOne>/*@ ae_constraint
  @   \disjoint(frameP, oldVariant) &amp;&amp;
  @   \disjoint(footprintP, oldVariant) &amp;&amp;
  @   \disjoint(frameQ, oldVariant) &amp;&amp;
  @   \disjoint(footprintQ, oldVariant) &amp;&amp;
  @   \disjoint(footprintG, oldVariant);
  @*/
{ ; }

/*@ ae_constraint
  @   \disjoint(footprintG, \dl_heap); // ???
  @*/
{ ; }

/*@ ae_constraint
  @   \disjoint(frameP, footprintG) &amp;&amp;
  @   \disjoint(frameQ, footprintG) &amp;&amp;
  @   \disjoint(footprintP, footprintG) &amp;&amp;
  @   \disjoint(footprintQ, footprintG);
  @*/
{ ; }

/*@ ae_constraint
  @   \disjoint(frameP, frameQ) &amp;&amp;
  @   \disjoint(frameP, footprintQ) &amp;&amp;
  @   \disjoint(frameQ, footprintP);
  @*/
{ ; }

/*@ assignable \hasTo(footprintG);
  @ accessible \nothing;
  @ exceptional_behavior requires false;
  @ return_behavior requires false;
  @ break_behavior requires false;
  @ continue_behavior requires false;
  @*/
\abstract_statement InitLoopCnt;

// Initial assumptions
/*@ ae_constraint
  @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
  @   loopInvG(\value(footprintG)) &amp;&amp;
  @   loopInvP(\value(frameP), \value(footprintP), \value(footprintG)) &amp;&amp;
  @   loopInvQ(\value(frameQ), \value(footprintQ), \value(footprintG));
  @*/
{ ; }

/*@ loop_invariant
  @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
  @   loopInvP(\value(frameP), \value(footprintP), \value(footprintG)) &amp;&amp;
  @   loopInvQ(\value(frameQ), \value(footprintQ), \value(footprintG)) &amp;&amp;
  @   loopInvG(\value(footprintG));
  @ assignable frameP, frameQ, footprintG;
  @ decreases variant(\value(footprintG));
  @*/
while (
    /*@ assignable \nothing;
      @ accessible footprintG;
      @ normal_behavior ensures
      @   (boolean) \result &lt;==&gt; guardIsTrue(\value(footprintG));
      @ exceptional_behavior requires false;
      @*/
    \abstract_expression boolean e
) {
    /*@ ae_constraint
      @   \disjoint(frameP, oldVariant) &amp;&amp;
      @   \disjoint(footprintP, oldVariant) &amp;&amp;
      @   \disjoint(frameQ, oldVariant) &amp;&amp;
      @   \disjoint(footprintQ, oldVariant) &amp;&amp;
      @   \disjoint(footprintG, oldVariant);
      @*/
    { ; }

    /*@ assignable \hasTo(oldVariant);
      @ accessible footprintG;
      @ normal_behavior ensures
      @   oldVariant == variant(\value(footprintG));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement GhostSetter;

    /*@ assignable \hasTo(footprintG);
      @ accessible \nothing;
      @ normal_behavior ensures
      @   loopInvG(\value(footprintG)) &amp;&amp;
      @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
      @   variant(\value(footprintG)) &lt; oldVariant;
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement LoopUpdate;
    
    /*@ assignable frameP;
      @ accessible footprintP, footprintG;
      @ normal_behavior ensures
      @   loopInvP(\value(frameP), \value(footprintP), \value(footprintG));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement P;

    /*@ assignable frameQ;
      @ accessible footprintQ, footprintG;
      @ normal_behavior ensures
      @   loopInvQ(\value(frameQ), \value(footprintQ), \value(footprintG));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement Q;
}













































































</programOne>
    <programTwo>/*@ ae_constraint
  @   \disjoint(frameP, oldVariant) &amp;&amp;
  @   \disjoint(footprintP, oldVariant) &amp;&amp;
  @   \disjoint(frameQ, oldVariant) &amp;&amp;
  @   \disjoint(footprintQ, oldVariant) &amp;&amp;
  @   \disjoint(footprintG, oldVariant);
  @*/
{ ; }

/*@ ae_constraint
  @   \disjoint(footprintG, \dl_heap);
  @*/
{ ; }

/*@ ae_constraint
  @   \disjoint(frameP, footprintG) &amp;&amp;
  @   \disjoint(frameQ, footprintG) &amp;&amp;
  @   \disjoint(footprintP, footprintG) &amp;&amp;
  @   \disjoint(footprintQ, footprintG);
  @*/
{ ; }

/*@ ae_constraint
  @   \disjoint(frameP, frameQ) &amp;&amp;
  @   \disjoint(frameP, footprintQ) &amp;&amp;
  @   \disjoint(frameQ, footprintP);
  @*/
{ ; }

/*@ assignable \hasTo(footprintG);
  @ accessible \nothing;
  @ exceptional_behavior requires false;
  @ return_behavior requires false;
  @ break_behavior requires false;
  @ continue_behavior requires false;
  @*/
\abstract_statement InitLoopCnt;

// Initial assumptions
/*@ ae_constraint
  @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
  @   loopInvG(\value(footprintG)) &amp;&amp;
  @   loopInvP(\value(frameP), \value(footprintP), \value(footprintG));
  @*/
{ ; }


/*@ loop_invariant
  @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
  @   loopInvP(\value(frameP), \value(footprintP), \value(footprintG)) &amp;&amp;
  @   loopInvG(\value(footprintG));
  @
  @ assignable frameP, footprintG;
  @ decreases variant(\value(footprintG));
  @*/
while (
    /*@ assignable \nothing;
      @ accessible footprintG;
      @ normal_behavior ensures
      @   (boolean) \result &lt;==&gt; guardIsTrue(\value(footprintG));
      @ exceptional_behavior requires false;
      @*/
    \abstract_expression boolean e
) {
    /*@ ae_constraint
      @   \disjoint(frameP, oldVariant) &amp;&amp;
      @   \disjoint(footprintP, oldVariant) &amp;&amp;
      @   \disjoint(footprintG, oldVariant);
      @*/
    { ; }



    /*@ assignable \hasTo(oldVariant);
      @ accessible footprintG;
      @ normal_behavior ensures
      @   oldVariant == variant(\value(footprintG));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement GhostSetter;

    /*@ assignable \hasTo(footprintG);
      @ accessible \nothing;
      @ normal_behavior ensures
      @   loopInvG(\value(footprintG)) &amp;&amp;
      @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
      @   variant(\value(footprintG)) &lt; oldVariant;
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement LoopUpdate;
    
    /*@ assignable frameP;
      @ accessible footprintP, footprintG;
      @ normal_behavior ensures
      @   loopInvP(\value(frameP), \value(footprintP), \value(footprintG));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement P;











}

/*@ assignable \hasTo(footprintG);
  @ accessible \nothing;
  @ exceptional_behavior requires false;
  @ return_behavior requires false;
  @ break_behavior requires false;
  @ continue_behavior requires false;
  @*/
\abstract_statement InitLoopCnt;

// Initial assumptions
/*@ ae_constraint
  @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
  @   loopInvG(\value(footprintG)) &amp;&amp;
  @   loopInvQ(\value(frameQ), \value(footprintQ), \value(footprintG));
  @*/
{ ; }


/*@ loop_invariant
  @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
  @   loopInvQ(\value(frameQ), \value(footprintQ), \value(footprintG)) &amp;&amp;
  @   loopInvG(\value(footprintG));
  @
  @ assignable frameQ, footprintG;
  @ decreases variant(\value(footprintG));
  @*/
while (
    /*@ assignable \nothing;
      @ accessible footprintG;
      @ normal_behavior ensures
      @   (boolean) \result &lt;==&gt; guardIsTrue(\value(footprintG));
      @ exceptional_behavior requires false;
      @*/
    \abstract_expression boolean e
) {
    /*@ ae_constraint
      @   \disjoint(frameQ, oldVariant) &amp;&amp;
      @   \disjoint(footprintQ, oldVariant) &amp;&amp;
      @   \disjoint(footprintG, oldVariant);
      @*/
    { ; }

    /*@ assignable \hasTo(oldVariant);
      @ accessible footprintG;
      @ normal_behavior ensures
      @   oldVariant == variant(\value(footprintG));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement GhostSetter;

    /*@ assignable \hasTo(footprintG);
      @ accessible \nothing;
      @ normal_behavior ensures
      @   loopInvG(\value(footprintG)) &amp;&amp;
      @   variant(\value(footprintG)) &gt;= 0 &amp;&amp;
      @   variant(\value(footprintG)) &lt; oldVariant;
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement LoopUpdate;

    /*@ assignable frameQ;
      @ accessible footprintQ, footprintG;
      @ normal_behavior ensures
      @   loopInvQ(\value(frameQ), \value(footprintQ), \value(footprintG));
      @ exceptional_behavior requires false;
      @ return_behavior requires false;
      @ break_behavior requires false;
      @ continue_behavior requires false;
      @*/
    \abstract_statement Q;
}</programTwo>
    <methodLevelContext></methodLevelContext>
    <locationSets>
        <locationSet locsetName="frameP">
            <relevantOne>0</relevantOne>
            <relevantTwo>0</relevantTwo>
        </locationSet>
        <locationSet locsetName="footprintP">
            <relevantOne>1</relevantOne>
            <relevantTwo>1</relevantTwo>
        </locationSet>
        <locationSet locsetName="frameQ">
            <relevantOne>2</relevantOne>
            <relevantTwo>2</relevantTwo>
        </locationSet>
        <locationSet locsetName="footprintQ">
            <relevantOne>3</relevantOne>
            <relevantTwo>3</relevantTwo>
        </locationSet>
        <locationSet locsetName="footprintG">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
        </locationSet>
    </locationSets>
    <functions>
        <function funcName="variant" resultSortName="int">
            <argSort>any</argSort>
        </function>
    </functions>
    <predicates>
        <predicate predName="loopInvP">
            <argSort>any</argSort>
            <argSort>any</argSort>
            <argSort>any</argSort>
        </predicate>
        <predicate predName="loopInvQ">
            <argSort>any</argSort>
            <argSort>any</argSort>
            <argSort>any</argSort>
        </predicate>
        <predicate predName="loopInvG">
            <argSort>any</argSort>
        </predicate>
        <predicate predName="guardIsTrue">
            <argSort>any</argSort>
        </predicate>
        <predicate predName="returnsP">
            <argSort>any</argSort>
            <argSort>any</argSort>
        </predicate>
    </predicates>
    <programVariables>
        <programVariable typeName="int" varName="oldVariant">
            <relevantOne>-1</relevantOne>
            <relevantTwo>-1</relevantTwo>
        </programVariable>
    </programVariables>
</ns2:aeRelationalModel>
