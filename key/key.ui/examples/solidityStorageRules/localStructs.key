\sorts{
	\generic G;
	\generic H;

	\generic alpha \extends any;
	\generic beta \extends any;
}

\rules(programRules:Solidity) {
	///////////////////// Sequences //////////////////////
	removeSingletonSeq {
		\schemaVar \term Field f;
		\find( seqRemove(seqSingleton(f), 0) )
		\replacewith( seqEmpty )
		\displayname "remove singleton seq"
		\heuristics(simplify)
	};
	
	removeFirstElementSeq {
		\schemaVar \term Field f;
		\schemaVar \term Seq seq1, seq2;
		\find( seqRemove(seqConcat(seq1, seq2), 0) )
		\replacewith( seq2 )
		\displayname "remove first element seq"
		\heuristics(simplify)
	};
	
	///////////////////// Writes /////////////////////////
	writeStructEmptyPath {
		\schemaVar \term alpha x;
		\schemaVar \term beta x0;
		\find( write(x, seqEmpty, x0) )
		\replacewith( x0 )
		\displayname "write struct empty path"
		\heuristics(simplify)
	};
	/*
	writeStructB {
		\schemaVar \term int i, i0, i1;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\find( write(B(i, i0), seqConcat(seqSingleton(f), rest), i1) )
		\replacewith( \if(f = MyContract.B::$b1)
		              \then (B((int)write(i, rest, i1), i0))
					  \else (B(i, (int)write(i0, rest, i1))) )
		\displayname "write struct B"
		\heuristics(simplify)
	};
	
	writeStructBEQ {
		\schemaVar \term int i, i0, i1;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\schemaVar \term Struct b;
		\assumes ( B(i, i0) = b ==> )
		\find( write(b, seqConcat(seqSingleton(f), rest), i1) )
		\replacewith( \if(f = MyContract.B::$b1)
		              \then (B((int)write(i, rest, i1), i0))
					  \else (B(i, (int)write(i0, rest, i1))) )
		\displayname "write struct B"
		\heuristics(simplify)
	};
	
	writeStructBSingletonPath {
		\schemaVar \term int i, i0, i1;
		\schemaVar \term Field f;
		\find( write(B(i, i0), seqSingleton(f), i1) )
		\replacewith( \if(f = MyContract.B::$b1)
		              \then (B((int)write(i, seqEmpty, i1), i0))
					  \else (B(i, (int)write(i0, seqEmpty, i1))) )
		\displayname "write struct B"
		\heuristics(simplify)
	};
	
	writeStructBSingletonPathEQ {
		\schemaVar \term int i, i0, i1;
		\schemaVar \term Field f;
		\schemaVar \term Struct b;
		\assumes (B(i, i0) = b ==> )
		\find( write(b, seqSingleton(f), i1) )
		\replacewith( \if(f = MyContract.B::$b1)
		              \then (B((int)write(i, seqEmpty, i1), i0))
					  \else (B(i, (int)write(i0, seqEmpty, i1))) )
		\displayname "write struct B"
		\heuristics(simplify)
	};
	
	writeStructA {
		\schemaVar \term Struct s1, s2;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\find( write(A(s1, s2), seqConcat(seqSingleton(f), rest), x) )
		\replacewith( \if(f = MyContract.A::$a1) 
		              \then (A((Struct)write(s1, rest, x), s2))
					  \else (A(s1, (Struct)write(s2, rest, x))) )
		\displayname "write struct A"
		\heuristics(simplify)
	};
	
	writeStructAEQ {
		\schemaVar \term Struct s1, s2, a;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\assumes ( A(s1, s2) = a ==> )
		\find( write(a, seqConcat(seqSingleton(f), rest), x) )
		\replacewith( \if(f = MyContract.A::$a1) 
		              \then (A((Struct)write(s1, rest, x), s2))
					  \else (A(s1, (Struct)write(s2, rest, x))) )
		\displayname "write struct A"
		\heuristics(simplify)
	};
	
	writeStructASingletonPath {
		\schemaVar \term Struct s1, s2;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\find( write(A(s1, s2), seqSingleton(f), x) )
		\replacewith( \if(f = MyContract.A::$a1) 
		              \then (A((Struct)write(s1, seqEmpty, x), s2))
					  \else (A(s1, (Struct)write(s2, seqEmpty, x))) )
		\displayname "write struct A"
		\heuristics(simplify)
	};
	
	writeStructASingletonPathEQ {
		\schemaVar \term Struct s1, s2, a;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\assumes( A(s1, s2) = a ==> )
		\find( write(a, seqSingleton(f), x) )
		\replacewith( \if(f = MyContract.A::$a1) 
		              \then (A((Struct)write(s1, seqEmpty, x), s2))
					  \else (A(s1, (Struct)write(s2, seqEmpty, x))) )
		\displayname "write struct A"
		\heuristics(simplify)
	};
	
	writeStorage {
		\schemaVar \term Struct s;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\find( write(Storage(s, i), seqConcat(seqSingleton(f), rest), x) )
		\replacewith ( \if(f = MyContractImpl::$f) 
		               \then (Storage((Struct)write(s, rest, x), i))
					   \else (Storage(s, (int)write(i, rest, x))) )
		\displayname "write storage"
		\heuristics(simplify)
	};
	
	writeStorageEQ {
		\schemaVar \term Struct s, st;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\assumes ( Storage(s, i) = st ==> )
		\find( write(st, seqConcat(seqSingleton(f), rest), x) )
		\replacewith ( \if(f = MyContractImpl::$f) 
		               \then (Storage((Struct)write(s, rest, x), i))
					   \else (Storage(s, (int)write(i, rest, x))) )
		\displayname "write storage"
		\heuristics(simplify)
	};
	
	writeStorageAlt {
		\schemaVar \term Struct s;
		\schemaVar \term int i;
		\schemaVar \term int[] j;
		\schemaVar \term alpha x;
		\schemaVar \term Seq seq;
		\find( write(Storage(s, i), seq, x) )
		\replacewith ( \if(Field::seqGet(seq, 0) = MyContractImpl::$f) 
		               \then (Storage((Struct)write(s, seqRemove(seq, 0), x), i))
					   \else (Storage(s, (int)write(i, seqRemove(seq, 0), x))) )
		\displayname "write storage ALT"
		\heuristics(simplify)
	};
	
	writeStorageSingletonPath { // 'writeStorage' covers this rule when rest = seqEmpty, but KeY will automatically use rule seqConcatWithEmpty when it sees 'seqConcat(seqSingleton(field), seqEmpty)', resulting in seqSingleton(field)
		\schemaVar \term Struct s;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\find( write(Storage(s, i), seqSingleton(f), x) )
		\replacewith ( \if(f = MyContractImpl::$f) 
		               \then (Storage((Struct)write(s, seqEmpty, x), i))
					   \else (Storage(s, (int)write(i, seqEmpty, x))) )
		\displayname "write storage singleton path"
		\heuristics(simplify)
	};
	
	writeStorageSingletonPathEQ {
		\schemaVar \term Struct s, st;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\assumes ( Storage(s, i) = st ==> )
		\find( write(st, seqSingleton(f), x) )
		\replacewith ( \if(f = MyContractImpl::$f) 
		               \then (Storage((Struct)write(s, seqEmpty, x), i))
					   \else (Storage(s, (int)write(i, seqEmpty, x))) )
		\displayname "write storage singleton path"
		\heuristics(simplify)
	};
	*/
	//////////////////////// Reads /////////////////////////
	readStructEmptyPath1 {
		\schemaVar \term beta x;
		\find ( alpha::read(x, seqEmpty) )
		\varcond ( \not \same(beta, Struct) )
		\replacewith ( (alpha)x )
		\displayname "read struct empty path"
		\heuristics(simplify)
	};
	
	readStructEmptyPath2 {
		// If 'x' is a struct, 'alpha' will be a concrete program struct type.
		// However, in SolidiKeY, all program structs are modelled as type "Struct"
		\schemaVar \term Struct x;
		\find ( alpha::read(x, seqEmpty) )
		\replacewith ( (Struct)x )
		\displayname "read struct empty path"
		\heuristics(simplify)
	};
	/*
	readStructB {
		\schemaVar \term int i, i0;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\find( alpha::read(B(i, i0), seqConcat(seqSingleton(f), rest)) )
		\replacewith( \if(f = MyContract.B::$b1) 
		              \then (alpha::read(i, rest)) 
					  \else (alpha::read(i0, rest)) )
		\displayname "read struct B"
		\heuristics(simplify)
	};
	
	readStructBEQ {
		\schemaVar \term int i, i0;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\schemaVar \term Struct b;
		\assumes( B(i, i0) = b ==> )
		\find( alpha::read(b, seqConcat(seqSingleton(f), rest)) )
		\replacewith( \if(f = MyContract.B::$b1) 
		              \then (alpha::read(i, rest)) 
					  \else (alpha::read(i0, rest)) )
		\displayname "read struct B"
		\heuristics(simplify)
	};
	
	readStructBSingletonPath {
		\schemaVar \term int i, i0;
		\schemaVar \term Field f;
		\find( alpha::read(B(i, i0), seqSingleton(f)) )
		\replacewith( \if(f = MyContract.B::$b1) 
		              \then (alpha::read(i, seqEmpty)) 
					  \else (alpha::read(i0, seqEmpty)) )
		\displayname "read struct B"
		\heuristics(simplify)
	};
	
	readStructBSingletonPathEQ {
		\schemaVar \term int i, i0;
		\schemaVar \term Field f;
		\schemaVar \term Struct b;
		\assumes( B(i, i0) = b ==> )
		\find( alpha::read(b, seqSingleton(f)) )
		\replacewith( \if(f = MyContract.B::$b1) 
		              \then (alpha::read(i, seqEmpty)) 
					  \else (alpha::read(i0, seqEmpty)) )
		\displayname "read struct B"
		\heuristics(simplify)
	};
	
	readStructA {
		\schemaVar \term Struct s1, s2;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\find( alpha::read(A(s1, s2), seqConcat(seqSingleton(f), rest)) )
		\replacewith( \if(f = MyContract.A::$a1) 
		              \then (alpha::read(s1, rest)) 
					  \else (alpha::read(s2, rest)) )
		\displayname "read struct A"
		\heuristics(simplify)
	};
	
	readStructAEQ {
		\schemaVar \term Struct s1, s2, a;
		\schemaVar \term Field f;
		\schemaVar \term Seq rest;
		\assumes( A(s1, s2) = a ==> )
		\find( alpha::read(a, seqConcat(seqSingleton(f), rest)) )
		\replacewith( \if(f = MyContract.A::$a1) 
		              \then (alpha::read(s1, rest)) 
					  \else (alpha::read(s2, rest)) )
		\displayname "read struct A"
		\heuristics(simplify)
	};
	
	readStructASingletonPath {
		\schemaVar \term Struct s1, s2;
		\schemaVar \term Field f;
		\find( alpha::read(A(s1, s2), seqSingleton(f)) )
		\replacewith( \if(f = MyContract.A::$a1) 
		              \then (alpha::read(s1, seqEmpty)) 
					  \else (alpha::read(s2, seqEmpty)) )
		\displayname "read struct A"
		\heuristics(simplify)
	};
	
	readStructASingletonPathEQ {
		\schemaVar \term Struct s1, s2, a;
		\schemaVar \term Field f;
		\assumes( A(s1, s2) = a ==> )
		\find( alpha::read(a, seqSingleton(f)) )
		\replacewith( \if(f = MyContract.A::$a1) 
		              \then (alpha::read(s1, seqEmpty)) 
					  \else (alpha::read(s2, seqEmpty)) )
		\displayname "read struct A"
		\heuristics(simplify)
	};
	
	readStorage {
		\schemaVar \term Struct s;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field head;
		\schemaVar \term Seq rest;
		\find( beta::read(Storage(s, i), seqConcat(seqSingleton(head), rest)) )
		\replacewith ( \if(head = MyContractImpl::$f) 
		               \then (beta::read(s, rest))
					   \else (beta::read(i, rest)))
		\displayname "read storage"
		\heuristics(simplify)
	};
	
	readStorageEQ {
		\schemaVar \term Struct s, st;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field head;
		\schemaVar \term Seq rest;
		\assumes ( Storage(s, i) = st ==>  )
		\find( beta::read(st, seqConcat(seqSingleton(head), rest)) )
		\replacewith ( \if(head = MyContractImpl::$f) 
		               \then (beta::read(s, rest))
					   \else (beta::read(i, rest)))
		\displayname "read storage"
		\heuristics(simplify)
	};
	
	readStorageSingletonPath {
		\schemaVar \term Struct s;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\find( beta::read(Storage(s, i), seqSingleton(f)) )
		\replacewith ( \if(f = MyContractImpl::$f) 
		               \then (beta::read(s, seqEmpty))
					   \else (beta::read(i, seqEmpty)))
		\displayname "read storage"
		\heuristics(simplify)
	};
	
	readStorageSingletonPathEQ {
		\schemaVar \term Struct s, st;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field f;
		\assumes ( Storage(s, i) = st ==>  )
		\find( beta::read(st, seqSingleton(f)) )
		\replacewith ( \if(f = MyContractImpl::$f) 
		               \then (beta::read(s, seqEmpty))
					   \else (beta::read(i, seqEmpty)))
		\displayname "read storage"
		\heuristics(simplify)
	};
	*/
	
	readOfWriteStruct {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field head, head0;
		\schemaVar \term Seq rest, rest0;
		\find( beta::read(write(s, seqConcat(seqSingleton(head), rest), x), seqConcat(seqSingleton(head0), rest0)) )
		\replacewith( \if (head = head0)
		              \then ( beta::read(write(s, rest, x), rest0) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head0), rest0))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructCast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field head, head0;
		\schemaVar \term Seq rest, rest0;
		\find( beta::read((Struct)(write(s, seqConcat(seqSingleton(head), rest), x)), seqConcat(seqSingleton(head0), rest0)) )
		\replacewith( \if (head = head0)
		              \then ( beta::read(write(s, rest, x), rest0) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head0), rest0))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath1 {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read(write(s, seqSingleton(f), x), seqConcat(seqSingleton(head), rest)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, seqEmpty, x), rest) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head), rest))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath1Cast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read((Struct)(write(s, seqSingleton(f), x)), seqConcat(seqSingleton(head), rest)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, seqEmpty, x), rest) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head), rest))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath2 {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read(write(s, seqConcat(seqSingleton(head), rest), x), seqSingleton(f)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, rest, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath2Cast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read((Struct)(write(s, seqConcat(seqSingleton(head), rest), x)), seqSingleton(f)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, rest, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPaths {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, f0;
		\find( beta::read(write(s, seqSingleton(f), x), seqSingleton(f0)) )
		\replacewith( \if (f = f0)
		              \then ( beta::read(write(s, seqEmpty, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f0)) ) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPathsCast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, f0;
		\find( beta::read((Struct)(write(s, seqSingleton(f), x)), seqSingleton(f0)) )
		\replacewith( \if (f = f0)
		              \then ( beta::read(write(s, seqEmpty, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f0)) ) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readArray {
		\schemaVar \term Struct s;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field head;
		\schemaVar \term Seq array, rest;
		\find( beta::read(array, seqSingleton(arr(i))) )
		\replacewith ( beta::read(any::seqGet(array, i), seqEmpty) )
		\displayname "read array"
		\heuristics(simplify)
	};
	
	//seqDef{int i;}(0,10, 2*i)
	
	////////////////////// Storage <=> self rules ///////////////////////
	selfToStorage {
		\schemaVar \term Heap h;
		\schemaVar \term Field f;
		\find( beta::select(h, self, f) ) // comes from a term like "self.f"
		\replacewith( beta::read(storage, seqSingleton(f)) )
		\displayname "self to storage"
		\heuristics(simplify)
	};
	
	/*
	storageField {
		\schemaVar \term Field f;
		\schemaVar \term Seq seq;
		\find( beta::read(storage, seq).f )
		\replacewith( beta::read(f, seqConcat(seq, f)) )
		\displayname "storage field"
		\heuristics(simplify)
	};
	*/
	//////////////////////// Assignments ///////////////////////////
	assignField1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. this.#a = #se; ... }\endmodality(post))
		\varcond ( \not \same(\typeof(#se), Seq) )
		\replacewith ( ==> { storage := (Struct)write(storage, seqSingleton(#memberPVToField(#a)), #se) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign field"
	};
	
	assignField2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #a0;

		\find ( ==> \modality{#allmodal}{ .. this.#a = this.#a0; ... }\endmodality(post))
		\varcond ( \hasSort(#a0, G) )
		\replacewith ( ==> { storage := (Struct)write(storage, seqSingleton(#memberPVToField(#a)), G::read(storage, seqSingleton(#memberPVToField(#a0)))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign field"
	};
	
	readField {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #a;

		\find ( ==> \modality{#allmodal}{ .. #v = this.#a; ... }\endmodality(post))
		\varcond ( \not \same(\typeof(#v), Seq), \hasSort(#a, G) )
		\replacewith ( ==> { #v := G::read(storage, seqSingleton(#memberPVToField(#a))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign field"
	};
	
	unfoldStorageAssignmentRight1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program LeftHandSide #lhs;

		\find ( ==> \modality{#allmodal}{ .. #lhs = #nse.#a; ... }\endmodality(post))
		\varcond( \new(#v, \typeof(#nse))) // #a is implicitly storage
		\replacewith ( ==> \modality{#allmodal}{ .. final #typeof(#nse) #v = #nse; #lhs = #v.#a; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	unfoldStorageAssignmentRight2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #a0, #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;

		\find ( ==> \modality{#allmodal}{ .. #v.#a = #nse.#a0; ... }\endmodality(post))
		\varcond( \new(#v0, \typeof(#nse))) // #a, #a0 are implicitly storage
		\replacewith ( ==> \modality{#allmodal}{ .. final #typeof(#nse) #v0 = #nse; #v.#a = #v0.#a0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	unfoldFieldAssignmentLeft {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e;

		\find ( ==> \modality{#allmodal}{ .. #nse.#a = #e; ... }\endmodality(post))
		\varcond( \new(#v, \typeof(#nse)) ) // #a is implicitly storage
		\replacewith ( ==> \modality{#allmodal}{ .. final #typeof(#nse) #v = #nse; #v.#a = #e; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	unfoldFieldAssignment1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #a0, #v, #v0;
		\schemaVar \program NonSimpleExpression #nse, #nse0;

		\find ( ==> \modality{#allmodal}{ .. #nse.#a = #nse0.#a0; ... }\endmodality(post))
		\varcond(\new(#v, Seq), \new(#v0, Seq))
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v; #v = #nse.#a; \seq #v0; #v0 = #nse0.#a0; #v = (#typeof(#a0))(#v0); ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold field assignment"
	};
	
	unfoldFieldAssignment2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. #nse.#a = #se; ... }\endmodality(post))
		\varcond(\new(#v, Seq), \not \same(\typeof(#se), Seq))
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v; #v = #nse.#a; #v = #se; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold field assignment"
	};
	
	unfoldFieldRead {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;

		\find ( ==> \modality{#allmodal}{ .. #v = #nse.#a; ... }\endmodality(post))
		\varcond(\not \same(\typeof(#v), Seq), \new(#v0, Seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0 = #nse.#a; #v = (#typeof(#a))(#v0); ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold field read"
	};
	
	unfoldArrayAssignment {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e, #e0;

		\find ( ==> \modality{#allmodal}{ .. #nse[#e] = #e0; ... }\endmodality(post))
		\varcond(\new(#v, Seq))
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v = #nse; #v[#e] = #e0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold array assignment"
	};
	
	unfoldArrayAssignment2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e;

		\find ( ==> \modality{#allmodal}{ .. #v[#nse] = #e; ... }\endmodality(post))
		\varcond( \same(\typeof(#v), Seq), \new(#v0, \typeof(#nse) ) )
		\replacewith ( ==> \modality{#allmodal}{ .. #typeof(#nse) #v0 = #nse; #v[#v0] = #e; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold array assignment"
	};
	
	unfoldArrayAssignment3 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program JavaIntExpression #seInt;
		\schemaVar \program Expression #e;

		\find ( ==> \modality{#allmodal}{ .. #v[#seInt] = #e; ... }\endmodality(post))
		\varcond( \same(\typeof(#v), Seq) )
		\replacewith ( ==> { #v := seqConcat(#v, seqSingleton(arr(#seInt))) }
		                   \modality{#allmodal}{ .. #v = #e; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold array assignment"
	};
	
	assignSeq1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #a, #v;

		\find ( ==> \modality{#allmodal}{ .. #v = this.#a; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq))
		\replacewith ( ==> { #v := seqConcat(seqSingleton(#memberPVToField(#a)), #v) } 
		                     \modality{#allmodal}{ .. ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;

		\find ( ==> \modality{#allmodal}{ .. #v = #nse.#a; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq))
		\replacewith ( ==> { #v := seqConcat(seqSingleton(#memberPVToField(#a)), #v) } 
		                     \modality{#allmodal}{ .. #v = #nse; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq3 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. #v = #se; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq), \not \same(\typeof(#se), Seq) )
		\replacewith ( ==> { storage := (Struct)write(storage, #v, #se) } 
		                     \modality{#allmodal}{ .. ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq4 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program Type #t;

		\find ( ==> \modality{#allmodal}{ .. #v = (#t)(#v0); ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq), \same(\typeof(#v0), Seq), \hasSort(#t, beta) )
		\replacewith ( ==> { storage := (Struct)write(storage, #v, beta::read(storage, #v0)) } 
		                     \modality{#allmodal}{ .. ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	unfoldStorageDeclaration {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program VariableInitializer #vi;

		\schemaVar \program Type #tr;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. final #tr #v = #vi; ... }\endmodality(post))
		\varcond( \isStorage(#vi) )
		\replacewith ( ==> \modality{#allmodal}{ .. final #tr #v; #v = #vi; ... }\endmodality(post) )
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold storage declaration"
	};

	eliminateVarStorageDeclaration {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program Type #tr;

		\find ( ==> \modality{#allmodal}{ .. final #tr #v; ... }\endmodality(post))

		\replacewith ( ==> \modality{#allmodal}{ ..  ... }\endmodality(post) )
		\addprogvars(#v)
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "storage var declaration"
	};
}