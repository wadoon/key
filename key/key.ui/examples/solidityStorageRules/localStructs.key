\sorts{
	\generic G;
	\generic H;

	\generic alpha \extends any;
	\generic beta \extends any;
}

\rules(programRules:Solidity) {
	///////////////////// Sequences //////////////////////
	
	removeSingletonSeq {
		\schemaVar \term Field f;
		\find( seqRemove(seqSingleton(f), 0) )
		\replacewith( seqEmpty )
		\displayname "remove singleton seq"
		\heuristics(simplify)
	};
	
	removeFirstElementSeq {
		\schemaVar \term Field f;
		\schemaVar \term Seq seq1, seq2;
		\find( seqRemove(seqConcat(seq1, seq2), 0) )
		\replacewith( seq2 )
		\displayname "remove first element seq"
		\heuristics(simplify)
	};
	
	///////////////////// Writes /////////////////////////
	writeStructEmptyPath {
		\schemaVar \term alpha x;
		\schemaVar \term beta x0;
		\find( write(x, seqEmpty, x0) )
		\replacewith( x0 )
		\displayname "write struct empty path"
		\heuristics(simplify)
	};
	
	//////////////////////// Reads /////////////////////////
	
	readStructEmptyPath1 {
		\schemaVar \term beta x;
		\find ( alpha::read(x, seqEmpty) )
		\varcond ( \not \same(beta, Struct) )
		\replacewith ( (alpha)x )
		\displayname "read struct empty path"
		\heuristics(simplify)
	};
	
	readStructEmptyPath2 {
		// If 'x' is a struct, 'alpha' will be a concrete program struct type.
		// However, in SolidiKeY, all program structs are modelled as type "Struct"
		\schemaVar \term Struct x;
		\find ( alpha::read(x, seqEmpty) )
		\replacewith ( (Struct)x )
		\displayname "read struct empty path"
		\heuristics(simplify)
	};
	
	readOfWriteStruct {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field head, head0;
		\schemaVar \term Seq rest, rest0;
		\find( beta::read(write(s, seqConcat(seqSingleton(head), rest), x), seqConcat(seqSingleton(head0), rest0)) )
		\replacewith( \if (head = head0)
		              \then ( beta::read(write(s, rest, x), rest0) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head0), rest0))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructCast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field head, head0;
		\schemaVar \term Seq rest, rest0;
		\find( beta::read((Struct)(write(s, seqConcat(seqSingleton(head), rest), x)), seqConcat(seqSingleton(head0), rest0)) )
		\replacewith( \if (head = head0)
		              \then ( beta::read(write(s, rest, x), rest0) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head0), rest0))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath1 {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read(write(s, seqSingleton(f), x), seqConcat(seqSingleton(head), rest)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, seqEmpty, x), rest) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head), rest))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath1Cast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read((Struct)(write(s, seqSingleton(f), x)), seqConcat(seqSingleton(head), rest)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, seqEmpty, x), rest) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head), rest))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath2 {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read(write(s, seqConcat(seqSingleton(head), rest), x), seqSingleton(f)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, rest, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath2Cast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read((Struct)(write(s, seqConcat(seqSingleton(head), rest), x)), seqSingleton(f)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, rest, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPaths {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, f0;
		\find( beta::read(write(s, seqSingleton(f), x), seqSingleton(f0)) )
		\replacewith( \if (f = f0)
		              \then ( beta::read(write(s, seqEmpty, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f0)) ) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPathsCast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, f0;
		\find( beta::read((Struct)(write(s, seqSingleton(f), x)), seqSingleton(f0)) )
		\replacewith( \if (f = f0)
		              \then ( beta::read(write(s, seqEmpty, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f0)) ) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readArray {
		\schemaVar \term Struct s;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field head;
		\schemaVar \term Seq array, rest;
		\find( beta::read(array, seqSingleton(arr(i))) )
		\replacewith ( beta::read(any::seqGet(array, i), seqEmpty) )
		\displayname "read array"
		\heuristics(simplify)
	};
	
	//seqDef{int i;}(0,10, 2*i)
	
	////////////////////// Storage <=> self rules ///////////////////////
	selfToStorage {
		\schemaVar \term Heap h;
		\schemaVar \term Field f;
		\find( beta::select(h, self, f) ) // comes from a term like "self.f"
		\replacewith( beta::read(storage, seqSingleton(f)) )
		\displayname "self to storage"
		\heuristics(simplify)
	};
	
	//////////////////////// Assignments ///////////////////////////
	
	assignField1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. this.#a = #se; ... }\endmodality(post))
		\varcond ( \not \same(\typeof(#se), Seq) )
		\replacewith ( ==> { storage := (Struct)write(storage, seqSingleton(#memberPVToField(#a)), #se) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign field"
	};
	
	assignField2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #a0;

		\find ( ==> \modality{#allmodal}{ .. this.#a = this.#a0; ... }\endmodality(post))
		\varcond ( \hasSort(#a0, G) )
		\replacewith ( ==> { storage := (Struct)write(storage, seqSingleton(#memberPVToField(#a)), G::read(storage, seqSingleton(#memberPVToField(#a0)))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign field"
	};
	
	readField {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #a;

		\find ( ==> \modality{#allmodal}{ .. #v = this.#a; ... }\endmodality(post))
		\varcond ( \not \same(\typeof(#v), Seq), \hasSort(#a, G) )
		\replacewith ( ==> { #v := G::read(storage, seqSingleton(#memberPVToField(#a))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign field"
	};
	
	unfoldFieldAssignment1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #a0, #v, #v0;
		\schemaVar \program NonSimpleExpression #nse, #nse0;

		\find ( ==> \modality{#allmodal}{ .. #nse.#a = #nse0.#a0; ... }\endmodality(post))
		\varcond(\new(#v, \seq), \new(#v0, \seq))
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v; #v = #nse.#a; \seq #v0; #v0 = #nse0.#a0; #v = (#typeof(#a0))(#v0); ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold field assignment"
	};
	
	unfoldFieldAssignment2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. #nse.#a = #se; ... }\endmodality(post))
		\varcond(\new(#v, \seq), \not \same(\typeof(#se), Seq))
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v; #v = #nse.#a; #v = #se; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold field assignment"
	};
	
	unfoldFieldRead {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;

		\find ( ==> \modality{#allmodal}{ .. #v = #nse.#a; ... }\endmodality(post))
		\varcond(\not \same(\typeof(#v), Seq), \new(#v0, \seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0 = #nse.#a; #v = (#typeof(#a))(#v0); ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold field read"
	};
	
	unfoldArrayAssignment {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e, #e0;

		\find ( ==> \modality{#allmodal}{ .. #nse[#e] = #e0; ... }\endmodality(post))
		\varcond(\new(#v, \seq))
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v = #nse; #v[#e] = #e0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold array assignment"
	};
	
	unfoldArrayAssignment2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e;

		\find ( ==> \modality{#allmodal}{ .. #v[#nse] = #e; ... }\endmodality(post))
		\varcond( \same(\typeof(#v), Seq), \new(#v0, \typeof(#nse) ) )
		\replacewith ( ==> \modality{#allmodal}{ .. #typeof(#nse) #v0 = #nse; #v[#v0] = #e; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold array assignment"
	};
	
	unfoldArrayAssignment3 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program JavaIntExpression #seInt;
		\schemaVar \program Expression #e;

		\find ( ==> \modality{#allmodal}{ .. #v[#seInt] = #e; ... }\endmodality(post))
		\varcond( \same(\typeof(#v), Seq) )
		\replacewith ( ==> { #v := seqConcat(#v, seqSingleton(arr(#seInt))) }
		                   \modality{#allmodal}{ .. #v = #e; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold array assignment"
	};
	
	assignSeq1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #a, #v;

		\find ( ==> \modality{#allmodal}{ .. #v = this.#a; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq))
		\replacewith ( ==> { #v := seqConcat(seqSingleton(#memberPVToField(#a)), #v) } 
		                     \modality{#allmodal}{ .. ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;

		\find ( ==> \modality{#allmodal}{ .. #v = #nse.#a; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq))
		\replacewith ( ==> { #v := seqConcat(seqSingleton(#memberPVToField(#a)), #v) } 
		                     \modality{#allmodal}{ .. #v = #nse; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq3 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. #v = #se; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq), \not \same(\typeof(#se), Seq) )
		\replacewith ( ==> { storage := (Struct)write(storage, #v, #se) } 
		                     \modality{#allmodal}{ .. ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq4 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program Type #t;

		\find ( ==> \modality{#allmodal}{ .. #v = (#t)(#v0); ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq), \same(\typeof(#v0), Seq), \hasSort(#t, beta) )
		\replacewith ( ==> { storage := (Struct)write(storage, #v, beta::read(storage, #v0)) } 
		                     \modality{#allmodal}{ .. ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	unfoldStorageDeclaration {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program VariableInitializer #vi;

		\schemaVar \program Type #tr;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. final #tr #v = #vi; ... }\endmodality(post))
		\varcond( \isStorage(#vi) )
		\replacewith ( ==> \modality{#allmodal}{ .. final #tr #v; #v = #vi; ... }\endmodality(post) )
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold storage declaration"
	};

	eliminateVarStorageDeclaration {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program Type #tr;

		\find ( ==> \modality{#allmodal}{ .. final #tr #v; ... }\endmodality(post))

		\replacewith ( ==> \modality{#allmodal}{ ..  ... }\endmodality(post) )
		\addprogvars(#v)
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "storage var declaration"
	};
}