\sorts{
	\generic alpha \extends any;
}

\rules(programRules:Solidity) {
	
	
	/*
	////////////////////////////// Storage/primitive => Storage/primitive //////////////////////////////
	assignStorageFromPrimitive {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. this.#a = #se; ... }\endmodality(post))
		\varcond( \not \isStorage(#se), \not \isMemory(#se) )
		\replacewith ( ==> { storage := writeField(storage, #memberPVToField(#a), #se) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignStorageFromStorageLocal {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v;

		\find ( ==> \modality{#allmodal}{ .. this.#a = #v; ... }\endmodality(post))
		\varcond( \isStorage(#v) )
		\replacewith ( ==> { storage := writeField(storage, #memberPVToField(#a), alpha::readField(storage, #memberPVToField(#v))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignToLocalStorage {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #a;

		\find ( ==> \modality{#allmodal}{ .. #v = this.#a; ... }\endmodality(post))
		\varcond( \isStorage(#v) )
		\replacewith ( ==> { storage := writeField(storage, #memberPVToField(#v), alpha::readField(storage, #memberPVToField(#a))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignPrimitiveFromStorage {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #a;

		\find ( ==> \modality{#allmodal}{ .. #v = this.#a; ... }\endmodality(post))
		\varcond( \not \isReference(\typeof(#v)) /*\not \isStorage(#v), \not \isMemory(#v)*/ )
		\replacewith ( ==> { #v := alpha::readField(storage, #memberPVToField(#a)) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignPrimitiveFromStorageLocal {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #v0;

		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \not \isStorage(#v), \not \isMemory(#v), \isStorage(#v0) )
		\replacewith ( ==> { #v := alpha::readField(storage, #memberPVToField(#v0)) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignPrimitiveToStorageLocal {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #v0;

		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \not \isMemory(#v0), \not \isStorage(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #memberPVToField(#v), #v0) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignLocalStorageVars {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v, #v0;

		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #memberPVToField(#v), alpha::readField(storage, #memberPVToField(#v0))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignStorage { // TODO: exception when trying to apply rule
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #a0;

		\find ( ==> \modality{#allmodal}{ .. this.#a = this.#a0; ... }\endmodality(post))
		\replacewith ( ==> { storage := writeField(storage, #memberPVToField(#a), alpha::readField(storage, #memberPVToField(#a0))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignStorageFromStorageArray {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #a0;
		\schemaVar \program JavaIntExpression #seInt;

		\find ( ==> \modality{#allmodal}{ .. this.#a = this.#a0[#seInt]; ... }\endmodality(post))
		\replacewith ( ==> { storage := writeField(storage, #memberPVToField(#a), alpha::readField(storage, alpha::readStruct((Struct)#a0, arr(#e)))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	unfoldStorageAssignmentRight {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #a0, #v;
		\schemaVar \program NonSimpleExpression #nse;

		\find ( ==> \modality{#allmodal}{ .. this.#a = #nse.#a0; ... }\endmodality(post)) // TODO: turn left side into "lhs" instead of "this.#a"
		\varcond( \isStorage(#a0), \new(#v, \typeof(#nse))) 
		\replacewith ( ==> \modality{#allmodal}{ .. final #typeof(#a0) #v = #nse.#a0; this.#a = #v; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	unfoldStorageAssignmentLeft {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e;

		\find ( ==> \modality{#allmodal}{ .. #nse.#a = #e; ... }\endmodality(post))
		\varcond( \isStorage(#a), \new(#v, \typeof(#nse))) 
		\replacewith ( ==> \modality{#allmodal}{ .. final #typeof(#nse) #v = #nse; #v = #e; ... }\endmodality(post)) // TODO: makes a local storage variable, can we really look it up in the storage later?
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	unfoldStorageDeclaration {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program VariableInitializer #vi;

		\schemaVar \program Type #tr;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. final #tr #v = #vi; ... }\endmodality(post))
		\varcond( \isStorage(#vi) )
		\replacewith ( ==> \modality{#allmodal}{ .. final #tr #v; #v = #vi; ... }\endmodality(post) )
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold storage declaration"
	};

	eliminateVarStorageDeclaration {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program Type #tr;

		\find ( ==> \modality{#allmodal}{ .. final #tr #v; ... }\endmodality(post))

		\replacewith ( ==> \modality{#allmodal}{ ..  ... }\endmodality(post) )
		\addprogvars(#v)
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "storage var declaration"
	};
	*/

}
