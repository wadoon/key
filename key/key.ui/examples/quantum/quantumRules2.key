\sorts {
   Complex \extends any;
   Entanglement;
   Register;

   Operation;
}

\functions {
    // shortcuts
    \unique Seq seq01;
    \unique Seq seq10;

    // operations
    Operation H(int);
    Entanglement apply(Operation, Entanglement);
    Register applyOnReg(Operation, Register);


    // constructors

    /* a pair of entangled qbits, for instance, < 0,2 | alpha_00, alpha_01, alpha_10, alpha_11 >
       amplitudes ordered after the bitvalue-index
     */
    Entanglement entangle(Seq /* qbit ids*/, Seq /* amplitudes */);

    /* a register consists of a sequence of entanglements and a lookup sequence */
    Register register(Seq /* entanglements */, Seq /* lookup */);

    // selectors

    /* selects the qbit ids of an entanglement */
    Seq getQbitIds(Entanglement);
    /* select the amplitudes of an entanglement */
    Seq getAmplitudes(Entanglement);

    /* get all entanglements */
    Seq getEntanglements(Register);
    /* get lookup sequence */
    Seq getLookup(Register);

    // queries

    /* length of an entanglement = nr of qbits */
    int len(Entanglement);

    /*
       split single qbit k from entanglement for B(k) = 0 / 1

     */
    Seq split(Entanglement, int /* qbit id */, int /* B(k) value */);

    // index shifters
    Seq bot(Seq, int /* idx */);
    int botAux(int, int, int);
    Seq top(Seq, int /* idx */);
    int topAux(int, int, int);

    // binary operators
    int getPosMBinary(int,int);
    int sign(int, int);


    // only for example
    Seq exAmp;
}

\predicates {
  wellFormedReg(Register);

  // example
  accum(Seq);
  accumE(any);
}

\programVariables {
    Register reg;
}

\rules {
    // = Axioms

    seq01 {
        \find (seq01)
        \replacewith(seqConcat(seqSingleton(0), seqSingleton(1)))
        \heuristics(simplify)
    };

    seq10 {
            \find (seq10)
            \replacewith(seqConcat(seqSingleton(1), seqSingleton(0)))
            \heuristics(simplify)
    };

    // == Selector Axioms
    getEntangledQbits {
        \schemaVar \term Seq qbitIds, amplitudes;
        \find (getQbitIds(entangle(qbitIds, amplitudes)))
        \replacewith(qbitIds)

        \heuristics(simplify)
    };

    getAmplitudes {
        \schemaVar \term Seq qbitIds, amplitudes;
        \find (getAmplitudes(entangle(qbitIds, amplitudes)))
        \replacewith(amplitudes)

        \heuristics(simplify)
    };

    getEntanglementSequent {
        \schemaVar \term Seq entanglementSeq, lookupSeq;
        \find (getEntanglements(register(entanglementSeq, lookupSeq)))
        \replacewith(entanglementSeq)

        \heuristics(simplify)
    };

    getLookupSequent {
        \schemaVar \term Seq entanglementSeq, lookupSeq;

        \find (getLookup(register(entanglementSeq, lookupSeq)))
        \replacewith(lookupSeq)

        \heuristics(simplify)
    };

    // == Equality

     entanglementEquality {
            \schemaVar \term Seq qbitIdsLeft, amplitudesLeft;
            \schemaVar \term Seq qbitIdsRight, amplitudesRight;

            \find(entangle(qbitIdsLeft, amplitudesLeft) = entangle(qbitIdsRight, amplitudesRight))
            \replacewith(qbitIdsLeft = qbitIdsRight & amplitudesLeft = amplitudesRight)
            \heuristics(simplify, no_self_application)
     };

     entanglementEqualityEQ {
            \schemaVar \term Seq qbitIdsLeft, amplitudesLeft;
            \schemaVar \term Seq qbitIdsRight, amplitudesRight;
            \schemaVar \term Entanglement EQ;

            \assumes (entangle(qbitIdsRight, amplitudesRight) = EQ ==>)
            \find(entangle(qbitIdsLeft, amplitudesLeft) = EQ) \sameUpdateLevel
            \replacewith(qbitIdsLeft = qbitIdsRight & amplitudesLeft = amplitudesRight)
            \heuristics(simplify, no_self_application)
     };


    // == Query Axioms

    lengthOfEntanglement {
        \schemaVar \term Seq qbitIds, amplitudes;

        \find(len(entangle(qbitIds, amplitudes)))
        \replacewith(seqLen(qbitIds))
        \heuristics(simplify)
    };

    // EQ versions
    getEntangledQbitsEQ {
        \schemaVar \term Seq qbitIds, amplitudes;
        \schemaVar \term Entanglement EQ;

        \assumes(entangle(qbitIds, amplitudes) = EQ ==>)
        \find (getQbitIds(EQ))
        \sameUpdateLevel
        \replacewith(qbitIds)

        \heuristics(simplify)
    };

    getAmplitudesEQ {
        \schemaVar \term Seq qbitIds, amplitudes;
        \schemaVar \term Entanglement EQ;

        \assumes(entangle(qbitIds, amplitudes) = EQ ==>)
        \find (getAmplitudes(EQ))
        \sameUpdateLevel
        \replacewith(amplitudes)

        \heuristics(simplify)
    };

    getEntanglementSequentEQ {
        \schemaVar \term Seq entanglementSeq, lookupSeq;
        \schemaVar \term Register EQ;

        \assumes(register(entanglementSeq, lookupSeq) = EQ ==>)
        \find (getEntanglements(EQ))
        \sameUpdateLevel
        \replacewith(entanglementSeq)

        \heuristics(simplify)
    };

    getLookupSequentEQ {
        \schemaVar \term Seq entanglementSeq, lookupSeq;
        \schemaVar \term Register EQ;

        \assumes(register(entanglementSeq, lookupSeq) = EQ ==>)
        \find (getLookup(EQ))
        \sameUpdateLevel
        \replacewith(lookupSeq)

        \heuristics(simplify)
    };

    lengthOfEntanglementEQ {
       \schemaVar \term Seq qbitIds, amplitudes;
       \schemaVar \term Entanglement EQ;

       \assumes(entangle(qbitIds, amplitudes) = EQ ==>)
       \find(entangle(qbitIds, amplitudes))
       \sameUpdateLevel
       \replacewith(seqLen(qbitIds))
       \heuristics(simplify)
    };

    // operations
    splitEntanglement {
        \schemaVar \term Seq qbitIds, amplitudes;
        \schemaVar \term int id, val;
        \schemaVar \skolemTerm int idx;

        \find (split(entangle(qbitIds, amplitudes), id, val))
        \varcond(\newDependingOn(idx, qbitIds), \newDependingOn(idx, id))
        \replacewith(
            \if ( idx >= 0 & idx < seqLen(qbitIds) & val >= 0 & val <= 1) \then (
                seqConcat(
                  seqSingleton(
                    entangle(
                      seqRemove(qbitIds, idx), // other qbit ids
                      \if (val = 0) \then ( bot(amplitudes, idx) ) \else ( top(amplitudes, idx) )
                    )
                  ),
                  seqSingleton(
                    entangle(
                      seqSingleton(id), // qbit id
                      \if (val = 0) \then ( seq10 ) \else ( seq01 )
                    )
                  )
                )
            ) \else (
                seqSingleton(entangle(qbitIds, amplitudes))
            )
        )
        \add (idx = seqIndexOf(qbitIds, id) ==>)
    };

    botDef {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;
        \schemaVar \variables int j;

        \find (bot(seq, idx))
        \varcond(\notFreeIn(j,seq,idx))
        \replacewith(seqDef{j;}(0, seqLen(seq)/2,
                int/* should be Complex */::seqGet(seq, botAux(j, idx, 2) ) ) )
    };

    botAux {
        \schemaVar \term int j,l,n;
        \find (botAux(j,l,n))
        \replacewith(shiftleft(shiftleft(shiftright(j,n-l),1), n - l - 1) + j-shiftleft(shiftright(j,n-l),n-l) )
        \heuristics(simplify)
    };

    topDef {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;
        \schemaVar \variables int j;
        \find (top(seq, idx))
        \varcond(\notFreeIn(j,seq,idx))
        \replacewith(seqDef{j;}(0, seqLen(seq)/2,
                int/* should be Complex */::seqGet(seq, topAux(j, idx, 2) ) ) )
    };

    topAux {
        \schemaVar \term int j,l,n;
        \find (topAux(j,l,n))
        \replacewith(shiftleft(shiftleft(shiftright(j, n-l), 1) + 1, n - l - 1) +
                                            j - shiftleft(shiftright(j,(n - l)), n - l))
        \heuristics(simplify)
    };


    // binary representation
    getPosMBinary {
        \schemaVar \term int m;
        \schemaVar \term int j;

        \find(getPosMBinary(j,m))
        \replacewith(shiftright(j, m) % 2)
        \heuristics (userTaclets1)
    };

     signDef {
            \schemaVar \term int j;
            \schemaVar \term int m;
            \find(sign(j,m))
            \replacewith(\if (getPosMBinary(j,m) = 0) \then (1) \else (-1) )
            \heuristics (simplify)
     };

    // apply Hadamard
    applyHadamardOnEntanglement {
        \schemaVar \term int id;
        \schemaVar \term Seq qbitIds, amplitudes;
        \schemaVar \variables int j;

        \find (apply(H(id), entangle(qbitIds, amplitudes)))
        \varcond(\notFreeIn(j,id, qbitIds, amplitudes))
        \replacewith (
            \if (seqIndexOf(qbitIds, id) >= 0 & seqIndexOf(qbitIds, id) < seqLen(qbitIds)) \then (
                entangle(
                    qbitIds,
                    seqDef{j;}(0, seqLen(amplitudes),
                        invSqrt2 * \if (sign(j,id) = -1) \then (
                            int::seqGet(amplitudes, botAux(j,id,2)) - int::seqGet(amplitudes,topAux(j,id,2))
                        ) \else (
                            int::seqGet(amplitudes, botAux(j,id,2)) + int::seqGet(amplitudes,topAux(j,id,2))
                        )
                    )
                )
            ) \else (
                entangle(qbitIds, amplitudes)
            )
        )
        \heuristics(userTaclet0)
    };

    applyHadamardOnEntanglementQ {
            \schemaVar \term int id;
            \schemaVar \term Entanglement EQ;
            \schemaVar \term Seq qbitIds, amplitudes;
            \schemaVar \variables int j;

            \assumes (entangle(qbitIds, amplitudes) = EQ ==>)
            \find (apply(H(id), EQ)) \sameUpdateLevel
            \varcond(\notFreeIn(j,id, qbitIds, amplitudes))
            \replacewith (
                \if (seqIndexOf(qbitIds, id) >= 0 & seqIndexOf(qbitIds, id) < seqLen(qbitIds)) \then (
                    entangle(
                        qbitIds,
                        seqDef{j;}(0, seqLen(amplitudes),
                            invSqrt2 * \if (sign(j,id) = -1) \then (
                                int::seqGet(amplitudes, botAux(j,id,2)) - int::seqGet(amplitudes,topAux(j,id,2))
                            ) \else (
                                int::seqGet(amplitudes, botAux(j,id,2)) + int::seqGet(amplitudes,topAux(j,id,2))
                            )
                        )
                    )
                ) \else (
                    entangle(qbitIds, amplitudes)
                )
            )
            \heuristics(userTaclet0)
        };

    applyHadamardOnRegister {
        \schemaVar \term int id;
        \schemaVar \term Register reg;
        \schemaVar \skolemTerm Entanglement entanglement;

        \find (applyOnReg(H(id), reg)) \sameUpdateLevel
        \varcond(\newDependingOn(entanglement, id), \newDependingOn(entanglement, reg))
        \replacewith( replaceEntanglement(reg,
                             entanglement,
                             apply(H(id), entanglement),
                             updateLookupHadamard(id, getLookup(reg)) )
                    )
        \add (entanglement = getEntanglementFor(reg,id) ==>)
        \heuristics(userTaclets0)
    };

    updateLookupHadamard {
        \schemaVar \term Seq bSeq;
        \schemaVar \term int id;
        \schemaVar \skolemTerm BValue val;

        \find(updateLookupHadamard(id, bSeq)) \sameUpdateLevel
        \varcond(\newDependingOn(val, id), \newDependingOn(val, bSeq))
        \replacewith(
            \if (id>=0 & id < seqLen(bSeq)) \then (
                seqReplaceAtPos(bSeq, id,
                    \if (val = zero) \then ( pos )
                    \else ( \if (val = one) \then ( negativ )
                            \else ( \if (val = pos) \then (zero)
                                    \else (\if (val = negativ) \then (one)
                                           \else (unknown) ) ) )
                )
            ) \else (
                bSeq
            )
         )
        \add(val = BValue::seqGet(bSeq, id) ==>)
    };

 /*   applyCNOT {
        \schemaVar \term Register regSV;
          \find (applyOnReg(CNOT(id1,id2), regSV)) \sameUpdateLevel
                \varcond(\newDependingOn(entanglement, id), \newDependingOn(entanglement, reg))
                \replacewith( replaceEntanglement(regSV,
                                     entanglement,
                                     apply(H(id), entanglement),
                                     updateLookupHadamard(id, getLookup(reg)) )
                            )
                \add (entanglement = getEntanglementFor(reg,id) ==>)
                \heuristics(userTaclets0)
    };*/

    executeHd {
        \schemaVar \formula post;
        \schemaVar \program SimpleExpression #arg1;

        \find (\[{.. QInstr.applyHd(#arg1); ...}\]post)
        \replacewith({reg:=applyOnReg(H(#arg1), reg)}\[{.. ...}\]post)

        \heuristics(simplify_prog)
      };

}


\problem {
    //accum(split(entangle(seqDef{int i;}(0,2,i), seqDef{int i;}(0,4,int::seqGet(exAmp, i))),0,0))
    //accum(split(entangle(seqDef{int i;}(0,2,i), seqDef{int i;}(0,4,int::seqGet(exAmp, i))),0,1))
    //accumE(apply(H(1), entangle(seqDef{int i;}(0,2,i), seqDef{int i;}(0,4,int::seqGet(exAmp, i)))))

     // number of available qbits
     availableQBits = 3 &
     // no entangled qbits
     // hence register consists of three singleton entanglements
     // where each qbit has the initial value 0
     qbit0Initial = entangle(seqSingleton(0), seqConcat(seqSingleton(1), seqSingleton(0)))
     &
     qbit1Initial = entangle(seqSingleton(1), seqConcat(seqSingleton(1), seqSingleton(0)))
     &
     qbit2Initial = entangle(seqSingleton(2), seqConcat(seqSingleton(1), seqSingleton(0)))
     ->
     {reg := register(
                seqConcat(seqSingleton(qbit0Initial), seqConcat(seqSingleton(qbit1Initial), seqSingleton(qbit2Initial))),
                seqDef{int j;}(0,availableQBits,zero)  // B=<0,0,0>
            )
     }
     \[{ QInstr.applyHd(0); }\] accumE(reg) //
}