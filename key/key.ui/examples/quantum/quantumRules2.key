\sorts {
   Complex \extends any;
   Entanglement;
   Register;

   Operation;
}

\functions {
    // shortcuts
    \unique Seq seq01;
    \unique Seq seq10;

    // operations
    Operation H(int);
    Entanglement apply(Operation, Entanglement);
    Register applyOnReg(Operation, Register);


    // constructors

    /* a pair of entangled qbits, for instance, < 0,2 | alpha_00, alpha_01, alpha_10, alpha_11 >
       amplitudes ordered after the bitvalue-index
     */
    Entanglement entangle(Seq /* qbit ids*/, Seq /* amplitudes */);

    /* a register consists of a sequence of entanglements and a lookup sequence */
    Register register(Seq /* entanglements */, Seq /* lookup */);

    // selectors

    /* selects the qbit ids of an entanglement */
    Seq getQbitIds(Entanglement);
    /* select the amplitudes of an entanglement */
    Seq getAmplitudes(Entanglement);

    /* get all entanglements */
    Seq getEntanglements(Register);
    /* get lookup sequence */
    Seq getLookup(Register);

    // queries

    /* length of an entanglement = nr of qbits */
    int len(Entanglement);

    /*
       split single qbit k from entanglement for B(k) = 0 / 1

     */
    Seq split(Entanglement, int /* qbit id */, int /* B(k) value */);

    // index shifters
    Seq bot(Seq, int /* idx */);
    int botAux(int, int, int);
    Seq top(Seq, int /* idx */);
    int topAux(int, int, int);

    // binary operators
    int getPosMBinary(int,int);
    int sign(int, int);


    // only for example
    Seq exAmp;
}

\predicates {
  wellFormedReg(Register);

  // example
  accum(Seq);
  accumE(any);
}

\programVariables {
    Register reg;
}

\rules {
    // = Axioms

    seq01 {
        \find (seq01)
        \replacewith(seqConcat(seqSingleton(0), seqSingleton(1)))
        \heuristics(simplify)
    };

    seq10 {
            \find (seq10)
            \replacewith(seqConcat(seqSingleton(1), seqSingleton(0)))
            \heuristics(simplify)
    };

    // == Selector Axioms
    getEntangledQbits {
        \schemaVar \term Seq qbitIds, amplitudes;
        \find (getQbitIds(entangle(qbitIds, amplitudes)))
        \replacewith(qbitIds)

        \heuristics(simplify)
    };

    getAmplitudes {
        \schemaVar \term Seq qbitIds, amplitudes;
        \find (getAmplitudes(entangle(qbitIds, amplitudes)))
        \replacewith(amplitudes)

        \heuristics(simplify)
    };

    getEntanglementSequent {
        \schemaVar \term Seq entanglementSeq, lookupSeq;
        \find (getEntanglements(register(entanglementSeq, lookupSeq)))
        \replacewith(entanglementSeq)

        \heuristics(simplify)
    };

    getLookupSequent {
        \schemaVar \term Seq entanglementSeq, lookupSeq;

        \find (getLookup(register(entanglementSeq, lookupSeq)))
        \replacewith(lookupSeq)

        \heuristics(simplify)
    };

    // == Query Axioms

    lengthOfEntanglement {
        \schemaVar \term Seq qbitIds, amplitudes;

        \find(len(entangle(qbitIds, amplitudes)))
        \replacewith(seqLen(qbitIds))
        \heuristics(simplify)
    };

    // EQ versions
    getEntangledQbitsEQ {
        \schemaVar \term Seq qbitIds, amplitudes;
        \schemaVar \term Entanglement EQ;

        \assumes(entangle(qbitIds, amplitudes) = EQ ==>)
        \find (getQbitIds(EQ))
        \sameUpdateLevel
        \replacewith(qbitIds)

        \heuristics(simplify)
    };

    getAmplitudesEQ {
        \schemaVar \term Seq qbitIds, amplitudes;
        \schemaVar \term Entanglement EQ;

        \assumes(entangle(qbitIds, amplitudes) = EQ ==>)
        \find (getAmplitudes(EQ))
        \sameUpdateLevel
        \replacewith(amplitudes)

        \heuristics(simplify)
    };

    getEntanglementSequentEQ {
        \schemaVar \term Seq entanglementSeq, lookupSeq;
        \schemaVar \term Register EQ;

        \assumes(register(entanglementSeq, lookupSeq) = EQ ==>)
        \find (getEntanglements(EQ))
        \sameUpdateLevel
        \replacewith(entanglementSeq)

        \heuristics(simplify)
    };

    getLookupSequentEQ {
        \schemaVar \term Seq entanglementSeq, lookupSeq;
        \schemaVar \term Register EQ;

        \assumes(register(entanglementSeq, lookupSeq) = EQ ==>)
        \find (getLookup(EQ))
        \sameUpdateLevel
        \replacewith(lookupSeq)

        \heuristics(simplify)
    };

    lengthOfEntanglementEQ {
       \schemaVar \term Seq qbitIds, amplitudes;
       \schemaVar \term Entanglement EQ;

       \assumes(entangle(qbitIds, amplitudes) = EQ ==>)
       \find(entangle(qbitIds, amplitudes))
       \sameUpdateLevel
       \replacewith(seqLen(qbitIds))
       \heuristics(simplify)
    };

    // operations
    splitEntanglement {
        \schemaVar \term Seq qbitIds, amplitudes;
        \schemaVar \term int id, val;
        \schemaVar \skolemTerm int idx;

        \find (split(entangle(qbitIds, amplitudes), id, val))
        \varcond(\newDependingOn(idx, qbitIds), \newDependingOn(idx, id))
        \replacewith(
            \if ( idx >= 0 & idx < seqLen(qbitIds) & val >= 0 & val <= 1) \then (
                seqConcat(
                  seqSingleton(
                    entangle(
                      seqRemove(qbitIds, idx), // other qbit ids
                      \if (val = 0) \then ( bot(amplitudes, idx) ) \else ( top(amplitudes, idx) )
                    )
                  ),
                  seqSingleton(
                    entangle(
                      seqSingleton(id), // qbit id
                      \if (val = 0) \then ( seq10 ) \else ( seq01 )
                    )
                  )
                )
            ) \else (
                seqSingleton(entangle(qbitIds, amplitudes))
            )
        )
        \add (idx = seqIndexOf(qbitIds, id) ==>)
    };

    botDef {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;
        \schemaVar \variables int j;

        \find (bot(seq, idx))
        \varcond(\notFreeIn(j,seq,idx))
        \replacewith(seqDef{j;}(0, seqLen(seq)/2,
                int/* should be Complex */::seqGet(seq, botAux(j, idx, 1) ) ) )
    };

    botAux {
        \schemaVar \term int j,l,n;
        \find (botAux(j,l,n))
        \replacewith(shiftleft(shiftright(j,l+1),1+l+n) + j-shiftleft(shiftright(j,l+n),l+n) )
        \heuristics(simplify)
    };

    topDef {
        \schemaVar \term Seq seq;
        \schemaVar \term int idx;
        \schemaVar \variables int j;
        \find (top(seq, idx))
        \varcond(\notFreeIn(j,seq,idx))
        \replacewith(seqDef{j;}(0, seqLen(seq)/2,
                int/* should be Complex */::seqGet(seq, topAux(j, idx, 1) ) ) )
    };

    topAux {
        \schemaVar \term int j,l,n;
        \find (topAux(j,l,n))
        \replacewith(shiftleft(shiftleft(shiftright(j,l+1),1) + 1, l+n) + j-shiftleft(shiftright(j,l+n),l+n))
        \heuristics(simplify)
    };


    // binary representation
    getPosMBinary {
        \schemaVar \term int m;
        \schemaVar \term int j;

        \find(getPosMBinary(j,m))
        \replacewith(shiftright(j, m) % 2)
        \heuristics (userTaclets1)
    };

     signDef {
            \schemaVar \term int j;
            \schemaVar \term int m;
            \find(sign(j,m))
            \replacewith(\if (getPosMBinary(j,m) = 0) \then (1) \else (-1) )
            \heuristics (simplify)
     };

    // apply Hadamard
    applyHadamardOnEntanglement {
        \schemaVar \term int id;
        \schemaVar \term Seq qbitIds, amplitudes;
        \schemaVar \variables int j;

        \find (apply(H(id), entangle(qbitIds, amplitudes)))
        \varcond(\notFreeIn(j,id, qbitIds, amplitudes))
        \replacewith (
            \if (seqIndexOf(qbitIds, id) >= 0 & seqIndexOf(qbitIds, id) < seqLen(qbitIds)) \then (
                entangle(
                    qbitIds,
                    seqDef{j;}(0,seqLen(amplitudes),
                        \if (sign(j,id) = -1) \then (
                            int::seqGet(amplitudes, botAux(j,id,0)) - int::seqGet(amplitudes,topAux(j,id,0))
                        ) \else (
                            int::seqGet(amplitudes, botAux(j,id,0)) + int::seqGet(amplitudes,topAux(j,id,0))
                        )
                    )
                )
            ) \else (
                entangle(qbitIds, amplitudes)
            )
        )
        \heuristics(userTaclet0)
    };

}


\problem {
    //accum(split(entangle(seqDef{int i;}(0,2,i), seqDef{int i;}(0,4,int::seqGet(exAmp, i))),0,0))
    //accum(split(entangle(seqDef{int i;}(0,2,i), seqDef{int i;}(0,4,int::seqGet(exAmp, i))),0,1))
    accumE(apply(H(1), entangle(seqDef{int i;}(0,2,i), seqDef{int i;}(0,4,int::seqGet(exAmp, i)))))
}