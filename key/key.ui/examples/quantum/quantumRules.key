\javaSource "src/";

\sorts {
   /* QBit;
   UMatrix \extends Matrix;
   Matrix;
   Complex; */ // declared a Java classes
   Pair;
}

\predicates {
    P(any,any,any,any,any);
}

\functions{
    Seq seqFlatten(Seq);

    UMatrix H(int);
    UMatrix X(int);
    UMatrix ID(int);
    UMatrix CNOT(int);

    int rows(Matrix);
    int cols(Matrix);

//  at position m for n entangled qubits
    UMatrix kProdEnlarge(Matrix, /* pos */ int, /* nr entangled qbits */ int);

    int /* Complex */ getMVal(Matrix, /* row */ int, /* col */ int);
    int getPosMBinary(int, int, int);

    int left(int,int,int);
    int right(int,int,int);
    int signH(int,int,int);
    int setBit(int,int,int,int);


    int measure(int/* bit */, int /* nr entangled qbits*/ , int /* value of bit */,  Matrix);
    int measure2(int/* bit */, int /* nr entangled qbits*/ , int /* value of bit */, int /* pos */,  Matrix);

    int bitx(int,int,int);


    Pair pair(Complex,int);
    Complex fst(Pair);
    int  snd(Pair);

    QVector ket(/* nr of qbits */int,/*qbit names*/Seq,/*vector*/Seq);

    \unique Complex invSqrtOf2;

    Matrix conjungateTranspose(Matrix);
    Matrix kProd(Matrix,Matrix);
    Matrix mProd(Matrix,Matrix);
    Matrix sProd(Complex,Matrix);
    Matrix mAdd(Matrix,Matrix);

    Complex cmul(Complex,Complex);

    QVector vec;

    //
    int invSqrt2;

    // needed for example
    \unique QBit a;
    \unique QBit b;
    \unique QBit x;
}

\rules {

  assignmentkProd {
    \schemaVar \formula post;
    \schemaVar \program Variable #lhs;
    \schemaVar \program SimpleExpression #arg1,#arg2;

    \find (\[{.. #lhs = Complex.cmul(#arg1,#arg2); ...}\]post)
    \replacewith({#lhs:=cmul(#arg1,#arg2)}\[{.. ...}\]post)

    \heuristics(simplify_prog)
  };

  assignmentkProd {
    \schemaVar \formula post;
    \schemaVar \program Variable #lhs;
    \schemaVar \program SimpleExpression #arg1,#arg2;

    \find (\[{.. #lhs = Matrix.kProd(#arg1,#arg2); ...}\]post)
    \replacewith({#lhs:=kProd(#arg1,#arg2)}\[{.. ...}\]post)

    \heuristics(simplify_prog)
  };

  assignmentmProd {
      \schemaVar \formula post;
      \schemaVar \program Variable #lhs;
      \schemaVar \program SimpleExpression #arg1,#arg2;

      \find (\[{.. #lhs = Matrix.mProd(#arg1,#arg2); ...}\]post)
      \replacewith({#lhs:=mProd(#arg1,#arg2)}\[{.. ...}\]post)

      \heuristics(simplify_prog)
    };

    computeMProd {
        \schemaVar \term Matrix a, b;
        \schemaVar \skolemTerm Matrix c;

        \find (mProd(a,b)) \sameUpdateLevel
        \varcond(\newDependingOn(c, a), \newDependingOn(c,b))
        \replacewith(c)
        \add(c = Matrix.mProd(a,b)@Matrix ==>)
    };

    assignmentmAdd {
          \schemaVar \formula post;
          \schemaVar \program Variable #lhs;
          \schemaVar \program SimpleExpression #arg1,#arg2;

          \find (\[{.. #lhs = Matrix.mAdd(#arg1,#arg2); ...}\]post)
          \replacewith({#lhs:=mAdd(#arg1,#arg2)}\[{.. ...}\]post)

         \heuristics(simplify_prog)
    };

  assignmentHadamard  {
      \schemaVar \formula post;
      \schemaVar \program Variable #lhs;
      \schemaVar \program SimpleExpression #arg1,#arg2;

      \find (\[{.. #lhs = UMatrix.H(#arg1); ...}\]post)
      \replacewith({#lhs:=H(#arg1)}\[{.. ...}\]post)

      \heuristics(simplify_prog)
    };

    assignmentIdentity  {
          \schemaVar \formula post;
          \schemaVar \program Variable #lhs;
          \schemaVar \program SimpleExpression #arg1,#arg2;

          \find (\[{.. #lhs = UMatrix.ID(#arg1); ...}\]post)
          \replacewith({#lhs:=ID(#arg1)}\[{.. ...}\]post)

          \heuristics(simplify_prog)
    };

    assignmentCNOT {
          \schemaVar \formula post;
          \schemaVar \program Variable #lhs;
          \schemaVar \program SimpleExpression #arg1,#arg2;

          \find (\[{.. #lhs = UMatrix.CNOT(#arg1); ...}\]post)
          \replacewith({#lhs:=CNOT(#arg1)}\[{.. ...}\]post)

          \heuristics(simplify_prog)

    };

  /*  HDId {
        \schemaVar \term int i;
        \find (mProd(HD(i),HD(i))
        \replacewith(ID(i))
    };*/

    conjTransposeIsInverse {
        \schemaVar \term UMatrix m;

        \find (mProd(m,conjungateTranspose(m)))
        \replacewith (ID(rows(m)))
    };

    conjTransposeIsInverseEQ {
        \schemaVar \term UMatrix m,n;
        \assumes (n = conjungateTranspose(m) ==>)
        \find (mProd(m,n))
        \replacewith (ID(rows(m)))
    };

    kProdIsAssociative {
        \schemaVar \term Matrix m,n,o;
        \find (kProd(kProd(m,n),o))
        \replacewith (kProd(m,kProd(n,o)))
    };

    mProdIsAssociative {
        \schemaVar \term Matrix m,n,o;
        \find (mProd(mProd(m,n),o))
        \replacewith (mProd(m,mProd(n,o)))
    };

    addIsAssociative {
        \schemaVar \term Matrix m,n,o;
        \find (mAdd(mAdd(m,n),o))
        \replacewith (mAdd(m,mAdd(n,o)))
    };

    addIsCommutative {
        \schemaVar \term Matrix m,n,o;
        \find (mAdd(m,n))
        \replacewith (mAdd(n,m))
    };

    kProdIsDistributive {
        \schemaVar \term Matrix m,n,o;

        \find(kProd(m,mAdd(n,o)))
        \replacewith(mAdd(kProd(m,n),kProd(m,o)))
    };

    kProdIsDistributive2 {
        \schemaVar \term Matrix m,n,o;

        \find(kProd(mAdd(n,o),m))
        \replacewith(mAdd(kProd(n,m),kProd(o,m)))
    };

    kProdIsDistributiveWithConjTranspose {
        \schemaVar \term Matrix m,n,o;
        \find(conjungateTranspose(kProd(m,n)))
        \replacewith(kProd(conjungateTranspose(m),conjungateTranspose(n)))
    };

    rowsKProd {
        \schemaVar \term Matrix m,n;

        \find(rows(kProd(m,n)))
        \replacewith(mul(rows(m),rows(n)))
    };

    rowsKProd {
       \schemaVar \term Matrix m,n;

       \find(cols(kProd(m,n)))
       \replacewith(mul(cols(m),cols(n)))

       \heuristics (simplify)

    };

    unitaryMatricesAreSquare {
      \schemaVar \term UMatrix m;

      \find(cols(m))
      \replacewith(rows(m))

      \heuristics (simplify)
    };

    kProdKet {
        \schemaVar \term int i, j;
        \schemaVar \term Seq q1names, q2names;
        \schemaVar \term Seq q1values, q2values;
        \schemaVar \variables int x, y;

        \find(kProd(ket(i, q1names, q1values),ket(j,q2names, q2values)))
        \varcond(\notFreeIn(x,i,j,q1values,q2values),\notFreeIn(y,i,j,q1values,q2values))
        \replacewith( ket (i+j, seqConcat(q1names,q2names),
                       seqFlatten( seqDef{x;}(0,seqLen(q1values),
                                      seqDef{y;}(0, seqLen(q2values),
                                                    pair(cmul(Complex::seqGet(q1values,x), fst(Pair::seqGet(q2values,y))),
                                                                 add(mul(x,i), snd(Pair::seqGet(q2values,y)))
                                                           ))))))
    };

    // algebraic definitions
    rowsKProdEnlarge {
        \schemaVar \term int pos, bits;

        \find (rows(kProdEnlarge(H(2), pos, bits)))
        \replacewith(bits)

        \heuristics(simplify)
    };

    rowsKProdEnlargeEQ {
        \schemaVar \term Matrix EQ;
        \schemaVar \term int pos, bits;

        \assumes (kProdEnlarge(H(2), pos, bits) = EQ ==>)
        \find (rows(EQ))
        \replacewith(bits)

        \heuristics(simplify)
    };

    columnsKProdEnlarge {
        \schemaVar \term int pos, bits;

        \find (cols(kProdEnlarge(H(2), pos, bits)))
        \replacewith(bits)

        \heuristics(simplify)
    };

    columnsKProdEnlargeEQ {
        \schemaVar \term Matrix EQ;
        \schemaVar \term int pos, bits;

        \assumes (kProdEnlarge(H(2), pos, bits) = EQ ==>)
        \find (cols(EQ))
        \replacewith(bits)

        \heuristics(simplify)
    };

    getMValGeneral {
        \schemaVar \term Matrix A, B;
        \schemaVar \term int i,j;
        \schemaVar \variables int x;

        \find(getMVal( mProd(A, B), i, j))
        \varcond(\notFreeIn(x,A,B,i,j))
        \replacewith(bsum{x;}(0,cols(A), mul(getMVal(A, i, x), getMVal(B, x, j))))

        //\heuristics (userTaclets1)
    };

    getMVal {
        \schemaVar \term int j, col;
        \schemaVar \term int m /* pos */, n /* qbits */;
        \schemaVar \term Matrix reg;

        \find (getMVal(mProd(kProdEnlarge(H(2), m, n), reg), j, col))
        \replacewith (invSqrt2 * (\if (signH(j,m,n) = -1)
                      \then (getMVal(reg,left(j,m,n),col) - getMVal(reg,right(j,m,n),col))
                      \else (getMVal(reg,left(j,m,n),col) + getMVal(reg,right(j,m,n),col) ))) // complex mul with inverse of sqrt
        \heuristics (userTaclets2)
    };

     getMValX {
            \schemaVar \term int j;
            \schemaVar \term int m /* row */, col /* columns */,  n /* qbits */;
            \schemaVar \term Matrix reg;

            \find (getMVal(mProd(kProdEnlarge(X(2), m, n), reg), j, col))
            \replacewith (getMVal(reg,bitx(j,m,n),col)) // complex mul with inverse of sqrt
            \heuristics (userTaclets2)
        };

     bitxDef {
        \schemaVar \term int m,n;
        \schemaVar \term int j;

            \find(bitx(j,m,n))
            \replacewith(
                \if (getPosMBinary(j,m,n) = 0) \then (right(j,m,n))
                \else (left(j,m,n))
             )
            \heuristics (userTaclets1)
     };

    getMValCNOT1 {
        \schemaVar \term Matrix reg;
        \schemaVar \term int pos, col;

        \find(getMVal(mProd(CNOT(4), reg), pos, col))
        \replacewith( \if (pos <= 1)
                      \then ( getMVal(reg, pos, col) )
                      \else (
                        \if (pos = 3) \then (
                            getMVal(reg, 2, col)
                        ) \else (
                            getMVal(reg, pos + 1, col)
                        )
                      )
                    )
        \heuristics (userTaclets2)
    };

    getMValCNOT2 {
            \schemaVar \term Matrix reg;
            \schemaVar \term int pos, col;

            \find(getMVal(mProd(kProdEnlarge(CNOT(4), 0, 2), reg), pos, col))
            \replacewith( \if (pos <= 3)
                          \then ( getMVal(reg, pos, col) )
                          \else (
                            \if (pos >= 6 & pos <=7) \then (
                                getMVal(reg, pos - 2, col)
                            ) \else (
                                getMVal(reg, pos + 2, col)
                            )
                          )
                        )
            \heuristics (userTaclets2)
        };

    getPosMBinary {
        \schemaVar \term int m,n;
        \schemaVar \term int j;

        \find(getPosMBinary(j,m,n))
        \replacewith(shiftright(j, (n-m)-1) % 2)
        \heuristics (userTaclets1)
    };

    leftBinary {
        \schemaVar \term int m,n;
        \schemaVar \term int j;
        \schemaVar \skolemTerm int shiftJM;
        \find(left(j,m,n))
        \sameUpdateLevel
        \varcond(\newDependingOn(shiftJM, j))
        \replacewith(\if (getPosMBinary(j,m,n) = 0)
                     \then (j)
                     \else ( shiftleft(shiftJM, n-m) + (j - shiftleft(shiftright(j,(n-m)-1),(n-m)-1))))
        \add(shiftright(j,n-m) = shiftJM ==>)

        \heuristics(userTaclets1)
    };

    rightBinary {
        \schemaVar \term int m, n;
        \schemaVar \term int j;
        \schemaVar \skolemTerm int shiftJM;

        \find(right(j,m,n))
        \sameUpdateLevel
        \varcond(\newDependingOn(shiftJM, j))
        \replacewith(\if (getPosMBinary(j,m,n) = 1)
                    \then (j)
                    \else ( shiftleft(shiftleft(shiftJM, 1) + 1, (n-m)-1) +
                            (j - shiftleft(shiftright(j,(n-m)-1), (n-m)-1))))
        \add(shiftright(j,n-m) = shiftJM ==>)

        \heuristics(userTaclets1)
    };

    signHDef {
        \schemaVar \term int m,n;
        \schemaVar \term int j;
        \find(signH(j,m,n))
        \replacewith(\if (getPosMBinary(j,m,n) = 0) \then (1) \else (-1) )
        \heuristics (simplify)
    };

    setBit0 {
        \schemaVar \term int m,n;
        \schemaVar \term int j;

        \find(setBit(j,m,n,0))
        \replacewith(left(j,m,n))
        \heuristics (simplify)

    };

    setBit1 {
        \schemaVar \term int m,n;
        \schemaVar \term int j;

        \find(setBit(j,m,n,1))
        \replacewith(right(j,m,n))
        \heuristics (simplify)
    };

    measure {
        \schemaVar \term int m,n,val;
        \schemaVar \term Matrix reg;
        \schemaVar \variables int x;

        \find(measure(m,n,val,reg))
        \varcond(\notFreeIn(x,m,n,val,reg))
        \replacewith(bsum{x;}(0,pow(2,n-1),getMVal(reg,setBit(x,m,n,val),0)))
      //  \heuristics(userTaclets1)
    };

     measure2 {
            \schemaVar \term int m,n,pos,val;
            \schemaVar \term Matrix reg;

            \find(measure2(m, n, val, pos, reg))
            \replacewith(getMVal(reg, setBit(pos, m, n, val), 0))
            \heuristics(userTaclets1)
        };

    valuesCNot {
        \schemaVar \term int i,j;
        \find(getMVal(kProdEnlarge(CNOT(4),0,2),i,j))
        \replacewith(
            \if ( (i=j & i>=0 & i<=3)
                  |
                  (i=4 & j = 6) | (i=5 & j = 7)
                  |
                  (j=4 & i = 6) | (j=5 & i = 7)
                 )
            \then (1) \else (0)
        )
        \heuristics(userTaclets3)
    };

    valuesH {
        \schemaVar \term int i,j;
        \find(getMVal(kProdEnlarge(H(2),1,3),i,j))
        \replacewith(
            \if ( (i=j & i>=0 & i<=3)
                  |
                  (i=j+4 & i>=0 & i<=3)
                  |
                  (j=i+4 & j>=0 & j<=3)
                 )
            \then (1)
            \else (
                \if ((i=j & i>=4 & i<=7))
                \then(-1)
                \else (0)
            )
        )
        \heuristics(userTaclets3)
    };
}

\programVariables {
/*  QVector ab;
 QVector xr;
 Matrix phi,aux;
 Complex alpha,beta;
 Matrix a,b;
 */
int c;

 QVector reg;
 int result;

 int alphaSqrt, betaSqrt;
}

\problem{
    // getMVal(mProd(kProdEnlarge(H(2), 0, 2), reg), 0, 2) = result
    // getMVal(mProd(kProdEnlarge(H(2), 0, 2), reg), 1, 2) = result
    //getMVal(mProd(kProdEnlarge(H(2), 0, 2), reg), 2, 2) = result
    // getMVal(mProd(kProdEnlarge(H(2), 0, 2), reg), 3, 2) = result
    //getMVal(mProd(kProdEnlarge(X(2), 0, 2), reg), 0, 2) = result
    //getMVal(mProd(kProdEnlarge(X(2), 0, 2), reg), 1, 2) = result
    //getMVal(mProd(kProdEnlarge(X(2), 0, 2), reg), 2, 2) = result
    //getMVal(mProd(kProdEnlarge(X(2), 0, 2), reg), 3, 2) = result
   // getMVal(mProd(CNOT(4), reg),0, 2) = result
   // getMVal(mProd(CNOT(4), reg),1, 2) = result
   // getMVal(mProd(CNOT(4), reg),2, 2) = result
   // getMVal(mProd(CNOT(4), reg),3, 2) = result
   //   getMVal(mProd(kProdEnlarge(CNOT(4), 0, 2), reg), 4, 3) = result
   // getMVal(mProd(kProdEnlarge(CNOT(4), 0, 2), reg), 4, 3)

   getMVal(reg,0,0) = alphaSqrt &
   getMVal(reg,1,0) = 0 &
   getMVal(reg,2,0) = 0 &
   getMVal(reg,3,0) = alphaSqrt &
   getMVal(reg,4,0) = betaSqrt &
   getMVal(reg,5,0) = 0 &
   getMVal(reg,6,0) = 0 &
   getMVal(reg,7,0) = betaSqrt &
   rows(reg) = 8 & cols(reg) = 1
//  & rows(kProdEnlarge(CNOT(4),0, 2)) = 8
//  & (c = 0 | c = 1)
    ->
  /* getMVal(mProd(kProdEnlarge(H(2), 1, 3),
                 mProd(kProdEnlarge(CNOT(4), 0, 2), reg)), 0, 3) = result */
   measure2(0, 3, 0, 0, mProd(kProdEnlarge(H(2), 1, 3),
                             mProd(kProdEnlarge(CNOT(4), 0, 2), reg))) = result

}
// m n val pos

 /* { ab:=ket(2,seqConcat(seqSingleton(a),seqSingleton(b)),seqConcat(seqSingleton(pair(invSqrtOf2,0)),seqSingleton(pair(invSqrtOf2,3))))
      ||
      xr:=ket(1,seqSingleton(x),seqConcat(seqSingleton(pair(alpha,0)),seqSingleton(pair(beta,1))))}
               \[{
                   phi = Matrix.kProd(xr,ab);
                   phi = Matrix.kProd(Matrix.kProd(UMatrix.CNOT(3),UMatrix.ID(3)), phi);
                }\] P(ab,xr,phi,alpha,beta)*/

/* a!=null & b!=null & a.content != null & b.content != null & wellFormed(heap) &
   (\forall int i; \forall int j; (a.content[i] != null & a.content[i][j] != null)) &
   (\forall int i; \forall int j; (b.content[i] != null & b.content[i][j] != null)) &
   a.rows = 3 & a.cols = 3 & b.rows = 3 & b.cols = 3 &
   a.content.length = a.rows & a.content[0].length = a.cols &
   b.content.length = b.rows & b.content[0].length = b.cols
   -> \[{
        c = Matrix.mProd(a,b);
     }\] (c.content.length=3 & c.content[0].length= 3) */
