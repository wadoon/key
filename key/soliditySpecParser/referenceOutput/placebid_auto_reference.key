\profile "Solidity";

\javaSource ".";

\withOptions transfer:noCallBack;


\programVariables {
  MultiAuctionImpl self;
  Message msg;
  
}

\rules {
    insertCInv {
        \schemaVar \term Heap h;
        \schemaVar \term MultiAuctionImpl self;
        \schemaVar \variable Address a;
\schemaVar \variable int i;
\schemaVar \variable Address hb;


        \find(CInv(h, self))
        \varcond(\notFreeIn(a,h,self),\notFreeIn(i,h,self),\notFreeIn(hb,h,self))
        \replacewith(    
            ((((\exists hb; (\forall a; (((((int::select(h,(int[]::select(h,self,MultiAuctionImpl::$balances)), arr((int)hb))) >= (int::select(h,(int[]::select(h,self,MultiAuctionImpl::$balances)), arr((int)a)))) & (((a != hb) & (a != (Address::select(h,self,MultiAuctionImpl::$auctionOwner)))) -> ((int::select(h,(int[]::select(h,self,MultiAuctionImpl::$balances)), arr((int)a))) = int::select(h,net,address(a))))) & (((MultiAuctionImpl.State::select(h,self,MultiAuctionImpl::$state)) = MultiAuctionImpl.State::select(h,null,MultiAuctionImpl.State::$AUCTION_OPEN)) -> (int::select(h,net,address((Address::select(h,self,MultiAuctionImpl::$auctionOwner)))) = 0))) & ((int::select(h,(int[]::select(h,self,MultiAuctionImpl::$balances)), arr((int)hb))) = (int::select(h,net,address(hb))+int::select(h,net,address((Address::select(h,self,MultiAuctionImpl::$auctionOwner))))))))) & (((MultiAuctionImpl.State::select(h,self,MultiAuctionImpl::$state)) = MultiAuctionImpl.State::select(h,null,MultiAuctionImpl.State::$AUCTION_OPEN)) -> (\forall a; (((int::select(h,net,address(a)) > 0) -> ((boolean::select(h,(boolean[]::select(h,self,MultiAuctionImpl::$bidded)), arr((int)a))) = TRUE)) & (((\exists i; (((i >= 0) & (i < (int::select(h,(Address[]::select(h,self,MultiAuctionImpl::$bidders)),arr_length)))) & ((Address::select(h,(Address[]::select(h,self,MultiAuctionImpl::$bidders)), arr((int)i))) = a))))<->(((boolean::select(h,(boolean[]::select(h,self,MultiAuctionImpl::$bidded)), arr((int)a))) = TRUE))))))) & ((int::select(h,(int[]::select(h,self,MultiAuctionImpl::$balances)), arr((int)(Address::select(h,self,MultiAuctionImpl::$auctionOwner))))) = 0)) & (\forall a; ((int::select(h,(int[]::select(h,self,MultiAuctionImpl::$balances)), arr((int)a))) >= 0)))
        )
    };
}
 
\problem {
msg.sender != self &
gross_to != gross_from 
&
CInv(heap,self) &
msg.value >= 0 &
self.bidders!= null &
self.balances!= null &
self.auctionOwner!= null &
self.bidded!= null &
self.state!= null 
    ->
    {savedHeap:=heap || heap:=store(heap, net, address(msg.sender), int::select(heap, net, address(msg.sender)) + msg.value)} 
     \[{ self.placeOrIncreaseBid(msg)@MultiAuctionImpl;
    }\] ( CInv(heap, self)  
         & ((((MultiAuctionImpl.State::select(savedHeap,self,MultiAuctionImpl::$state)) = MultiAuctionImpl.State::select(savedHeap,null,MultiAuctionImpl.State::$AUCTION_OPEN)) & ((Address::select(savedHeap,msg,java.lang.Message::$sender)) != (Address::select(savedHeap,self,MultiAuctionImpl::$auctionOwner)))) & ((int::select(savedHeap,msg,java.lang.Message::$value)) > 0))& (\forall Field f; \forall java.lang.Object o; (elementOf(o,f,union(singleton((int[]::select(savedHeap,self,MultiAuctionImpl::$balances)), arr((int)(Address::select(savedHeap,msg,java.lang.Message::$sender)))),union(singleton((Address[]::select(savedHeap,self,MultiAuctionImpl::$bidders)), arr((int::select(savedHeap,(Address[]::select(savedHeap,self,MultiAuctionImpl::$bidders)),arr_length)))),union(singleton((Address[]::select(savedHeap,self,MultiAuctionImpl::$bidders)),arr_length),union(singleton((boolean[]::select(savedHeap,self,MultiAuctionImpl::$bidded)), arr((int)(Address::select(savedHeap,msg,java.lang.Message::$sender)))),singleton(net,address((Address::select(savedHeap,msg,java.lang.Message::$sender))))))))) |  !o = null & !o.<created>@savedHeap = TRUE | o.f = o.f@savedHeap))
    )

}

