\schemaVariables {
  \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
  \modalOperator { diamond, diamond_transaction } #dia;
  \modalOperator { box, box_transaction } #box;
  \formula post;

  \program SimpleExpression #se;
  \program LeftHandSide #lhs;
  \program Statement #body;
  \program[list] Statement #slist;
  \program Expression #nse;
  \program Label #lb, #lb1;

  \program Variable #x;
}

\rules(programRules:Java) {

  /////////////////////////////////////////////////////
  // Rules transforming loops: Invariant & Unwinding //
  /////////////////////////////////////////////////////

  loopScopeInvDia {
    \schemaVar \formula inv;
    \schemaVar \term any variantTerm;
    \schemaVar \update beforeLoopUpdate;
    \schemaVar \update heapAnonUpdate;
    \schemaVar \formula loopFormula;
    \schemaVar \program Variable #variant;
     
    \find ( (\modality{#dia} {.. while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#variant, any))
   
    \varcond(\not\hasLoopLabel) 
    \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\getInvariant(inv))
    \varcond(\getVariant(variantTerm))
    \varcond(\initBeforeLoopUpdate(beforeLoopUpdate, loopFormula))
    \varcond(\initHeapAnonUpdate(heapAnonUpdate, loopFormula))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Invariant Preserved and Used":
      \replacewith (
        {beforeLoopUpdate} 
          {#createLocalAnonUpdate(loopFormula) || heapAnonUpdate}
            {#variant:=variantTerm}
              (inv & #wellFormedCond(heapAnonUpdate) ->
                 (\modality{#dia}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#nse) { 
                        #body
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv
                      & #createFrameCond(loopFormula, beforeLoopUpdate)
                      & prec(variantTerm, #variant))
                   )))
      )
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  loopScopeInvDiaLabel {
    \schemaVar \formula inv;
    \schemaVar \term any variantTerm;
    \schemaVar \update beforeLoopUpdate;
    \schemaVar \update heapAnonUpdate;
    \schemaVar \formula loopFormula;
    \schemaVar \program Variable #variant;
     
    \find ( (\modality{#dia} {.. #lb: while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#variant, any))
   
    \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\getInvariant(inv))
    \varcond(\getVariant(variantTerm))
    \varcond(\initBeforeLoopUpdate(beforeLoopUpdate, loopFormula))
    \varcond(\initHeapAnonUpdate(heapAnonUpdate, loopFormula))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Invariant Preserved and Used":
      \replacewith (
        {beforeLoopUpdate} 
          {#createLocalAnonUpdate(loopFormula) || heapAnonUpdate}
            {#variant:=variantTerm}
              (inv & #wellFormedCond(heapAnonUpdate) ->
                 (\modality{#dia}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#nse) #lb: { 
                        #body
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv
                      & #createFrameCond(loopFormula, beforeLoopUpdate)
                      & prec(variantTerm, #variant))
                   )))
      )
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  loopScopeInvBox {
    \schemaVar \formula inv;
    \schemaVar \term any variantTerm;
    \schemaVar \update beforeLoopUpdate;
    \schemaVar \update heapAnonUpdate;
    \schemaVar \formula loopFormula;
     
    \find ( (\modality{#box} {.. while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    
    \varcond(\not\hasLoopLabel) 
    \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\getInvariant(inv))
    \varcond(\initBeforeLoopUpdate(beforeLoopUpdate, loopFormula))
    \varcond(\initHeapAnonUpdate(heapAnonUpdate, loopFormula))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Invariant Preserved and Used":
      \replacewith (
        {beforeLoopUpdate} 
          {#createLocalAnonUpdate(loopFormula) || heapAnonUpdate}
            (inv & #wellFormedCond(heapAnonUpdate) ->
               (\modality{#box}{
                  ..
                  boolean #x;
                  #x = true;
                  loop-scope(#x) {
                    if (#nse) { 
                      #body
                      #x = false;
                    }
                  }
                  ...
                }\endmodality(
                  (#x<<loopScopeIndex>> = TRUE -> post) & 
                  (#x<<loopScopeIndex>> = FALSE -> 
                      inv
                    & #createFrameCond(loopFormula, beforeLoopUpdate))
                 )))
      )
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  loopScopeInvBoxLabel {
    \schemaVar \formula inv;
    \schemaVar \term any variantTerm;
    \schemaVar \update beforeLoopUpdate;
    \schemaVar \update heapAnonUpdate;
    \schemaVar \formula loopFormula;
     
    \find ( (\modality{#box} {.. #lb: while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    
    \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\getInvariant(inv))
    \varcond(\initBeforeLoopUpdate(beforeLoopUpdate, loopFormula))
    \varcond(\initHeapAnonUpdate(heapAnonUpdate, loopFormula))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Invariant Preserved and Used":
      \replacewith (
        {beforeLoopUpdate} 
          {#createLocalAnonUpdate(loopFormula) || heapAnonUpdate}
            (inv & #wellFormedCond(heapAnonUpdate) ->
               (\modality{#box}{
                  ..
                  boolean #x;
                  #x = true;
                  loop-scope(#x) {
                    if (#nse) #lb: { 
                      #body
                      #x = false;
                    }
                  }
                  ...
                }\endmodality(
                  (#x<<loopScopeIndex>> = TRUE -> post) & 
                  (#x<<loopScopeIndex>> = FALSE -> 
                      inv
                    & #createFrameCond(loopFormula, beforeLoopUpdate))
                 )))
      )
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  unwindLoopScope { 
    // TODO (DS, 2019-02-14): Handle loop label
    
    \schemaVar \program Variable #cont;
    
    \find ( (\modality{#allmodal} {.. while (#nse) #body ... }\endmodality(post)) )
    \varcond(\new(#x, boolean))
    \varcond(\new(#cont, boolean))

    \replacewith (
      {#x:=TRUE || #cont:=FALSE}
         (\modality{#allmodal}{
            ..
            loop-scope(#x) {
              if (#nse) {
                #body
                #x = false;
              }
              if (!#x) {
                #x = true;
                #cont = true;
              }
            }
            if (#cont) {
              #reattachLoopInvariant(
                while (#nse) {
                  #body
                }
              );
            }
            ...
          }\endmodality(post))
    )
  
    \heuristics(loop_scope_expand)
  };

  ////////////////////////////////
  // Rules Handling Loop Scopes //
  ////////////////////////////////

  emptyIndexedLoopScope {
      \find (\modality{#allmodal}{.. loop-scope(#lhs) {} ...}\endmodality(post))
      \replacewith (
        \if (#lhs = TRUE) 
        \then (\modality{#allmodal}{.. ...}\endmodality(post))
        \else (\modality{#allmodal}{}\endmodality(post)))
      \heuristics(simplify_prog)
  };

  // NOTE (DS, 2019-02-15): This works because the loop body is put into
  //   a block by the loop scope invariant rule, and the other rules drop
  //   the rest of the block when encountering a continue. We have to keep
  //   that context since #slist will contain a program added by the loop
  //   scope invariant or unwinding rules, which sets some continue variable
  //   or executes a for loop update. See, for instance, blockContinue as
  //   an example for why this will work (and, of course, the invariant /
  //   unwinding rules).
  unlabeledContinueIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { continue; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. loop-scope(#lhs) { #lhs = false; #slist } ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  blockLoopScopes {
      \find        (\modality{#allmodal}{.. { loop-scope(#lhs) { #slist }  } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  loop-scope(#lhs) { #slist } ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  labeledContinueIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. #lhs = true; continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  throwIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { throw #se; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; throw #se; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  returnIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { return #se; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; return #se; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  emptyReturnIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { return; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; return; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  labeledBreakIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { break #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; break #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  unlabeledBreakIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { break; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  ////////////////////////////////
  //// Loop Scope-Related Rules //
  ////////////////////////////////

  blockContinue {
      \find        (\modality{#allmodal}{.. { continue; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   continue; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockBreak {
      \find        (\modality{#allmodal}{.. { break; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   break; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockContinueLabeled {
      \find        (\modality{#allmodal}{.. { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockBreakLabeled {
      \find        (\modality{#allmodal}{.. { break #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   break #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  blockContinueNoMatch {
      \find        (\modality{#allmodal}{.. #lb1: { continue #lb; #slist } ...}\endmodality(post))
      \varcond (\different (#lb1, #lb))
      \replacewith (\modality{#allmodal}{.. continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  blockContinueLabel {
      \find        (\modality{#allmodal}{.. #lb: { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. continue; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
}