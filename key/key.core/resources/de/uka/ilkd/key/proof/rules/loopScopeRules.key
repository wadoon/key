\schemaVariables {
  \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
  \formula post;

  \program SimpleExpression #se;
  \program LeftHandSide #lhs;
  \program Statement #body;
  \program[list] Statement #slist;
  \program Expression #nse;
  \program Label #lb, #lb1;

  \program Variable #x;
  \formula #inv;
  
  \update #anon_update;
}

// TODO (DS, 2019-02-14): Anonymize heap, add accessibles condition. CURRENTLY IN GENERAL UNSOUND!

\rules(programRules:Java) {

  /////////////////////////////////////////////////////
  // Rules transforming loops: Invariant & Unwinding //
  /////////////////////////////////////////////////////

  loopScopeInvariantTaclet { 
    \find ( (\modality{#allmodal} {.. while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\getInvariant(#inv))

    "Invariant Initially Valid":
      \replacewith(#inv);

    "Invariant Preserved and Used":
      \replacewith (
        {#createAnonUpdate(\modality{#allmodal}{#body}\endmodality(post))}
        (#inv ->
           (\modality{#allmodal}{
              ..
              boolean #x;
              #x = true;
              loop-scope(#x) {
                if (#nse) { 
                  #body
                  #x = false;
                }
              }
              ...
            }\endmodality(
              (#x = TRUE -> post) & 
            (#x = FALSE -> 
              #inv //  & accessibles & prec(_i, variant)
            )
           )))
      )
  
    \heuristics(loop_inv_taclets)
  };
  
  unwindLoopScope { 
    // TODO (DS, 2019-02-14): Handle loop label
    
    \schemaVar \program Variable #cont;
    
    \find ( (\modality{#allmodal} {.. while (#nse) #body ... }\endmodality(post)) )
    \varcond(\new(#x, boolean))
    \varcond(\new(#cont, boolean))

    \replacewith (
      {#x:=TRUE || #cont:=FALSE}
         (\modality{#allmodal}{
            ..
            loop-scope(#x) {
              if (#nse) {
                #body
                #x = false;
              }
              if (!#x) {
                #x = true;
                #cont = true;
              }
            }
            if (#cont) {
              #reattachLoopInvariant(
                while (#nse) {
                  #body
                }
              );
            }
            ...
          }\endmodality(post))
    )
  
    \heuristics(loop_inv_taclets)
  };

  ////////////////////////////////
  // Rules Handling Loop Scopes //
  ////////////////////////////////

  emptyIndexedLoopScope {
      \find (\modality{#allmodal}{.. loop-scope(#lhs) {} ...}\endmodality(post))
      \replacewith (
        \if (#lhs = TRUE) 
        \then (\modality{#allmodal}{.. ...}\endmodality(post))
        \else (\modality{#allmodal}{}\endmodality(post)))
      \heuristics(simplify_prog)
  };

  // NOTE (DS, 2019-02-15): This works because the loop body is put into
  //   a block by the loop scope invariant rule, and the other rules drop
  //   the rest of the block when encountering a continue. We have to keep
  //   that context since #slist will contain a program added by the loop
  //   scope invariant or unwinding rules, which sets some continue variable
  //   or executes a for loop update. See, for instance, blockContinue as
  //   an example for why this will work (and, of course, the invariant /
  //   unwinding rules).
  unlabeledContinueIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { continue; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. loop-scope(#lhs) { #lhs = false; #slist } ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  blockLoopScopes {
      \find        (\modality{#allmodal}{.. { loop-scope(#lhs) { #slist }  } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  loop-scope(#lhs) { #slist } ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  labeledContinueIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. #lhs = true; continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  throwIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { throw #se; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; throw #se; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  returnIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { return #se; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; return #se; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  emptyReturnIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { return; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; return; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  labeledBreakIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { break #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; break #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  unlabeledBreakIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { break; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  ////////////////////////////////
  //// Loop Scope-Related Rules //
  ////////////////////////////////

  blockContinue {
      \find        (\modality{#allmodal}{.. { continue; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   continue; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockBreak {
      \find        (\modality{#allmodal}{.. { break; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   break; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockContinueLabeled {
      \find        (\modality{#allmodal}{.. { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockBreakLabeled {
      \find        (\modality{#allmodal}{.. { break #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   break #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  blockContinueNoMatch {
      \find        (\modality{#allmodal}{.. #lb1: { continue #lb; #slist } ...}\endmodality(post))
      \varcond (\different (#lb1, #lb))
      \replacewith (\modality{#allmodal}{.. continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  blockContinueLabel {
      \find        (\modality{#allmodal}{.. #lb: { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. continue; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
}