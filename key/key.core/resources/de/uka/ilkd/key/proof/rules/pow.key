// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//


// The first few rules on pow were contained in
// integerSimplification.key. But since they
// use bprod they should be placed after bprod.key.

\rules {

//
//--------------------------------------------------------------------
// rules for order and multiplication
//
// should finally be moved to integerSimplificationRules
//
//--------------------------------------------------------------------

  multLess {
	\schemaVar \term int right, factor;
        \assumes (0<factor ==>)
        \find (factor < factor*right) \sameUpdateLevel 
        \replacewith (1 < right)
        \heuristics(concrete)
  };


 multLessAux {
	\schemaVar \variables int right, left,  factor;
      
        \add (\forall right;\forall left;\forall factor;(
              0 < factor -> (
             (left < right <-> left*factor < right*factor) &
             (left < right <-> factor*left < factor*right))) ==> )
      
  };

 multLess2 {
	\schemaVar \term int right, left,  factor;
        \assumes (0<factor ==>)
        \find (left*factor < right*factor) \sameUpdateLevel 
        \replacewith (left < right)
        \heuristics(concrete)
  };

//
//--------------------------------------------------------------------
// rules for exponentiation pow(base,exp)
//--------------------------------------------------------------------

 pow_literals {
    \schemaVar \term  numbers iz, jz;

    \find (pow(Z(iz),Z(jz)))     
    \replacewith (#pow(Z(iz),Z(jz))) 
    \heuristics (simplify_literals)
  };


 powDef {
   	\schemaVar \term int base, exp;
   	\schemaVar \variables int x;

	\find ( pow(base, exp) )
	\varcond(\notFreeIn(x, exp, base))
	\replacewith ( \if (exp >= 0) 
				   \then ( bprod{x;}(0, exp, base) )
				   \else ( undefinedPow(base,exp) )
				  )
   
  };    

  powExpZero{
	\schemaVar \term int base;
       
	\find ( pow(base, 0) )
	\replacewith (1)
        \heuristics(concrete)
};

 powExpOne{
	\schemaVar \term int base;
       
	\find ( pow(base, 1) )
	\replacewith (base)
        \heuristics(concrete)
};

 powBaseOne{
	\schemaVar \term int exp;
        \assumes(exp>=0 ==> )
  	\find ( pow(1, exp) ) \sameUpdateLevel
	\replacewith (1)
        \heuristics(concrete)
};

 powBaseZero{
	\schemaVar \term int exp;
        \assumes(exp>=1 ==> )
  	\find ( pow(0, exp) ) \sameUpdateLevel
	\replacewith (0)
        \heuristics(concrete)
};

  powExpSucc{
    	\schemaVar \term int base, exp;
       \assumes( exp >= 0 ==>)
     	\find ( pow(base, exp+1 ) ) \sameUpdateLevel
	\replacewith (pow(base, exp)*base )
       \heuristics( simplify )
};

  powExpAdd{
    	\schemaVar \term int base, exp1, exp2;
        \assumes( exp1 >= 0,  exp2 >=  0 ==>)
     	\find ( pow(base, exp1 + exp2 ) ) \sameUpdateLevel
	\replacewith ( pow(base,exp1)*pow(base,exp2))
       \heuristics(simplify_enlarging)
};

 powExpExp{
    	\schemaVar \term int base, exp1, exp2;
        \assumes( exp1 >= 0,  exp2 >=  0 ==>)
     	\find ( pow(pow(base, exp1),exp2 )) \sameUpdateLevel
	\replacewith ( pow(base,exp1*exp2))
        \heuristics(simplify_enlarging)
};

 powGreaterOne{
	\schemaVar \term int base, exp;
        \assumes( exp > 0,  base >  1 ==>)
     	\find ( pow(base, exp) )\sameUpdateLevel
	\add ( pow(base, exp) > 1 ==>  )
        \heuristics(simplify_enlarging)
};

 powGreaterOneEven{
	\schemaVar \term int base, exp;
        \assumes( exp > 0, base != 0 ==>)
     	\find ( pow(base, exp) )\sameUpdateLevel
	\add ( pow(base, 2*exp) >= 1 ==>  )
};

  powExpMonotone{
    	\schemaVar \variables int base, e1, e2;
     	\add  (\forall base;\forall e1;\forall e2;(
            0<= e1 & e1 < e2 & 1 < base ->  pow(base, e1) < pow(base,e2)) ==> ) 
};

 powBaseMonotone{
    	\schemaVar \variables int base1, base2, e;
     	\add  (\forall base1;\forall base2;\forall e;(
            0 < e &  1 < base1 & base1 < base2  ->  pow(base1, e) < pow(base2,e))==>) 
};

 powInfiniteRange{
  \schemaVar \variables int base, exp, goal;
   \add(\forall goal;\forall base;(0<= goal & 1<base -> \exists exp;(0<= exp & goal < pow(base,exp)))
        ==>)
 };

}