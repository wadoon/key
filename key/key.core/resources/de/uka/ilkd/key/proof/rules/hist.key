\sorts {
	Event;
	EventType;
	MethodIdentifier;
}

\functions {
	//constructors
	//type, caller, callee, service, content, heap
	Event event(EventType, Object, Object, MethodIdentifier, Seq, Heap);
	\unique EventType serviceCall;
	\unique EventType serviceTermination;

	//destructors
	EventType evType(Event);
	Object evCaller(Event);
	Object evCallee(Event);
	MethodIdentifier evService(Event);
	Seq evContent(Event);
	Heap evHeap(Event);

	Seq filterInput(Seq);
	Seq filterVisible(Seq);
	Seq filterVisibleInternal(Seq);

	//other stuff
	//signature for heapjoin: sendingHeap, receivingHeap, parameterlist, self object of the receiving bean
	Heap heapjoin(Heap, Heap, Seq, any);
}

\predicates {
    wfHist(Seq); // =? wellformedList

		wellformedList(Seq);
		wellformedListCoop(Seq);
		coopListEquiv(Seq, Seq);
		equivHistory(Seq,Seq);
		equivHistoryFiltered(Seq,Seq);
		equivEvent(Event, Event);
		equivEventLocal(Event, Event);
		equivEventGlobal(Event, Event);
		invEvent(Event);
		invEventLocal(Event);
		invEventGlobal(Event);
		isCallable(Event);

		agreePre(Heap, Heap);
		agreePreLocal(Heap, Heap);
		agreePreGlobal(Heap, Heap);
		agreePost(Heap, Heap);

    //similarities
    similarHist(Object, Seq, Seq);
    similarEvent(Event, Event);
    similar(any, any, Heap, Heap);

	//Helper predicates for recursive definitions
	wellformedListInternal(Seq);
	wellformedListCoopInternal(Seq);
	coopListEquivInternal(Seq, Seq);
	coopListEquivFilteredInternal(Seq, Seq);
	equivHistoryInternal(Seq,Seq);
	equivHistoryFilteredInternal(Seq,Seq);
	correspondingEvents(Event, Event);
	correspondingEventsCoop(Event, Event);

	//other stuff
	isIso(any, Heap, any, Heap);
	transfresh(any, Heap, Heap);
		agreeBasic(Seq, Seq);
}

\programVariables {
    Seq hist;
	Seq internalHist;
	Seq currentParams;
	Object environmentCaller;
	Object activeComponent;
}



\rules{

  addEventsToEquivLeft {
    \schemaVar \term Event eA, eB, eAlong;
    \assumes(eAlong = eA ==>)
    \find(equivEvent(eA, eB))
    \replacewith(equivEvent(eAlong, eB))
    \heuristics(simplify)
  };
  
  addEventsToEquivRight {
    \schemaVar \term Event eA, eB, eBlong;
    \assumes(eBlong = eB ==>)
    \find(equivEvent(eA, eB))
    \replacewith(equivEvent(eA, eBlong))
    \heuristics(simplify)
  };
  
  addEventsToInvEvent {
    \schemaVar \term Event e, elong;
    \assumes(elong = e ==>)
    \find(invEvent(e))
    \replacewith(invEvent(elong))
    \heuristics(simplify)
  };
  
  selectOfheapjoinSelf {
	\schemaVar \term Heap h, ho;
	\schemaVar \term Object o, selfO;
	\schemaVar \term Seq s;
	\schemaVar \term Field f;
	
	\find(beta::select(heapjoin(h, ho, s, selfO), o, f))
	
    \varcond(\selfExpression(o, selfO))

	\replacewith(beta::select(ho, o, f))
	\heuristics(semantics_blasting)
   };
   
   
   selectOfheapjoinParam {
	\schemaVar \term Heap h, ho;
	\schemaVar \term Object o, selfO;
	\schemaVar \term Seq s;
	\schemaVar \term Field f;
	
	\find(beta::select(heapjoin(h, ho, s, selfO), o, f))
	
    \varcond(\paramExpression(o, s))

	\replacewith(beta::select(h, o, f))
	\heuristics(semantics_blasting)
   };
   

  
  
}
