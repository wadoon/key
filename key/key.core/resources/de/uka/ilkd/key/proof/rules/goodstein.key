
// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//

// This file contains only RULES.
// Function and predicate declarations can be found in ord.key
// The rules come in sections
//  * Core Axioms
//  + Derived  Taclets

\rules{

//--------------------------------------------------------------------------
//  
//  Axioms
//  
//--------------------------------------------------------------------------

oGSDef1{
  \schemaVar \variables int n, m;
  \add(\forall n;\forall m;(
   2<=n & 0<=m & m < n -> oGS(n,m) = onat(m)) ==>)
  };

oGSDef2{
  \schemaVar \variables int n, m, k, a, c;
  \add(\forall n;\forall m;\forall k;\forall a;\forall c;(
    m = add(mul(pow(n,k),a),c) & 
    2<=n & 1<=k &   0 < a & a < n & c < pow(n,k)
   -> oGS(n,m) = oadd(otimes(oexp(omega,oGS(n,k)),onat(a)),oGS(n,c))) ==> )
};

// oHNf is a bad name
// it amounts to f^{m,base}(base+1) in the notation of KirbyParis

oHNfDef1{
  \schemaVar \variables int base, m;
  \add(\forall base;\forall m;(
   2<=base & 0<=m & m < base -> oHNf(base,m) = m) ==>)
  };

oHNfDef2{
  \schemaVar \variables int base, m, k, a, c;
  \add(\forall base;\forall m;\forall k;\forall a;\forall c;(
    m = add(mul(pow(base,k),a),c) & 
    2<=base & 1<=k &   0 < a & a < base & c < pow(base,k)
   -> oHNf(base,m) = pow(base+1,oHNf(base,k))*a + oHNf(base,c)) ==> )
};

//--------------------------------------------------------------------------
//  
//  Derived  taclets on oGS
//  
//--------------------------------------------------------------------------


\lemma
oGSZero{
  \schemaVar \term int n;
  \assumes(2<= n ==> )
  \find(oGS(n,0))   \sameUpdateLevel 
  \replacewith(onat(0))
  };



\lemma
oGSGreaterZeroQ{
 \schemaVar \variable int n,e; 
 \add(\forall n;\forall e;(
           1 <n & 0 < e -> olt(o_0, oGS(n,e)))
      ==> )
};


\lemma
oGSGreaterZero{
 \schemaVar \term int n,e; 
 \assumes( 1 <n , 0 < e ==>)
 \find(olt(o_0, oGS(n,e)))  \sameUpdateLevel 
 \replacewith(true)
};

\lemma
oGSGEZero{
 \schemaVar \term int n,e; 
 \assumes( 1 <n , 0 <= e ==>)
 \find(oleq(o_0, oGS(n,e)))  \sameUpdateLevel 
 \replacewith(true)
};

\lemma
oGSstrictMonotone{
    \schemaVar \variables int n, m1, m2;
     \add(\forall n;\forall m1;\forall m2;(
           (2<= n & 0<= m1 & m1 < m2)  ->
       olt(oGS(n,m1), oGS(n,m2)))
      ==> )
};


//--------------------------------------------------------------------------
//  
//  Derived  taclets on oHNf
//  
///--------------------------------------------------------------------------

\lemma
oHNfZero{
  \schemaVar \term int n;
  \assumes(2<= n ==> )
  \find(oHNf(n,0))   \sameUpdateLevel 
  \replacewith(0)
  \heuristics(simplify)
  };

\lemma
oHNfIncreasing{
  \schemaVar \variables int base, m;
  \add(\forall base;\forall m;( 2<=base & base <= m  -> m < oHNf(base,m)) ==> )
};

\lemma
oHNfWeakIncreasing{
  \schemaVar \variables int base, m;
  \add(\forall base;\forall m;( 2<=base & 0 <= m -> m <= oHNf(base,m)) ==> )
};

oHNfDef2a{
  \schemaVar \variables int base, m, k;
  \add(\forall base;\forall m;\forall k;(
    m = pow(base,k) & 
    2<=base & 1<=k 
   -> oHNf(base,m) = pow(base+1,oHNf(base,k))) ==> )
};

\lemma
oHNfMonotone{
  \schemaVar \variables int base, m1, m2;
  \add(\forall m2;\forall m1;\forall base;( 2<=base & 0 <= m1 & m1 < m2  -> oHNf(base, m1) < oHNf(base, m2)) ==> )
};

}