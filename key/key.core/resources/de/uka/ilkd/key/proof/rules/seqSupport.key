// These are supporting normalisation rules for explicit sequences.
// The goal is to avoid nested concats, but have as first element of a concat a singleton.

\rules {  

  //those all are lemmas
  \lemma
  moveSingletonOut {
    \schemaVar \term Seq s;
    \schemaVar \term Seq t;
    \schemaVar \term any a;
   
    \find(seqConcat(seqConcat(seqSingleton(a), s),t))
    \replacewith(seqConcat(seqSingleton(a), seqConcat(s, t)))
    
    \heuristics(simplify)
  };
  
  moveSingletonOut_EQ {
    \schemaVar \term Seq x;
    \schemaVar \term Seq y;
    \schemaVar \term Seq s;
    \schemaVar \term Seq t;
    \schemaVar \term any a;
    
    \assumes(seqSingleton(a) = y ==>)
    \find(seqConcat(y, t))
    \replacewith(seqConcat(seqSingleton(a), t))
    \heuristics(simplify)
  };
  
  moveSingletonOut_EQ2 {
    \schemaVar \term Seq x;
    \schemaVar \term Seq y;
    \schemaVar \term Seq s;
    \schemaVar \term Seq t;
    \schemaVar \term any a;
    
    \assumes(seqConcat(y, s) = x, seqSingleton(a) = y ==>)
    \find(seqConcat(x, t))
    \replacewith(seqConcat(seqSingleton(a), seqConcat(s, t)))
    \heuristics(simplify)
  };
  
  //easy Selection of first element in case of singleton
  \lemma
  selectFirstOfSingleton {
    \schemaVar \term Seq s;
    \schemaVar \term any a;
    
    \find(alpha::seqGet(seqConcat(seqSingleton(a),s), Z(0(#)) ))
    \replacewith((alpha)a)
    \heuristics(simplify)
  };
}

