\sorts {
	Set;

	SetList;

	SetGraph;
	SetGraphTree;



	/*
	SetGraphEdge;
	SetGraphNodes;
	SetGraphEdges;
	//*/
}

\predicates {
   element(any, Set);
   is_subset(Set, Set);
   finite(Set);

   // --- GRAPH ---

   wellFormedGraph(SetGraph);
   wellFormedTree(SetGraphTree);

}

\functions {
// --- SET ---

	// empty Set
	\unique Set SetEmpty;
	
	// Singleton Set
	\unique Set single(any);

	// union of two Sets
	Set SetUnion(Set, Set);

	// intersection of two Sets
	Set SetIntersection(Set, Set);

	// difference of two Sets
	Set SetDifference(Set, Set);

	// complement of a Set
	//Set compl(Set);

	// cardinality
	int cardinality(Set);

// --- SET LIST ---

	// empty set list
	SetList SetListEmpty;

	// set list
	SetList setList(Set, SetList);

// --- GRAPH ---

// structural

	//graph tree (number of nodes, content of top node, children)
	SetGraphTree tree(int, Set, SetGraph);

	//graph tree not found value
	SetGraphTree noTree;

	//graph empty
	\unique SetGraph SetGraphEmpty;

	//graph (number of nodes, first tree, rest)
	SetGraph graph(int, SetGraphTree, SetGraph);

// helper functions

	//add tree
	SetGraph addTree(SetGraph, SetGraphTree);

	//find tree with set in top node
	SetGraphTree findTree(SetGraph, Set);

	// number of nodes of graph/tree
	int nodeCountG(SetGraph);
	int nodeCountT(SetGraphTree);

//Bansal et al. functions -----
	
	//graph add
	SetGraph addToGraph(SetGraph, Set);
	
	//graph merge
	//SetGraph mergeGraph(SetGraph, Set, Set);

	//non empty leaves of a set in the graph
	//SetList nonEmptyLeaves(SetGraph, Set);

	//instead leaves
	SetList leaves(SetGraph, Set);
}



\axioms {
	// axioms
	
	// --- GRAPH ---

	// axiomatic graph
	/*
	
	//*/

	// structural graph


	addTreeEmpty{
		\schemaVar \term int i;
		\schemaVar \term Set s;
		\schemaVar \term SetGraph sub;

		\find( addTree(SetGraphEmpty, tree(i, s, sub)) )
		\replacewith( graph(i, tree(i, s, sub), SetGraphEmpty) )

		\heuristics(simplify)
	};

	addTree{
		\schemaVar \term int i, j;
		\schemaVar \term Set s;
		\schemaVar \term SetGraph sub, sub1;
		\schemaVar \term SetGraphTree t;


		\find( addTree(graph(j, t, sub1), tree(i, s, sub)) )
		\replacewith( graph(i + j, tree(i, s, sub), graph(j, t, sub1)) )

		\heuristics(simplify)
	};

	findTreeEmpty{
		\schemaVar \term int i, j;
		\schemaVar \term Set s, s0;
		\schemaVar \term SetGraph sub, sub0;

		\find( findTree(SetGraphEmpty, s) )
		\replacewith( noTree )
	};

	findTree{
		\schemaVar \term int i, j;
		\schemaVar \term Set s, s0;
		\schemaVar \term SetGraph sub, sub0;

		\find( findTree(graph(i, tree(j, s0, sub), sub0), s) )
		\replacewith( 
			\if( s0 = s )
			\then( tree(j, s0, sub) )
			\else(
				\if( findTree(sub, s) = noTree )
				\then( findTree(sub0, s) )
				\else( findTree(sub, s) )
			)
		)
	};


/* //Were for merge
	findTreesEmpty{
		\schemaVar \term Set s1, s2;

		\find( findTrees(SetGraphEmpty, s1, s2) )
		\replacewith( graph(0, noTree, graph(0, noTree, SetGraphEmpty)) )

		\heuristics(simplify)
	};

	findTreesRec1{
		\schemaVar \term int i, j;
		\schemaVar \term Set s1, s2, s0;
		\schemaVar \term SetGraph sub, sub0;

		\find( findTrees(graph(i, tree(j, s0, sub0), sub)) ) //TODO finnish
	};
//*/


	addChildrenEmpty{ //currently only that is needed
		\schmeaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;

		\find( addCildren(tree(i, s, SetGraphEmpty), g) )
		\replacewith( tree(nodeCountG(g) + 1, s, g) )
	};

	addAllTreesFromEmpty{
		\schemaVar \term SetGraph g, original;

		\find( addAllTreesFrom(g, SetListEmpty, original) )
		\replacewith( g )
	};

	addAllTreesFromRec{
		\schemaVar \term SetGraph g, original;

		\find( addAllTreesFrom(g,  setList(s, l), original) )
		\replacewith( 
			\if( findTree(original, s) = noTree )
			\then( addTree(g, tree(1, s, SetGraphEmpty)) )
			\else( addAllTreesFrom(addTree(g, findTree(original, s)), l, original) )
		)
	};

	leavesRec{
		\schemaVar \term int i, j;
		\schemaVar \term SetGraph sub, sub0;
		\schemaVar \term Set s;

		\find( leaves(graph(i, tree(j, s, sub0), sub)) )
		\replacewith( 
			\if( sub0 = SetGraphEmpty )
			\then( setList(s, leaves(sub)) )
			\else( setListAddAll(leaves(sub0), leaves(sub)) )
		)

		\heuristics(simplify)
	};

	leavesEmpty{
		\find( leaves(SetGraphEmpty) )
		\replacewith( SetListEmpty )

		\heuristics( simplify )
	};

	addEdges{
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;
		\schemaVar \term SetList l;


		\find( addEdges(g, s, l) )
		\replacewith( changingMarker(s, l, addEdgesG(g, s, l, g)) )

		\heuristics(simplify)
	};

	addEdgesFin0{
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;
		\schemaVar \term SetList l;

		\find( changingMarker(s, l, changedMarkerG(g)) )
		\replacewith( g )

		\heuristics(simplify)
	};

	addEdgesFin1{
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;
		\schemaVar \term SetList l;

		\find( changingMarker(s, l, unchangedMarkerG(g)) )
		\replacewith( 
			addTree(g, addChildren(tree(1, s, SetGraphEmpty), addAllTreesFrom(SetGraphEmpty, l, original)))
		)

		\heuristics(simplify)
	};

	addEdgesPropagateChangeG0{
		\schemaVar \term int i;
		\schemaVar \term SetGraph sub;
		\schemaVar \term SetGraphTree t;

		\find( graph(i, t, changedMarkerG(sub)) )
		\replacewith( changedMarkerG(addTree(sub, t)) )
	};

	addEdgesPropagateChangeG1{
		\schemaVar \term int i;
		\schemaVar \term SetGraph sub;
		\schemaVar \term Set s;

		\find( tree(i, s, changedMarkerG(sub)) )
		\replacewith( changedMarkerT(tree(nodeCountG(sub), s, sub)) )
	};

	addEdgesPropagateChangeT{
		\schemaVar \term int i;
		\schemaVar \term Set s;
		\schemaVar \term SetGraph original, sub;
		\schemaVar \term SetGraphTree t;
		\schemaVar \term SetList l;

		\find( graph(i, changedMarkerT(t), addEdgesGInactive(sub, s, l, original)) )
		\replacewith( changedMarkerG(addTree(sub, t)) )
	};

	addEdgesPropagateUnchangedG0{
		\schemaVar \term int i;
		\schemaVar \term SetGraph sub;
		\schemaVar \term SetGraphTree t;

		\find( graph(i, t, unchangedMarkerG(sub)) )
		\replacewith( unchangedMarkerG(graph(i, t, sub)) )
	};

	addEdgesPropagateUnchangedG1{
		\schemaVar \term int i;
		\schemaVar \term SetGraph sub;
		\schemaVar \term Set s;

		\find( tree(i, s, unchangedMarkerG(sub)) )
		\replacewith( unchangedMarkerT(tree(i, s, sub)) )
	};

	addEdgesActivate{
		\schemaVar \term int i;
		\schemaVar \term Set s;
		\schemaVar \term SetGraph original, sub;
		\schemaVar \term SetGraphTree t;
		\schemaVar \term SetList l;

		\find( graph(i, unchangedMarkerT(t), addEdgesGInactive(sub, s, l, original)) )
		\replacewith( graph(i, t, addEdgesG(sub, s, l, original)) )
	};


	addEdgesEmpty{
		\schemaVar \term Set s;
		\schemaVar \term SetGraph original;
		\schemaVar \term SetList l;

		\find( addEdgesG(SetGraphEmpty, s, l, original) )
		\replacewith( unchangedMarkerG(SetGraphEmpty) )
	};

	addEdgesRec{
		\schemaVar \term int i;
		\schemaVar \term Set s;
		\schemaVar \term SetGraph original, sub;
		\schemaVar \term SetGraphTree t;
		\schemaVar \term SetList l;

		\find( addEdgesG(graph(i, t, sub), s, l, original) )
		\replacewith( 
			\if( t = tree(1, s, SetGraphEmpty) ) //only for leaves to keep graph invariant

			\then( changedMarkerG(addTree(sub, addChildren(t, addAllTreesFrom(SetGraphEmpty, l, original)))) )

			\else( graph(i, addEdgesT(t, s, l, original), addEdgesGInactive(sub, s, l, original) ))
		)
	};

	wellFormedGraph{
		\schemaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term SetGraphTree t;

		\find( wellFormedGraph(graph(i, t, g) )
		\replacewith( i = nodeCountT(t) + nodeCountG(g) & wellFormedTree(t) & wellFormedGraph(g) )


	};

	wellFormedGraphEmpty{

		\add( wellFormedGraph(SetGraphEmpty) ==> )
	};

	wellFormedTree{
		\schemaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;

		\find( wellFormed( tree(i, s, g) )
		\replacewith( i = 1 + nodeCountG(g) & wellFormedGraph(g) )
	};

	nodeCountG{
		\schemaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term SetGraphTree t;

		\find( nodeCountG(graph(i, t, g)) )
		\replacewith( i )

		\heuristics(simplify)
	};

	nodeCountGEmpty{

		\find( nodeCountG(SetGraphEmpty) )
		\replacewith( 0 )

		\heuristics(concrete)
	};

	nodeCountT{
		\schemaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term SetGraphSet s;

		\find( nodeCountT(tree(i, s, g)) )
		\replacewith( i )

		\heuristics(simplify)
	};

	graphEq{
		\schemaVar \term int i, j;
		\schemaVar \term SetGraph g, h;
		\schemaVar \term SetGraphTree t, u;

		\find( graph(i, t, g) = graph(j, u, h) )
		\replacewith( i = j & t = u & g = h )

		\heuristics(simplify_enlarging)
	};

	graphEqEmpty1{
		\schemaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term SetGraphTree t;

		\find( graph(i, t, g) = SetGraphEmpty )
		\replacewith( false )

		\heuristics(concrete)
	};

	graphEqEmpty2{
		\schemaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term SetGraphTree t;

		\find( SetGraphEmpty = graph(i, t, g) )
		\replacewith( false )

		\heuristics(concrete)
	};

	treeEq{
		\schemaVar \term int i, j;
		\schemaVar \term SetGraph g, h;
		\schemaVar \term Set s, t;

		\find( tree(i, s, g) = tree(j, t, h) )
		\replacewith( i = j & s = t & g = h )

		\heuristics(simplify_enlarging)
	};

	treeEqNoTree1{
		\schemaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;

		\find( tree(i, s, g) = noTree )
		\replacewith( false )

		\heuristics(concrete)
	};

	treeEqNoTree2{
		\schemaVar \term int i;
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;

		\find( noTree = tree(i, s, g) )
		\replacewith( false )

		\heuristics(concrete)
	};


	//Rules for addToGraph
	
	//case 1 with empty
	handleAdd1_0{
		\schemaVar \term SetGraph g;
		
		\find( addToGraph(g, SetEmpty) )
		\replacewith (
			\if(findTree(g, SetEmpty) = noTree)
			\then(addTree(g, tree(1, SetEmpty, SetGraphEmpty)))
			\else(g)
		)


	};

	//case 1 with singleton
	handleAdd1_1{
		\schemaVar \term SetGraph g;
		\schemaVar \term any a;
		
		\find( addToGraph(g, single(a)) )
		\replacewith (
			\if(findTree(g, single(a)) = noTree)
			\then(addTree(g, tree(1, single(a), SetGraphEmpty)))
			\else(g)
		)
		

	};

	//case 1 with constant
	//Not needed
	
	
	

	handleAdd2_0{
		\schemaVar \term SetGraphNodes nodes;
		\schemaVar \term SetGraphEdges edges;
		\schemaVar \term Set s, t;
		
		\find( addToGraph(g, SetIntersection(s, t)) )
		\replacewith ( addEdges(
								addEdges(g, s, 
									setList(SetDifference(s, t),
									setList(SetIntersection(s, t),
									SetListEmpty))),
								t,
								setList(SetDifference(t, s),
								setList(SetIntersection(s, t),
								SetListEmpty)))
		)
		\heuristics(simplify_enlarging)
	};
	
	handleAdd2_1{
		\schemaVar \term SetGraphNodes nodes;
		\schemaVar \term SetGraphEdges edges;
		\schemaVar \term Set s, t;
		
		\find( addToGraph(g, SetDifference(s, t)) )
		\replacewith ( addEdges(
								addEdges(g, s, 
									setList(SetDifference(s, t),
									setList(SetIntersection(s, t),
									SetListEmpty))),
								t,
								setList(SetDifference(t, s),
								setList(SetIntersection(s, t),
								SetListEmpty)))
		)
		\heuristics(simplify_enlarging)
	};
	
	handleAdd3{
		\schemaVar \term SetGraphNodes nodes;
		\schemaVar \term SetGraphEdges edges;
		\schemaVar \term Set s, t;
		
		\find( addToGraph(graph(nodes, edges), SetUnion(s, t)) )
		\replacewith ( addEdges(
								addEdges(
									addEdges(g, s, 
										setList(SetDifference(s, t),
										setList(SetIntersection(s, t),
										SetListEmpty))),
									t,
									setList(SetDifference(t, s),
									setList(SetIntersection(s, t),
									SetListEmpty))),
								SetUnion(s, t),
								setList(SetDifference(t, s),
								setList(SetIntersection(s, t),
								setList(SetDifference(s, t),
								SetListEmpty))))
		)
		\heuristics(simplify_enlarging)

	};
	
	

	// rules to handle mergeGraph
	/*
	handleMerge{
		\schemaVar \term SetGraph graph;
		\schemaVar \term Set s, t;

		\find( mergeGraph(graph, s, t) )
		\replacewith(
			mergeGraphInternal0(
				graph,
				findTrees(s, t)
			)
		)

		\heuristics(simplify_enlarging)
	};

	handleMerge0{
		\schemaVar \term SetGraph graph;
		\schemaVar \term SetGraphTree t1, t2;

		\find( mergeGraph(graph, graph(i, t1, graph(j, t2, SetgraphEmpty))) )
		\replacewith(
			mergeGraphInternal0(
				graph,
				nonEmptyLeaves(t1),
				nonEmptyLeaves(t2)
			)
		)

		\heuristics(simplify_enlarging)
	};

	handleMerge1{
		\schemaVar \term SetGraph graph;
		\schemaVar \term SetList ls, lt;

		\find( mergeGraphInternal1(graph, ls, lt) )
		\replacewith(
			mergeGraphInternal2(
				graph,
				removeAllSets(ls, lt),
				removeAllSets(lt, ls)
			)
		)

		//only apply after nonEmptyLeaves is resolved
		\heuristics(userTaclets3) //TODO write proper heuristic
	};

	handleMerge2{
		\schemaVar \term SetGraph graph;
		\schemaVar \term SetList l1, l2;

		\find( mergeGraphInternal2(graph, l1, l2) )
		\replacewith( mergeGraphInternal3(mergeGraphInternal3(graph, l1, l2), l2, l1) )

		\heuristics(simplify)
	};


	makeListofIntersectionsEmpty{
		\schemaVar \term SetList l;
		\schemaVar \term Set s;


		\find( makeListOfIntersections(l, s, SetListEmpty) )
		\replacewith( l )
	};

	makeListofIntersectionsRec{
		\schemaVar \term SetList l, l2;
		\schemaVar \term Set s, t;


		\find( makeListOfIntersections(l, s, setList(t, l2)) )
		\replacewith( makeListOfIntersections(setList(SetIntersection(s, t), l), s, l2) )
	};

	handleMerge3Step{
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;
		\schemaVar \term SetList l1, l2;

		\find( mergeGraphInternal3(g, setList(s, l1), l2) )
		\replacewith(
			mergeGraphInternal3(
				addEdges(g, s, makeListOfIntersections(SetListEmpty, s, l2)),
				l1,
				l2
			) 
		)

		\heuristics(simplify_enlarging)
	};
	
	handleMerge3Terminate{
		\schemaVar \term SetGraph graph;
		\schemaVar \term SetGraphNodes l2;

		\find( mergeGraphInternal3(graph, SetListEmpty, l2) )
		\replacewith( graph )

		\heuristics(simplify)
	};
//*/
	// TODO change all rules below for structured graphs

	// rules to handle nonEmptyLeaves
/*
	handleNonEmptyLeaves{
		\schemaVar \term SetGraph g;
		\schemaVar \term Set s;

		\find( nonEmptyLeaves(g, s) )
		\replacewith( setListremoveDuplicates(nonEmptyLeavesInternal1(g, s)) )

		\heuristics(simplify)
	};



	handleNonEmptyLeaves1_Empty{
		\schemaVar \term Set set;

		\find( nonEmptyLeavesInternal1(SetGraphEmpty, set) )
		\replacewith( 
			SetListEmpty
		)
	};

	handleNonEmptyLeavesRec{
		\schemaVar \term Set from, to;
		\schemaVar \term SetGraphEdges edges, all;
		\schemaVar \term Set set;
		\schemaVar \term boolean foundBefore;

		\find( nonEmptyLeavesInternal1(addEdge(edges, edge(from, to)), set, foundBefore, all) )
		\replacewith( 
			\if(set = from)
			\then(
				addAllNodes(
					nonEmptyLeavesInternal1(all, to, FALSE, all), 
					nonEmptyLeavesInternal1(edges, set, TRUE, all)
				) 
			)
			\else(
				nonEmptyLeavesInternal1(edges, set, foundBefore, all)
			)
		)
		
		\heuristics(simplify_enlarging)
	};


	handleNonEmptyLeavesBaseEmpty{
		\schemaVar \term SetGraphEdges edges, all;
		\schemaVar \term boolean foundBefore;

		\find( nonEmptyLeavesInternal1(edges, SetEmpty, foundBefore, all) )
		\replacewith( 
			SetGraphNodesEmpty
		)

		\heuristics(simplify)
	};

	handleNonEmptyLeavesBaseFalse{
		\schemaVar \term SetGraphEdges all;
		\schemaVar \term Set set;

		\find( nonEmptyLeavesInternal1(SetGraphEdgesEmpty, set, FALSE, all) )
		\replacewith( 
			\if(set = SetEmpty)
			\then(SetGraphNodesEmpty)
			\else(
				addNode(
					SetGraphNodesEmpty, 
					set
				) 
			)
		)

		\heuristics(simplify)
	};

	handleNonEmptyLeavesBaseTrue{
		\schemaVar \term SetGraphEdges all;
		\schemaVar \term Set set;

		\find( nonEmptyLeavesInternal1(SetGraphEdgesEmpty, set, TRUE, all) )
		\replacewith(
			SetGraphNodesEmpty
		)

		\heuristics(simplify)
	};

//*/

	//--- SET ---
	
	finite_terms{
		\schemaVar \variable Set set;
		\schemaVar \variable Set a;
		\schemaVar \variable Set b;
		\schemaVar \variable any el;
		
		\add(
			\forall set;
				(
					finite(set) <->
					(
						set = SetEmpty |
						(\exists el; set = single(el)) |
						(\exists a; \exists b; 
							(
								(finite(a) & finite(b) & set = SetUnion(a, b)) |
								((finite(a) | finite(b)) & set = SetIntersection(a, b)) |
								(finite(a) & set = SetDifference(a, b))
							)
						)
					)
				)		
		==> )
	};
	
	
	SetInduction{
		\schemaVar \variable any e;
		\schemaVar \variable Set s, s1, s2;
		\schemaVar \formula ih;
		
		
		\varcond (\notFreeIn(e, ih), \notFreeIn(s1, ih), \notFreeIn(s2, ih))
		"baseCase: Empty": \add (==> {\subst s ; SetEmpty} ih);
		"baseCase: Single": \add (==> \forall e; {\subst s ; single(e)} ih);
		"Ind. Step": \add (==> \forall s1; \forall s2; ({\subst s; s1} ih & {\subst s; s2} ih -> {\subst s; SetUnion(s1, s2)} ih));
		"Use proven theorem": \add (\forall s1; {\subst s; s1} ih ==>)
	};
	
	empty{
		\schemaVar \variable any el;
		\add(!\exists el; element(el, SetEmpty) ==> )
	};

	cardin_not_negative{//maybe has to be restricted to finite
		\schemaVar \variable Set set;
		
		\add(\forall set; cardinality(set) >= 0 ==>)
	};
	
	cardin_finite{ // n has to be restricted to constants
		\schemaVar \variable Set set;
		\schemaVar \variable int n;
		
		
		\add (\forall set; (finite(set) <-> \exists n; cardinality(set) = n) ==>)
	};

	cardin_of_empty{
		\schemaVar \variable Set set;
		
		\add(\forall set; (cardinality(set) = 0 <-> set = SetEmpty) ==>)
	};

	cardin_of_single{
		\schemaVar \variable Set set;
		\schemaVar \variable any el;
		
		\add (\forall set; (cardinality(set) = 1 <-> \exists el; set = single(el)) ==>)
	};

/*
	cardin_step{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any el;
		\schemaVar \variable int n;
		
		\add (\forall set; \forall n; \forall el; \exists set1; (! element(el, set1) -> (set = SetUnion(set1, single(el)) & (cardinality(set1) = n <-> cardinality(SetUnion(set1, single(el))) = n + 1))) ==>)
	};
*/	

	
	build_of_union{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any el;
		
		\add (\forall set; (set = SetEmpty | \exists set1; \exists el; set = SetUnion(single(el), set1)) ==>)
	};
	
	cardin_union_axiom{
		\schemaVar \variable Set set, set1;
	
		\add(\forall set; \forall set1; cardinality(SetUnion(set, set1)) = cardinality(set) + cardinality(set1) - cardinality(SetIntersection(set, set1)) ==> )
	};
	
	
	
	

	element_of_single{
		\schemaVar \term any el;
		\schemaVar \term any el2;

		\find (element(el, single(el2)))
		\replacewith (el = el2)
		\heuristics (simplify)
	};

	union{
		\schemaVar \term Set set;
		\schemaVar \term Set set1;
		\schemaVar \term any e;

        \find (element(e, SetUnion(set, set1))) 
        \replacewith ((element(e, set) | element(e, set1)))
        \heuristics(simplify_enlarging)
    };


	intersect{
		\schemaVar \term Set set, set1;
		\schemaVar \term any e;

        \find (element(e, SetIntersection(set, set1)))
	    \replacewith (element(e, set) & element(e, set1))
        \heuristics(simplify_enlarging)
	};


	difference{
		\schemaVar \term Set set, set1;
		\schemaVar \term any e;

		\find (element(e, SetDifference(set, set1)))
		\replacewith (element(e, set) & ! element(e, set1))
        \heuristics(simplify_enlarging)
	};

	setEquality{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any el;

		\add (\forall set; \forall set1; (set = set1 <-> \forall el; (element(el, set) <-> element(el, set1))) ==>)
	};

	setCombinations{
		\schemaVar \variable Set set, set1;

		\add (\forall set; \forall set1;
								(set = SetUnion(SetDifference(set, set1), SetIntersection(set, set1)) & 
								SetUnion(set, set1) = SetUnion(SetUnion(SetDifference(set, set1), SetIntersection(set, set1)), SetDifference(set1, set)))
			 ==>)
	};



/*
	complement{
		\schemaVar \term Set set;
		\schemaVar \term any e;

		\find (element(e, compl(set)))
		\replacewith (!element(e, set))
	};
*/

	subset{
		\schemaVar \term Set set, set1;
		\schemaVar \variable any el;

		\find (is_subset(set, set1))
		\varcond (\notFreeIn(el,set), \notFreeIn(el,set1))
		\replacewith (\forall el; (element(el, set) -> element(el, set1)))
	};

	subset_empty{
		\schemaVar \variable Set set;

		\add(\forall set; (is_subset(set, SetEmpty) -> set = SetEmpty) ==> )
	};


}


	// lemmas
\rules{	


	cardin_subset{// TODO make a lemma
		\schemaVar \variable Set set, set1;
		
		\add(\forall set; \forall set1; (is_subset(set, set1) -> cardinality(set) <= cardinality(set1)) ==> )	
	};

	\lemma
	cardin_empty{
		\find (cardinality(SetEmpty))
		\replacewith(0)
		\heuristics(concrete)
	};
	
	\lemma
	cardin_single{
		\schemaVar \term any el;

		\find (cardinality(single(el)))
		\replacewith (1)
		\heuristics(concrete)
	};
	
	\lemma
	set_equal{
		\schemaVar \term Set set, set1;
		\schemaVar \variable any el;
		
		\find (set = set1)
		\varcond (\notFreeIn(el,set), \notFreeIn(el,set1))
		\replacewith (\forall el; (element(el, set) <-> element(el, set1)))
		//should be done when neither set nor set1 is a variable symbol.
		
	};
	
	//TODO make a lemma //simplification
	subset_to_intersect{
		\schemaVar \term Set set, set1;
		
		\find (is_subset(set, set1))
		\replacewith (set = SetIntersection(set, set1))
		
		\heuristics(simplify)
	};
	
	
	//TODO make a lemma //simplification
	element_to_subset{
		\schemaVar \term Set set;
		\schemaVar \term any x;
		
		\find (element(x, set))
		\replacewith (is_subset(single(x), set))
		
		//\heuristics(simplify) //probably not beneficial
	};
	
	
	\lemma
	cardin_disjunctive_union{
		\schemaVar \variable Set set, set1;
	
		\add(\forall set; \forall set1;
									(SetIntersection(set, set1) = SetEmpty 
									->
									 cardinality(SetUnion(set, set1)) = cardinality(set) + cardinality(set1)) ==> )
	};

	\lemma
	union_of_empty{
		\schemaVar \term Set set;
		
		\find (SetUnion(set, SetEmpty))
		\replacewith (set)
		
		\heuristics (simplify)
	};
	
	\lemma
	union_of_empty2{
		\schemaVar \term Set set;
		
		\find (SetUnion(SetEmpty, set))
		\replacewith (set)
		
		\heuristics (simplify)
	};
	
	\lemma
	intersect_of_empty{
		\schemaVar \term Set set;
		
		\find (SetIntersection(set, SetEmpty))
		\replacewith (SetEmpty)
		
		\heuristics (concrete)
	};
	
	\lemma
	intersect_of_empty2{
		\schemaVar \term Set set;
		
		\find (SetIntersection(SetEmpty, set))
		\replacewith (SetEmpty)
		
		\heuristics (concrete)
	};

	\lemma //for normalform
	union_commutative{
		\schemaVar \term Set commEqLeft, commEqRight;

		\find (SetUnion(commEqLeft, commEqRight))
		\replacewith(SetUnion(commEqRight, commEqLeft))
		\heuristics(order_terms)
	};

	\lemma //for normalform
	intersect_commutative{
		\schemaVar \term Set commEqLeft, commEqRight;

		\find (SetIntersection(commEqLeft, commEqRight))
		\replacewith(SetIntersection(commEqRight, commEqLeft))
		\heuristics(order_terms)
	};
	
	\lemma //for normalform
	union_commutative2{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetUnion(SetUnion(set, set1), set2))
		\replacewith (SetUnion(SetUnion(set, set2), set1))
	};
	
	\lemma //for normalform
	intersect_commutative2{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetIntersection(SetIntersection(set, set1), set2))
		\replacewith (SetIntersection(SetIntersection(set, set2), set1))
	};
	
	\lemma //for normalform
	union_assoc{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetUnion(set, SetUnion(set1, set2)))
		\replacewith (SetUnion(SetUnion(set, set1), set2))
		
		\heuristics (setUnionAssoc)
	};
	
	\lemma //for normalform
	union_assoc2{
		\schemaVar \term Set set, set1, set2, set3;
		
		\find (SetUnion(SetUnion(set, set1), SetUnion(set2, set3)))
		\replacewith (SetUnion(SetUnion(SetUnion(set, set1), set2), set3))
	};
	
	\lemma //for normalform
	intersect_assoc{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetIntersection(set, SetIntersection(set1, set2)))
		\replacewith (SetIntersection(SetIntersection(set, set1), set2))
	};
	
	\lemma //for normalform
	intersect_assoc2{
		\schemaVar \term Set set, set1, set2, set3;
		
		\find (SetIntersection(SetIntersection(set, set1), SetIntersection(set2, set3)))
		\replacewith (SetIntersection(SetIntersection(SetIntersection(set, set1), set2), set3))
	};
	
	\lemma //for normalform
	union_distrib{//preferred
		\schemaVar \term Set set, set1, set2;
		
		\find (SetUnion(set, SetIntersection(set1, set2)))
		\replacewith (SetIntersection(SetUnion(set, set1), SetUnion(set,set2)))
	};
	
	\lemma //not used
	intersect_distrib{ //should not be automatic
		\schemaVar \term Set set, set1, set2;
		
		\find (SetIntersection(set, SetUnion(set1, set2)))
		\replacewith (SetUnion(SetIntersection(set, set1), SetIntersection(set,set2)))
	};

	\lemma //simplification
	element_of_empty{
		\schemaVar \term any e;

		\find (element(e, SetEmpty))
		\replacewith (false)
		\heuristics(concrete)
	};

	\lemma //needed?
	empty_right{
		\schemaVar \term Set set;
		\schemaVar \variable any el;


		\find( ==> set = SetEmpty)
		\varcond(\notFreeIn(el, set))
		\add(\exists el; element(el, set) ==> )

	};

	\lemma //needed?
	empty_left{
		\schemaVar \term Set set;
		\schemaVar \variable any el;


		\find(set = SetEmpty ==> )
		\varcond(\notFreeIn(el, set))
		\add( ==> \exists el; element(el, set))

	};

	\lemma //simplification
	union_simplify{
		\schemaVar \term Set set, set1;
		\schemaVar \term any el;

		\assumes (==> element(el, set1))
		\find (element(el, SetUnion(set, set1)))
		\sameUpdateLevel
		\replacewith (element(el, set))
		\heuristics(simplify)
	};

	\lemma //simplification
	intersect_simplify{
		\schemaVar \term Set set, set1;
		\schemaVar \term any el;

		\assumes (element(el, set1) ==>)
		\find (element(el, SetIntersection(set, set1)))
		\sameUpdateLevel
		\replacewith (element(el, set))
		\heuristics(simplify)
	};

	\lemma //simplification
	intersect_disjunctive1{
		\schemaVar \term Set set, set1;

		\find (SetIntersection(SetDifference(set, set1), SetIntersection(set, set1)))
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_disjunctive2{
		\schemaVar \term Set set, set1;

		\find (SetIntersection(SetDifference(set, set1), SetDifference(set1, set)))
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_disjunctive3{
		\schemaVar \term Set set, set1;

		\find (SetIntersection(SetDifference(set, set1), set1))
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //not strong enough in general
	cardin_union{
		\schemaVar \term Set set, set1;

		\find(cardinality(SetUnion(set, set1)))
		\sameUpdateLevel
		\add(cardinality(SetUnion(set, set1)) <= cardinality(set) + cardinality(set1) ==> )
		\heuristics(userTaclets1)
	};

	\lemma //not strong enough in general
	cardin_intersect{
		\schemaVar \term Set set, set1;

		\find(cardinality(SetIntersection(set, set1)))
		\sameUpdateLevel
		\add(cardinality(SetIntersection(set, set1)) <= cardinality(set) , cardinality(SetIntersection(set, set1)) <= cardinality(set1) ==> )
		\heuristics(userTaclets1)
		
	};

	\lemma //not strong enough in general
	cardin_difference{
		\schemaVar \term Set set, set1;

		\find (cardinality(SetDifference(set, set1)))
		\sameUpdateLevel
		\add (cardinality(SetDifference(set, set1)) <= cardinality(set) ==> )
		\heuristics(userTaclets1)
	};
	
	\lemma //simplification
	cardin0{
		\schemaVar \term Set set;
		
		\find (cardinality(set) = 0 ==>)
		\add (set = SetEmpty ==>)
		\heuristics (simplify) //?
	};
	
	\lemma //simplification
	cardin1{
		\schemaVar \term Set set;
		\schemaVar \variable any x;
		
		\find (cardinality(set) = 1 ==>)
		\varcond(\notFreeIn(x, set))
		\add (\exists x; (set = single(x)) ==>)
		\heuristics (simplify_enlarging)
	};
	
	//probably not necessary
	equalSetsRight{
		\schemaVar \term Set set, set1;
		\schemaVar \skolemTerm any el;
		
		\find (==> set = set1)
		\varcond (\new(el, \dependingOn(set))) // ? not supported ?
		\replacewith (==> element(el, set) & element(el, set1), !element(el, set) & !element(el, set1))
		\heuristics (userTaclets2)
	};
	
}