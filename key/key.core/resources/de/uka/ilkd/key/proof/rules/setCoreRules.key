\sorts {
	//TODO make not subtype of any
	Set;
}

\predicates {
   element(any, Set);
   is_subset(Set, Set);
   is_disjoint(Set, Set);
}

\functions {

	// empty Set
	\unique Set SetEmpty;
	
	// Singleton Set
	\unique Set single(any);

	// union of two Sets
	Set SetUnion(Set, Set);

	// intersection of two Sets
	Set SetIntersection(Set, Set);

	// difference of two Sets
	Set SetDifference(Set, Set);

	// complement of a Set
	//Set compl(Set);

	// cardinality
	int cardinality(Set);

}



\axioms {
	// axioms
	
	SetInduction{
		\schemaVar \variable any e;
		\schemaVar \variable Set s;
		\schemaVar \formula ih;
		
		
		\varcond (\notFreeIn(e, ih))

		"baseCase: Empty": \add (==> {\subst s; SetEmpty} ih);

		//Not necessary
		//"baseCase: Single": \add (==> \forall e; {\subst s; single(e)} ih); 


		"Ind. Step": \add ( ==> 
								\forall s; (
									ih 
									-> 
									\forall e; {\subst s; SetUnion(s, single(e))} ih
								)
						);

		"Use proven theorem": \add ( \forall s; ih ==> )
	};
	
	empty{
		\schemaVar \variable any el;
		\schemaVar \variable Set set;

		\add(\forall set; (set = SetEmpty <-> !\exists el; element(el, set)) ==> )
	};

	cardin_not_negative{//maybe has to be restricted to finite
		\schemaVar \variable Set set;
		
		\add(\forall set; cardinality(set) >= 0 ==>)
	};
	

	cardin_of_empty{
		\schemaVar \variable Set set;
		
		\add(\forall set; (cardinality(set) = 0 <-> set = SetEmpty) ==>)
	};

	cardin_of_single{
		\schemaVar \variable Set set;
		\schemaVar \variable any el;
		
		\add (\forall set; (cardinality(set) = 1 <-> \exists el; set = single(el)) ==>)
	};

/*
	cardin_step{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any el;
		\schemaVar \variable int n;
		
		\add (
			\forall set; \forall n; \forall el;
				set = SetEmpty | 
				\exists set1; (! element(el, set1) -> (set = SetUnion(set1, single(el)) & (cardinality(set1) = n <-> cardinality(SetUnion(set1, single(el))) = n + 1))) 
		==>)
	};
*/	

	
	build_of_union{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any el;
		
		\add (\forall set; (set = SetEmpty | \exists set1; \exists el; (!element(el, set1) & set = SetUnion(single(el), set1))) ==>)
	};
	
	cardin_union_axiom{
		\schemaVar \variable Set set, set1;
	
		\add(\forall set; \forall set1; cardinality(SetUnion(set, set1)) = cardinality(set) + cardinality(set1) - cardinality(SetIntersection(set, set1)) ==> )
	};
	
	
	singleDef{
		\schemaVar \variable any el, el1;

		\add (\forall el; \forall el1; (el = el1 <-> element(el, single(el1))) ==>)
	};
	

	unionDef{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any e;

		\add( 
			\forall e; \forall set; \forall set1;(
					element(e, SetUnion(set, set1))
				<->
					(element(e, set) | element(e, set1))
			)
		==> )
	};

	
	intersectDef{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any e;

		\add( 
			\forall e; \forall set; \forall set1;(
					element(e, SetIntersection(set, set1))
				<->
					(element(e, set) & element(e, set1))
			)
		==> )
	};


	differenceDef{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any e;

		\add( 
			\forall e; \forall set; \forall set1;(
					element(e, SetDifference(set, set1))
				<->
					(element(e, set) & ! element(e, set1))
			)
		==> )
	};


	setEquality{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any el;

		\add (\forall set; \forall set1; (set = set1 <-> \forall el; (element(el, set) <-> element(el, set1))) ==>)
	};


	//subset

	subsetDef{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any el;

		\add(
			\forall set; \forall set1; (
				is_subset(set, set1)
				<->
				\forall el; (element(el, set) -> element(el, set1))
			)
		==> )
	};
	
	


	//disjoint

	is_disjoint{
		\schemaVar \variable Set set, set1;
		\schemaVar \variable any el;

		\add( 
			\forall set; \forall set1; 
				(is_disjoint(set, set1) 
				<->
				!\exists el; (element(el, set) & element(el, set1)))
		==> )
	};

}

	// lemmas
\rules{

	\lemma
	element_of_single{
		\schemaVar \term any el;
		\schemaVar \term any el2;

		\find (element(el, single(el2)))
		\replacewith (el = el2)
		\heuristics (simplify)
	};

	\lemma
	union{
		\schemaVar \term Set set;
		\schemaVar \term Set set1;
		\schemaVar \term any e;

        \find (element(e, SetUnion(set, set1))) 
        \replacewith ((element(e, set) | element(e, set1)))
        \heuristics(simplify_enlarging)
    };

    \lemma
    intersect{
		\schemaVar \term Set set, set1;
		\schemaVar \term any e;

        \find (element(e, SetIntersection(set, set1)))
	    \replacewith (element(e, set) & element(e, set1))
        \heuristics(simplify_enlarging)
	};

	//cannot make \lemma, split rules not supported
	intersectSplit1{
		\schemaVar \term Set set, set1;
		\schemaVar \term any e;

		\assumes ( element(e, set) ==> )
        \find (SetIntersection(set, set1))
	    "element": \add( element(e, set1) ==> );
        "NOT element": \add( ==> element(e, set1) )

        //TODO heuristics: simple split, should be done if nothing else can be done
	};

	//cannot make \lemma, split rules not supported
	intersectSplit2{
		\schemaVar \term Set set, set1;
		\schemaVar \term any e;

		\assumes ( element(e, set1) ==> )
        \find (SetIntersection(set, set1))
	    "element": \add( element(e, set) ==> );
        "NOT element": \add( ==> element(e, set) )

        //TODO heuristics: simple split, should be done if nothing else can be done
	};

	\lemma
	difference{
		\schemaVar \term Set set, set1;
		\schemaVar \term any e;

		\find (element(e, SetDifference(set, set1)))
		\replacewith (element(e, set) & ! element(e, set1))
        \heuristics(simplify_enlarging)
	};

	\lemma
	cardin_empty{
		\find (cardinality(SetEmpty))
		\replacewith(0)
		\heuristics(concrete)
	};
	
	\lemma
	cardin_single{
		\schemaVar \term any el;

		\find (cardinality(single(el)))
		\replacewith (1)
		\heuristics(concrete)
	};
	
	\lemma
	set_equal{
		\schemaVar \term Set set, set1;
		\schemaVar \variable any el;
		
		\find (set = set1)
		\varcond (\notFreeIn(el,set), \notFreeIn(el,set1))
		\replacewith (\forall el; (element(el, set) <-> element(el, set1)))

		//should be done when neither set nor set1 is a variable symbol.
		
	};

	\lemma //necessary? no, will be translated into intersection
	subset{
		\schemaVar \term Set set, set1;
		\schemaVar \variable any el;

		\find (is_subset(set, set1))
		\varcond (\notFreeIn(el,set), \notFreeIn(el,set1))
		\replacewith (\forall el; (element(el, set) -> element(el, set1)))

		
	};

	\lemma //simplification
	subset_empty{
		\schemaVar \term Set set;

		\find( is_subset(set, SetEmpty) )
		\replacewith( set = SetEmpty )

		\heuristics(concrete)
	};
	
	\lemma //simplification
	subset_to_intersect{
		\schemaVar \term Set set, set1;
		
		\find (is_subset(set, set1))
		\replacewith (set = SetIntersection(set, set1))
		
		\heuristics(simplify_enlarging)
	};
	
	
	\lemma
	element_to_subset{
		\schemaVar \term Set set;
		\schemaVar \term any x;
		
		\find (element(x, set))
		\replacewith (is_subset(single(x), set))
		
		//\heuristics(simplify) //probably not beneficial according to Bansal et al.
	};
	

	\lemma //simplification
	union_of_empty{
		\schemaVar \term Set set;
		
		\find (SetUnion(set, SetEmpty))
		\replacewith (set)
		
		\heuristics (simplify)
	};
	
	\lemma //simplification
	union_of_empty2{
		\schemaVar \term Set set;
		
		\find (SetUnion(SetEmpty, set))
		\replacewith (set)
		
		\heuristics (simplify)
	};
	
	\lemma //simplification
	intersect_of_empty{
		\schemaVar \term Set set;
		
		\find (SetIntersection(set, SetEmpty))
		\replacewith (SetEmpty)
		
		\heuristics (concrete)
	};
	
	\lemma //simplification
	intersect_of_empty2{
		\schemaVar \term Set set;
		
		\find (SetIntersection(SetEmpty, set))
		\replacewith (SetEmpty)
		
		\heuristics (concrete)
	};

	//Commutativity, Associativity and Distributativity for union, intersect and disjoint
	//TODO order_terms does not quite bring it into the intended order

	\lemma //for normalform
	union_commutative{
		\schemaVar \term Set commEqLeft, commEqRight;

		\find (SetUnion(commEqRight, commEqLeft))
		\replacewith(SetUnion(commEqLeft, commEqRight))
		\heuristics(order_terms)
	};

	\lemma //for normalform
	intersect_commutative{
		\schemaVar \term Set commEqLeft, commEqRight;

		\find (SetIntersection(commEqRight, commEqLeft))
		\replacewith(SetIntersection(commEqLeft, commEqRight))
		\heuristics(order_terms)
	};

	\lemma //for normalform
	disjoint_commutative{
		\schemaVar \term Set commEqLeft, commEqRight;

		\find (is_disjoint(commEqRight, commEqLeft))
		\replacewith(is_disjoint(commEqLeft, commEqRight))
		\heuristics(order_terms)
	};
	
	\lemma //for normalform
	union_commutative2{
		\schemaVar \term Set set, commEqLeft, commEqRight;
		
		\find (SetUnion(SetUnion(set, commEqRight), commEqLeft))
		\replacewith (SetUnion(SetUnion(set, commEqLeft), commEqRight))
		\heuristics(order_terms)
	};
	
	\lemma //for normalform
	intersect_commutative2{
		\schemaVar \term Set set, commEqLeft, commEqRight;
		
		\find (SetIntersection(SetIntersection(set, commEqRight), commEqLeft))
		\replacewith (SetIntersection(SetIntersection(set, commEqLeft), commEqRight))
		\heuristics(order_terms)
	};


	\lemma //for normalform
	difference_commutative{
		\schemaVar \term Set set, commEqLeft, commEqRight;
		
		\find (SetDifference(SetDifference(set, commEqRight), commEqLeft))
		\replacewith (SetDifference(SetDifference(set, commEqLeft), commEqRight))
		\heuristics(order_terms)
	};
	
	\lemma //for normalform
	union_assoc{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetUnion(set, SetUnion(set1, set2)))
		\replacewith (SetUnion(SetUnion(set, set1), set2))
		
		\heuristics (simplify)
	};
	
	\lemma //for normalform, actually covered by rule above
	union_assoc2{
		\schemaVar \term Set set, set1, set2, set3;
		
		\find (SetUnion(SetUnion(set, set1), SetUnion(set2, set3)))
		\replacewith (SetUnion(SetUnion(SetUnion(set, set1), set2), set3))

		\heuristics(simplify)
	};
	
	\lemma //for normalform
	intersect_assoc{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetIntersection(set, SetIntersection(set1, set2)))
		\replacewith (SetIntersection(SetIntersection(set, set1), set2))

		\heuristics(simplify)
	};
	
	\lemma //for normalform, actually covered by rule above
	intersect_assoc2{
		\schemaVar \term Set set, set1, set2, set3;
		
		\find (SetIntersection(SetIntersection(set, set1), SetIntersection(set2, set3)))
		\replacewith (SetIntersection(SetIntersection(SetIntersection(set, set1), set2), set3))

		\heuristics(simplify)
	};
	
	\lemma //not used automatically
	union_distrib{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetUnion(set, SetIntersection(set1, set2)))
		\replacewith (SetIntersection(SetUnion(set, set1), SetUnion(set,set2)))
	};

	\lemma //for normalform
	distribDiffOverDiff{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetDifference(set, SetDifference(set1, set2)))
		\replacewith (SetUnion(SetDifference(set, set1), SetIntersection(set, set2)))

		\heuristics(simplify_enlarging)
	};

	\lemma //for normalform
	distribDiffOverIntersLeft{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetDifference(SetIntersection(set, set1), set2))
		\replacewith (SetIntersection(SetDifference(set, set2), SetDifference(set1, set2)))

		\heuristics(simplify_enlarging)
	};

	\lemma //for normalform
	distribDiffOverIntersRight{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetDifference(set, SetIntersection(set1, set2)))
		\replacewith (SetUnion(SetDifference(set, set1), SetDifference(set, set2)))

		\heuristics(simplify_enlarging)
	};
	
	\lemma //for normalform
	distribDiffOverUnionLeft{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetDifference(SetUnion(set, set1), set2))
		\replacewith (SetUnion(SetDifference(set, set2), SetDifference(set1, set2)))

		\heuristics(simplify_enlarging)
	};

	\lemma //for normalform
	distribDiffOverUnionRight{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetDifference(set, SetUnion(set1, set2)))
		\replacewith (SetDifference(SetDifference(set, set1), set2))

		\heuristics(simplify)
	};


	\lemma //for normalform
	distribIntersOverUnionLeft{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetIntersection(SetUnion(set, set1), set2))
		\replacewith (SetUnion(SetIntersection(set, set2), SetIntersection(set1, set2)))

		\heuristics(simplify_enlarging)
	};

	\lemma //for normalform
	distribIntersOverUnionRight{
		\schemaVar \term Set set, set1, set2;
		
		\find (SetIntersection(set, SetUnion(set1, set2)))
		\replacewith (SetUnion(SetIntersection(set, set1), SetIntersection(set,set2)))

		\heuristics(simplify_enlarging)
	};


	//Simplification

	\lemma //simplification
	element_of_empty{
		\schemaVar \term any e;

		\find (element(e, SetEmpty))
		\replacewith (false)
		\heuristics(concrete)
	};

	\lemma
	empty_right{
		\schemaVar \term Set set;
		\schemaVar \variable any el;


		\find( ==> set = SetEmpty)
		\varcond(\notFreeIn(el, set))
		\add(\exists el; element(el, set) ==> )

		\heuristics(simplify_enlarging) //?
	};

	

	\lemma //simplification
	union_simplify{
		\schemaVar \term Set set, set1;
		\schemaVar \term any el;

		\assumes (==> element(el, set1))
		\find (element(el, SetUnion(set, set1)))
		\sameUpdateLevel
		\replacewith (element(el, set))
		\heuristics(simplify)
	};

	\lemma //simplification
	intersect_simplify{
		\schemaVar \term Set set, set1;
		\schemaVar \term any el;

		\assumes (element(el, set1) ==>)
		\find (element(el, SetIntersection(set, set1)))
		\sameUpdateLevel
		\replacewith (element(el, set))
		\heuristics(simplify)
	};

	\lemma //simplification
	intersection_disjoint{
		\schemaVar \term Set set, set1;


		\assumes ( is_disjoint(set, set1) ==> )
		\find ( SetIntersection(set, set1) )
		\sameUpdateLevel
		\replacewith( SetEmpty )

		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_disjoint1{
		\schemaVar \term Set set, set1;

		\find (SetIntersection(SetDifference(set, set1), SetIntersection(set, set1)))
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_disjoint2{
		\schemaVar \term Set set, set1;

		\find (SetIntersection(SetDifference(set, set1), SetDifference(set1, set)))
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_disjoint3{
		\schemaVar \term Set set, set1;

		\find (SetIntersection(SetDifference(set, set1), set1))
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};


	\lemma //simplification
	intersect_disjointSingle1{
		\schemaVar \term Set set;
		\schemaVar \term any e;

		\assumes( ==> element(e, set))
		\find (SetIntersection(single(e), set))
		\sameUpdateLevel
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_disjointSingle2{
		\schemaVar \term Set set;
		\schemaVar \term any e;

		\assumes( ==> element(e, set))
		\find (SetIntersection(set, single(e)))
		\sameUpdateLevel
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_disjointSingles1{
		\schemaVar \term any e, e1;

		\assumes( ==> e = e1)
		\find (SetIntersection(single(e), single(e1)))
		\sameUpdateLevel
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_disjointSingles2{
		\schemaVar \term any e, e1;

		\assumes( ==> e = e1)
		\find (SetIntersection(single(e1), single(e)))
		\sameUpdateLevel
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_simplifySingle1{
		\schemaVar \term Set set;
		\schemaVar \term any e;

		\assumes( element(e, set) ==> )
		\find (SetIntersection(single(e), set))
		\sameUpdateLevel
		\replacewith (single(e))
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_simplifySingle2{
		\schemaVar \term Set set;
		\schemaVar \term any e;

		\assumes( element(e, set) ==> )
		\find (SetIntersection(set, single(e)))
		\sameUpdateLevel
		\replacewith (single(e))
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_simplifySingles1{
		\schemaVar \term any e, e1;

		\assumes( e = e1 ==> )
		\find (SetIntersection(single(e), single(e1)))
		\sameUpdateLevel
		\replacewith (single(e))
		\heuristics(concrete)
	};

	\lemma //simplification
	intersect_simplifySingles2{
		\schemaVar \term any e, e1;

		\assumes( e = e1 ==> )
		\find (SetIntersection(single(e1), single(e)))
		\sameUpdateLevel
		\replacewith (single(e))
		\heuristics(concrete)
	};

	\lemma //simplification
	difference_simplifySingle1{
		\schemaVar \term any e;
		\schemaVar \term Set set;

		\assumes( element(e, set) ==> )
		\find (SetDifference(single(e), set))
		\sameUpdateLevel
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	difference_simplifySingle2{
		\schemaVar \term any e;
		\schemaVar \term Set set;

		\assumes( ==> element(e, set) )
		\find (SetDifference(single(e), set))
		\sameUpdateLevel
		\replacewith (single(e))
		\heuristics(concrete)
	};

	\lemma //simplification
	difference_simplifySingles1{
		\schemaVar \term any e, e1;

		\assumes( e = e1 ==> )
		\find (SetDifference(single(e), single(e1)))
		\sameUpdateLevel
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	difference_simplifySingles2{
		\schemaVar \term any e, e1;

		\assumes( e1 = e ==> )
		\find (SetDifference(single(e), single(e1)))
		\sameUpdateLevel
		\replacewith (SetEmpty)
		\heuristics(concrete)
	};

	\lemma //simplification
	difference_simplifySingles3{
		\schemaVar \term any e, e1;

		\assumes( ==> e = e1 )
		\find (SetDifference(single(e), single(e1)))
		\sameUpdateLevel
		\replacewith (single(e))
		\heuristics(concrete)
	};

	\lemma //simplification
	difference_simplifySingles4{
		\schemaVar \term any e, e1;

		\assumes( ==> e1 = e )
		\find (SetDifference(single(e), single(e1)))
		\sameUpdateLevel
		\replacewith (single(e))
		\heuristics(concrete)
	};

	//Cardinality

	\lemma
	cardin_union{
		\schemaVar \term Set set, set1;

		\find(cardinality(SetUnion(set, set1)))
		\replacewith(
			cardinality(set) + cardinality(set1) - cardinality(SetIntersection(set, set1))
		)
		\heuristics(simplify_enlarging)
	};

	
	\lemma //simplification
	cardin0{
		\schemaVar \term Set set;
		
		\find (cardinality(set) = 0 )
		\replacewith (set = SetEmpty )
		\heuristics (concrete)
	};
	
	\lemma //simplification
	cardin1{
		\schemaVar \term Set set;
		\schemaVar \variable any x;
		
		\find (cardinality(set) = 1 ==>)
		\varcond(\notFreeIn(x, set))
		\replacewith (\exists x; (set = single(x)) ==>)
		\heuristics (simplify_enlarging)
	};
	
	\lemma
	cardinGeq0{
		\schemaVar \term Set set;

		\find( cardinality(set) )
		\sameUpdateLevel
		\add( cardinality(set) >= 0 ==> )

		// When cardinalities add up to negative value
	};


	\lemma
	cardin_intersectSingle1{
		\schemaVar \term any el;
		\schemaVar \term Set set;

		\find(cardinality(SetIntersection(single(el), set)))
		\replacewith(
			\if(element(el, set))
			\then(1)
			\else(0)
		)

		\heuristics(simplify_enlarging)
	};

	\lemma
	cardin_intersectSingle2{
		\schemaVar \term any el;
		\schemaVar \term Set set;

		\find(cardinality(SetIntersection(set, single(el))))
		\replacewith(
			\if(element(el, set))
			\then(1)
			\else(0)
		)

		\heuristics(simplify_enlarging)
	};

	\lemma
	cardin_differenceSingle{
		\schemaVar \term any el;
		\schemaVar \term Set set;

		\find(cardinality(SetDifference(single(el), set)))
		\replacewith(
			\if(element(el, set))
			\then(0)
			\else(1)
		)

		\heuristics(simplify_enlarging)
	};

	\lemma
	equalSetsRight{
		\schemaVar \term Set set, set1;
		\schemaVar \variable any el;
		
		\find (==> set = set1)
		\varcond (\notFreeIn(el, set), \notFreeIn(el, set1))
		\replacewith ( ==> 
			\forall el; (element(el, set) <-> element(el, set1))
		)

		\heuristics (simplify_enlarging)
	};
	

	\lemma
	introduceVennPropertiesDiff{
		\schemaVar \term Set set, set1;

		\find( cardinality(SetDifference(set, set1)) )
		\sameUpdateLevel
		\add( 
			cardinality(set) = 
				cardinality(SetDifference(set, set1)) + 
				cardinality(SetIntersection(set, set1)) &
			cardinality(SetUnion(set, set1)) =
				cardinality(SetDifference(set, set1)) + 
				cardinality(SetIntersection(set, set1)) +
				cardinality(SetDifference(set1, set)) &
			cardinality(set1) = 
				cardinality(SetDifference(set1, set)) + 
				cardinality(SetIntersection(set, set1))
		==> )


		\heuristics(userTaclets1)
		//TODO heuristics: after everything else (because it blows the sequent up)
	};

	\lemma
	introduceVennPropertiesInter{
		\schemaVar \term Set set, set1;

		\find( cardinality(SetIntersection(set, set1)) )
		\sameUpdateLevel
		\add( 
			cardinality(set) = 
				cardinality(SetDifference(set, set1)) + 
				cardinality(SetIntersection(set, set1)) &
			cardinality(SetUnion(set, set1)) =
				cardinality(SetDifference(set, set1)) + 
				cardinality(SetIntersection(set, set1)) +
				cardinality(SetDifference(set1, set)) &
			cardinality(set1) = 
				cardinality(SetDifference(set1, set)) + 
				cardinality(SetIntersection(set, set1))
		==> )

		\heuristics(userTaclets1)
		//TODO heuristics: after everything else (because it blows the sequent up)
	};


}