// rules c/p from javaRules.key

\sorts{
  \generic G;
  \generic H;
  \generic J \extends G;
  \generic GOS \extends Object;
  \generic alphaObj \extends Object;
  \generic betaObj \extends Object;
}

\schemaVariables {
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
 \modalOperator { diamond, diamond_transaction } #diamond;
 \modalOperator { box, box_transaction } #box;


 \formula post, inv, post1;
 \program Type #t, #t2 ;
 \program NonPrimitiveType #npit ;  

 \term G q ;
 \skolemTerm G sk ;

 \program ArrayLength #length ;
 
 \program MultipleVariableDeclaration #multvardecl ;
 \program ArrayPostDeclaration #arraypost ;
 \program SimpleExpression #se, #se0, #se1, #se2 ;
 \program SimpleExpression #src, #dest, #srcOff, #destOff, #arlength;

 \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2 ;
 \program LeftHandSide #attribute ;
 \program Variable #loc ;
 \program StaticVariable #sv, #sv0, #sv1 ;

 \program Variable #v, #v0, #v1, #v2, #boolv, #a, #a0, #a1 ;

 \program ConstantPrimitiveTypeVariable #cv ;   // variables that are compile-time constants
 \program Variable #b0, #ar1 ;
 \program VariableInitializer #vi ;
 \program SimpleExpression #seBool,#seBool0,#seBool1,#seBool2 ;
 \program JavaBooleanExpression #exBool,#exBool0,#exBool1,#exBool2 ;

 \program NonSimpleExpression #nseBool,#nseBool0,#nseBool1,#nseBool2 ;
 \program Statement #s, #s0, #s1 ;
 \program LoopInit #loopInit ;
 \program Guard #guard ;
 \program ForUpdates #forupdates ;
 \program ForLoop #forloop ;
 \program Expression #e, #e0, #e1, #e2 ;
 \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv ;

 \program[list] Statement #slist, #slist1, #slist2, #slist3 ;
 \program[list] Expression #elist ;
 \program[list] SimpleExpression #selist ;
 \program[list] Catch #cs ;

 \program Switch #sw ;
 \program Label #lb, #lb0, #lb1, #innerLabel, #outerLabel;
 \program NonSimpleMethodReference #nsmr;
 \program NonModelMethodBody #mb;
 \program MethodName #mn;

 \program ExecutionContext #ex, #ex1 ; 
 \program ProgramMethod #pm ; 

 \formula anon1, anon2, anon3;
 
 \formula for1,for2;
 
 \variables int iv, iv2, iv3 ;
 \term int idx;

 // generic sorts
 \term G variant ;
 \term GOS array;
 \term H obj ;

 \variables G x ;
 \term H then, else ;
 
 \term G updatedTerm1, updatedTerm2;

// for anonymization (maybe remove again later)
 \term LocSet l;
 \formula rely;
 \skolemTerm Heap anonHeap;
}

\programVariables {
  Seq heaps;
}

\rules(programRules:Java, concurrency:RG) {
  assignment_read_final_attribute_this {
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
	        \varcond(\final(#a), \not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		      \replacewith(==>
                          {#v0 := G::select(heap, #v, #memberPVToField(#a))}
                      \modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment_read_attribute"
  };
}

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_read_final_attribute {
		\find (\modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
	        \varcond(\final(#a), \not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({#v0 := G::select(heap, #v, #memberPVToField(#a))}
                         \modality{#allmodal}{.. ...}\endmodality(post))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment_read_attribute"
  };
}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_read_final_attribute {
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
	        \varcond(\final(#a), \not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> 
                         {#v0 := G::select(heap, #v, #memberPVToField(#a))}
                         \modality{#allmodal}{.. ...}\endmodality(post))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment_read_attribute"
  };
}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_read_final_attribute { 
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\final(#a), \not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		      \replacewith(==> 
                         {#v0 := G::select(heap, #v, #memberPVToField(#a))}
                         \modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		\displayname "assignment_read_attribute"
  };
}

// static read rules

\rules(programRules:Java, concurrency:RG) {
  assignment_read_static_final_attribute {
               \find (\modality{#allmodal}{.. #v0 = @(#sv); ...}\endmodality(post)) \sameUpdateLevel
               \varcond(\final(#sv), \hasSort(#sv, G))
               \replacewith({#v0 := G::select(heap, null, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
               \heuristics(simplify_prog, simplify_prog_subset)
  };

  // constant case cannot occur as no static initilisation handling happens
  assignment_read_static_final_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. #loc = @(#v.#sv); ...}\endmodality(post))
	\varcond(\final(#sv), \hasSort(#sv, G))
        \replacewith({#loc := G::select(heap,#v,#memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
	\heuristics(simplify_prog)
        \displayname "assignment"
  };
}

// more assignment rules

\rules(programRules:Java, concurrency:RG) {
	assignment_write_attribute_this {
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \isThisReference(#v))
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se)}{heaps:=seqConcat(heaps,seqSingleton(heap))}
                                   \modality{#allmodal}{.. ...}\endmodality(post))
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };
}

\rules(programRules:Java, runtimeExceptions:allow, concurrency:RG) {
  assignment_write_attribute {
		\find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post)) \sameUpdateLevel
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}{heaps:=seqConcat(heaps,seqSingleton(heap))}\modality{#allmodal}{.. ...}\endmodality(post))
		      \add (==>(#v=null));
		"Null Reference (#v = null)":
		      \replacewith(\modality{#allmodal}{..throw new java.lang.NullPointerException();...}\endmodality(post))
		      \add (#v=null ==>)
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };
}

\rules(programRules:Java, runtimeExceptions:ban, concurrency:RG) {
  assignment_write_attribute {
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se)}{heaps:=seqConcat(heaps,seqSingleton(heap))}
                                   \modality{#allmodal}{.. ...}\endmodality(post))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };
}

\rules(programRules:Java, runtimeExceptions:ignore, concurrency:RG) {
  assignment_write_attribute {
    \find (\modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
    \varcond(\not \static(#a))
    \replacewith({heap:=store(heap,#v,#memberPVToField(#a),#se)}{heaps:=seqConcat(heaps,seqSingleton(heap))}\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog, simplify_prog_subset)
    \displayname "assignment"
  };
}

\rules(programRules:Java, concurrency:RG) {
  // for this rule we do not need a separate one for constant
  // fieldreferences as the attribute case does not throw any exception
  // for an implicit "this" and so behaves same for constant and instance
  // attributes
  assignment_write_static_attribute {
	\find (\modality{#allmodal}{.. @(#sv) = #se; ...}\endmodality(post))
	\replacewith(
             {heap := store(heap, null, #memberPVToField(#sv), #se)}
             {heaps:=seqConcat(heaps,seqSingleton(heap))}
             \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "assignment"
  };

  // constant case cannot occur as no static initialisation handling happens
  assignment_write_static_attribute_with_variable_prefix {
	\find (\modality{#allmodal}{.. @(#v.#sv) = #se; ...}\endmodality(post))
	\replacewith(
             {heap := store(heap, #v, #memberPVToField(#sv), #se)}
             {heaps:=seqConcat(heaps,seqSingleton(heap))}
             \modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog, simplify_prog_subset)
        \displayname "active_attribute_access"
  };
}
