
// Rules for handling event histories.
// we are restricted here for stuff relevant for proving non-interference according to distributed systems.
// we leave underspecified the definition of event equivalence, which is problem-specific and a xxxatter of specification.
// All traces are xxxeant to be component-local. There is no intention of combining traces of several components.
// What a component is, i.e. what a remote call and a local call is, is a xxxatter of spec.
// In this structure, event stuff is xxxodeled on the level of contracts.
// Methods datatype also is underspecified, its also a xxxatter of specification (possible remote calls)


\sorts {
  Method;
  Calltype;
  CallDirection;
  Event;
}

\predicates {
  wellformed(Event);
  wellformedList(Seq);
  wellformedListCoop(Seq);
  wellformedListResume(Event, Seq);
  coopListEquiv(Seq, Seq);
  equivHistory(Seq,Seq);
  equivHistoryFiltered(Seq,Seq);
  equivEvent(Event, Event);
  invEvent(Event);
}

//Criteria for wellformed histories:
//- every outgoing call is followed by an incoming return of the same xxxethod. (Termination assumption)
//- every outgoing visible call is followed by a incoming visible term (and vice versa) (Visiblity preserving)

\functions{

  //generates a new event. call or return, commpartner (caller when incoming and callee when outgiong), Method, params, heap in which the params are evaluated
  Event event(Calltype, CallDirection, Object, Method, Seq, Heap);

  //constructors for the calltype
  \unique Calltype servcall;
  \unique Calltype servterm;
  \unique CallDirection in;
  \unique CallDirection out;
  Seq filterInput(Seq);
  Seq filterVisible(Seq);

  //selectors
  Calltype evCalltype(Event);
  CallDirection evDirection(Event);
  Object evPartner(Event);
  Method evMethod(Event);
  Seq evParams(Event);
  Heap evHeap(Event);

  //TODO JK these are temporary ids for remote services, remove after using karstens proper implementation
  \unique Method serv;
  \unique Method remoteServB;
   
    \unique Method AccountIF_orderElementsInCart;
  \unique Method AccountIF_setAdress;
  \unique Method AccountIF_setCCNr;
  \unique Method AccountIF_setCVC;
  \unique Method AccountIF_setName;
  
  \unique Method BankIF_makePayment;
  
  \unique Method BillingIF_getBillsToSend;
  
  \unique Method BillingToAccountIF_getBillingAdress;
  \unique Method BillingToAccountIF_getBillingCreditCard;
  \unique Method BillingToAccountIF_getBillingName;
  \unique Method BillingToAccountIF_getOrdersToBill;
  
  \unique Method CartIF_addToCart;
  \unique Method CartIF_getCartContent;
  
    \unique Method getCartContent;
  
  \unique Method CartToAccountIF_getCartElementsForOrder;
  
  \unique Method DeliveryIF_getDeliverySheets;
  
  \unique Method DeliveryToAccount_getAdress;
  \unique Method DeliveryToAccount_getName;
  \unique Method DeliveryToAccount_getOrdesForDelivery;
  
  \unique Method OrdersToAccountIF_getAllOrders;
  \unique Method OrdersToAccountIF_getUnbilledOrders;
  \unique Method OrdersToAccountIF_getUnshippedOrders;
  \unique Method OrdersToAccountIF_makeNewOrder;
  
  \unique Method ProductDBIF_getProductPrice;
  
}


\rules {

  inOutInequal {
    \find(in = out)
    \replacewith(false)
    \heuristics(simplify)
  };

  inOutInequal2 {
    \find(out = in)
    \replacewith(false)
    \heuristics(simplify)
  };

  callTermInequal {
    \find(servcall = servterm)
    \replacewith(false)
    \heuristics(simplify)
  };

  callTermInequal2 {
    \find(servterm = servcall)
    \replacewith(false)
    \heuristics(simplify)
  };

  //Selector defs
  defOfevCalltype {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;

    \find(evCalltype(event(ct,cd,o,xxx,p,h)))
    \replacewith(ct)
    \heuristics(simplify)
  };

  defOfevHeap {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;

    \find(evHeap(event(ct,cd,o,xxx,p,h)))
    \replacewith(h)
    \heuristics(simplify)
  };

  defOfevDirection {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;

    \find(evDirection(event(ct,cd,o,xxx,p,h)))
    \replacewith(cd)
    \heuristics(simplify)
  };

  defOfevPartner {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;

    \find(evPartner(event(ct,cd,o,xxx,p,h)))
    \replacewith(o)
    \heuristics(simplify)
  };

  defOfevMethod {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;

    \find(evMethod(event(ct,cd,o,xxx,p,h)))
    \replacewith(m)
    \heuristics(simplify)
  };

  defOfevParams {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;

    \find(evParams(event(ct,cd,o,xxx,p,h)))
    \replacewith(p)
    \heuristics(simplify)
  };

  //History Wellformedness (To be proven. Does not take cooperativeness into consideration, since this is an assumption, which can not be proven(?))
  defOfHistoryWfEmpty {
    \find(wellformedList(seqEmpty))
    \replacewith(true)
    \heuristics(simplify)
  };

  defOfHistoryWfSingle {
    \schemaVar \term Event e;
    \find(wellformedList(seqSingleton(e)))
    \replacewith(evDirection(e) = out & evCalltype(e) = servterm)
    \heuristics(simplify)
  };

  defOfHistoryWfInter {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;

    \find(wellformedList(seqConcat(seqSingleton(e), s)))
    \replacewith(  ((evDirection(e) = out & evCalltype(e) = servcall) ->
                     (evDirection(Event::seqGet(s,0)) = in &  evCalltype(Event::seqGet(s,0)) = servterm &
                     evMethod(Event::seqGet(s,0)) = evMethod(e)))
                   & wellformedList(s))
    \heuristics(simplify)
  };


  //Includes the cooperativeness of the environment.
  defOfHistoryWfcoopEmpty {
    \find(wellformedListCoop(seqEmpty))
    \replacewith(true)
    \heuristics(simplify)
  };

  defOfHistoryWfcoopSingle {
    \schemaVar \term Event e;
    \find(wellformedListCoop(seqSingleton(e)))
    \replacewith(evDirection(e) = out & evCalltype(e) = servterm)
    \heuristics(simplify)
  };

  defOfHistoryWfcoopInter {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;

    \find(wellformedListCoop(seqConcat(seqSingleton(e), s)))
    \replacewith(  ((evDirection(e) = out & evCalltype(e) = servcall) ->
                     (evDirection(Event::seqGet(s,0)) = in &  evCalltype(Event::seqGet(s,0)) = servterm &
                     evMethod(Event::seqGet(s,0)) = evMethod(e) & (invEvent(e) <-> invEvent(Event::seqGet(s,0)))))
                   & wellformedListCoop(s))
    \heuristics(simplify)
  };

//JK Attempt to do history equivalence without assumptions (maybe better for automation)
   defOfHistoryEquivToFilteredVersion {
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \find(equivHistory( hist1, hist2 ))
     \replacewith(equivHistoryFiltered(filterVisible(hist1),filterVisible(hist2)))
     \heuristics(simplify)
  };

   defOfHistoryEquivFilteredDefault {
     \schemaVar \term Event e1;
     \schemaVar \term Event e2;
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \find(equivHistoryFiltered( seqConcat(seqSingleton(e1), hist1), seqConcat(seqSingleton(e2), hist2) ))
     \replacewith(equivEvent(e1, e2) & equivHistoryFiltered(hist1,hist2))
     \heuristics(simplify)
  };
  
  defOfHistoryEquivFilteredSingle {
      \schemaVar \term Event e1;
      \schemaVar \term Event e2;

      \find(equivHistoryFiltered( seqSingleton(e1), seqSingleton(e2)))
      \replacewith(equivEvent(e1, e2))
      \heuristics(simplify)
   };
  
  defOfHistoryEquivFilteredEmpty {
     \find(equivHistoryFiltered( seqEmpty, seqEmpty))
     \replacewith(true)
     \heuristics(simplify)
  };
   //TODO JK add rules for non-equivalent traces
  
  //JK try something for filterVisible on singleton sequences
  filterVisibleCut {
      \schemaVar \term Event e;
      \schemaVar \term Seq p;

      \find(filterVisible(seqSingleton(e)))
      \add(==> invEvent(e));\add(invEvent(e)==> )
      \heuristics(simplify)
    };








  //To prove equivalence of traces, we start from the first one and work backwards.
  defOfHistoryEquivInv {

     \schemaVar \term Event e;
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \assumes(invEvent(e) ==>)
     \find(equivHistory( seqConcat(seqSingleton(e), hist1), hist2 ))
     \replacewith(equivHistory(hist1,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivInvSingle {

     \schemaVar \term Event e;
     \schemaVar \term Seq hist2;

     \assumes(invEvent(e) ==>)
     \find(equivHistory( seqSingleton(e), hist2 ))
     \replacewith(equivHistory(seqEmpty,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivInv2 {

     \schemaVar \term Event e;
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \assumes(invEvent(e) ==>)
     \find(equivHistory( hist1, seqConcat(seqSingleton(e), hist2) ))

     \replacewith(equivHistory(hist1,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivInv2Single {

     \schemaVar \term Event e;
     \schemaVar \term Seq hist1;

     \assumes(invEvent(e) ==>)
     \find(equivHistory( hist1, seqSingleton(e) ))

     \replacewith(equivHistory(hist1,seqEmpty))
     \heuristics(simplify)
  };

  //TODO: xxxake distinction here: If input, assume equiv. If output require output.
  //Nope! we assume the equivalent input in the proof obligation.
  //Here we require the trace to be equivalent.

  defOfHistoryEquivNonInvIn {  //If inputs are equivalent, then following outputs are equivalent
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Calltype ct;
     \schemaVar \term Object callee;
     \schemaVar \term Method xxx;
     \schemaVar \term Seq p;
    \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method xxx2;
     \schemaVar \term Seq p2;
    \schemaVar \term Heap h2;

     \assumes(==> invEvent(event(ct, in, callee, xxx, p, h)), invEvent(event(ct2, in, callee2, xxx2, p2, h2)))
     \find(equivHistory( seqConcat(seqSingleton(event(ct, in, callee, xxx, p, h)), hist1),
                    seqConcat(seqSingleton(event(ct2, in, callee2, xxx2, p2, h2)), hist2) ))

     \replacewith(equivEvent(event(ct, in, callee, xxx, p, h), event(ct2, in, callee2, xxx2, p2, h2)) ->
                   equivHistory(hist1,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivNonInvOut { //outputs are equivalent and rest of sequences are equivalent
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Calltype ct;
     \schemaVar \term Object callee;
     \schemaVar \term Method xxx;
     \schemaVar \term Seq p;
     \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method xxx2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

     \assumes(==> invEvent(event(ct, out, callee, xxx, p, h)), invEvent(event(ct2, out, callee2, xxx2, p2, h2)))
     \find(equivHistory(seqConcat(seqSingleton(event(ct, out, callee, xxx, p, h)), hist1),
                    seqConcat(seqSingleton(event(ct2, out, callee2, xxx2, p2, h2)), hist2) ))

     \replacewith(equivEvent(event(ct, out, callee, xxx, p, h), event(ct2, out, callee2, xxx2, p2, h2)) &
                    equivHistory(hist1,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivNonInvOutSingle { //Last element of trace. Is output and servterm
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Calltype ct;
     \schemaVar \term Object callee;
     \schemaVar \term Method xxx;
     \schemaVar \term Seq p;
     \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method xxx2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

 //    \assumes(==> invEvent(event(servterm, out, callee, xxx, p, h)), invEvent(event(ct2, out, callee2, xxx2, p2, h2)))
     \find(equivHistory(seqSingleton(event(servterm, out, callee, xxx, p, h)),
                    seqSingleton(event(servterm, out, callee2, xxx2, p2, h2)) ))

     \replacewith(equivEvent(event(servterm, out, callee, xxx, p, h), event(servterm, out, callee2, xxx2, p2, h2)))
     \heuristics(simplify)
  };

  // Cooperational equivalence due to coop environments
  defOfCoopListEquiv { //If the start event in both cases are equivalent, then the termination events are
    \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Object callee1;
     \schemaVar \term Method xxx;
     \schemaVar \term Seq p1;
     \schemaVar \term Heap h1;

     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

     \schemaVar \term Object callee2;
     \schemaVar \term Seq p3;
     \schemaVar \term Heap h3;

     \schemaVar \term Seq p4;
     \schemaVar \term Heap h4;

    \find(coopListEquiv(seqConcat(seqSingleton(event(servcall,out,callee1,xxx,p1,h1)),
                          seqConcat(seqSingleton(event(servterm,in,callee1,xxx,p2,h2)), hist1)),
                        seqConcat(seqSingleton(event(servcall,out,callee2,xxx,p3,h3)),
                          seqConcat(seqSingleton(event(servterm,in,callee2,xxx,p4,h4)), hist2)) )
            ==>)

    \replacewith(equivEvent(event(servcall,out,callee1,xxx,p1,h1), event(servcall,out,callee2,xxx,p3,h3))
         -> (equivEvent(event(servterm,in,callee1,xxx,p2,h2), event(servterm,in,callee2,xxx,p4,h4))
             & coopListEquiv(hist1,hist2) )
          ==>)

   \heuristics(simplify)
  };

  defOfCoopListEquivStart {

     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Object callee1;
     \schemaVar \term Method xxx;
     \schemaVar \term Seq p1;
     \schemaVar \term Heap h1;

     \schemaVar \term Object callee2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

    \find(coopListEquiv(seqConcat(seqSingleton(event(servcall,in,callee1,xxx,p1,h1)), hist1),
                        seqConcat(seqSingleton(event(servcall,in,callee2,xxx,p2,h2)), hist2))
          ==>)

    \replacewith(equivEvent(event(servcall,in,callee1,xxx,p1,h1), event(servcall,in,callee2,xxx,p2,h2))
               -> coopListEquiv(hist1, hist2)
          ==>)
    \heuristics(simplify)
  };

/*  defOfHistoryEquivNonInv {
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Calltype ct;
     \schemaVar \term CallDirection dir;
     \schemaVar \term Object callee;
     \schemaVar \term Method xxx;
     \schemaVar \term Seq p;
     \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method xxx2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

     \assumes(==> invEvent(event(ct, dir, callee, xxx, p, h)), invEvent(event(ct2, dir, callee2, xxx2, p2, h2)))
     \find(equivHistory( seqConcat(seqSingleton(event(ct, dir, callee, xxx, p, h)), hist1),
                    seqConcat(seqSingleton(event(ct2, dir, callee2, xxx2, p2, h2)), hist2) ))

     \replacewith(equivEvent(event(ct, dir, callee, xxx, p, h), event(ct2, dir, callee2, xxx2, p2, h2)) &
                    equivHistory(hist1,hist2))
     \heuristics(simplify)
  };


  defOfHistoryEquivNonInvOutSingle {

     \schemaVar \term Calltype ct;
     \schemaVar \term CallDirection dir;
     \schemaVar \term Object callee;
     \schemaVar \term Method xxx;
     \schemaVar \term Seq p;
     \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method xxx2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

     \assumes(==> invEvent(event(ct, dir, callee, xxx, p, h)), invEvent(event(ct2, dir, callee2, xxx2, p2, h2)))
     \find(equivHistory( seqSingleton(event(ct, dir, callee, xxx, p, h)),
                    seqSingleton(event(ct2, dir, callee2, xxx2, p2, h2)) ))

     \replacewith(equivEvent(event(ct, out, callee, xxx, p, h), event(ct2, out, callee2, xxx2, p2, h2)))
     \heuristics(simplify)
  };*/

// Equivalence of empty trace rules
  defOfHistoryEquivEmtpy {
    \find(equivHistory(seqEmpty, seqEmpty))
    \replacewith(true)
    \heuristics(simplify)
  };

  //Histories are non-equivalent, if one is empty, the other one is is not and first element is visible
  defOfHistoryNonEquiv {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;

    \assumes(==> invEvent(e))
    \find(equivHistory(seqEmpty, seqConcat(seqSingleton(e),s)))
    \replacewith(false)
    \heuristics(simplify)
  };

  defOfHistoryNonEquiv2 {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;

    \assumes(==> invEvent(e))
    \find(equivHistory(seqConcat(seqSingleton(e),s), seqEmpty))
    \replacewith(false)
    \heuristics(simplify)
  };

    defOfHistoryNonEquivSingl {
    \schemaVar \term Event e;

    \assumes(==> invEvent(e))
    \find(equivHistory(seqEmpty, seqSingleton(e)))
    \replacewith(false)
    \heuristics(simplify)
  };

  defOfHistoryNonEquivSingl2 {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;

    \assumes(==> invEvent(e))
    \find(equivHistory(seqSingleton(e), seqEmpty))
    \replacewith(false)
    \heuristics(simplify)
  };

//define here the visiblity filter
  defOfFilterVisibleEmpty{
    \find(filterVisible(seqEmpty))
    \replacewith(seqEmpty)
    \heuristics(simplify)
  };


  defOfFilterVisibleSingle1 {
    \schemaVar \term Event e;
    \schemaVar \term Seq p;

    \assumes(invEvent(e) ==>)
    \find(filterVisible(seqSingleton(e)))
    \replacewith(seqEmpty)
    \heuristics(simplify)
  };

  defOfFilterVisibleSingle2 {
    \schemaVar \term Event e;
    \schemaVar \term Seq p;

    \assumes(==> invEvent(e))
    \find(filterVisible(seqSingleton(e)))
    \replacewith(seqSingleton(e))
    \heuristics(simplify)
  };

  defOfFilterInvisibleConc {
    \schemaVar \term Event e;
    \schemaVar \term Seq hist;

    \find(filterVisible(seqConcat(seqSingleton(e),hist)))
    \replacewith(seqConcat(filterVisible(seqSingleton(e)),filterVisible(hist)))
    \heuristics(simplify)
  };



  //define here the input filter
  defOfFilterInputEmpty {
    \find(filterInput(seqEmpty))
    \replacewith(seqEmpty)
    \heuristics(simplify)
  };

  defOfFilterInputConcIn {
    \schemaVar \term Calltype ct;
    \schemaVar \term Object callee;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Seq hist;
    \schemaVar \term Heap h;

    \find(filterInput(seqConcat(seqSingleton(event(ct, in, callee, xxx, p, h)),hist)))
    \replacewith(seqConcat(seqSingleton(event(ct, in, callee, xxx, p, h)),filterInput(hist)))
    \heuristics(simplify)
  };

  defOfFilterInputConcInSingle {
    \schemaVar \term Calltype ct;
    \schemaVar \term Object callee;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;

    \find(filterInput(seqSingleton(event(ct, in, callee, xxx, p,h))))
    \replacewith(seqSingleton(event(ct, in, callee, xxx, p, h)))
    \heuristics(simplify)
  };

  defOfFilterInputConcOut {
    \schemaVar \term Calltype ct;
    \schemaVar \term Object callee;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Seq hist;
    \schemaVar \term Heap h;

    \find(filterInput(seqConcat(seqSingleton(event(ct, out, callee, xxx, p, h)),hist)))
    \replacewith(filterInput(hist))
    \heuristics(simplify)
  };

  defOfFilterInputConcOutSingle {
    \schemaVar \term Calltype ct;
    \schemaVar \term Object callee;
    \schemaVar \term Method xxx;
    \schemaVar \term Seq p;
    \schemaVar \term Seq hist;
    \schemaVar \term Heap h;

    \find(filterInput(seqSingleton(event(ct, out, callee, xxx, p, h))))
    \replacewith(seqEmpty)
    \heuristics(simplify)
  };

}

\programVariables {
    Seq hist;
}
