
// Rules for handling event histories.
// we are restricted here for stuff relevant for proving non-interference according to distributed systems.
// we leave underspecified the definition of event equivalence, which is problem-specific and a matter of specification.
// All traces are meant to be component-local. There is no intention of combining traces of several components.
// What a component is, i.e. what a remote call and a local call is, is a matter of spec.
// In this structure, event stuff is modeled on the level of contracts.
// Methods datatype also is underspecified, its also a matter of specification (possible remote calls)


\sorts {
  Method;
  Calltype;
  CallDirection;
  Event;
}

\predicates {
  wellformed(Event);
  wellformedList(Seq);
  wellformedListCoop(Seq);
  wellformedListResume(Event, Seq);
  coopListEquiv(Seq, Seq);
  equivHistory(Seq,Seq);
  equivEvent(Event, Event);
  invEvent(Event);
}

//Criteria for wellformed histories:
//- every outgoing call is followed by an incoming return of the same method. (Termination assumption)
//- every outgoing visible call is followed by a incoming visible term (and vice versa) (Visiblity preserving)

\functions{
  
  //generates a new event. call or return, commpartner (caller when incoming and callee when outgiong), Method, params, heap in which the params are evaluated
  Event event(Calltype, CallDirection, Object, Method, Seq, Heap);

  //constructors for the calltype
  Calltype servcall;
  Calltype servterm;
  CallDirection in;
  CallDirection out;
  Seq filterInput(Seq);
  Seq filterVisible(Seq);

  //selectors
  Calltype evCalltype(Event);
  CallDirection evDirection(Event);
  Object evPartner(Event);
  Method evMethod(Event);
  Seq evParams(Event);
  
}


\rules {

  inOutInequal {
    \find(in = out)
    \replacewith(false)
    \heuristics(simplify)
  };

  inOutInequal2 {
    \find(out = in)
    \replacewith(false)
    \heuristics(simplify)
  };

  callTermInequal {
    \find(servcall = servterm)
    \replacewith(false)
    \heuristics(simplify)
  };

  callTermInequal2 {
    \find(servterm = servcall)
    \replacewith(false)
    \heuristics(simplify)
  };

  //Selector defs
  defOfevCalltype {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;
   
    \find(evCalltype(event(ct,cd,o,m,p,h)))
    \replacewith(ct)
    \heuristics(simplify)
  };

  defOfevDirection {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;
   
    \find(evDirection(event(ct,cd,o,m,p,h)))
    \replacewith(cd)
    \heuristics(simplify)
  };

  defOfevPartner {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;
   
    \find(evPartner(event(ct,cd,o,m,p,h)))
    \replacewith(o)
    \heuristics(simplify)
  };

  defOfevMethod {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;
   
    \find(evMethod(event(ct,cd,o,m,p,h)))
    \replacewith(m)
    \heuristics(simplify)
  };

  defOfevParams {
    \schemaVar \term Calltype ct;
    \schemaVar \term CallDirection cd;
    \schemaVar \term Object o;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;
   
    \find(evParams(event(ct,cd,o,m,p,h)))
    \replacewith(p)
    \heuristics(simplify)
  };

  //History Wellformedness (To be proven. Does not take cooperativeness into consideration, since this is an assumption, which can not be proven(?))
  defOfHistoryWfEmpty {
    \find(wellformedList(seqEmpty))
    \replacewith(true)
    \heuristics(simplify)
  };

  defOfHistoryWfSingle {
    \schemaVar \term Event e;
    \find(wellformedList(seqSingleton(e)))
    \replacewith(evDirection(e) = out & evCalltype(e) = servterm)
    \heuristics(simplify)
  };

  defOfHistoryWfInter {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;

    \find(wellformedList(seqConcat(seqSingleton(e), s)))
    \replacewith(  ((evDirection(e) = out & evCalltype(e) = servcall) -> 
                     (evDirection(Event::seqGet(s,0)) = in &  evCalltype(Event::seqGet(s,0)) = servterm & 
                     evMethod(Event::seqGet(s,0)) = evMethod(e))) 
                   & wellformedList(s))
    \heuristics(simplify)
  };
  

  //Includes the cooperativeness of the environment.
  defOfHistoryWfcoopEmpty {
    \find(wellformedListCoop(seqEmpty))
    \replacewith(true)
    \heuristics(simplify)
  };

  defOfHistoryWfcoopSingle {
    \schemaVar \term Event e;
    \find(wellformedListCoop(seqSingleton(e)))
    \replacewith(evDirection(e) = out & evCalltype(e) = servterm)
    \heuristics(simplify)
  };

  defOfHistoryWfcoopInter {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;

    \find(wellformedListCoop(seqConcat(seqSingleton(e), s)))
    \replacewith(  ((evDirection(e) = out & evCalltype(e) = servcall) -> 
                     (evDirection(Event::seqGet(s,0)) = in &  evCalltype(Event::seqGet(s,0)) = servterm & 
                     evMethod(Event::seqGet(s,0)) = evMethod(e) & (invEvent(e) <-> invEvent(Event::seqGet(s,0))))) 
                   & wellformedListCoop(s))
    \heuristics(simplify)
  };


  //To prove equivalence of traces, we start from the first one and work backwards.
  defOfHistoryEquivInv {
    
     \schemaVar \term Event e;
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \assumes(invEvent(e) ==>)
     \find(equivHistory( seqConcat(seqSingleton(e), hist1), hist2 ))
     \replacewith(equivHistory(hist1,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivInvSingle {
    
     \schemaVar \term Event e;
     \schemaVar \term Seq hist2;

     \assumes(invEvent(e) ==>)
     \find(equivHistory( seqSingleton(e), hist2 ))
     \replacewith(equivHistory(seqEmpty,hist2))
     \heuristics(simplify)
  };
  
  defOfHistoryEquivInv2 {
    
     \schemaVar \term Event e;
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \assumes(invEvent(e) ==>)
     \find(equivHistory( hist1, seqConcat(seqSingleton(e), hist2) ))
     
     \replacewith(equivHistory(hist1,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivInv2Single {
    
     \schemaVar \term Event e;
     \schemaVar \term Seq hist1;

     \assumes(invEvent(e) ==>)
     \find(equivHistory( hist1, seqSingleton(e) ))
     
     \replacewith(equivHistory(hist1,seqEmpty))
     \heuristics(simplify)
  };
  
  //TODO: make distinction here: If input, assume equiv. If output require output.
  //Nope! we assume the equivalent input in the proof obligation.
  //Here we require the trace to be equivalent.

  defOfHistoryEquivNonInvIn {  //If inputs are equivalent, then following outputs are equivalent
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Calltype ct;
     \schemaVar \term Object callee;
     \schemaVar \term Method m;
     \schemaVar \term Seq p;
    \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method m2;
     \schemaVar \term Seq p2;
    \schemaVar \term Heap h2;

     \assumes(==> invEvent(event(ct, in, callee, m, p, h)), invEvent(event(ct2, in, callee2, m2, p2, h2)))
     \find(equivHistory( seqConcat(seqSingleton(event(ct, in, callee, m, p, h)), hist1), 
                    seqConcat(seqSingleton(event(ct2, in, callee2, m2, p2, h2)), hist2) ))
     
     \replacewith(equivEvent(event(ct, in, callee, m, p, h), event(ct2, in, callee2, m2, p2, h2)) -> 
                   equivHistory(hist1,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivNonInvOut { //outputs are equivalent and rest of sequences are equivalent
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Calltype ct;
     \schemaVar \term Object callee;
     \schemaVar \term Method m;
     \schemaVar \term Seq p;
     \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method m2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

     \assumes(==> invEvent(event(ct, out, callee, m, p, h)), invEvent(event(ct2, out, callee2, m2, p2, h2)))
     \find(equivHistory(seqConcat(seqSingleton(event(ct, out, callee, m, p, h)), hist1), 
                    seqConcat(seqSingleton(event(ct2, out, callee2, m2, p2, h2)), hist2) ))
     
     \replacewith(equivEvent(event(ct, out, callee, m, p, h), event(ct2, out, callee2, m2, p2, h2)) & 
                    equivHistory(hist1,hist2))
     \heuristics(simplify)
  };

  defOfHistoryEquivNonInvOutSingle { //Last element of trace. Is output and servterm
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Calltype ct;
     \schemaVar \term Object callee;
     \schemaVar \term Method m;
     \schemaVar \term Seq p;
     \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method m2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

 //    \assumes(==> invEvent(event(servterm, out, callee, m, p, h)), invEvent(event(ct2, out, callee2, m2, p2, h2)))
     \find(equivHistory(seqSingleton(event(servterm, out, callee, m, p, h)), 
                    seqSingleton(event(servterm, out, callee2, m2, p2, h2)) ))
     
     \replacewith(equivEvent(event(servterm, out, callee, m, p, h), event(servterm, out, callee2, m2, p2, h2)))
     \heuristics(simplify)
  };

  // Cooperational equivalence due to coop environments
  defOfCoopListEquiv { //If the start event in both cases are equivalent, then the termination events are
    \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Object callee1;
     \schemaVar \term Method m;
     \schemaVar \term Seq p1;
     \schemaVar \term Heap h1;

     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

     \schemaVar \term Object callee2;
     \schemaVar \term Seq p3;
     \schemaVar \term Heap h3;

     \schemaVar \term Seq p4;
     \schemaVar \term Heap h4;
  
    \find(coopListEquiv(seqConcat(seqSingleton(event(servcall,out,callee1,m,p1,h1)), 
                          seqConcat(seqSingleton(event(servterm,in,callee1,m,p2,h2)), hist1)),  
                        seqConcat(seqSingleton(event(servcall,out,callee2,m,p3,h3)), 
                          seqConcat(seqSingleton(event(servterm,in,callee2,m,p4,h4)), hist2)) ) 
            ==>)

    \replacewith(equivEvent(event(servcall,out,callee1,m,p1,h1), event(servcall,out,callee2,m,p3,h3))
         -> (equivEvent(event(servterm,in,callee1,m,p2,h2), event(servterm,in,callee2,m,p4,h4))
             & coopListEquiv(hist1,hist2) ) 
          ==>)

   \heuristics(simplify)
  };

  defOfCoopListEquivStart {
   
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Object callee1;
     \schemaVar \term Method m;
     \schemaVar \term Seq p1;
     \schemaVar \term Heap h1;

     \schemaVar \term Object callee2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;
 
    \find(coopListEquiv(seqConcat(seqSingleton(event(servcall,in,callee1,m,p1,h1)), hist1),  
                        seqConcat(seqSingleton(event(servcall,in,callee2,m,p2,h2)), hist2)) 
          ==>)
 
    \replacewith(equivEvent(event(servcall,in,callee1,m,p1,h1), event(servcall,in,callee2,m,p2,h2))
               -> coopListEquiv(hist1, hist2)
          ==>)
    \heuristics(simplify)
  };

/*  defOfHistoryEquivNonInv {
     \schemaVar \term Seq hist1;
     \schemaVar \term Seq hist2;

     \schemaVar \term Calltype ct;
     \schemaVar \term CallDirection dir;
     \schemaVar \term Object callee;
     \schemaVar \term Method m;
     \schemaVar \term Seq p;
     \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method m2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

     \assumes(==> invEvent(event(ct, dir, callee, m, p, h)), invEvent(event(ct2, dir, callee2, m2, p2, h2)))
     \find(equivHistory( seqConcat(seqSingleton(event(ct, dir, callee, m, p, h)), hist1), 
                    seqConcat(seqSingleton(event(ct2, dir, callee2, m2, p2, h2)), hist2) ))
     
     \replacewith(equivEvent(event(ct, dir, callee, m, p, h), event(ct2, dir, callee2, m2, p2, h2)) & 
                    equivHistory(hist1,hist2))
     \heuristics(simplify)
  };


  defOfHistoryEquivNonInvOutSingle {

     \schemaVar \term Calltype ct;
     \schemaVar \term CallDirection dir;
     \schemaVar \term Object callee;
     \schemaVar \term Method m;
     \schemaVar \term Seq p;
     \schemaVar \term Heap h;

     \schemaVar \term Calltype ct2;
     \schemaVar \term Object callee2;
     \schemaVar \term Method m2;
     \schemaVar \term Seq p2;
     \schemaVar \term Heap h2;

     \assumes(==> invEvent(event(ct, dir, callee, m, p, h)), invEvent(event(ct2, dir, callee2, m2, p2, h2)))
     \find(equivHistory( seqSingleton(event(ct, dir, callee, m, p, h)), 
                    seqSingleton(event(ct2, dir, callee2, m2, p2, h2)) ))
     
     \replacewith(equivEvent(event(ct, out, callee, m, p, h), event(ct2, out, callee2, m2, p2, h2)))
     \heuristics(simplify)
  };*/

// Equivalence of empty trace rules
  defOfHistoryEquivEmtpy {
    \find(equivHistory(seqEmpty, seqEmpty))
    \replacewith(true)
    \heuristics(simplify)
  };

  //Histories are non-equivalent, if one is empty, the other one is is not and first element is visible
  defOfHistoryNonEquiv {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;
    
    \assumes(==> invEvent(e))
    \find(equivHistory(seqEmpty, seqConcat(seqSingleton(e),s)))
    \replacewith(false)
    \heuristics(simplify)
  };

  defOfHistoryNonEquiv2 {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;
    
    \assumes(==> invEvent(e))
    \find(equivHistory(seqConcat(seqSingleton(e),s), seqEmpty))
    \replacewith(false)
    \heuristics(simplify)
  };

    defOfHistoryNonEquivSingl {
    \schemaVar \term Event e;
    
    \assumes(==> invEvent(e))
    \find(equivHistory(seqEmpty, seqSingleton(e)))
    \replacewith(false)
    \heuristics(simplify)
  };

  defOfHistoryNonEquivSingl2 {
    \schemaVar \term Event e;
    \schemaVar \term Seq s;
    
    \assumes(==> invEvent(e))
    \find(equivHistory(seqSingleton(e), seqEmpty))
    \replacewith(false)
    \heuristics(simplify)
  };

//define here the visiblity filter
  defOfFilterVisibleEmpty{
    \find(filterVisible(seqEmpty))
    \replacewith(seqEmpty)
    \heuristics(simplify)
  };  


  defOfFilterVisibleSingle1 {
    \schemaVar \term Event e;
    \schemaVar \term Seq p;

    \assumes(invEvent(e) ==>)
    \find(filterVisible(seqSingleton(e)))
    \replacewith(seqEmpty)
    \heuristics(simplify)
  };
  
  defOfFilterVisibleSingle2 {
    \schemaVar \term Event e;
    \schemaVar \term Seq p;

    \assumes(==> invEvent(e))
    \find(filterVisible(seqSingleton(e)))
    \replacewith(seqSingleton(e))
    \heuristics(simplify)
  };

  defOfFilterInvisibleConc {
    \schemaVar \term Event e;
    \schemaVar \term Seq hist;

    \find(filterVisible(seqConcat(seqSingleton(e),hist)))
    \replacewith(seqConcat(filterVisible(seqSingleton(e)),filterVisible(hist)))
    \heuristics(simplify)
  };
  
  

  //define here the input filter
  defOfFilterInputEmpty {
    \find(filterInput(seqEmpty))
    \replacewith(seqEmpty)
    \heuristics(simplify)
  };

  defOfFilterInputConcIn {
    \schemaVar \term Calltype ct;
    \schemaVar \term Object callee;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Seq hist;
    \schemaVar \term Heap h;

    \find(filterInput(seqConcat(seqSingleton(event(ct, in, callee, m, p, h)),hist)))
    \replacewith(seqConcat(seqSingleton(event(ct, in, callee, m, p, h)),filterInput(hist)))
    \heuristics(simplify)
  };

  defOfFilterInputConcInSingle {
    \schemaVar \term Calltype ct;
    \schemaVar \term Object callee;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Heap h;

    \find(filterInput(seqSingleton(event(ct, in, callee, m, p,h))))
    \replacewith(seqSingleton(event(ct, in, callee, m, p, h)))
    \heuristics(simplify)
  };

  defOfFilterInputConcOut {
    \schemaVar \term Calltype ct;
    \schemaVar \term Object callee;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Seq hist;
    \schemaVar \term Heap h;

    \find(filterInput(seqConcat(seqSingleton(event(ct, out, callee, m, p, h)),hist)))
    \replacewith(filterInput(hist))
    \heuristics(simplify)
  };

  defOfFilterInputConcOutSingle {
    \schemaVar \term Calltype ct;
    \schemaVar \term Object callee;
    \schemaVar \term Method m;
    \schemaVar \term Seq p;
    \schemaVar \term Seq hist;
    \schemaVar \term Heap h;

    \find(filterInput(seqSingleton(event(ct, out, callee, m, p, h))))
    \replacewith(seqEmpty)
    \heuristics(simplify)
  };

}