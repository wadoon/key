// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//

// This file contains only the RULES for the data type Ord
// of ordinals.
// The rules come in sections
//  * Core Axioms
//  * Definitional Extensions 
//  * Additional Axioms
//  * Derived  Taclets
// 



\rules{


//--------------------------------------------------------------------------
//  
//  Core Axioms
//  
//--------------------------------------------------------------------------

olt_trans_Axiom{ 
   \schemaVar \variables Ord nv, nv0, nv1;

   \add(  \forall nv;(\forall nv0; (\forall nv1;(
           (olt(nv,nv0) &  olt(nv0,nv1)) -> olt(nv,nv1)))) ==>)
  };

olt_irref_Axiom{ 
    \schemaVar \variables Ord nv;

  \add(  \forall nv;( (!olt(nv,nv))) ==>)
  };

olt_total_Axiom{ 
    \schemaVar \variables Ord nv, nv1;

  \add(  \forall nv;(  \forall nv1;(
           olt(nv,nv1) | nv = nv1 | olt(nv1,nv))) ==>)
  };



oleq_zeroAxiom{ 
    \schemaVar \variables Ord nv;
    \add(  \forall nv;(  oleq(o_0, nv)) ==>)
  };



oIndBasic{ 
  \schemaVar \variables Ord nv,nv1,nv2;
  \schemaVar \formula phi;
  \find (==> \forall nv;phi)
  \varcond(\notFreeIn(nv1,phi),\notFreeIn(nv2,phi))
  \replacewith(==> 
   \forall nv1;(
    (\forall nv2;(olt(nv2,nv1) -> {\subst nv; nv2}phi))
   ->  {\subst nv; nv1}phi))
  };

oSucc{ 
     \schemaVar \variables Ord nv;
     \add(\forall nv;(olt(nv,oadd(nv,o_1)))==>)
};

oLeastSucc{ 
     \schemaVar \variables Ord nv, nv1;
     \add(\forall nv;(\forall nv1;(
       olt(nv,nv1) -> oleq(oadd(nv,o_1),nv1)))==>)
};


//--------------------------------------------------------------------------
//  
//  Definitional Extensions 
//  
//--------------------------------------------------------------------------


// osup{nv;}(j,i) is the least ordinal that is greater or equal
//  than any i for all nv < j. Typically, nv will be a
//  free variable in the term i.

osupDef{ 
  \schemaVar \variables Ord nv,nv1,nv2;
  \schemaVar \term Ord i,j;
  \find(osup{nv;}(j,i))
  \varcond(\notFreeIn(nv,j), \notFreeIn(nv1,j),\notFreeIn(nv2,j), \notFreeIn(nv1,i),\notFreeIn(nv2,i))
  \add(\forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), osup{nv;}(j,i))),
  \forall nv2;(
       \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), nv2)) ->
         oleq(osup{nv;}(j,i), nv2))   ==> )
  };

// Definition of less_or_equal relation

oleq_Def{ 
       \schemaVar \variables Ord nv, nv1;
            \schemaVar \term Ord i,i1;
       \find(oleq(i,i1))
       \add( \forall nv;( \forall nv1;(
         oleq(nv,nv1) <-> olt(nv,nv1) | nv = nv1)) ==> )
       };

// Definition of limit ordinal

olimDef{ 
      \schemaVar \variables Ord nv;
      \schemaVar \term Ord i;
      \find(lim(i))
      \varcond (\notFreeIn(nv,i))
      \replacewith(o_0!=i & !\exists nv;(i=oadd(nv,o_1)))};

// maximum of two ordinals

omaxDef{ 
      \schemaVar \term Ord i,i1;
      \find(omax(i,i1))
      \replacewith(\if(oleq(i,i1))\then(i1)\else(i))
};

//--------------------------------------------------------------------------
//  
//  Definitional Extensions: Arithmetic
//  
//--------------------------------------------------------------------------


omegaDef1{ 
    \find(omega)
    \add(lim(omega)==>)
    \heuristics(simplify_enlarging)   
};



omegaDefLeastInf{ 
    \schemaVar \variables Ord i,j;
    \add(\forall j;(
         ( olt(o_0,j)  
      &   \forall i;(olt(i,j) -> olt(oadd(i,o_1),j))
        )
      -> oleq(omega,j)) ==>)
};

oadd_Def0Right{ 
     \schemaVar \term Ord i;
     \find(oadd(i,o_0))
     \replacewith(i)
     \heuristics(concrete)
     };

oadd_DefSucc{ 
     \schemaVar \term Ord i,i1;
     \find(oadd(i,oadd(i1,o_1)))
     \replacewith(oadd(oadd(i,i1),o_1))
     };

oadd_DefLim{ 
     \schemaVar \variables Ord nv;
     \schemaVar \term Ord i,i1;
     \assumes(lim(i1)==>) 
     \find(oadd(i,i1))  \sameUpdateLevel 
     \varcond (\notFreeIn(nv,i), \notFreeIn(nv,i1))
         \replacewith(osup{nv;}(i1,oadd(i,nv)))
     };

otimes_Def0Right{  
     \schemaVar \term Ord i;
     \find(otimes(i,o_0))
     \replacewith(o_0)
     \heuristics(concrete)
     };

otimes_DefSucc{ 
     \schemaVar \term Ord i,i1;
     \find(otimes(i,oadd(i1,o_1)))
     \replacewith(oadd(otimes(i,i1),i))
     };

otimes_DefLim{ 
     \schemaVar \variables Ord nv;
     \schemaVar \term Ord i,i1;
     \assumes(lim(i1)==>) 
     \find(otimes(i,i1))  \sameUpdateLevel 
     \varcond (\notFreeIn(nv,i), \notFreeIn(nv,i1))
         \replacewith(osup{nv;}(i1,otimes(i,nv)))
     };

oexp_Def0Right{  
     \schemaVar \term Ord i;
     \find(oexp(i,o_0))
     \replacewith(o_1)
     \heuristics(concrete)
     };

oexp_DefSucc{ 
     \schemaVar \term Ord i,i1;
     \find(oexp(i,oadd(i1,o_1)))
     \replacewith(otimes(oexp(i,i1),i))
     };

oexp_DefLim{ 
     \schemaVar \variables Ord nv;
     \schemaVar \term Ord i,i1;
     \assumes(lim(i1)==>) 
     \find(oexp(i,i1))  \sameUpdateLevel 
     \varcond (\notFreeIn(nv,i), \notFreeIn(nv,i1))
         \replacewith(osup{nv;}(i1,oexp(i,nv)))
     };

//--------------------------------------------------------------------------
//  
//  Derived  taclets
//  
//--------------------------------------------------------------------------

// proofScript exists
least_number_principle{ 
 \schemaVar \variable Ord i,k; 
 \schemaVar \formula phi; 
  \find(\exists i;phi)
  \varcond(\notFreeIn(k,phi))
  \replacewith(\exists i;(phi & \forall k;(olt(k,i) -> !({\subst i;k}phi))))
  };

// this is a practical version of the transitivity axiom
// avoiding manual instantiation of universal quantifiers.

// proofScript exists
olt_trans{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (olt(i, i0) ==>) \find (olt(i0, i1) ==>) 
   \add (olt(i, i1) ==>)};

// frequently occuring consequence from olt_irref_Axiom
// proofScript exists
olt_irref{ 
    \schemaVar \term Ord i;
   \find (olt(i, i)) 
   \replacewith (false) 
   \heuristics(simplify) };

// proofScript exists
oleq_replace{ 
   \schemaVar \term Ord i,i1;
   \find(oleq(i,i1))
   \replacewith(olt(i,i1) | i = i1)
   \heuristics(simplify)
 };

// proofScript exists
notLim1{ 
 \schemaVar \term Ord i,j;
 \assumes(lim(i)==>)
 \find(i=oadd(j,o_1)==>)
 \inSequentState
 \closegoal
  \heuristics(closure)
};

// proofScript exists
notLim2{ 
 \schemaVar \term Ord i,j;
 \assumes(lim(i)==>)
 \find(oadd(j,o_1)=i==>)
 \inSequentState
 \closegoal
  \heuristics(closure)
};

// proofScript exists
olimDefAdd{ 
      \schemaVar \variables Ord nv;
      \schemaVar \term Ord i;
      \find(lim(i) ==>)
      \varcond (\notFreeIn(nv,i))
      \add(o_0!=i & !\exists nv;(i=oadd(nv,o_1))==>)
};

// proofScript exists
olimDefEquiv{ 
     \schemaVar \term Ord i;
     \schemaVar \variables  Ord ov;
   \find(lim(i))
  \varcond(\notFreeIn(ov,i))
   \replacewith(i!=o_0 & \forall ov;(olt(ov,i) -> olt(oadd(ov,o_1),i)))
};
//--------------------------------------------------------------------------
//
// derived taclets for oleq
//
//--------------------------------------------------------------------------
 
// proofScript exists
oleq_antisym{ 
  \schemaVar \term Ord i, i1; 
  \assumes(oleq(i,i1) ==>)
  \find(oleq(i1,i) ==>)
  \add(i=i1 ==>)  
  \heuristics(simplify)
  };

// proofScript exists
oleq_trans{ 
   \schemaVar \term Ord i, i0, i1;
  \assumes (oleq(i, i0) ==>) 
   \find (oleq(i0, i1) ==>) 
   \add (oleq(i, i1) ==>)
};

// proofScript exists
oltleq_trans{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (oleq(i, i0) ==>) 
   \find (olt(i0, i1) ==>) 
   \add (olt(i, i1) ==>)
};

// proofScript exists
oleqolt_trans{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (olt(i, i0) ==>) 
   \find (oleq(i0, i1) ==>) 
   \add (olt(i, i1) ==>)
};

// proofScript exists
olt_0Min{ 
   \schemaVar \term Ord i;
   \find (olt(i, o_0))
   \replacewith(false)
   \heuristics(concrete) 
};

//  proofScript exists
oleq_zero{ 
   \schemaVar \term Ord i;
   \find (oleq(o_0, i))
   \replacewith(true)
   \heuristics(concrete) 
};

// proofScript exists
olessPlusOne{ 
 \schemaVar \term Ord i,j;
 \find(olt(i,oadd(j,o_1)))
 \replacewith(olt(i,j)|i=j)
 \heuristics(simplify_enlarging)
};

// proofScript exists
omaxLess{ 
 \schemaVar \term Ord i, i0, i1; 
   \find(olt(i,omax(i0,i1)))
   \replacewith(olt(i,i0)|olt(i,i1))
   \heuristics(simplify)}
;

// proofScript exists
omaxGreater{ 
 \schemaVar \term Ord i, i0, i1; 
   \find(olt(omax(i0,i1),i))
   \replacewith(olt(i0,i)&olt(i1,i))
   \heuristics(simplify)}
;

// proofScript exists
omaxLeq{ 
 \schemaVar \term Ord i, i0, i1; 
   \find(oleq(i,omax(i0,i1)))
   \replacewith(oleq(i,i0)|oleq(i,i1))
   \heuristics(simplify)}
;

// proofScript exists
omaxGeq{ 
 \schemaVar \term Ord i, i0, i1; 
   \find(oleq(omax(i0,i1),i))
   \replacewith(oleq(i0,i)&oleq(i1,i))
   \heuristics(simplify)}
;

// proofScript exists
omax0Left{ 
 \schemaVar \term Ord i; 
 \find(omax(o_0,i))
  \replacewith(i)
  \heuristics(concrete)
};

// proofScript exists
omax0Right{ 
 \schemaVar \term Ord i; 
 \find(omax(i,o_0))
  \replacewith(i)
  \heuristics(concrete)
};

// proofScript exists
irrByolt{ 
 \schemaVar \term Ord i,j; 
 \assumes(olt(i,j) ==>)
  \find(olt(j,i) ==>)
  \inSequentState
  \closegoal
  \heuristics(closure)
};

// proofScript exists
irrByoltleq{ 
 \schemaVar \term Ord i,j; 
 \assumes(oleq(i,j) ==>)
  \find(olt(j,i) ==>)
  \inSequentState
  \closegoal
  \heuristics(closure)
};

// proofScript exists
o0notSucc{
   \schemaVar \term Ord i;
   \find(oadd(i,o_1)=o_0)
   \replacewith(false)
   \heuristics(concrete)
 };

// proofScript exists
olt2oleq{
   \schemaVar \term Ord i,j;
   \assumes(olt(i,j)==>)
   \find(==>oleq(i,j))
   \inSequentState
   \replacewith(==>true)
   \heuristics(simplify)
 };


//--------------------------------------------------------------------------
//
// derived taclets on osup
//
//--------------------------------------------------------------------------

// proofScript exists
osupEQDef{  
  \schemaVar \variables Ord nv,nv1,nv2;
  \schemaVar \term Ord i,j,k;
  \find(==> osup{nv;}(j,i) = k)
  \varcond(\notFreeIn(nv,j), \notFreeIn(nv1,j),\notFreeIn(nv2,j), \notFreeIn(nv1,i),\notFreeIn(nv2,i),
           \notFreeIn(nv,k), \notFreeIn(nv1,k), \notFreeIn(nv2,k) )
  \replacewith( ==> 
  \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), k)) &
  \forall nv2;(
       \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), nv2)) ->
         oleq(k, nv2)))
  };

// proofScript exists
osup0{ 
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i;
  \find(osup{nv;}(o_0,i))
  \replacewith(o_0)
  \heuristics(simplify)
  };

// proofScript exists
oselfSup{ 
  \schemaVar \variables Ord nv, lambda;
 \add(\forall nv;(lim(nv) -> osup{lambda;}(nv,lambda) = nv)==>)
};

// proofScript exists
oselfSupSucc{ 
  \schemaVar \variables Ord nv, lambda;
 \add(\forall nv; osup{lambda;}(oadd(nv,o_1),lambda) = nv==>)
};

// proofScript exists
oInd{ 
  \schemaVar \variables Ord nv,nv1;
  \schemaVar \formula phi;
  \find (==> \forall nv;phi)
  \varcond(\notFreeIn(nv1,phi))
  "Base Case":      \add(==> {\subst nv; o_0}phi); 
  "Successor Case": \add(==> \forall nv;   (phi ->  {\subst nv; (oadd(nv,o_1))}phi)); 
  "Limit Case":     \add(==> (\forall nv1; (
                         (lim(nv1) &\forall nv; (olt(nv,nv1) -> phi)) ->  {\subst nv; nv1}phi)))
   }; 

// proofScript exists
osupSucc{ 
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i, j;
  \find(osup{nv;}(oadd(j,o_1),i))
  \varcond(\notFreeIn(nv,j))
  \replacewith(omax(osup{nv;}(j,i),{\subst  nv;(j)}i))
  }; 

// proofScript exists
osupEqualTerms{ 
   \schemaVar \variables Ord nv;
   \schemaVar \term Ord i1,i2,alpha;
   \find(\forall nv;(olt(nv,alpha) -> i1 = i2) ==>)
   \varcond(\notFreeIn(nv,alpha))
   \add(osup{nv;}(alpha,i1) = osup{nv;}(alpha,i2)==>)
};

// proofScript exists
osupMutualCofinal{ 
   \schemaVar \variables Ord nv1,nv2, i,j;
   \schemaVar \term Ord i1,i2,alpha1, alpha2;
  \find(==> osup{nv1;}(alpha1,i1) = osup{nv2;}(alpha2,i2))
    \varcond(
    \notFreeIn(nv1,alpha1), \notFreeIn(nv2,alpha2),
    \notFreeIn(nv1,alpha2), \notFreeIn(nv2,alpha1),
    \notFreeIn(i,alpha1), \notFreeIn(j,alpha2),
    \notFreeIn(i,alpha2), \notFreeIn(j,alpha1),
    \notFreeIn(i,i1), \notFreeIn(j,i2),
    \notFreeIn(j,i1), \notFreeIn(i,i2)
    )
   \replacewith(==>
    \forall i;(olt(i,alpha1)->\exists j;(olt(j,alpha2) & oleq({\subst nv1;i}i1,{\subst nv2;j}i2)))
    &
    \forall j;(olt(j,alpha2)->\exists i;(olt(i,alpha1) & oleq({\subst nv2;j}i2,{\subst nv1;i}i1))))
};

// proofScript exists
osupLocalLess{ 
     \schemaVar \term Ord i1,i2,b;
     \schemaVar \variables Ord lambda;
     \find(\forall lambda;(olt(lambda,b) -> oleq(i1,i2)) ==>)
    \varcond(
    \notFreeIn(lambda,b)
     )
    \add(oleq(osup{lambda;}(b,i1),osup{lambda;}(b,i2)) ==>)
};

// proofScript exists
osupShorter{ 
   \schemaVar \term Ord b1,b2,i;
  \schemaVar \variables Ord lambda;
  \find(oleq(b1,b2)==>)
      \varcond(
    \notFreeIn(lambda,b1), \notFreeIn(lambda,b2))
  \add( oleq(osup{lambda;}(b1,i), osup{lambda;}(b2,i)) ==>)
};

// proofScript exists
oadd0Left{ 
 \schemaVar \term Ord i;
 \find(oadd(o_0,i))
 \replacewith(i)
 \heuristics(concrete)
};

// proofScript exists
oadd01{ 
 \find(oadd(o_0,o_1))
 \replacewith(o_1)
 \heuristics(concrete)
};

// proofScript exists
oDiff01{ 
   \find(o_0=o_1)
   \replacewith(false)
   \heuristics(concrete)
};

// proofScript exists
olt_O1{ 
   \find (olt(o_0, o_1))
   \replacewith(true)
   \heuristics(concrete) 
};

// proofScript exists
//  but needs interaction at the end
olt_one{ 
   \schemaVar \term Ord i;
   \find (olt(i, o_1))
   \replacewith (i=o_0) 
   \heuristics(concrete) 
};

// proofScript exists
osup1{ 
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i;
  \find(osup{nv;}(o_1,i))
  \replacewith({\subst  nv; (o_0)}i)
 \heuristics(simplify)
  };


// proofScript exists
olt_discret{ 
    \schemaVar \term Ord i;
   \find (olt(o_0, i)) 
   \replacewith(oleq(o_1,i))
   \heuristics(simplify_enlarging) };


//--------------------------------------------------------------------------
//
// derived taclets for addition and order
//
//--------------------------------------------------------------------------

// proofScript exists
oaddStrictMonotone{ 
\schemaVar \variables Ord x,y;
  \add( \forall x; \forall y;(
       y!=o_0 -> olt(x,oadd(x,y)))  ==>)
};

// proofScript exists
oaddMonotone{ 
\schemaVar \variables Ord x,y;
  \add( \forall x; \forall y;oleq(x,oadd(x,y))  ==>)
};

// proofScript exists
oaddLeftMonotone{ 
\schemaVar \variables Ord x,y;
  \add( \forall x; \forall y;oleq(y,oadd(x,y))  ==>)
};

// proofScript exists
// but needs manual interaction at the end
zerosum{
   \schemaVar \term Ord i,j;
   \find(oadd(i,j)=o_0)
   \replacewith(i=o_0 & j=o_0)
   \heuristics(simplify)
};

// proofScript exists
oltAddLessLeft{ 
   \schemaVar \term Ord i,j;
 \schemaVar \variables Ord k;
  \find(olt(i,j) ==>)
 \varcond(\notFreeIn(k,i), \notFreeIn(k,j))
  \add(\forall k;olt(oadd(k,i),oadd(k,j))==>) 
};

// proofScript exists
oleqAddLessLeft{ 
   \schemaVar \term Ord i,j;
 \schemaVar \variables Ord k;
  \find(oleq(i,j) ==>)
 \varcond(\notFreeIn(k,i), \notFreeIn(k,j))
  \add(\forall k;oleq(oadd(k,i),oadd(k,j))==>) 
};

// proofScript exists
oleqAddLessRight{ 
   \schemaVar \term Ord i,j;
 \schemaVar \variables Ord k;
  \find(oleq(i,j) ==>)
 \varcond(\notFreeIn(k,i), \notFreeIn(k,j))
  \add(\forall k;oleq(oadd(i,k),oadd(j,k))==>)
};

// proofScript exists
omaxAddL{ 
 \schemaVar \term Ord i,j,k;
  \find(omax(oadd(k,i),oadd(k,j)))
  \replacewith(oadd(k,omax(i,j)))
  \heuristics(simplify)  
};

// proofScript exists
omaxAddR{ 
 \schemaVar \term Ord i,j,k;
  \find(omax(oadd(i,k),oadd(j,k)))
  \replacewith(oadd(omax(i,j),k))
  \heuristics(simplify)  
};

//--------------------------------------------------------------------------
//  
//  Derived  taclets on addition oadd
//  
//--------------------------------------------------------------------------


// proofScript exists
olimAddolim{ 
   \schemaVar \term Ord lambda;
    \schemaVar \variables  Ord ov;
   \find(lim(lambda) ==>)
   \varcond(\notFreeIn(ov,lambda))
   \add(\forall ov;(lim(oadd(ov,lambda)))==>)
};

// proofScript exists
omegaZero{ 
   \find(olt(o_0,omega))
   \replacewith(true)
   \heuristics(concrete)
};



// proofScript exists
omegaOne{ 
   \find(olt(o_1,omega))
   \replacewith(true)
   \heuristics(concrete)
};



// proofScript exists
omegaLeastLim1{
  \schemaVar \term Ord lambda;
  \find(lim(lambda)==>)
  \add(oleq(omega,lambda)==>)
  \heuristics(simplify_enlarging)
};

// proofScript exists
omegaLeastLim2{
  \schemaVar \term Ord lambda;
  \assumes(lim(lambda)==>)
  \find(olt(lambda,omega)==>)
  \inSequentState
   \closegoal
  \heuristics(closure)
};

// proofScript exists
omegaLeastLim3{
  \schemaVar \term Ord lambda;
  \assumes(lim(lambda)==>)
  \find(oleq(lambda,omega)==>)
  \inSequentState
   \add(lambda=omega==>)
  \heuristics(simplify)
};
// proofScript exists

limitZero{ 
   \schemaVar \term Ord lambda;
   \assumes(lim(lambda)==>)
   \find(olt(o_0,lambda))
   \inSequentState
   \replacewith(true)
   \heuristics(concrete)
};

// proofScript exists
limitOne{ 
   \schemaVar \term Ord lambda;
   \assumes(lim(lambda)==>)
   \find(olt(o_1,lambda))
   \inSequentState
   \replacewith(true)
   \heuristics(concrete)
};


// proofScript exists
oaddRightInjective{ 
    \schemaVar \term Ord i,j,k;
    \find(oadd(k,i) = oadd(k,j) ==>)
    \add(i=j ==>)
   \heuristics(simplify_enlarging)
};

// proofScript exists
olimDedekind{ 
    \schemaVar \term Ord j;
    \schemaVar \variables Ord i;
    \assumes(lim(j)==>)
    \varcond(\notFreeIn(i,j))
    \add(\forall i;(olt(i,j) -> olt(oadd(i,o_1),j))==>)
};

// proofScript exists
oaddLessOmega{ 
    \schemaVar \term Ord i,j;
    \assumes(olt(i,omega) ==>)
    \find(olt(j,omega)==>)
    \add(olt(oadd(i,j),omega)==>)
};

// The following taclet is a workaround
// for deficiencies of proofScript
// which cannot apply the previous taclet
// proofScript exists
oaddLessOmegaAxiom{ 
    \schemaVar \variables Ord i,j;
    \add(\forall i;(\forall j;(olt(i,omega) & olt(j,omega) -> olt(oadd(i,j),omega)))==>)
};

// proofScript exists
osupOmega{ 
 \schemaVar \variables Ord lambda;
 \add(omega = osup{lambda;}(omega,lambda) ==>)
};

// proofScript exists
oaddLeftomega{ 
    \schemaVar \term Ord i;
    \assumes(olt(i,omega) ==>)
   \find(oadd(i,omega))
   \inSequentState
   \replacewith(omega)
   \heuristics(concrete)
};

// proofScript exists
oaddLeftAbsorb{ 
    \schemaVar \term Ord i,lambda;
    \assumes(olt(i,omega) & oleq(omega,lambda) ==>)
   \find(oadd(i,lambda))
   \inSequentState
   \replacewith(lambda)
};

// proofScript exists
repLimPlusNat{ 
    \schemaVar \variables Ord ov, lambda, n;
   \add(\forall ov ;(oleq(omega,ov) ->
       \exists lambda;\exists n;(lim(lambda) & olt(n,omega) & ov = oadd(lambda,n)))
        ==>)
};

// proofScript exists
ordDiff{ 
  \schemaVar \term Ord i,j;
  \schemaVar \variables Ord k;
  \find(oleq(i,j)==>)
   \varcond(\notFreeIn(k,i),\notFreeIn(k,j))
  \add(\exists k;(oadd(i,k)=j)  ==>)
};

// proofScript exists
oltPlusOne{ 
  \schemaVar \term Ord i,j;
   \find(olt(i,j)==>)
  \add( olt(oadd(i,o_1),oadd(j,o_1))  ==>)
};

// proofScript exists
oAddOneInj{ 
  \schemaVar \term Ord i,j;
   \find(oadd(i,o_1) = oadd(j,o_1) ==>)
  \add(i=j  ==>)
   \heuristics(simplify_enlarging)
};

// proofScript exists
oAddOltPreserv{ 
  \schemaVar \term Ord i,j,k;
   \find(olt(oadd(i,j),oadd(i,k)) ==>)
  \add(olt(j,k)  ==>)
   \heuristics(simplify_enlarging)
};

osupAddStaticTerm{ 
   \schemaVar \term Ord i,j,b;
   \schemaVar \variables Ord lambda;
    \assumes(b!=o_0 ==>)
   \find(osup{lambda;}(b,oadd(i,j)))
   \inSequentState
    \varcond(\notFreeIn(lambda,b),  
             \notFreeIn(lambda,i))
   \replacewith(oadd(i,osup{lambda;}(b,j)))
}; 


//  proofScript exists
// proofScript exists
oaddAssoc{ 
   \schemaVar \term Ord i,j,k;
   \find(oadd(i,oadd(j,k)))
   \replacewith(oadd(oadd(i,j),k))
};

//--------------------------------------------------------------------------
//  
//  Derived  taclets on multiplication  otimes 
//  
//--------------------------------------------------------------------------

// proofScript exists
otimesOneRight{ 
  \schemaVar \term Ord i;
   \find(otimes(i,o_1))
   \replacewith(i)
   \heuristics(concrete)
};

// proofScript exists
otimesOneLeft{ 
  \schemaVar \term Ord i;
   \find(otimes(o_1,i))
   \replacewith(i)
   \heuristics(concrete)
};

// proofScript exists
otimesZeroLeft{ 
  \schemaVar \term Ord i;
   \find(otimes(o_0,i))
   \replacewith(o_0)
   \heuristics(concrete)
};

// proofScript exists
otimesMonotoneQ{
 \schemaVar \variables Ord i,j, k;
 \add(\forall k;\forall i;\forall j;((olt(o_0,k) & olt(i,j)) -> olt(otimes(k,i),otimes(k,j)))==>)
};


// proofScript exists
otimesWeakMonotoneQ{
 \schemaVar \variables Ord i,j, k;
 \add(\forall k;\forall i;\forall j;((oleq(i,j)) -> oleq(otimes(k,i),otimes(k,j)))==>)
};


// proofScript exists
otimesMonotone{
 \schemaVar \term Ord i,j,k;
 \assumes(olt(o_0,k)==>)
 \find(olt(i,j)==>)
 \inSequentState
 \add(olt(otimes(k,i),otimes(k,j))==>)
};


// proofScript exists
// but needs manual interaction at the end
otimesMonotoneRev{
 \schemaVar \term Ord i,j,k;
 \find(olt(otimes(k,i),otimes(k,j))==>)
 \add(olt(o_0,k) & olt(i,j)  ==>)
};


// proofScript exists
otimesLeftInjective{
  \schemaVar \term Ord i,j,k;
  \assumes(olt(o_0,k)==>)
  \find(otimes(k,i)=otimes(k,j)==>)
  \inSequentState
  \add(i=j==>)
  \heuristics(simplify_enlarging)
};

// proofScript exists
otimesLeftMonotone{
 \schemaVar \term Ord i,j;
 \schemaVar \variables Ord k;
 \find(oleq(i,j)==>)
 \varcond(\notFreeIn(k,i),\notFreeIn(k,j))
 \add(\forall k;oleq(otimes(i,k),otimes(j,k))==>)
};

// proofScript exists
otimesRightMonotoneQ{
 \schemaVar \variables Ord i,j;
 \add(\forall i;\forall j;((o_0 != i -> oleq(j,otimes(i,j))))==>)
};

// proofScript exists
// but needs manual interaction at the end
otimesZero{
 \schemaVar \term Ord i,j;
 \find(otimes(i,j)=o_0)
 \replacewith(i=o_0 | j=o_0)
 \heuristics(simplify)
};


// The following taclet is a workaround
// for deficiencies of proofScript
// which cannot apply the next taclet
// proofScript exists
otimesFiniteAxiom{
 \schemaVar \variables Ord x,y;
 \add(\forall x;\forall y;(olt(x,omega) & olt(y,omega) -> olt(otimes(x,y),omega)) ==>)
};

// proofScript exists
otimesFinite{
 \schemaVar \term Ord i,j;
 \assumes(olt(i,omega)==>)
 \find(olt(j,omega)==>)
 \inSequentState
 \add(olt(otimes(i,j),omega)==>)
};

// proofScript exists
otimesNomegaQ{
   \schemaVar \variables Ord i;
   \add(\forall i;(
       (olt(i,omega) & !i=o_0) -> otimes(i,omega) = omega)==>)
};

// proofScript exists
otimesNomega{
   \schemaVar \term Ord i;
   \assumes(olt(i,omega)==>)
   \find(otimes(i,omega))
   \inSequentState
   \replacewith(\if(i=o_0)\then(o_0)\else(omega))
   \heuristics(concrete)
};


//proofScript exits
// requires trivial manual interaction at the end 
omaxTimesL{ 
 \schemaVar \term Ord i,j,k;
  \find(omax(otimes(k,i),otimes(k,j)))
  \replacewith(otimes(k,omax(i,j)))
  \heuristics(simplify)  
};

//proofScript exits
// requires trivial manual interaction at the end 
omaxTimesR{ 
 \schemaVar \term Ord i,j,k;
  \find(omax(otimes(i,k),otimes(j,k)))
  \replacewith(otimes(omax(i,j),k))
  \heuristics(simplify)  
};


osupTimesStaticTerm{ 
   \schemaVar \term Ord i,j,b;
   \schemaVar \variables Ord lambda;
  \assumes(i!=o_0 ==>)
   \find(osup{lambda;}(b,otimes(i,j)))
   \inSequentState
    \varcond(\notFreeIn(lambda,b),  
             \notFreeIn(lambda,i))
   \replacewith(otimes(i,osup{lambda;}(b,j)))
}; 

odistributiveQ{
   \schemaVar \variables Ord i,j,k;
   \add(\forall i;\forall j;\forall k;(
         otimes(i,oadd(j,k)) = oadd(otimes(i,j),otimes(i,k)))
       ==>)
};

otimesAssoc{ 
   \schemaVar \term Ord i,j,k;
   \find(otimes(i,otimes(j,k)))
   \replacewith(otimes(otimes(i,j),k))
};

//--------------------------------------------------------------------------
//  
//  Derived  taclets on exponentiation   oexp
//  
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//  
//  Derived  taclets on decomposition 
//  
//--------------------------------------------------------------------------

// proofScript exists
oleastMultiple{
   \schemaVar \variables Ord i,j,k;
   \add(\forall i;(\forall j;(j!=o_0 ->
        \exists k;(oleq(otimes(j,k),i) & olt(i,otimes(j,oadd(k,o_1)))))) 
       ==>)
};

// proofScript exists
odivQ{
   \schemaVar \variables Ord i,j,d,r;
   \add(\forall i;(\forall j;(j!=o_0 ->
        \exists d;\exists r;(i = oadd(otimes(j,d),r) & olt(r,j))))
       ==>)
};
// revision upto here
}



