// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//

// This file contains only the RULES for the data type Ord
// of ordinals.
// The rules come in sections
//  * Core Axioms
//  * Definitional Extensions 
//  * Additional Axioms
//  * Derived  Taclets
// 


\rules{


//--------------------------------------------------------------------------
//  
//  Core Axioms
//  
//--------------------------------------------------------------------------

 olt_trans_Axiom{
   \schemaVar \variables Ord nv, nv0, nv1;

   \add(  \forall nv;(\forall nv0; (\forall nv1;(
           (olt(nv,nv0) &  olt(nv0,nv1)) -> olt(nv,nv1)))) ==>)
  };

  olt_irref_Axiom{
    \schemaVar \variables Ord nv;

  \add(  \forall nv;( (!olt(nv,nv))) ==>)
  };

  olt_total_Axiom{
    \schemaVar \variables Ord nv, nv1;

  \add(  \forall nv;(  \forall nv1;(
           olt(nv,nv1) | nv = nv1 | olt(nv1,nv))) ==>)
  };

 oleq_zeroAxiom{
    \schemaVar \variables Ord nv;
    \add(  \forall nv;(  oleq('o_0',nv)) ==>)
  };

 osupDef{
  \schemaVar \variables Ord nv,nv1,nv2;
  \schemaVar \term Ord i,j;
  \find(osup{nv;}(j,i))
  \varcond(\notFreeIn(nv,j), \notFreeIn(nv1,j),\notFreeIn(nv2,j), \notFreeIn(nv1,i),\notFreeIn(nv2,i))
  \add(\forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), osup{nv;}(j,i))),
  \forall nv2;(
       \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), nv2)) ->
         oleq(osup{nv;}(j,i), nv2))   ==> )
  };




//--------------------------------------------------------------------------
//  
//  Definitional Extensions 
//  
//--------------------------------------------------------------------------


 oleq_Def{
       \schemaVar \variables Ord nv, nv1;
       \schemaVar \term Ord i,i1;
       \find(oleq(i,i1))
       \add( \forall nv;( \forall nv1;(
         oleq(nv,nv1) <-> olt(nv,nv1) | nv = nv1)) ==> )
       };

 olimDef{
      \schemaVar \variables Ord nv;
      \schemaVar \term Ord i;
      \find(lim(i))
      \varcond (\notFreeIn(nv,i))
      \add(!\exists nv;(i=oadd(nv,'o_1'))==>) };

 oadd_Def0{
     \schemaVar \term Ord i;
     \find(oadd(i,'o_0'))
     \replacewith(i)
     \heuristics(simplify) };

 oadd_DefSucc{
     \schemaVar \term Ord i,i1;
     \find(oadd(i,oadd(i1,'o_1')))
     \replacewith(oadd(oadd(i,i1),'o_1'))};

 oadd_DefLim{
     \schemaVar \variables Ord nv;
     \schemaVar \term Ord i,i1;
     \find(oadd(i,i1))
      \varcond (\notFreeIn(nv,i),\notFreeIn(nv,i1))
     \add((lim(i1) ->  oadd(i,i1) = osup{nv;}(i1,oadd(i,nv))) ==> )};

omaxDef{
      \schemaVar \term Ord i,i1;
      \find(omax(i,i1))
      \replacewith(\if(olt(i,i1))\then(i1)\else(i))
};

//--------------------------------------------------------------------------
//  
//  Additional Axioms 
//  
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//  
//  Derived  Taclets
//  
//--------------------------------------------------------------------------

 olt_trans{ 
   \schemaVar \term Ord i, i0, i1; 
   \assumes (olt(i, i0) ==>) \find (olt(i0, i1) ==>) 
   \add (olt(i, i1) ==>)};

  olt_irref{
    \schemaVar \term Ord i;
   \find (olt(i, i)) 
   \replacewith (false) 
   \heuristics(simplify) };

 oleq_replace{
   \schemaVar \term Ord i,i1;
   \find(oleq(i,i1))
   \replacewith(olt(i,i1) | i = i1)
   \heuristics(simplify)
 };

 oleq_trans{
   \schemaVar \variables Ord nv, nv0, nv1;
   \add(  \forall nv;(\forall nv0; (\forall nv1;(
           (oleq(nv,nv0) &  oleq(nv0,nv1)) -> oleq(nv,nv1)))) ==>)
  };

 oleq_antisym{
  \schemaVar \term Ord i, i1; 
  \assumes(oleq(i,i1) ==>)
  \find(oleq(i1,i) ==>)
  \add(i=i1 ==>)  
  \heuristics(simplify)
  };

 oltleq_trans{ 
   \schemaVar \term Ord i, i0, i1; 
   \assumes (oleq(i, i0) ==>) 
   \find (olt(i0, i1) ==>) 
   \add (olt(i, i1) ==>)};

 oleqolt_trans{ 
   \schemaVar \term Ord i, i0, i1; 
   \assumes (olt(i, i0) ==>) 
   \find (oleq(i0, i1) ==>) 
   \add (olt(i, i1) ==>)};

osupEQDef{ \schemaVar \variables Ord nv,nv1,nv2;
  \schemaVar \term Ord i,j,k;
  \find(==> osup{nv;}(j,i) = k)
  \varcond(\notFreeIn(nv,j), \notFreeIn(nv1,j),\notFreeIn(nv2,j), \notFreeIn(nv1,i),\notFreeIn(nv2,i),
           \notFreeIn(nv,k), \notFreeIn(nv1,k), \notFreeIn(nv2,k) )
  \replacewith( ==> \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), k)) &
  \forall nv2;(
       \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), nv2)) ->
         oleq(k, nv2)))
  };

 osup0{
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i;
  \find(osup{nv;}('o_0',i))
  \replacewith('o_0')
  \heuristics(simplify)
  };



 olt_zero{
    \schemaVar \term Ord i;
   \find (olt(i, 'o_0')) 
   \replacewith (false) 
   \heuristics(simplify) };

// proved upto here

 olt_discret{
    \schemaVar \term Ord i;
   \find (olt('o_0', i)) 
   \replacewith(oleq('o_1',i))
   \heuristics(simplify) };

 osup1{
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i;
  \find(osup{nv;}('o_1',i))
  \replacewith({\subst  nv; ('o_0')}i)
 \heuristics(simplify)
  };

 osupSucc{
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i, j;
  \find(osup{nv;}(oadd(j,'o_1'),i))
  \varcond(\notFreeIn(nv,j))
  \replacewith(omax(osup{nv;}(j,i),{\subst  nv;(j)}i))
  };  

}