// We don't have any rule for {event}(event)

\schemaVariables{
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
}


\rules { 
//===================General=====================
 parallelUpdateAssociative {
    \schemaVar \update u1, u2, u3;
    
    \find (u1 || (u2 || u3))
    \replacewith(u1 || u2 || u3)
    
    \heuristics(simplify)
 };
 
 applyUpdateOnEvent {
 	\schemaVar \update u;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term int ts;
 	
 	\find({u}(\event(rw, loc, ts)))
 	
 	\replacewith(\event({u}rw, {u}loc, {u}ts))
 	
 	\heuristics(update_apply_on_update)
 };

 applyUpdateOnInverseEvent {
 	\schemaVar \update u;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term int ts;
 	
 	\find({u}(\invEvUp(rw, loc, ts)))
 	
 	\replacewith(\invEvUp({u}rw, {u}loc, {u}ts))
 	
 	\heuristics(update_apply_on_update)
	 	
};
 applyEventOnEvent {
 	\schemaVar \term LocSet loc1,loc2;
 	\schemaVar \term EventMarker rw1,rw2;
 	\schemaVar \term int ts1,ts2;
 	
 	\find({\event(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))
 	
 	\replacewith(\event({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))
 	
 	\heuristics(update_apply_on_update)
	 	
 };
 
 applyInverseEventOnEvent {
 	\schemaVar \term LocSet loc1,loc2;
 	\schemaVar \term EventMarker rw1,rw2;
 	\schemaVar \term int ts1,ts2;
 	
 	\find({\invEvUp(rw1, loc1, ts1)}(\event(rw2, loc2, ts2)))
 	
 	\replacewith(\event({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))
 	
 	\heuristics(update_apply_on_update)
	 	
 };
 
 applyEventOnInverseEvent {
 	\schemaVar \term LocSet loc1,loc2;
 	\schemaVar \term EventMarker rw1,rw2;
 	\schemaVar \term int ts1,ts2;
 	
 	\find({\event(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))
 	
 	\replacewith(\invEvUp({\event(rw1, loc1, ts1)}rw2, {\event(rw1, loc1, ts1)}loc2, {\event(rw1, loc1, ts1)}ts2))
 	
 	\heuristics(update_apply_on_update)
	 	
 };

 applyInverseEventOnInverseEvent {
 	\schemaVar \term LocSet loc1,loc2;
 	\schemaVar \term EventMarker rw1,rw2;
 	\schemaVar \term int ts1,ts2;
 	
 	\find({\invEvUp(rw1, loc1, ts1)}(\invEvUp(rw2, loc2, ts2)))
 	
 	\replacewith(\invEvUp({\invEvUp(rw1, loc1, ts1)}rw2, {\invEvUp(rw1, loc1, ts1)}loc2, {\invEvUp(rw1, loc1, ts1)}ts2))
 	
 	\heuristics(update_apply_on_update)
	 	
 };
 
//-----------------------------------------------------------------------------------------
//                        Event Elimination Rules 
//-----------------------------------------------------------------------------------------
 
 elimUpdateOnRigidTerm1 {
    \schemaVar \term[rigid] any t;
	\schemaVar \update u;
	
	\find({u}t)
	
	\replacewith(t)
	
	\heuristics(update_elim)
 };
 
 elimEventOnRigidTerm2 {
	\schemaVar \term any t, result;
	\schemaVar \update u;	
	
	\find({u}t)
	\varcond(\applyEventOnRigid(u, t, result))
	
	\replacewith(result)
	
	\heuristics(update_elim)
 };

 elimEventOnRigidFormula1 {  
    \schemaVar \formula[rigid] phi;
	\schemaVar \update u;
	
	\find({u}phi)
	
	\replacewith(phi)
	
	\heuristics(update_elim)
 };
 
 elimEventOnRigidFormula2 {
	\schemaVar \formula phi, result;
	\schemaVar \update u;
	
	\find({u}phi)
	\varcond(\applyEventOnRigid(u, phi, result))
	
	\replacewith(result)
	
	\heuristics(update_elim)
 };

 applyEventOnElementary {
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;	
	\schemaVar \term int ts;
	
	\find({\event(rw, loc, ts)}(pv := t))
	
	\replacewith((pv := {\event(rw, loc, ts)}t))
	
	\heuristics(update_apply_on_update)
 };
   
 elimEventOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
		
	\find({\event(rw, loc, ts)}pv)
	
	\replacewith(pv)
	
	\heuristics(update_elim)
 };
    
 elimEventOnSkip {
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
	
	\find({\event(rw, loc, ts)}skip)
	
	\replacewith(skip)
	
	\heuristics(update_elim)
 };

//-----------------------------------------------------------------------------------------
//                        Spliting Rules 
//-----------------------------------------------------------------------------------------

 splitNoRaW {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noRaW(union(loc1,loc2)))
    \replacewith(noRaW(loc1) & noRaW(loc2))
    
    \heuristics(simplify)
    
 };
 
 splitNoWaR {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noWaR(union(loc1,loc2)))
    \replacewith(noWaR(loc1) & noWaR(loc2))
    
    \heuristics(simplify)
    
 };
 
 splitNoWaW {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noWaW(union(loc1,loc2)))
    \replacewith(noWaW(loc1) & noWaW(loc2))
    
    \heuristics(simplify)
 };
 
 splitNoR {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noR(union(loc1,loc2)))
    \replacewith(noR(loc1) & noR(loc2))
    
    \heuristics(simplify)
 };
 
 splitNoW {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noW(union(loc1,loc2)))
    \replacewith(noW(loc1) & noW(loc2))
    
    \heuristics(simplify)
 };
 
//-------------------------------------------------- 

 splitNoRaWEQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noRaW(EQ)) \sameUpdateLevel
    \replacewith(noRaW(loc1) & noRaW(loc2))
  
    \heuristics(simplify)
 };
 
 splitNoWaREQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noWaR(EQ)) \sameUpdateLevel
    \replacewith(noWaR(loc1) & noWaR(loc2))
    
    \heuristics(simplify)
  
 };
 
 splitNoWaWEQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noWaW(EQ)) \sameUpdateLevel
    \replacewith(noWaW(loc1) & noWaW(loc2))
  
    \heuristics(simplify)
 };
 
 splitNoREQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noR(EQ)) \sameUpdateLevel
    \replacewith(noR(loc1) & noR(loc2))
  
    \heuristics(simplify)
 };
 
 
 splitNoWEQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noW(EQ)) \sameUpdateLevel
    \replacewith(noW(loc1) & noW(loc2))
    
    \heuristics(simplify)
  
 };
 
//--------------------------------------------------  noR Or noW Known-------------------------------------------------------------------
 noRKnownForSupersetOrSubset{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noR(loc1) ==> )
	\find(==> noR(loc2))
	
	\replacewith(==>noR(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(dep_pred_known_2)
	};
// noRKnownForSupersetOrSubsetDef{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noR(loc1) ==> )
//	\find(==> noR(loc2))
//	
//	\replacewith(==>noR(setMinus(loc2,loc1)))
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations_def)
//	};
// noRKnownForSupersetOrSubset2{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noR(loc1) ==> )
//	\find(==> noR(loc2))
//	
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations)
//	};
//----------------------------------------------------------- 
 noWKnownForSupersetOrSubset{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noW(loc1) ==> )
	\find(==> noW(loc2))
	
	\replacewith(==>noW(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(dep_pred_known_2)
	};

//noWKnownForSupersetOrSubsetDef{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noW(loc1) ==> )
//	\find(==> noW(loc2))
//	
//	\replacewith(==>noW(setMinus(loc2,loc1)))
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations_def)
//	};
//noWKnownForSupersetOrSubset2{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noW(loc1) ==> )
//	\find(==> noW(loc2))
//	
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations)
//	};

//---------------------------------------------------
noRaWKnownForSupersetOrSubset{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noRaW(loc1) ==> )
	\find(==> noRaW(loc2))
	
	\replacewith(==>noRaW(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(dep_pred_known_3)
	};
//noRaWKnownForSupersetOrSubsetDef{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noRaW(loc1) ==> )
//	\find(==> noRaW(loc2))
//	
//	\replacewith(==>noRaW(setMinus(loc2,loc1)))
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations_def)
//	};
//noRaWKnownForSupersetOrSubset2{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noRaW(loc1) ==> )
//	\find(==> noRaW(loc2))
//	
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations)
//	};

//---------------------------------------------------
noWaRKnownForSupersetOrSubset{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noWaR(loc1) ==> )
	\find(==> noWaR(loc2))
	
	\replacewith(==>noWaR(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(dep_pred_known_3)
};
//noWaRKnownForSupersetOrSubsetDef{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noWaR(loc1) ==> )
//	\find(==> noWaR(loc2))
//	
//	\replacewith(==>noWaR(setMinus(loc2,loc1)))
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations_def)
//	};	
//noWaRKnownForSupersetOrSubset{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noWaR(loc1) ==> )
//	\find(==> noWaR(loc2))
//	
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations)
//	};
//--------------------------------------------------
noWaWKnownForSupersetOrSubset{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noWaW(loc1) ==> )
	\find(==> noWaW(loc2))
	
	\replacewith(==>noWaW(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(dep_pred_known_3)
	}; 
//noWaWKnownForSupersetOrSubsetDef{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noWaW(loc1) ==> )
//	\find(==> noWaW(loc2))
//	
//	\replacewith(==>noWaW(setMinus(loc2,loc1)))
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations_def)
//	}; 
// noWaWKnownForSupersetOrSubset2{
//	\schemaVar \term LocSet loc1, loc2;
//	
//	\assumes(noWaW(loc1) ==> )
//	\find(==> noWaW(loc2))
//	
//	\add(==> subset(loc2,loc1))
//	\heuristics(saturate_dep_locset_relations)
//	};
//------------------------------------------------
noReadKnownForSupersetOrSubsetOfNoRaWDef{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noR(loc1) ==> )
	\find(==>noRaW(loc2))
	
	\replacewith(==>noRaW(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations_def)
};

noReadKnownForSupersetOrSubsetOfNoRaW2{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noR(loc1) ==> )
	\find(==>noRaW(loc2))
	
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations)
};
//---------------------------------------------------
noWriteKnownForSupersetOrSubsetOfNoRaWDef{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noW(loc1) ==> )
	\find(==>noRaW(loc2))
	
	\replacewith(==>noRaW(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations_def)
};

noWriteKnownForSupersetOrSubsetOfNoRaW2{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noW(loc1) ==> )
	\find(==>noRaW(loc2))
	
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations)
};
//-------------------------------------------------------------------------------
noWriteKnownForSupersetOrSubsetOfNoWaRDef{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noW(loc1) ==> )
	\find(==>noWaR(loc2))
	
	\replacewith(==>noWaR(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations_def)
};

noWriteKnownForSupersetOrSubsetOfNoWaR2{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noW(loc1) ==> )
	\find(==>noWaR(loc2))
	
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations)
};
//-------------------------------------------------------------------------------

noReadKnownForSupersetOrSubsetOfNoWaRDef{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noR(loc1) ==> )
	\find(==>noWaR(loc2))
	
	\replacewith(==>noWaR(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations_def)
};

noReadKnownForSupersetOrSubsetOfNoWaR2{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noR(loc1) ==> )
	\find(==>noWaR(loc2))
	
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations)
};
//-------------------------------------------------------------------------------

noWriteKnownForSupersetOrSubsetOfNoWaWDef{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noW(loc1) ==> )
	\find(==>noWaW(loc2))
	
	\replacewith(==>noWaW(setMinus(loc2,loc1)))
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations_def)
};

noWriteKnownForSupersetOrSubsetOfNoWaW2{
	\schemaVar \term LocSet loc1, loc2;
	
	\assumes(noW(loc1) ==> )
	\find(==>noWaW(loc2))
	
	\add(==> subset(loc2,loc1))
	\heuristics(saturate_dep_locset_relations)
};
 
//-----------------------------------------------------------------------------------------
//                        Update Parallel to Event Rules 
//-----------------------------------------------------------------------------------------

 applyUpdateParallelToEventOnElementary {
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
	\schemaVar \update u;

	\find({u || \event(rw, loc, ts)}(pv := t))
	
	\replacewith((pv := {u || \event(rw, loc, ts)}t))
	
	\heuristics(update_apply_on_update)//userTaclets1)
 };
    
 applyUpdateParallelToEventOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
	\schemaVar \update u;
		
	\find({u || \event(rw, loc, ts)}pv)
	
	\replacewith({u}pv)
	
	\heuristics(update_apply)//userTaclets1)
 };
    
 applyUpdateParallelToEventOnSkip {
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
	\schemaVar \update u;
	
	\find({u || \event(rw, loc, ts)}skip)
	
	\replacewith(skip)
	
	\heuristics(update_elim)//userTaclets1)
 };
//
elimStateUpdatesBeforeNoRaW{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noRaW(tr))
	\replacewith({u}noRaW(tr))
	\heuristics(update_elim)
};
elimStateUpdatesBeforeNoWaR{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noWaR(tr))
	\replacewith({u}noWaR(tr))
	\heuristics(update_elim)
};
elimStateUpdatesBeforeNoWaW{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noWaW(tr))
	\replacewith({u}noWaW(tr))
	\heuristics(update_elim)
};
elimStateUpdatesBeforeNoR{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noR(tr))
	\replacewith({u}noR(tr))
	\heuristics(update_elim)
};
elimStateUpdatesBeforeNoW{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noW(tr))
	\replacewith({u}noW(tr))
	\heuristics(update_elim)
};
//------------------------------------{u || event} Data Dependence Predicates-----------------------------------------------------
updateParallelToReadEventOnNoRaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noRaW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noRaW(tempVar))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2, 
          intersect(loc1, tempVar) = empty ==> );  
//     \replacewith(==> ({u}noW(tempVar)) & {u}noRaW(setMinus(tempVar, loc1)))//Why not (==> ({u}noW(*intersect*(tempVar, loc1))) & ...)?
    \replacewith(==> ({u}noW(intersect(tempVar, loc1))) & {u}noRaW(setMinus(tempVar, loc1)))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2, 
          !(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(update_apply)//userTaclets1)
 };
 
 updateParallelToWriteEventOnNoRaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noRaW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noRaW(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> )
     
     \heuristics(update_apply)//userTaclets1)
 };

//
 updateParallelToWriteEventOnNoWaR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noWaR(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noWaR(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
     	intersect(tempVar, loc1) = empty ==> );
     \replacewith(==> ({u}noR(intersect(tempVar, loc1))) & {u}noWaR(setMinus(tempVar, loc1)))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
     	!(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(update_apply)//userTaclets1)
 };
 
 updateParallelToReadEventOnNoWaR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noWaR(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noWaR(tempVar))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==>)
     \heuristics(update_apply)//userTaclets1)
 };
//
 updateParallelToWriteEventOnNoWaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noWaW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noWaW(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
     	intersect(tempVar, loc1) = empty ==> );
     \replacewith(==> {u}noW(intersect(tempVar, loc1)) & {u}noWaW(setMinus(tempVar, loc1)))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
     	!(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(update_apply)//userTaclets1)
 };
 
 updateParallelToReadEventOnNoWaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noWaW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noWaW(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> )
     \heuristics(update_apply)//userTaclets1)
 };
//
 updateParallelToReadEventOnNoR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noR(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noR(tempVar))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2, 
          intersect(loc1, tempVar) = empty ==> );  
     \replacewith(==> false)
     \add(tempVar = {u || \event(read, loc1, ts)}loc2, 
          !(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(update_apply)//userTaclets1)
 };
 
 updateParallelToWriteEventOnNoR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noR(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noR(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> )
     
     \heuristics(update_apply)//userTaclets1)
 };

 //===================NoW=====================
 updateParallelToWriteEventOnNoW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noW(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2, 
          intersect(loc1, tempVar) = empty ==> );  
     \replacewith(==> false)
     \add(tempVar = {u || \event(write, loc1, ts)}loc2, 
          !(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(update_apply)//userTaclets1)
 };
 
 updateParallelToReadEventOnNoW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noW(tempVar))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==> )
     
     \heuristics(update_apply)//userTaclets1)
 };

//-----------------------------------------------------------------------------------------
//                        Non-Event Update Propagation Rules 
//-----------------------------------------------------------------------------------------
    
 propagateNonEventUpdateONnoRaW{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noRaW(loc))
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noRaW({u}loc))
	
	\heuristics(update_apply)
 };
 
 propagateNonEventUpdateONnoWaR{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noWaR(loc))
	
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noWaR({u}loc))
	
	\heuristics(update_apply)
 };
 
 propagateNonEventUpdateONnoWaW{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noWaW(loc))
	
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noWaW({u}loc))
	
	\heuristics(update_apply)
 };
 
 propagateNonEventUpdateONnoR{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noR(loc))
	
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noR({u}loc))
	
	\heuristics(update_apply)
 };
 
 propagateNonEventUpdateONnoW{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noW(loc))
	
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noW({u}loc))
	
	\heuristics(update_apply)
 };
//-----------------------------------------------------------------------------------------
//                        Event Shifting Rules 
//-----------------------------------------------------------------------------------------
 shiftEventParallelToUpdate {
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	\schemaVar \update u;
 	
 	\find(\event(rw, loc, ts) || u)
 	
 	\varcond(\noEventUpdate(u)) 
 	
 	\replacewith(u || \event(rw, loc, ts))
 	
 	\heuristics(update_apply)
 };

 shiftEventParallelToElementry {
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find(\event(rw, loc, ts) || pv:=t)
 	
 	\replacewith(pv:=t || \event(rw, loc, ts))
 	
 	\heuristics(update_apply)
 };

 shiftEventWithUpdateAtFirstPlace {
 	\schemaVar \update u;
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find(u || \event(rw, loc, ts) || pv:=t)
 	
 	\replacewith(u || pv:=t || \event(rw, loc, ts))
 	
 	\heuristics(update_apply)
 };

 shiftEventWithUpdateAtLastPlace {
 	\schemaVar \update u;
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find(\event(rw, loc, ts) || pv:=t || u)
 	
 	\replacewith(pv:=t || \event(rw, loc, ts) || u)
 	
 	\heuristics(update_apply)
 };

// ----------------------------------Shifting rules for only events-----------------------------------------------------------

 shiftOnlyEventParallelToElementry {
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \update evUp;
 	
 	\find(evUp || pv:=t)
 	\varcond(\onlyEventUpdates(evUp))
 	
 	\replacewith(pv:=t || evUp)
 	
 	\heuristics(update_apply)
 };

 shiftOnlyEventWithUpdateAtFirstPlace {
 	\schemaVar \update evUp;
 	\schemaVar \update u;
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find(u || evUp || pv:=t)
 	\varcond(\onlyEventUpdates(evUp))
 	
 	\replacewith(u || pv:=t || evUp)
 	
 	\heuristics(update_apply)
 };

 shiftOnlyEventWithUpdateAtLastPlace {
 	\schemaVar \update evUp;
 	\schemaVar \update u;
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find( pv:=t || evUp || u)
 	\varcond(\onlyEventUpdates(evUp),\noEventUpdate(u))
 	
 	\replacewith(pv:=t || u || evUp)
 	
 	\heuristics(update_apply)
 };


//-----------------------------------------------------------------------------------------
//                        Simplification Rules for Dependence Predicates
//-----------------------------------------------------------------------------------------
//----------------------------------------NON Event Updates on Data Dependence Predicates-------------------------------------------------
 simplifyNONEventUpdateNoR {
	\schemaVar \update u1,u2;
	\schemaVar \term[rigid] LocSet loc;
// 	\schemaVar \skolemTerm LocSet tempVar;
	
	\find({u1||u2}noR(loc))
	
	\varcond(\noEventUpdate(u1)
	   /*,\new(tempVar, \dependingOn(u)),
            \new(tempVar, \dependingOn(loc))*/)   
	
	\replacewith({u2}noR(loc))
	
	\heuristics(update_apply)
   };
   simplifyNONEventUpdateNoW {
	   \schemaVar \update u1,u2;
	   \schemaVar \term[rigid] LocSet loc;
	
	\find({u1||u2}noW(loc))
	
	\varcond(\noEventUpdate(u1))   
	
	\replacewith({u2}noW(loc))
	
	\heuristics(update_apply)
   };  
 simplifyNONEventUpdateNoRaW {
	\schemaVar \update u1,u2;
	\schemaVar \term[rigid] LocSet loc;
 	
	\find({u1||u2}noRaW(loc))
	
	\varcond(\noEventUpdate(u1))   
	
	\replacewith({u2}noRaW(loc))
	
	\heuristics(update_apply)
   };
   
 simplifyNONEventUpdateNoWaR {
	\schemaVar \update u1,u2;
	\schemaVar \term[rigid] LocSet loc;
	
	\find({u1||u2}noWaR(loc))
	
	\varcond(\noEventUpdate(u1))
	
	\replacewith({u2}noWaR(loc))
	
	\heuristics(update_apply)
        
   };
   
   simplifyNONEventUpdateNoWaW {
	\schemaVar \update u1,u2;
	\schemaVar \term[rigid] LocSet loc;
	
	\find({u1||u2}noWaW(loc))
	
	\varcond(\noEventUpdate(u1))
             
	\replacewith({u2}noWaW(loc))
	
	\heuristics(update_apply)
        
   };
//----------------------------------------Event Updates on Data Dependence Predicates-------------------------------------------------   
 writeEventBeforeNoRaW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	\find({\event(write, loc1, ts)} noRaW(loc2))
 	
 	\replacewith(noRaW({\event(write, loc1, ts)}loc2))
 	
 	\heuristics(update_apply)//userTaclets1)
 };
 
 readEventBeforeNoRaW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find({\event(read, loc1, ts)} noRaW(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))
		
 	\replacewith(noRaW(tempVar))
 	\add(tempVar = {\event(read, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );
 	
 	\replacewith(noW(intersect(loc1, tempVar)) & noRaW(setMinus(tempVar,loc1)))
 	\add(tempVar = {\event(read, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )
 	
 	\heuristics(update_apply)//userTaclets1)
 };
//
 writeEventBeforeNoWaR {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find({\event(write, loc1, ts)} noWaR(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))
		
 	\replacewith(noWaR(tempVar))
 	\add(tempVar = {\event(write, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );
 	
 	\replacewith(noR(intersect(loc1, tempVar)) & noWaR(setMinus(tempVar,loc1)))
 	\add(tempVar = {\event(write, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )
 	
 	\heuristics(update_apply)//userTaclets1)
 };
 
 readEventBeforeNoWaR {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	\find({\event(read, loc1, ts)} noWaR(loc2))
 	
 	\replacewith( noWaR({\event(read, loc1, ts)}loc2))
 	
 	\heuristics(update_apply)//userTaclets1)
 };
 //
 writeEventBeforeNoWaW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find({\event(write, loc1, ts)} noWaW(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))
		
 	\replacewith(noWaW(tempVar))
 	\add(tempVar = {\event(write, loc1, ts)}loc2, intersect(loc1, tempVar) = empty ==> );
 	
 	\replacewith(noW(intersect(loc1, tempVar)) & noWaW(setMinus(tempVar,loc1)))
 	\add(tempVar = {\event(write, loc1, ts)}loc2, !(intersect(loc1, tempVar) = empty) ==> )
 	
 	\heuristics(update_apply)//userTaclets1)
 };
 
 readEventBeforeNoWaW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	\find({\event(read, loc1, ts)} noWaW(loc2))
 	
 	\replacewith( noWaW({\event(read, loc1, ts)}loc2))
 	
 	\heuristics(update_apply)//userTaclets1)
 };
 //
 writeEventBeforeNoW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {\event(write, loc1, ts)} noW(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> noW(tempVar))
     \add(tempVar = {\event(write, loc1, ts)}loc2,
     	intersect(loc1, tempVar) = empty ==> );
     
     \replacewith(==> false)
     \add(tempVar = {\event(write, loc1, ts)}loc2,
     	!(intersect(loc1, tempVar) = empty) ==> )
     
 	\heuristics(update_apply)//userTaclets1)
 };
 
 readEventBeforeNoW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	\find({\event(read, loc1, ts)} noW(loc2))
 	
 	
 	\replacewith( noW({\event(read, loc1, ts)}loc2))
 	
 	\heuristics(update_apply)//userTaclets1)
 };  
 //
 writeEventBeforeNoR {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	
 	\find({\event(write, loc1, ts)} noR(loc2))
 	
 	\replacewith(noR({\event(write, loc1, ts)}loc2))
 	
 	\heuristics(update_apply)//userTaclets1)
 };
 
 readEventBeforeNoR {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {\event(read, loc1, ts)} noR(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> noR(tempVar))
     \add(tempVar = {\event(read, loc1, ts)}loc2,
     	intersect(loc1, tempVar) = empty ==> );
     
     \replacewith(==> false)
     \add(tempVar = {\event(read, loc1, ts)}loc2,
     	!(intersect(loc1, tempVar) = empty) ==> )
     
 	\heuristics(update_apply)//userTaclets1)
 };
 
 
 simplifyUpdateOnReadPred {
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;

		\find({u}rPred(loc, ts))
		\varcond(\noEventUpdate(u))  
		
		\replacewith(rPred({u}loc, {u}ts))
		
		\heuristics(update_apply)
	};
		
	simplifyUpdateOnWritePred {
		\schemaVar \update u;
		\schemaVar \term LocSet loc;
		\schemaVar \term int ts;


		\find({u}wPred(loc, ts))
		\varcond(\noEventUpdate(u))   
		
		\replacewith(wPred({u}loc, {u}ts))
		
		\heuristics(update_apply)
	};


	 
//-------------------------------------------------r/w Preds in realtion to noX----------------------------------------
//rPredAndNoR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int label1;
//	
//	\assumes(rPred(loc1,label1) ==>)
//	\find(==> noR(loc2))
//	
//	\replacewith(==>noR(loc2))
//	\add(intersect(loc1,loc2)=empty==>);
//	
//	\replacewith(==>intersect(loc1,loc2)=empty)
//	
//	\heuristics(dep_pred_known,simplify)
//};
//rPredAndNoR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int label1;
//	
//	\assumes(rPred(loc1,label1) ==>)
//	\find(==> noR(loc2))
//	
//	\add(==> intersect(loc1,loc2)=empty)
//	
//	\heuristics(dep_pred_known,simplify)
//};
rPredAndNoR{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1;
	
	\assumes(rPred(loc1,label1) ==>)
	\find(==> noR(loc2))
	
	\replacewith(==>false)
	\add(intersect(loc1,loc2)!=empty==>);
	
	\add(intersect(loc1,loc2)=empty==>)
	
	\heuristics(dep_pred_known_3)//,simplify)
};



wPredAndNoW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1;
	
	\assumes(wPred(loc1,label1) ==>)
	\find(==> noW(loc2))
	
	\replacewith(==>false)
	\add(intersect(loc1,loc2)!=empty==>);
	
	\add(intersect(loc1,loc2)=empty==>)
	
	\heuristics(dep_pred_known_3)//,simplify)
};
//wPredAndNoW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int label1;
//	
//	\assumes(wPred(loc1,label1) ==>)
//	\find(==> noW(loc2))
//	
//	\add(==>intersect(loc1,loc2)=empty)
//	
//	\heuristics(dep_pred_known,simplify)
//};
//

//rPredAndNoRaW{ 
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \term int label1;
//	\schemaVar \variables int label2;
//	
//	\assumes(rPred(loc1,label1) ==>)
//	\find(==> noRaW(loc2))
//	\varcond ( \notFreeIn (label2, loc1), \notFreeIn (label2, loc2), \notFreeIn (label2, label1))
//	\replacewith(==> noRaW(setMinus(loc2,loc1)) & ((\exists label2; (wPred(tempVar, label2) & label1 < label2)) | noW(tempVar)))//this is actually the relaxed version. Then unrelaxed version would be label1 \leq label 2
//	\add(tempVar=intersect(loc1,loc2), !tempVar=empty ==>);
//	
//	\add(intersect(loc1,loc2)=empty==>)
//
//	\heuristics(dep_pred_known,simplify)
//};


//rPredAndNoWaR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \term int label1;
//	\schemaVar \variables int label2;
//	
//	\assumes(rPred(loc1,label1)==>)
//	\find(==> noWaR(loc2))
//	\varcond ( \notFreeIn (label2, loc1), \notFreeIn (label2, loc2), \notFreeIn (label2, label1))
//	\replacewith(==> noWaR(setMinus(loc2,loc1)) & ((\exists label2; (wPred(tempVar, label2) & label1 > label2)) | noW(tempVar)))
//	\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);
//	
//	
//	\add(intersect(loc1,loc2)=empty==>)
//	
//	\heuristics(dep_pred_known,simplify)
//};
//-----------------> altered
wPredAndNoWaR{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1;
	\schemaVar \variables int label2;
	\schemaVar \variables LocSet loc3;
	
	\assumes(wPred(loc1,label1)==>)
	\find(==> noWaR(loc2))
	\varcond(\new(tempVar, \dependingOn(loc1)),
            \new(tempVar, \dependingOn(loc2)))

	\replacewith(==> noWaR(setMinus(loc2,loc1)) & noRAtHistory(tempVar,label1 + 1))
	\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);
	
	
	\add(intersect(loc1,loc2)=empty==>)
	
	\heuristics(dep_pred_known_3)//,simplify) //but it didn't get a higher priority in the proof.
};


//
//wPredAndNoRaW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \term int label1;
//	\schemaVar \variables int label2;
//	
//	\assumes(wPred(loc1,label1)==>)
//	\find(==> noRaW(loc2))
//	\varcond ( \notFreeIn (label2, loc1), \notFreeIn (label2, loc2), \notFreeIn (label2, label1))
//	\replacewith(==>noRaW(setMinus(loc2,loc1)) & ((\exists label2;(rPred(tempVar, label2) & label1 > label2)) | noR(tempVar)))
//	\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);
//	
//	\add(intersect(loc1,loc2)=empty==>)
//	
//	\heuristics(dep_pred_known,simplify)
//};

//---------------------------------------->altered
rPredAndNoRaW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1;
	\schemaVar \variables int label2;
	\schemaVar \variables LocSet loc3;
	
	\assumes(rPred(loc1,label1)==>)
	\find(==> noRaW(loc2))
	\varcond(\new(tempVar, \dependingOn(loc1)),
	        \new(tempVar, \dependingOn(loc2)))
	
	\replacewith(==>noRaW(setMinus(loc2,loc1)) & noWAtHistory(tempVar, label1 + 1))
	
	\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);
	
	\add(intersect(loc1,loc2)=empty==>)
	
	\heuristics(dep_pred_known_3)//,simplify)
};



//wPredAndNoWaR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \term int label1;
//	\schemaVar \variables int label2;
//	
//	\assumes(wPred(loc1,label1)==>)
//	\find(==> noWaR(loc2))
//	\varcond ( \notFreeIn (label2, loc1), \notFreeIn (label2, loc2), \notFreeIn (label2, label1))
//	\replacewith(==>noWaR(setMinus(loc2,loc1)) & ((\exists label2; (rPred(tempVar, label2) & label1 < label2)) | noR(tempVar)))
//	\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);
//	
//	\add(intersect(loc1,loc2)=empty==>)
//	
//	\heuristics(dep_pred_known,simplify)
//};
//
//wPredAndNoWaW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \term int label1;
//	\schemaVar \variables int label2;
//	
//	\assumes(wPred(loc1,label1)==>)
//	\find(==> noWaW(loc2))
//	\varcond ( \notFreeIn (label2, loc1), \notFreeIn (label2, loc2), \notFreeIn (label2, label1))
//	\replacewith(==>noWaW(setMinus(loc2,loc1)) & ((\exists label2; (wPred(tempVar, label2) & !label1=label2)) | noW(tempVar)))//This one does not work in the unrelaxed mode.
//	\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);
//	
//	\add(intersect(loc1,loc2)=empty==>)
//	
//	\heuristics(dep_pred_known,simplify)
//};
//-----------------------------> altered
wPredAndNoWaW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1;
	\schemaVar \variables int label2;
	\schemaVar \variables LocSet loc3;
	
	\assumes(wPred(loc1,label1)==>)
	\find(==> noWaW(loc2))
	\varcond(\new(tempVar, \dependingOn(loc1)),
            \new(tempVar, \dependingOn(loc2)))

	\replacewith(==>noWaW(setMinus(loc2,loc1)) & noWAtHistory(tempVar, label1 + 1))
	\add(tempVar=intersect(loc1,loc2), !tempVar=empty==>);
	
	\add(intersect(loc1,loc2)=empty==>)
	
	\heuristics(dep_pred_known_3)//,simplify)
};

//-------------------------------------------------r/w on empty set----------------------------------------
//rPredOnBothSides{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int label1, label2;
//	
//	\assumes(rPred(loc1,label1)==>)
//	\find(==> rPred(loc2,label2))
//	
//	\replacewith(==>\if(subset(loc2,loc1) & label1<=label2)
//				\then(true) 
//				\else(\if(intersect(loc1,loc2)=empty) 
//						\then(rPred(loc2,label2)) 
//						\else(\if(label1>label2) 
//								\then(rPred(loc2,label2)) 
//								\else(rPred(setMinus(loc2,loc1),label2)))))
//				
//	\heuristics(dep_replace_known,no_self_application)			
//};
//wPredOnBothSides{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int label1, label2;
//	
//	\assumes(wPred(loc1,label1)==>)
//	\find(==> wPred(loc2,label2))
//	
//	\replacewith(==>\if(subset(loc2,loc1) & label1<=label2)
//				\then(true) 
//				\else(\if(intersect(loc1,loc2)=empty) 
//						\then(wPred(loc2,label2)) 
//						\else(\if(label1>label2) 
//								\then(wPred(loc2,label2)) 
//								\else(wPred(setMinus(loc2,loc1),label2)))))
//	
//	\heuristics(dep_replace_known,no_self_application)
//};

//rPredOnBothSides{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int label1, label2;
//	
//	\assumes(rPred(loc1,label1)==>)
//	\find(==> rPred(loc2,label2))
//	\add(==> subset(loc2,loc1))
//	
//	\heuristics(dep_replace_known,no_self_application)			
//};
//wPredOnBothSides{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int label1, label2;
//	
//	\assumes(wPred(loc1,label1)==>)
//	\find(==> wPred(loc2,label2))
//	\add(==> subset(loc2,loc1))
//	
//	\heuristics(dep_replace_known,no_self_application)
//};


//-----------------------------------------------------------------------------------------
//                        Proof Closing Rules 
//-----------------------------------------------------------------------------------------

 noRaWOnEmptySet{
 	
 	\find(noRaW(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };

 noWaROnEmptySet{
 	
 	\find(noWaR(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };
 
 noWaWOnEmptySet{
 	
 	\find(noWaW(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };
 
 noWOnEmptySet{
 	
 	\find(noW(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };
 
 noROnEmptySet{
 	
 	\find(noR(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 }; 
 
 rPredOnEmptySet{
	 \schemaVar \term int id;
	 
	 \find(rPred(empty,id))
 	 \replacewith(true)
	 	
	 	\heuristics(concrete)
}; 
	 
 wPredOnEmptySet{
	 \schemaVar \term int id;
	 
 	 \find(wPred(empty,id))
	 \replacewith(true)
	 	
	 \heuristics(concrete)
}; 

noRAtHistoryOnEmptySet{
	 \schemaVar \term int id;
	 
	 \find(noRAtHistory(empty,id))
	 \replacewith(true)
	 	
	 \heuristics(concrete)
};

noWAtHistoryOnEmptySet{
	 \schemaVar \term int id;
	 
	 \find(noWAtHistory(empty,id))
	 \replacewith(true)
	 	
	 \heuristics(concrete)
};

noRaWAtHistoryOnEmptySet{
	 \schemaVar \term int id;
	 
	 \find(noRaWAtHistory(empty,id))
	 \replacewith(true)
	 	
	 \heuristics(concrete)
};
noWaRAtHistoryOnEmptySet{
	 \schemaVar \term int id;
	 
	 \find(noWaRAtHistory(empty,id))
	 \replacewith(true)
	 	
	 \heuristics(concrete)
};
noWaWAtHistoryOnEmptySet{
	 \schemaVar \term int id;
	 
	 \find(noWaWAtHistory(empty,id))
	 \replacewith(true)
	 	
	 \heuristics(concrete)
};
//-----------------------------------------------------{u} noXAtHistory---------------------------------------------------------------------
updateOnNoRAtHistory{
	 \schemaVar \term int id;
	 \schemaVar \term LocSet loc;
	 \schemaVar \update u;
	  
	 \find({u}noRAtHistory(loc,id))
	 \varcond(\noEventUpdate(u)) 
	 \replacewith(noRAtHistory({u}loc,{u}id))
	 	
	 \heuristics(update_apply)
};
updateOnNoWAtHistory{
	 \schemaVar \term int id;
	 \schemaVar \term LocSet loc;
	 \schemaVar \update u;
	 
	 \find({u}noWAtHistory(loc,id))
	 \varcond(\noEventUpdate(u)) 
	 \replacewith(noWAtHistory({u}loc,{u}id))
	 	
	 \heuristics(update_apply)
};
updateOnNoRaWAtHistory{
	 \schemaVar \term int id;
	 \schemaVar \term LocSet loc;
	 \schemaVar \update u;
	 
	 \find({u}noRaWAtHistory(loc,id))
	 \varcond(\noEventUpdate(u)) 
	 \replacewith(noRaWAtHistory({u}loc,{u}id))
	 	
	 \heuristics(update_apply)
};
updateOnNoWaRAtHistory{
	 \schemaVar \term int id;
	 \schemaVar \term LocSet loc;
	 \schemaVar \update u;
	 
	 \find({u}noWaRAtHistory(loc,id))
	 \varcond(\noEventUpdate(u)) 
	 \replacewith(noWaRAtHistory({u}loc,{u}id))
	 	
	 \heuristics(update_apply)
};
updateOnNoWaWAtHistory{
	 \schemaVar \term int id;
	 \schemaVar \term LocSet loc;
	 \schemaVar \update u;
	 
	 \find({u}noWaWAtHistory(loc,id))
	 \varcond(\noEventUpdate(u)) 
	 \replacewith(noWaWAtHistory({u}loc,{u}id))
	 	
	 \heuristics(update_apply)
};
//==========================================================================================================================
noRAtHistoryOnBothSides{
	 \schemaVar \term int id1, id2;
	 \schemaVar \term LocSet loc1, loc2;
	 \schemaVar \update u;
	 
	 \assumes(noRAtHistory(loc1,id1)==>)
	 \find(==>noRAtHistory(loc2,id2))
	 \replacewith(==>noRAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1, loc2)=empty & id1>=id2 ==>);// 
	 
	 \add(intersect(loc1, loc2)=empty | (id1<id2) ==>)//
	 
	 \heuristics(dep_pred_known)
};

noRAndNoRAtHistory{
	 \schemaVar \term int id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noR(loc1)==>)
	 \find(==>noRAtHistory(loc2,id2))
	 \replacewith(==>noRAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1,loc2)=empty==>);
	 
	 \add(intersect(loc1,loc2)=empty==>)
	 
	 \heuristics(dep_pred_known)
};

noWAtHistoryOnBothSides{
	 \schemaVar \term int id1, id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noWAtHistory(loc1,id1)==>)
	 \find(==>noWAtHistory(loc2,id2))
	 \replacewith(==>noWAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1, loc2)=empty & id1>=id2 ==>);// & id1=id2
	 
	 \add(intersect(loc1, loc2)=empty==> id1<id2)  //| (!id1=id2)
	 
	 \heuristics(dep_pred_known)
};

noWAndNoWAtHistory{
	 \schemaVar \term int id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noW(loc1)==>)
	 \find(==>noWAtHistory(loc2,id2))
	 \replacewith(==>noWAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1,loc2)=empty==>);
	 
	 \add(intersect(loc1,loc2)=empty==>)
	 
	 \heuristics(dep_pred_known)
};

noRaWAtHistoryOnBothSides{
	 \schemaVar \term int id1, id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noRaWAtHistory(loc1,id1)==>)
	 \find(==>noRaWAtHistory(loc2,id2))
	 \replacewith(==>noRaWAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1, loc2)=empty & id1 >= id2==>);// & id1=id2
	 
	 \add(intersect(loc1, loc2)=empty | id1 < id2==>)  //| (!id1=id2)
	 
	 \heuristics(dep_pred_known)
};

noRaWAndNoRaWAtHistory{
	 \schemaVar \term int id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noRaW(loc1)==>)
	 \find(==>noRaWAtHistory(loc2,id2))
	 \replacewith(==>noRaWAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1,loc2)=empty==>);
	 
	 \add(intersect(loc1,loc2)=empty==>)
	 
	 \heuristics(dep_pred_known)
};

noWaRAtHistoryOnBothSides{
	 \schemaVar \term int id1, id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noWaRAtHistory(loc1,id1)==>)
	 \find(==>noWaRAtHistory(loc2,id2))
	 \replacewith(==>noWaRAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1, loc2)=empty & id1 >= id2==>);// & id1=id2
	 
	 \add(intersect(loc1, loc2)=empty | id1 < id2==>)  //| (!id1=id2)
	 
	 \heuristics(dep_pred_known)
};

noWaRAndNoWaRAtHistory{
	 \schemaVar \term int id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noWaR(loc1)==>)
	 \find(==>noWaRAtHistory(loc2,id2))
	 \replacewith(==>noWaRAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1,loc2)=empty==>);
	 
	 \add(intersect(loc1,loc2)=empty==>)
	 
	 \heuristics(dep_pred_known)
};
noWaWAtHistoryOnBothSides{
	 \schemaVar \term int id1, id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noWaWAtHistory(loc1,id1)==>)
	 \find(==>noWaWAtHistory(loc2,id2))
	 \replacewith(==>noWaWAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1, loc2)=empty & id1>=id2 ==>);// & id1=id2
	 
	 \add(intersect(loc1, loc2)=empty & id1 < id2 ==>)  //| (!id1=id2)
	 
	 \heuristics(dep_pred_known)
};

noWaWAndNoWaWAtHistory{
	 \schemaVar \term int id2;
	 \schemaVar \term LocSet loc1, loc2;
	 
	 \assumes(noWaW(loc1)==>)
	 \find(==>noWaWAtHistory(loc2,id2))
	 \replacewith(==>noWaWAtHistory(setMinus(loc2,loc1),id2))
	 \add(!intersect(loc1,loc2)=empty==>);
	 
	 \add(intersect(loc1,loc2)=empty==>)
	 
	 \heuristics(dep_pred_known)
};


}

//-----------------------------------------------------------------------------------------
//                      Anon Event Rules 
//-----------------------------------------------------------------------------------------
/*\rules(programRules:Java, runtimeExceptions:ban, dependencies:on){

 applyEventOnAnonEvUp { 
	
	\schemaVar \term LocSet loc, anonLoc;
	\schemaVar \term EventMarker rw;
	\schemaVar \term int ts, id;
	 	
	\find({\event(rw, loc, ts)} (\anonEvUp(anonLoc, id)))
	\replacewith(\anonEvUp({\event(rw, loc, ts)}anonLoc, {\event(rw, loc, ts)}id))
};

applyanonEvUpOnEvent { 

	\schemaVar \term LocSet loc, anonLoc;
	\schemaVar \term EventMarker rw;
	\schemaVar \term int ts, id;
	 	
	\find({\anonEvUp(anonLoc, id)}(\event(rw, loc, ts)))
	\replacewith(\event({\anonEvUp(anonLoc,id)}rw, {\anonEvUp(anonLoc,id)}loc, {\anonEvUp(anonLoc,id)}ts))

 };
		
//===================================={anonEvUp} depPred ===============
anonEvUpOnNoRaW{
	 	
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term LocSet loc, anonLoc;
	\schemaVar \term int id;
	
	\find({\anonEvUp(anonLoc,id)} noRaW(loc))
	\varcond(\new(tempVar, \dependingOn(anonLoc)),
	           \new(tempVar, \dependingOn(loc)))
			  
	\replacewith(({\anonEvUp(anonLoc,id)}noRaW(tempVar)) & noRaW(setMinus(tempVar, anonLoc))) //ask Richard: shouldn't it be ({\anonEvUp(anonLoc)}noRaW(intersect(tempVar,anonLoc))) for completeness
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		!(intersect(tempVar, anonLoc) = empty)==> );
			
	\replacewith({\anonEvUp(anonLoc,id)}noRaW(tempVar))
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		intersect(tempVar, anonLoc) = empty==> )
};


anonEvUpOnNoWaR{
 	
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term LocSet loc, anonLoc;
	\schemaVar \term int id;
	 	
	\find({\anonEvUp(anonLoc,id)} noWaR(loc))	
	\varcond(\new(tempVar, \dependingOn(anonLoc)),
	           \new(tempVar, \dependingOn(loc)))
			  
	\replacewith(({\anonEvUp(anonLoc,id)}noWaR(tempVar)) & noWaR(setMinus(tempVar, anonLoc))) //ask Richard: shouldn't it be ({\anonEvUp(anonLoc)}noRaW(intersect(tempVar,anonLoc))) for completeness
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		!(intersect(tempVar, anonLoc) = empty)==> );
			
	\replacewith({\anonEvUp(anonLoc,id)}noWaR(tempVar))
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		intersect(tempVar, anonLoc) = empty==> )
};

anonEvUpOnNoWaW{
 	
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term LocSet loc, anonLoc;
	\schemaVar \term int id;
	 	
	 \find({\anonEvUp(anonLoc,id)} noWaW(loc))
		
	\varcond(\new(tempVar, \dependingOn(anonLoc)),
	           \new(tempVar, \dependingOn(loc)))
			  
	\replacewith(({\anonEvUp(anonLoc,id)}noWaW(tempVar)) & noWaW(setMinus(tempVar, anonLoc))) //ask Richard: shouldn't it be ({\anonEvUp(anonLoc)}noRaW(intersect(tempVar,anonLoc))) for completeness
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		!(intersect(tempVar, anonLoc) = empty)==> );
			
	\replacewith({\anonEvUp(anonLoc,id)}noWaW(tempVar))
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		intersect(tempVar, anonLoc) = empty==> )
};

anonEvUpOnNoW{
 	
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term LocSet loc, anonLoc;
	\schemaVar \term int id;
	 	
	 \find({\anonEvUp(anonLoc,id)} noW(loc))
		
	\varcond(\new(tempVar, \dependingOn(anonLoc)),
	           \new(tempVar, \dependingOn(loc)))
			  
	\replacewith(({\anonEvUp(anonLoc,id)}noW(tempVar)) & noW(setMinus(tempVar, anonLoc))) //ask Richard: shouldn't it be ({\anonEvUp(anonLoc)}noRaW(intersect(tempVar,anonLoc))) for completeness
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		!(intersect(tempVar, anonLoc) = empty)==> );
			
	\replacewith({\anonEvUp(anonLoc,id)}noW(tempVar))
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		intersect(tempVar, anonLoc) = empty==> )
};

anonEvUpOnNoR{
 	
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term LocSet loc, anonLoc;
	\schemaVar \term int id;
	 	
	 \find({\anonEvUp(anonLoc,id)} noR(loc))
		
	\varcond(\new(tempVar, \dependingOn(anonLoc)),
	           \new(tempVar, \dependingOn(loc)))
			  
	\replacewith(({\anonEvUp(anonLoc,id)}noR(tempVar)) & noR(setMinus(tempVar, anonLoc))) //ask Richard: shouldn't it be ({\anonEvUp(anonLoc)}noRaW(intersect(tempVar,anonLoc))) for completeness
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		!(intersect(tempVar, anonLoc) = empty)==> );
			
	\replacewith({\anonEvUp(anonLoc,id)}noR(tempVar))
	\add(tempVar = {\anonEvUp(anonLoc,id)}loc,
		intersect(tempVar, anonLoc) = empty==> )
};
//===================================={anonEvUp} depPred ==>  {anonEvUp} depPred===============

anonEvUponNoRaWBothSides{
	\schemaVar \skolemTerm LocSet tempVar1, tempVar2;
	\schemaVar \term LocSet loc1, loc2, anonLoc;
	\schemaVar \term int id;
	
	\assumes({\anonEvUp(anonLoc,id)}noRaW(loc1) ==>)
	\find(==> {\anonEvUp(anonLoc,id)}noRaW(loc2))
		
	\replacewith(==> \if(!(intersect(tempVar1, tempVar2) = empty)) \then({\anonEvUp(anonLoc,id)}noRaW(setMinus(tempVar2, tempVar1))) \else({\anonEvUp(anonLoc,id)}noRaW(tempVar2)))
	\add(tempVar1 = {\anonEvUp(anonLoc,id)}loc1,
		tempVar2 = {\anonEvUp(anonLoc,id)}loc2 ==>)
	};
	
anonEvUponNoWaRBothSides{
	\schemaVar \skolemTerm LocSet tempVar1, tempVar2;
	\schemaVar \term LocSet loc1, loc2, anonLoc;
	\schemaVar \term int id;
	
	\assumes({\anonEvUp(anonLoc,id)}noWaR(loc1) ==>)
	\find(==> {\anonEvUp(anonLoc,id)}noWaR(loc2))
		
	\replacewith(==> \if(!(intersect(tempVar1, tempVar2) = empty)) \then({\anonEvUp(anonLoc,id)}noWaR(setMinus(tempVar2, tempVar1))) \else({\anonEvUp(anonLoc,id)}noWaR(tempVar2)))
	\add(tempVar1 = {\anonEvUp(anonLoc,id)}loc1,
		tempVar2 = {\anonEvUp(anonLoc,id)}loc2 ==>)
	};
	
anonEvUponNoWaWBothSides{
	\schemaVar \skolemTerm LocSet tempVar1, tempVar2;
	\schemaVar \term LocSet loc1, loc2, anonLoc;
	\schemaVar \term int id;
	
	\assumes({\anonEvUp(anonLoc,id)}noWaW(loc1) ==>)
	\find(==> {\anonEvUp(anonLoc,id)}noWaW(loc2))
		
	\replacewith(==> \if(!(intersect(tempVar1, tempVar2) = empty)) \then({\anonEvUp(anonLoc,id)}noWaW(setMinus(tempVar2, tempVar1))) \else({\anonEvUp(anonLoc,id)}noWaW(tempVar2)))
	\add(tempVar1 = {\anonEvUp(anonLoc,id)}loc1,
		tempVar2 = {\anonEvUp(anonLoc,id)}loc2 ==>)
	};
	
anonEvUponNoWBothSides{
	\schemaVar \skolemTerm LocSet tempVar1, tempVar2;
	\schemaVar \term LocSet loc1, loc2, anonLoc;
	\schemaVar \term int id;
	
	\assumes({\anonEvUp(anonLoc,id)}noW(loc1) ==>)
	\find(==> {\anonEvUp(anonLoc,id)}noW(loc2))
		
	\replacewith(==> \if(!(intersect(tempVar1, tempVar2) = empty)) \then({\anonEvUp(anonLoc,id)}noW(setMinus(tempVar2, tempVar1))) \else({\anonEvUp(anonLoc,id)}noW(tempVar2)))
	\add(tempVar1 = {\anonEvUp(anonLoc,id)}loc1,
		tempVar2 = {\anonEvUp(anonLoc,id)}loc2 ==>)
	};
	
anonEvUponNoRBothSides{
	\schemaVar \skolemTerm LocSet tempVar1, tempVar2;
	\schemaVar \term LocSet loc1, loc2, anonLoc;
	\schemaVar \term int id;
	
	\assumes({\anonEvUp(anonLoc,id)}noR(loc1) ==>)
	\find(==> {\anonEvUp(anonLoc,id)}noR(loc2))
		
	\replacewith(==> \if(!(intersect(tempVar1, tempVar2) = empty)) \then({\anonEvUp(anonLoc,id)}noR(setMinus(tempVar2, tempVar1))) \else({\anonEvUp(anonLoc,id)}noR(tempVar2)))
	\add(tempVar1 = {\anonEvUp(anonLoc,id)}loc1,
		tempVar2 = {\anonEvUp(anonLoc,id)}loc2 ==>)
	};	
//=================================={ update/event/anonEvUp || \anonEvUp}==================================
	applyUpdateParallelToAnonEventOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term LocSet anonLoc;	
		\schemaVar \term int id;
		\schemaVar \update u;

		\find({u || \anonEvUp(anonLoc, id)}(pv := t))
		
		\replacewith((pv := {u || \anonEvUp(anonLoc, id)}t))
		
		\heuristics(update_apply_on_update)//userTaclets1)
	 };
	    
	 applyUpdateParallelToAnonEventOnPV {
		\schemaVar \program Variable pv;
		\schemaVar \term LocSet anonLoc;
		\schemaVar \term int id;
		\schemaVar \update u;
			
		\find({u || \anonEvUp(anonLoc, id)}pv)
		
		\replacewith({u}pv)
		
		\heuristics(update_apply)//userTaclets1)
	 };
	    
	 applyUpdateParallelToAnonEventOnSkip {
		\schemaVar \term LocSet anonLoc;
		\schemaVar \term int id;
		\schemaVar \update u;
		
		\find({u || \anonEvUp(anonLoc, id)}skip)
		
		\replacewith(skip)
		
		\heuristics(update_elim)//userTaclets1)
	 };

	
//===================================={ update/event/anonEvUp || \anonEvUp} depPred==================================
	 
updateBeforeanonEvUpOnNoRaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet anonLoc, loc;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int id;
	 	
	 \find(==> {u || \anonEvUp(anonLoc,id)} noRaW(loc))
	
	 \varcond(//\new(tempVar, \dependingOn(u)),
	             \new(tempVar, \dependingOn(anonLoc)),
	             \new(tempVar, \dependingOn(loc)))   
				 
	 \replacewith(==> {u}noRaW(tempVar))
	 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, 
	          intersect(anonLoc, tempVar) = empty ==> );  
			  
			  
	 \replacewith(==> ({u ||  \anonEvUp(anonLoc,id)} noRaW(intersect(tempVar, anonLoc))) & {u}noRaW(setMinus(tempVar, anonLoc)))
	 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, !(intersect(anonLoc, tempVar) = empty) ==> )
};
 
updateBeforeanonEvUpOnNoWaR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet anonLoc, loc;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int id;
		 	
		 \find(==> {u || \anonEvUp(anonLoc,id)} noWaR(loc))
		
		 \varcond(//\new(tempVar, \dependingOn(u)),
             \new(tempVar, \dependingOn(anonLoc)),
             \new(tempVar, \dependingOn(loc)))   
			 
 \replacewith(==> {u}noWaR(tempVar))
 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, 
          intersect(anonLoc, tempVar) = empty ==> );  
		  
		  
 \replacewith(==> ({u ||  \anonEvUp(anonLoc,id)} noWaR(intersect(tempVar, anonLoc))) & {u}noWaR(setMinus(tempVar, anonLoc)))
 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, !(intersect(anonLoc, tempVar) = empty) ==> )
 };
	 
 updateBeforeanonEvUpOnNoWaW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet anonLoc, loc;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int id;
		 	
		 \find(==> {u || \anonEvUp(anonLoc,id)} noWaW(loc))
		
		 \varcond(//\new(tempVar, \dependingOn(u)),
             \new(tempVar, \dependingOn(anonLoc)),
             \new(tempVar, \dependingOn(loc)))   
			 
 \replacewith(==> {u}noWaW(tempVar))
 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, 
          intersect(anonLoc, tempVar) = empty ==> );  
		  
		  
 \replacewith(==> ({u ||  \anonEvUp(anonLoc,id)} noWaW(intersect(tempVar, anonLoc))) & {u}noWaW(setMinus(tempVar, anonLoc)))
 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, !(intersect(anonLoc, tempVar) = empty) ==> )
 };

 
 updateBeforeanonEvUpOnNoW{
	 	\schemaVar \update u;
		\schemaVar \term LocSet anonLoc, loc;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int id;
		 	
		 \find(==> {u || \anonEvUp(anonLoc,id)} noW(loc))
		
		 \varcond(//\new(tempVar, \dependingOn(u)),
             \new(tempVar, \dependingOn(anonLoc)),
             \new(tempVar, \dependingOn(loc)))   
			 
 \replacewith(==> {u} noW(tempVar))
 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, 
          intersect(anonLoc, tempVar) = empty ==> );  
		  
		  
 \replacewith(==> ({u ||  \anonEvUp(anonLoc,id)} noW(intersect(tempVar, anonLoc))) & {u}noW(setMinus(tempVar, anonLoc)))
 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, !(intersect(anonLoc, tempVar) = empty) ==> )
 };

 updateBeforeanonEvUpOnNoR{
	 	\schemaVar \update u;
		\schemaVar \term LocSet anonLoc, loc;
		\schemaVar \skolemTerm LocSet tempVar;
		\schemaVar \term int id;
		 	
		 \find(==> {u || \anonEvUp(anonLoc,id)} noR(loc))
		
		 \varcond(//\new(tempVar, \dependingOn(u)),
             \new(tempVar, \dependingOn(anonLoc)),
             \new(tempVar, \dependingOn(loc)))   
			 
 \replacewith(==> {u}noR(tempVar))
 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, 
          intersect(anonLoc, tempVar) = empty ==> );  
		  
 \replacewith(==> ({u ||  \anonEvUp(anonLoc,id)} noR(intersect(tempVar, anonLoc))) & {u}noR(setMinus(tempVar, anonLoc)))
 \add(tempVar = {u || \anonEvUp(anonLoc,id)}loc, !(intersect(anonLoc, tempVar) = empty) ==> )
 };
 
//==================================== Update on anon===================================
 applyUpdateOnAnonEvent {
	 	\schemaVar \update u;
	 	\schemaVar \term LocSet anonLoc;
	 	\schemaVar \term int id;
	 	
	 	\find({u}(\anonEvUp(anonLoc, id)))
	 	
	 	\replacewith(\anonEvUp({u}anonLoc, {u}id))
	 	
	 	\heuristics(update_apply_on_update)
	 	
};

//-----------------------------------------------------------------------------------------
//									Anon-Event Elimination Rules 
//-----------------------------------------------------------------------------------------
//	elimAnonEventOnRigidTerm1 {
//		\schemaVar \term[rigid] any t;
//		\schemaVar \update u;
//
//		\find({u} t)
//
//		\replacewith(t)
//
//		\heuristics(update_elim)
//	};
//
//	elimAnonEventOnRigidTerm2 {
//		\schemaVar \term any t, result;
//		\schemaVar \update u;	
//		
//		\find({u}t)
//		\varcond(\applyAnonEventOnRigid(u, t, result))
//		
//		\replacewith(result)
//		
//		\heuristics(update_elim)
//	};
//	
//	elimAnonEventOnRigidFormula1 {  
//		\schemaVar \formula[rigid] phi;
//		\schemaVar \update u;
//		
//		\find({u}phi)
//		
//		\replacewith(phi)
//		
//		\heuristics(update_elim)
//	};
//	
//	elimAnonEventOnRigidFormula2 {
//		\schemaVar \formula phi, result;
//		\schemaVar \update u;
//		
//		\find({u}phi)
//		\varcond(\applyAnonEventOnRigid(u, phi, result))
//		
//		\replacewith(result)
//		
//		\heuristics(update_elim)
//	};
//	
//	applyAnonEventOnElementary {
//		\schemaVar \program Variable pv;
//		\schemaVar \term any t;
//		\schemaVar \term LocSet anonLoc;
//	 	\schemaVar \term int id;
//		
//		\find({\anonEvUp(anonLoc, id)}(pv := t))
//		
//		\replacewith((pv := {\anonEvUp(anonLoc, id)}t))
//		
//		\heuristics(update_apply_on_update)
//	};
//	
//	elimAnonEventOnPV {
//		\schemaVar \program Variable pv;
//		\schemaVar \term LocSet anonLoc;
//	 	\schemaVar \term int id;
//		
//		\find({\anonEvUp(anonLoc, id)}pv)
//		
//		\replacewith(pv)
//		
//		\heuristics(update_elim)
//	};
//	
//	elimAnonEventOnSkip {
//		\schemaVar \term LocSet anonLoc;
//	 	\schemaVar \term int id;
//		
//		\find({\anonEvUp(anonLoc, id)}skip)
//		
//		\replacewith(skip)
//		
//		\heuristics(update_elim)
//	};
	
}*/

//-----------------------------------------------------------------------------------------
//					Data Dependence Simplification rules for heuristics
//-----------------------------------------------------------------------------------------

\rules(programRules:Java, runtimeExceptions:ban, dependencies: on) {
	//Same location sets
	rPredAndNoROnSameLocations{
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		
		\assumes(rPred(loc, label) ==>)
		\find(noR(loc)) \sameUpdateLevel
		\replacewith(false)
		\heuristics(concrete)
	};
	wPredAndNoWOnSameLocations{
		\schemaVar \term LocSet loc;
		\schemaVar \term int label;
		
		\assumes(wPred(loc, label) ==>)
		\find(noW(loc)) \sameUpdateLevel
		\replacewith(false)
		\heuristics(concrete)
	};
	noRAndNoRaWOnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noR(loc) ==>)
		\find(noRaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
	
	noWAndNoRaWOnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noW(loc) ==>)
		\find(noRaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
	
	noRAndNoWaROnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noR(loc) ==>)
		\find(noWaR(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
	
	noWAndNoWaROnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noW(loc) ==>)
		\find(noWaR(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
	
	noWAndNoWaWOnSameLocations{
		\schemaVar \term LocSet loc;
		
		\assumes(noW(loc) ==>)
		\find(noWaW(loc)) \sameUpdateLevel
		\replacewith(true)
		\heuristics(concrete)
	};
// Subset location set
//	noRAndNoRaWOnSubsetLocation{
//		\schemaVar \term LocSet loc1;
//		\schemaVar \term LocSet loc2;
//		
//		\assumes(noR(loc1) ==>)
//		\find(==> noRaW(loc2))
//		\add(==> subset(loc2, loc1))
//		\heuristics(saturate_dep_locset_relations)
//	};
//	
//	noWAndNoRaWOnSubsetLocation{
//		\schemaVar \term LocSet loc1;
//		\schemaVar \term LocSet loc2;
//		
//		\assumes(noW(loc1) ==>)
//		\find(==> noRaW(loc2))
//		\add(==> subset(loc2, loc1))
//		\heuristics(saturate_dep_locset_relations)
//	};
////	
//	noRAndNoWaROnSubsetLocation{
//		\schemaVar \term LocSet loc1;
//		\schemaVar \term LocSet loc2;
//		
//		\assumes(noR(loc1) ==>)
//		\find(==> noWaR(loc2))
//		\add(==> subset(loc2, loc1))
//		\heuristics(saturate_dep_locset_relations)
//	};
////	
//	noWAndNoWaROnSubsetLocation{
//		\schemaVar \term LocSet loc1;
//		\schemaVar \term LocSet loc2;
//		
//		\assumes(noW(loc1) ==>)
//		\find(==> noWaR(loc2))
//		\add(==> subset(loc2, loc1))
//		\heuristics(saturate_dep_locset_relations)
//	};
////	
//	noWAndNoWaWOnSubsetLocation{
//		\schemaVar \term LocSet loc1;
//		\schemaVar \term LocSet loc2;
//		
//		\assumes(noW(loc1) ==>)
//		\find(==> noWaW(loc2))
//		\add(==> subset(loc2, loc1))
//		\heuristics(saturate_dep_locset_relations)
//	};
}


//-----------------------------------------------------------------------------------------
// 					Inverse Event Update Rules
//-----------------------------------------------------------------------------------------
\rules(programRules:Java, runtimeExceptions:ban, dependencies: on) {

	//---------------------------------------------Inverse-Event Elimination Rules--------------------------------------------

elimInverseEventOnRigidTerm1 {
	\schemaVar \term[rigid] any t;
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	\schemaVar \term int label;
	\schemaVar \term EventMarker rw;
	
	\find({\invEvUp(rw, loc, label)} t)
	
	\replacewith(t)
	
	\heuristics(update_elim)
};

elimInverseEventOnRigidTerm2 {
	\schemaVar \term any t, result;
	\schemaVar \update u;	
	
	\find({u}t)
	\varcond(\applyInverseEventOnRigid(u, t, result))
	
	\replacewith(result)
	
	\heuristics(update_elim)
};

elimInverseEventOnRigidFormula1 {  
	\schemaVar \formula[rigid] phi;
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	\schemaVar \term int label;
	\schemaVar \term EventMarker rw;

	\find({\invEvUp(rw, loc, label)}phi)

	\replacewith(phi)

	\heuristics(update_elim)
};

elimInverseEventOnRigidFormula2 {
	\schemaVar \formula phi, result;
	\schemaVar \update u;

	\find({u}phi)
	\varcond(\applyInverseEventOnRigid(u, phi, result))

	\replacewith(result)

	\heuristics(update_elim)
};

applyInverseEventOnElementary {
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term LocSet loc;
	\schemaVar \term int label;
	\schemaVar \term EventMarker rw;
	
	\find({\invEvUp(rw, loc, label)}(pv := t))
	
	\replacewith((pv := {\invEvUp(rw, loc, label)}t))
	
	\heuristics(update_apply_on_update)
};

elimInverseEventOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term LocSet loc;
	\schemaVar \term int label;
	\schemaVar \term EventMarker rw;
	
	\find({\invEvUp(rw, loc, label)}pv)
	
	\replacewith(pv)
	
	\heuristics(update_elim)
};

elimInverseEventOnSkip {
	\schemaVar \term LocSet loc;
	\schemaVar \term int label;
	\schemaVar \term EventMarker rw;
	
	\find({\invEvUp(rw, loc, label)}skip)
	
	\replacewith(skip)
	
	\heuristics(update_elim)
};	
//---------------------------------------------------------------{\invEvUp}depPred---------------------------------------------------------------

// Nothing inverse event on any dep pred is thrown out
nothingInverseOnNoR{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	
	\find({\invEvUp(nothing, loc1, label)}noR(loc2))
	\replacewith(noR(loc2))
	\heuristics(update_apply)
};
nothingInverseOnNoW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	
	\find({\invEvUp(nothing, loc1, label)}noW(loc2))
	\replacewith(noW(loc2))
	\heuristics(update_apply)
};
nothingInverseOnNoRaW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	
	\find({\invEvUp(nothing, loc1, label)}noRaW(loc2))
	\replacewith(noRaW(loc2))
	\heuristics(update_apply)
};
nothingInverseOnNoWaR{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	
	\find({\invEvUp(nothing, loc1, label)}noWaR(loc2))
	\replacewith(noWaR(loc2))
	\heuristics(update_apply)
};
nothingInverseOnNoWaW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	
	\find({\invEvUp(nothing, loc1, label)}noWaW(loc2))
	\replacewith(noWaW(loc2))
	\heuristics(update_apply)
};


nothingInverseLastInParallelOnNoR{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	\schemaVar \update u;
	
	\find({u || \invEvUp(nothing, loc1, label)}noR(loc2))
	\replacewith(noR(loc2))
	\heuristics(update_apply)
};
nothingInverseLastInParallelOnNoW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	\schemaVar \update u;
	
	\find({u || \invEvUp(nothing, loc1, label)}noW(loc2))
	\replacewith(noW(loc2))
	\heuristics(update_apply)
};
nothingInverseLastInParallelOnNoRaW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	\schemaVar \update u;
	
	\find({u || \invEvUp(nothing, loc1, label)}noRaW(loc2))
	\replacewith(noRaW(loc2))
	\heuristics(update_apply)
};
nothingInverseLastInParallelOnNoWaR{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	\schemaVar \update u;
	
	\find({u || \invEvUp(nothing, loc1, label)}noWaR(loc2))
	\replacewith(noWaR(loc2))
	\heuristics(update_apply)
};
nothingInverseLastInParallelOnNoWaW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	\schemaVar \update u;
	
	\find({u || \invEvUp(nothing, loc1, label)}noWaW(loc2))
	\replacewith(noWaW(loc2))
	\heuristics(update_apply)
};

//============================================================{\invEvUp()} NoX==============================================================
  readInverseEvUpOnNoRNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({\invEvUp(read,loc1,label)} noR(loc2)==>)
	
	\varcond(//\new(tempVar, \dependingOn(u)),
         \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label)))   
 			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then(noR(tempVar)) \else(noR(setMinus(tempVar,loc1)) & noRAtHistory(tempVar, 1))==>)
	\add((tempVar = {\invEvUp(read,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
  };
//-  
writeInverseEvUpOnNoR{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	 	
	\find( {\invEvUp(write,loc1,label)} noR(loc2)==>)
	
	\replacewith(noR({\invEvUp(write,loc1,label)}loc2)==>)
	\heuristics(update_apply)
 		  
  };  
//----------------------------------------------------------------------------------------------------------------------------- 
 writeInverseEvUpOnNoWNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({\invEvUp(write,loc1,label)} noW(loc2)==>)
	
	\varcond(//\new(tempVar, \dependingOn(u)),
	    \new(tempVar, \dependingOn(loc1)),
	    \new(tempVar, \dependingOn(loc2)),
	    \new(tempVar, \dependingOn(label)))   
			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then(noW(tempVar)) \else(noW(setMinus(tempVar,loc1)) & noWAtHistory(tempVar, 1))==>)
	\add((tempVar = {\invEvUp(write,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
 };
//
readInverseEvUpOnNoW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	 	
	\find({\invEvUp(read,loc1,label)} noW(loc2)==>)
	
	\replacewith(noW({\invEvUp(read,loc1,label)}loc2)==>)
	\heuristics(update_apply)
 		  
  };
//-----------------------------------------------------------------------------------------------------------------------------

 readInverseEvUpOnNoRaWNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({\invEvUp(read,loc1,label)} noRaW(loc2)==>)
	
	\varcond(//\new(tempVar, \dependingOn(u)),
	    \new(tempVar, \dependingOn(loc1)),
	    \new(tempVar, \dependingOn(loc2)),
	    \new(tempVar, \dependingOn(label)))   
			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then(noRaW(tempVar)) \else(noRaW(setMinus(tempVar,loc1)) & noRaWAtHistory(tempVar,1))==>)
	\add((tempVar = {\invEvUp(read,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
 };
//
writeInverseEvUpOnNoRaW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	 	
	\find( {\invEvUp(write,loc1,label)} noRaW(loc2)==>)
	
	\replacewith(noRaW({\invEvUp(write,loc1,label)}loc2)==>)
	\heuristics(update_apply)
 		  
  };
//-----------------------------------------------------------------------------------------------------------------------------  
writeInverseEvUpOnNoWaRNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({\invEvUp(write,loc1,label)} noWaR(loc2)==>)
	
	\varcond(//\new(tempVar, \dependingOn(u)),
	    \new(tempVar, \dependingOn(loc1)),
	    \new(tempVar, \dependingOn(loc2)),
	    \new(tempVar, \dependingOn(label)))   
			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then(noWaR(tempVar)) \else(noWaR(setMinus(tempVar,loc1)) & noWaRAtHistory(tempVar,1))==>)
	\add((tempVar = {\invEvUp(write,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
 };

readInverseEvUpOnNoWaR{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	 	
	\find( {\invEvUp(read,loc1,label)} noWaR(loc2)==>)
	
	\replacewith(noWaR({\invEvUp(read,loc1,label)}loc2)==>)
	\heuristics(update_apply)
 		  
  };
//-----------------------------------------------------------------------------------------------------------------------------  
writeInverseEvUpOnNoWaWNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({\invEvUp(write,loc1,label)} noWaW(loc2)==>)
	
	\varcond(//\new(tempVar, \dependingOn(u)),
	    \new(tempVar, \dependingOn(loc1)),
	    \new(tempVar, \dependingOn(loc2)),
	    \new(tempVar, \dependingOn(label)))   
			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then(noWaW(tempVar)) \else(noWaW(setMinus(tempVar,loc1)) & noWaWAtHistory(tempVar,1))==>)
	\add((tempVar = {\invEvUp(write,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
 };
	//
readInverseEvUpOnNoWaW{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	 	
	\find( {\invEvUp(read,loc1,label)} noWaW(loc2)==>)
	
	\replacewith(noWaW({\invEvUp(read,loc1,label)}loc2)==>)
	\heuristics(update_apply)
 		  
  };
//
//============================================================{\invEvUp()} NoXAtHistory==============================================================
readInverseEvUpOnNoRAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	 	
	\find({\invEvUp(read,loc1,label1)} noRAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
  		noRAtHistory(tempVar, label2 + 1) & 
		(
		   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
		   ->
			noR(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
	    ) ==>)
	\add((tempVar = {\invEvUp(read,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
writeInverseEvUpOnNoRAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \skolemTerm LocSet tempVar;
	 	
	\find( {\invEvUp(write,loc1,label1)} noRAtHistory(loc2, label2)==>)
	
	\replacewith(noRAtHistory(tempVar, label2 + 1) & (
			label2 = 0 
			   ->
				noR(tempVar)    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    )==>)
	
	\add((tempVar = {\invEvUp(write,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  };  
//----------------------------------------------------------------------------------------------------------------------------- 
writeInverseEvUpOnNoWAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	 	
	\find({\invEvUp(write,loc1,label1)} noWAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
  		noWAtHistory(tempVar, label2 + 1) & 
		(
		   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
		   ->
			noW(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
	    ) ==>)
	\add((tempVar = {\invEvUp(write,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
readInverseEvUpOnNoWAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \skolemTerm LocSet tempVar;
	 	
	\find( {\invEvUp(read,loc1,label1)} noWAtHistory(loc2, label2)==>)
	
	\replacewith(noWAtHistory(tempVar, label2 + 1) & (
			label2 = 0 
			   ->
				noW(tempVar)    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    )==>)
	
	\add((tempVar = {\invEvUp(read,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  };
//-----------------------------------------------------------------------------------------------------------------------------
readInverseEvUpOnNoRaWAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	 	
	\find({\invEvUp(read,loc1,label1)} noRaWAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
	  		noRaWAtHistory(tempVar, label2 + 1) & 
			(
			   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
			   ->
				noW(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    ) ==>)

	\add((tempVar = {\invEvUp(read,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
writeInverseEvUpOnNoRaWAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \skolemTerm LocSet tempVar;
	 	
	\find( {\invEvUp(write,loc1,label1)} noRaWAtHistory(loc2, label2)==>)
	
	\replacewith(noRaWAtHistory(tempVar, label2 + 1) & (
			label2 = 0 
			   ->
				noRaW(tempVar)    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    )==>)
	
	\add((tempVar = {\invEvUp(write,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  };  
  
 //-----------------------------------------------------------------------------------------------------------------------------
 writeInverseEvUpOnNoWaRAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	 	
	\find({\invEvUp(write,loc1,label1)} noWaRAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
	  		noWaRAtHistory(tempVar, label2 + 1) & 
			(
			   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
			   ->
				noR(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    ) ==>)

	\add((tempVar = {\invEvUp(read,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
readInverseEvUpOnNoWaRAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \skolemTerm LocSet tempVar;
	 	
	\find( {\invEvUp(read,loc1,label1)} noWaRAtHistory(loc2, label2)==>)
	
	\replacewith(noWaRAtHistory(tempVar, label2 + 1) & (
			label2 = 0 
			   ->
				noWaR(tempVar)    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    )==>)
	
	\add((tempVar = {\invEvUp(read,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  }; 
 //-----------------------------------------------------------------------------------------------------------------------------
writeInverseEvUpOnNoWaWAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	 	
	\find({\invEvUp(write,loc1,label1)} noWaWAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
	  		noWaWAtHistory(tempVar, label2 + 1) & 
			(
			   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
			   ->
				noW(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    ) ==>)

	\add((tempVar = {\invEvUp(write,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
readInverseEvUpOnNoWaWAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \skolemTerm LocSet tempVar;
	 	
	\find( {\invEvUp(read,loc1,label1)} noWaWAtHistory(loc2, label2)==>)
	
	\replacewith(noWaWAtHistory(tempVar, label2 + 1) & (
			label2 = 0 
			   ->
				noWaW(tempVar)    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    )==>)
	
	\add((tempVar = {\invEvUp(read,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  }; 
//
//============================================================{u || \invEvUp()} NoXAtHistory==============================================================
updateParallelReadInverseEvUpOnNoRAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	
	\find({u || \invEvUp(read,loc1,label1)} noRAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
  		{u}noRAtHistory(tempVar, label2 + 1) & 
		(
		   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
		   ->
			{u}noR(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
	    ) ==>)
	\add((tempVar = {u || \invEvUp(read,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
updateParallelWriteInverseEvUpOnNoRAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	\schemaVar \skolemTerm LocSet tempVar;
	
	\find( {u || \invEvUp(write,loc1,label1)} noRAtHistory(loc2, label2)==>)
	
	\replacewith(
	  		{u}noRAtHistory(tempVar, label2 + 1) & 
		   (label2 = 0
			   ->
				{u}noR(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    ) ==>)
		\add((tempVar = {u || \invEvUp(read,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  };  
//----------------------------------------------------------------------------------------------------------------------------- 
updateParallelWriteInverseEvUpOnNoWAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	
	\find({u || \invEvUp(write,loc1,label1)} noWAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
  		{u} noWAtHistory(tempVar, label2 + 1) & 
		(
		   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
		   ->
			{u} noW(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
	    ) ==>)
	\add((tempVar = {u || \invEvUp(write,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
updateParallelReadInverseEvUpOnNoWAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	\schemaVar \skolemTerm LocSet tempVar;
	
	\find( {u || \invEvUp(read,loc1,label1)} noWAtHistory(loc2, label2)==>)
	
	\replacewith(
	  		{u}noWAtHistory(tempVar, label2 + 1) & 
		   (label2 = 0 
			   ->
				{u}noW(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    ) ==>)
		\add((tempVar = {u || \invEvUp(read,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  };
//-----------------------------------------------------------------------------------------------------------------------------
updateParallelReadInverseEvUpOnNoRaWAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	
	\find({u||\invEvUp(read,loc1,label1)} noRaWAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
	  		{u} noRaWAtHistory(tempVar, label2 + 1) & 
			(
			   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
			   ->
				{u} noRaW(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    ) ==>)

	\add((tempVar = {u || \invEvUp(read,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
updateParallelWriteInverseEvUpOnNoRaWAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	\schemaVar \skolemTerm LocSet tempVar;
	
	\find( {u || \invEvUp(write,loc1,label1)} noRaWAtHistory(loc2, label2)==>)
	
	\replacewith(noRaWAtHistory(tempVar, label2 + 1) & (
			label2 = 0 
			   ->
				{u} noRaW(tempVar)    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    )==>)
	
	\add((tempVar = {u || \invEvUp(write,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  };  
  
 //-----------------------------------------------------------------------------------------------------------------------------
 updateParallelWriteInverseEvUpOnNoWaRAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	
	\find({u || \invEvUp(write,loc1,label1)} noWaRAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
	  		{u} noWaRAtHistory(tempVar, label2 + 1) & 
			(
			   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
			   ->
				{u} noWaR(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    ) ==>)

	\add((tempVar = {u || \invEvUp(read,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
updateParallelReadInverseEvUpOnNoWaRAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	\schemaVar \skolemTerm LocSet tempVar;
	
	\find( {u || \invEvUp(read,loc1,label1)} noWaRAtHistory(loc2, label2)==>)
	
	\replacewith(noWaRAtHistory(tempVar, label2 + 1) & (
			label2 = 0 
			   ->
				{u} noWaR(tempVar)    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    )==>)
	
	\add((tempVar = {u || \invEvUp(read,loc1,label1)}loc2) ==> )
	\heuristics(update_apply)
 		  
  }; 
 //-----------------------------------------------------------------------------------------------------------------------------
updateParallelWriteInverseEvUpOnNoWaWAtHistoryNoBranch{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	
	\find({u || \invEvUp(write,loc1,label1)} noWaWAtHistory(loc2, label2)==>)
	
	\varcond( \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label1)))   
 			 
	\replacewith(
	  		{u} noWaWAtHistory(tempVar, label2 + 1) & 
			(
			   (label2 = 0 & !intersect(loc1, tempVar) = empty) 
			   ->
				{u} noWaW(setMinus(tempVar,loc1))    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    ) ==>)

	\add((tempVar = {u || \invEvUp(write,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
};
//-  
updateParallelReadInverseEvUpOnNoWaWAtHistory{
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label1, label2;
	\schemaVar \update u;
	\schemaVar \skolemTerm LocSet tempVar;
	
	\find( {u || \invEvUp(read,loc1,label1)} noWaWAtHistory(loc2, label2)==>)
	
	\replacewith(noWaWAtHistory(tempVar, label2 + 1) & (
			label2 = 0 
			   ->
				{u} noWaW(tempVar)    // equivalently noRAtHistory(setMinus(tempVar,loc1), 0)
		    )==>)
	
	\add((tempVar = {u || \invEvUp(read,loc1,label1)}loc2) ==> )
	
	\heuristics(update_apply)
 		  
  }; 
//

  
  
  
//=================================={ update || \invEvUp}==================================
//////////////////////////////////////On Elementary:
applyUpdateParallelToInverseEventOnElementary {
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term LocSet loc;	
	\schemaVar \term int label;
	\schemaVar \update u;
	\schemaVar \term EventMarker rw;

	\find({u || \invEvUp(rw, loc, label)}(pv := t))
	
	\replacewith((pv := {u || \invEvUp(rw, loc, label)}t))
	
	\heuristics(update_apply_on_update)
 };

 applyInverseEventParallelToUpdateOnElementary {
		\schemaVar \program Variable pv;
		\schemaVar \term any t;
		\schemaVar \term LocSet loc;	
		\schemaVar \term int label;
		\schemaVar \update u;
		\schemaVar \term EventMarker rw;

		\find({\invEvUp(rw, loc, label) || u}(pv := t))
		
		\replacewith((pv := {\invEvUp(rw, loc, label) || u}t))
		
		\heuristics(update_apply_on_update)
	 };

// applyUpdateParallelToInverseEventParallelToUpdateOnElementary {
//		\schemaVar \program Variable pv;
//		\schemaVar \term any t;
//		\schemaVar \term LocSet loc;	
//		\schemaVar \term int label;
//		\schemaVar \update u1,u2;
//		\schemaVar \term EventMarker rw;
//
//		\find({u1 || \invEvUp(rw, loc, label) || u2}(pv := t))
//		
//		\replacewith((pv := {u1 || \invEvUp(rw, loc, label) || u2}t))
//		
//		\heuristics(update_apply_on_update)
//	 };
	 
// applyInverseEventParallelToUpdateParallelToInverseEventOnElementary {
//		\schemaVar \program Variable pv;
//		\schemaVar \term any t;
//		\schemaVar \term LocSet loc1, loc2;	
//		\schemaVar \term int label1, label2;
//		\schemaVar \update u;
//		\schemaVar \term EventMarker rw1, rw2;
//
//		\find({\invEvUp(rw1, loc1, label1) || u || \invEvUp(rw2, loc2, label2)}(pv := t))
//		
//		\replacewith((pv := {\invEvUp(rw1, loc1, label1) || u || \invEvUp(rw2, loc2, label2)}t))
//		
//		\heuristics(update_apply_on_update)
//	 };	 
//////////////////////////////////////On PV:	 
 applyInverseEventParallelToUpdateOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term LocSet loc;
	\schemaVar \term int label;
	\schemaVar \update u;
	\schemaVar \term EventMarker rw;
			
	\find({ \invEvUp(rw, loc, label) || u}pv)
	
	\replacewith({u}pv)
	
	\heuristics(update_apply)
 };
 applyUpdateParallelToInverseEventOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term LocSet loc;
	\schemaVar \term int label;
	\schemaVar \update u;
	\schemaVar \term EventMarker rw;
			
	\find({ u || \invEvUp(rw, loc, label)}pv)
	
	\replacewith({u}pv)
	
	\heuristics(update_apply)
 };

// applyUpdateParallelToInverseEventParallelToUpdateOnPV {
//		\schemaVar \program Variable pv;
//		\schemaVar \term LocSet loc;
//		\schemaVar \term int label;
//		\schemaVar \update u1,u2;
//		\schemaVar \term EventMarker rw;
//				
//		\find({ u1 || \invEvUp(rw, loc, label) || u2}pv)
//		
//		\replacewith({u1 || u2}pv)
//		
//		\heuristics(update_apply)
//	 };
	 
// applyInverseEventParallelToUpdateParallelToInverseEventOnPV {
//		\schemaVar \program Variable pv;
//		\schemaVar \term LocSet loc1,loc2;
//		\schemaVar \term int label1,label2;
//		\schemaVar \update u;
//		\schemaVar \term EventMarker rw1,rw2;
//				
//		\find({\invEvUp(rw1, loc1, label1) || u || \invEvUp(rw2, loc2, label2)}pv)
//		
//		\replacewith({u}pv)
//		
//		\heuristics(update_apply)
//	 };
 applyInverseEventParallelToUpdateOnSkip {
	\schemaVar \term LocSet loc;
	\schemaVar \term int label;
	\schemaVar \update u;
	\schemaVar \term EventMarker rw;
	
	\find({\invEvUp(rw, loc, label) || u}skip)
	
	\replacewith(skip)
	
	\heuristics(update_elim)
 };

//===================================={ update || \invEvUp} depPred==================================

 updateParallelToReadInverseEvUpOnNoRNoBranch{
	\schemaVar \update u;  
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({u || \invEvUp(read,loc1,label)} noR(loc2))
	
	\varcond(//\new(tempVar, \dependingOn(u)),
         \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label)))   
 			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then({u}noR(tempVar)) \else({u}noR(setMinus(tempVar,loc1)) & {u}noRAtHistory(tempVar,1)))
	\add((tempVar = {u || \invEvUp(read,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
  };  
//
  updateParallelToWriteInverseEvUpOnNoR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	 	
	\find( {u || \invEvUp(write,loc1,label)} noR(loc2))
	
	\replacewith({u}noR({u || \invEvUp(write,loc1,label)}loc2))
	\heuristics(update_apply)
 		  
  };
//-----------------------------------------------------------------------------------------------------------------------------------------
 updateParallelToWriteInverseEvUpOnNoWNoBranch{
	\schemaVar \update u;  
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({u || \invEvUp(write,loc1,label)} noW(loc2))
	
	\varcond(//\new(tempVar, \dependingOn(u)),
         \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label)))   
 			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then({u}noW(tempVar)) \else({u}noW(setMinus(tempVar,loc1)) & {u}noWAtHistory(tempVar,1)))
	\add((tempVar = {u || \invEvUp(write,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
 };
 updateParallelToReadInverseEvUpOnNoW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int label;
	 	
	\find({u || \invEvUp(read,loc1,label)} noW(loc2))
	
	\replacewith({u}noW({u || \invEvUp(write,loc1,label)}loc2))
	\heuristics(update_apply)
 		  
  };
//----------------------------------------------------------------------------------------------------------------------------------------- 
updateParallelToReadInverseEvUpOnNoRaWNoBranch{
	\schemaVar \update u;  
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({u || \invEvUp(read,loc1,label)} noRaW(loc2)==>)
	
	\varcond(//\new(tempVar, \dependingOn(u)),
         \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label)))   
 			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then({u}noRaW(tempVar)) \else({u}noRaW(setMinus(tempVar,loc1)) & {u}noRaWAtHistory(tempVar,1))==>)
	\add((tempVar = {u || \invEvUp(read,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
  };  
//
updateParallelToWriteInverseEvUpOnNoRaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find( {u || \invEvUp(write,loc1,label)} noRaW(loc2)==>)
	
	\replacewith({u}noRaW({u || \invEvUp(write,loc1,label)}loc2)==>)
	\heuristics(update_apply)
 		  
  };
//------------------------------------------------------------------------------------------------------------------------------------------	
updateParallelToWriteInverseEvUpOnNoWaRNoBranch{
	\schemaVar \update u;  
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({u || \invEvUp(write,loc1,label)} noWaR(loc2)==>)
	
	\varcond(//\new(tempVar, \dependingOn(u)),
        \new(tempVar, \dependingOn(loc1)),
        \new(tempVar, \dependingOn(loc2)),
        \new(tempVar, \dependingOn(label)))   
			 
	\replacewith(\if(intersect(loc1, tempVar) = empty) \then({u}noWaR(tempVar)) \else({u}noWaR(setMinus(tempVar,loc1)) & {u}noWaRAtHistory(tempVar,1))==>)//& {u}noRAtHistory(intersect(loc1, tempVar),label) & {u}noWaRAtHistory(tempVar,label)
	\add((tempVar = {u || \invEvUp(write,loc1,label)}loc2) ==> )
	
	\heuristics(update_apply)
 };
//
updateParallelToreadInverseEvUpOnNoWaR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find( {u || \invEvUp(read,loc1,label)} noWaR(loc2)==>)
	
	\replacewith({u}noWaR({u || \invEvUp(read,loc1,label)}loc2)==>)
	\heuristics(update_apply)
 		  
  };
//-----------------------------------------------------------------------------------------------------------------------------------------
updateParallelToWriteInverseEvUpOnNoWaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	 \find({u || \invEvUp(write,loc1,label)} noWaW(loc2)==>)
	 \varcond(//\new(tempVar, \dependingOn(u)),
          \new(tempVar, \dependingOn(loc1)),
          \new(tempVar, \dependingOn(loc2)),
          \new(tempVar, \dependingOn(label)))   
 			 
  \replacewith({u}noWaW(tempVar)==>)
  \add(tempVar = {u || \invEvUp(write, loc1,label)}loc2, 
           intersect(loc1, tempVar) = empty ==>);  
 		  
  \replacewith({u} noWaW(setMinus(tempVar,loc1)) & {u}noWAtHistory(intersect(tempVar,loc1),1)==>)//& {u}noWaWAtHistory(tempVar,label)
  \add(tempVar = {u || \invEvUp(write,loc1,label)}loc2, !(intersect(loc1, tempVar) = empty) ==> )
//	\heuristics(update_apply)
  };
//
updateParallelToWriteInverseEvUpOnNoWaWNoBranch{
	\schemaVar \update u;  
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find({u || \invEvUp(write,loc1,label)} noWaW(loc2)==>)
	
	\varcond(//\new(tempVar, \dependingOn(u)),
         \new(tempVar, \dependingOn(loc1)),
         \new(tempVar, \dependingOn(loc2)),
         \new(tempVar, \dependingOn(label)))   

	\replacewith(\if(intersect(loc1, tempVar) = empty) \then({u}noWaW(tempVar)) \else({u}noWaW(setMinus(tempVar,loc1)) & {u}noWaWAtHistory(tempVar,1))==>)
	\add(tempVar = {u || \invEvUp(write,loc1,label)}loc2 ==> )
	
	\heuristics(update_apply)
	  };  
// 
updateParallelToreadInverseEvUpOnNoWaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \skolemTerm LocSet tempVar;
	\schemaVar \term int label;
	 	
	\find( {u || \invEvUp(read,loc1,label)} noWaW(loc2)==>)
	
	\replacewith({u}noWaW({u || \invEvUp(read,loc1,label)}loc2)==>)
	\heuristics(update_apply)
	 		  
};
	
}

//------------------------------------------------------------------------------------------------------------------
//---------------------------------------------Relaxed dependences rules--------------------------------------------
//------------------------------------------------------------------------------------------------------------------
//\rules(programRules:Java, runtimeExceptions:ban, dependencies: on) {
//	
////-----------------------------------------------------{u || event} Relaxed Data Dependence Predicates------------------------------------	
//updateParallelToWriteEventOnRelaxedNoR{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(write, loc1, ts1)} relaxedNoR(loc2, ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))        
//   
//   \replacewith(==> {u}relaxedNoR(tempVar, tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2==> )
//   \heuristics(userTaclets1)
//};
//
//updateParallelToReadEventOnRelaxednoR{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(read, loc1, ts1)} relaxedNoRaW(loc2,ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))
//           
//  
//           
//   \replacewith(==> {u}relaxedNoR(tempVar, tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//   	intersect(tempVar, loc1) = empty ==> );
//           
//   \replacewith(==> {u}relaxedNoR(tempVar, tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//   
//   \replacewith(==> {u}relaxedNoR(setMinus(tempVar,loc1), tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//   
//   \heuristics(userTaclets1)
//};
////
//updateParallelToWriteEventOnRelaxedNoW{
//	 	\schemaVar \update u;
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \term int ts1, ts2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \skolemTerm int tempTs;
//	 	
//	 	\find(==> {u || \event(write, loc1, ts1)} relaxedNoW(loc2, ts2))
//	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//	             \new(tempVar, \dependingOn(loc1)),
//	             \new(tempVar, \dependingOn(ts1)),
//	             \new(tempVar, \dependingOn(loc2)),
//	             /*\new(tempTs, \dependingOn(u)),*/
//	             \new(tempTs, \dependingOn(loc1)),
//	             \new(tempTs, \dependingOn(ts1)),
//	             \new(tempTs, \dependingOn(ts2)))        
//	     
//	 	 \replacewith(==> {u}relaxedNoW(tempVar, tempTs))
//	     \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//	     	intersect(tempVar, loc1) = empty ==> );
//	             
//	     \replacewith(==> {u}relaxedNoW(tempVar, tempTs))
//	     \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//	     	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//	     
//	     \replacewith(==> {u}relaxedNoW(setMinus(tempVar,loc1), tempTs))
//	     \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//	     	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//	
//	     \heuristics(userTaclets1)
//	 };
//
//	updateParallelToReadEventOnRelaxednoW{
//	 	\schemaVar \update u;
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \term int ts1,ts2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \skolemTerm int tempTs;
//	 	
//	 	\find(==> {u || \event(read, loc1, ts1)} relaxedNoW(loc2,ts2))
//	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//	             \new(tempVar, \dependingOn(loc1)),
//	             \new(tempVar, \dependingOn(ts1)),
//	             \new(tempVar, \dependingOn(loc2)),
//	             /*\new(tempTs, \dependingOn(u)),*/
//	             \new(tempTs, \dependingOn(loc1)),
//	             \new(tempTs, \dependingOn(ts1)),
//	             \new(tempTs, \dependingOn(ts2)))
//	             
//	    
//	             
//	 	\replacewith(==> {u}relaxedNoW(tempVar, tempTs))
//	     \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2==> )
//	     
//	     \heuristics(userTaclets1)
//	 };
////
//updateParallelToWriteEventOnRelaxedNoRaW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(write, loc1, ts1)} relaxedNoRaW(loc2, ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))        
//   
//   \replacewith(==> {u}relaxedNoRaW(tempVar, tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2==> )
//   \heuristics(userTaclets1)
//};
//
//updateParallelToReadEventOnRelaxednoRaW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(read, loc1, ts1)} relaxedNoRaW(loc2,ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))
//           
//  
//           
//   \replacewith(==> {u}relaxedNoRaW(tempVar, tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//   	intersect(tempVar, loc1) = empty ==> );
//           
//   \replacewith(==> {u}relaxedNoRaW(tempVar, tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//   
//   \replacewith(==> {u}relaxedNoW(tempVar, tempTs) & {u}relaxedNoRaW(setMinus(tempVar,loc1), tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//   
//   \heuristics(userTaclets1)
//};
////
//updateParallelToReadEventOnRelaxedNoWaR{
//	 	\schemaVar \update u;
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \term int ts1, ts2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \skolemTerm int tempTs;
//	 	
//	 	\find(==> {u || \event(read, loc1, ts1)} relaxedNoWaR(loc2, ts2))
//	 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))        
//   
//   \replacewith(==> {u}relaxedNoWaR(tempVar, tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2==> )
//   \heuristics(userTaclets1)
//};
//
//updateParallelToWriteEventOnRelaxednoWaR{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(write, loc1, ts1)} relaxedNoWaR(loc2,ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))
//           
//  
//           
//   \replacewith(==> {u}relaxedNoWaR(tempVar, tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	intersect(tempVar, loc1) = empty ==> );
//           
//   \replacewith(==> {u}relaxedNoWaR(tempVar, tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//   
//   \replacewith(==> {u}relaxedNoR(tempVar, tempTs) & {u}relaxedNoWaR(setMinus(tempVar,loc1), tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//   
//   \heuristics(userTaclets1)
//}; 
////
//updateParallelToReadEventOnRelaxedNoWaW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(read, loc1, ts1)} relaxedNoWaW(loc2, ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))        
//   
//   \replacewith(==> {u}relaxedNoWaW(tempVar, tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2==> )
//   \heuristics(userTaclets1)
//};
//
//updateParallelToWriteEventOnRelaxednoWaW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(write, loc1, ts1)} relaxedNoWaW(loc2,ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))
//           
//  
//           
//   \replacewith(==> {u}relaxedNoWaW(tempVar, tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	intersect(tempVar, loc1) = empty ==> );
//           
//   \replacewith(==> {u}relaxedNoWaW(tempVar, tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//   
//   \replacewith(==> {u}relaxedNoW(tempVar, tempTs) & {u}relaxedNoWaW(setMinus(tempVar,loc1), tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//   
//   \heuristics(userTaclets1)
//};
////
//updateParallelToReadEventOnRelaxedNoW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(read, loc1, ts1)} relaxedNoW(loc2, ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))        
//   
//   \replacewith(==> {u}relaxedNoW(tempVar, tempTs))
//   \add(tempVar = {u || \event(read, loc1, ts1)}loc2, tempTs = {u || \event(read, loc1, ts1)}ts2==> )
//   \heuristics(userTaclets1)
//};
//
//updateParallelToWriteEventOnRelaxednoW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {u || \event(write, loc1, ts1)} relaxedNoW(loc2,ts2))
//	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
//	\varcond(/*\new(tempVar, \dependingOn(u)),*/
//           \new(tempVar, \dependingOn(loc1)),
//           \new(tempVar, \dependingOn(ts1)),
//           \new(tempVar, \dependingOn(loc2)),
//           /*\new(tempTs, \dependingOn(u)),*/
//           \new(tempTs, \dependingOn(loc1)),
//           \new(tempTs, \dependingOn(ts1)),
//           \new(tempTs, \dependingOn(ts2)))
//           
//  
//           
//   \replacewith(==> {u}relaxedNoW(tempVar, tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	intersect(tempVar, loc1) = empty ==> );
//           
//   \replacewith(==> {u}relaxedNoW(tempVar, tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//   
//   \replacewith(==> {u}relaxedNoW(tempVar, tempTs) & {u}relaxedNoW(setMinus(tempVar,loc1), tempTs))
//   \add(tempVar = {u || \event(write, loc1, ts1)}loc2, tempTs = {u || \event(write, loc1, ts1)}ts2,
//   	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//   
//   \heuristics(userTaclets1)
//};
////-----------------------------------------------------{event} Relaxed Data Dependence Predicates------------------------------------	
//writeEventOnRelaxedNoR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(write, loc1, ts1)} relaxedNoR(loc2, ts2))
//	
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))        
// 
//	 \replacewith(==> relaxedNoR(tempVar, tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2 ==> )
//	 \heuristics(userTaclets1)
//};
//
//readEventOnRelaxednoR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(read, loc1, ts1)} relaxedNoRaW(loc2,ts2))
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))
//         
// \replacewith(==> relaxedNoR(tempVar, tempTs))
// \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
// 	intersect(tempVar, loc1) = empty ==> );
//         
// \replacewith(==> relaxedNoR(tempVar, tempTs))
// \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
// 	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
// 
// \replacewith(==> relaxedNoR(setMinus(tempVar,loc1), tempTs))
// \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
// 	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
// 
// \heuristics(userTaclets1)
//};
////
//writeEventOnRelaxedNoW{
//		\schemaVar \term LocSet loc1, loc2;
//		\schemaVar \term int ts1, ts2;
//		\schemaVar \skolemTerm LocSet tempVar;
//		\schemaVar \skolemTerm int tempTs;
//	 	
//	 	\find(==> {\event(write, loc1, ts1)} relaxedNoW(loc2, ts2))
//	 	\varcond(\new(tempVar, \dependingOn(loc1)),
//	             \new(tempVar, \dependingOn(ts1)),
//	             \new(tempVar, \dependingOn(loc2)),
//	             \new(tempTs, \dependingOn(loc1)),
//	             \new(tempTs, \dependingOn(ts1)),
//	             \new(tempTs, \dependingOn(ts2)))        
//	     
//	 	 \replacewith(==> relaxedNoW(tempVar, tempTs))
//	     \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
//	     	intersect(tempVar, loc1) = empty ==> );
//	             
//	     \replacewith(==> relaxedNoW(tempVar, tempTs))
//	     \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
//	     	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//	     
//	     \replacewith(==> relaxedNoW(setMinus(tempVar,loc1), tempTs))
//	     \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
//	     	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//	
//	     \heuristics(userTaclets1)
//	 };
//
//readEventOnRelaxednoW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	 	
// 	\find(==> {\event(read, loc1, ts1)} relaxedNoW(loc2,ts2))
// 	\varcond(\new(tempVar, \dependingOn(loc1)),
//             \new(tempVar, \dependingOn(ts1)),
//             \new(tempVar, \dependingOn(loc2)),
//             \new(tempTs, \dependingOn(loc1)),
//             \new(tempTs, \dependingOn(ts1)),
//             \new(tempTs, \dependingOn(ts2)))
//	             
// 	\replacewith(==> relaxedNoW(tempVar, tempTs))
//    \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2==> )
//	     
//    \heuristics(userTaclets1)
// };
////
//writeEventOnRelaxedNoRaW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(write, loc1, ts1)} relaxedNoRaW(loc2, ts2))
//	\varcond(
//         \new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))        
// 
//	\replacewith(==> relaxedNoRaW(tempVar, tempTs))
//	\add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2==> )
//
//	\heuristics(userTaclets1)
//};
//
//readEventOnRelaxednoRaW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(read, loc1, ts1)} relaxedNoRaW(loc2,ts2))
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))
//         
//	\replacewith(==> relaxedNoRaW(tempVar, tempTs))
//	\add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
// 		intersect(tempVar, loc1) = empty ==> );
//         
//	 \replacewith(==> relaxedNoRaW(tempVar, tempTs))
//	 \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
//	 	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//	 
//	 \replacewith(==> relaxedNoW(tempVar, tempTs) & relaxedNoRaW(setMinus(tempVar,loc1), tempTs))
//	 \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2,
//	 	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//	 
//	 \heuristics(userTaclets1)
//};
////
//readEventOnRelaxedNoWaR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
// 	
// 	\find(==> {\event(read, loc1, ts1)} relaxedNoWaR(loc2, ts2))
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))        
// 
//	\replacewith(==> relaxedNoWaR(tempVar, tempTs))
//	\add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2==> )
//	\heuristics(userTaclets1)
//};
//
//writeEventOnRelaxednoWaR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(write, loc1, ts1)} relaxedNoWaR(loc2,ts2))
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))
//         
//	\replacewith(==> relaxedNoWaR(tempVar, tempTs))
//	\add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
// 		intersect(tempVar, loc1) = empty ==> );
//         
//	 \replacewith(==> relaxedNoWaR(tempVar, tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
//	 	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//	 
//	 \replacewith(==> relaxedNoR(tempVar, tempTs) & relaxedNoWaR(setMinus(tempVar,loc1), tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
//	 	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//	 
//	 \heuristics(userTaclets1)
//}; 
////
//readEventOnRelaxedNoWaW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(read, loc1, ts1)} relaxedNoWaW(loc2, ts2))
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))        
// 
//	 \replacewith(==> relaxedNoWaW(tempVar, tempTs))
//	 \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = {\event(read, loc1, ts1)}ts2==> )
//	 \heuristics(userTaclets1)
//};
//
//writeEventOnRelaxedNoWaW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(write, loc1, ts1)} relaxedNoWaW(loc2,ts2))
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))
//         
//
//         
//	 \replacewith(==> relaxedNoWaW(tempVar, tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
//	 	intersect(tempVar, loc1) = empty ==> );
//	         
//	 \replacewith(==> relaxedNoWaW(tempVar, tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
//	 	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//	 
//	 \replacewith(==> relaxedNoW(tempVar, tempTs) & relaxedNoWaW(setMinus(tempVar,loc1), tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
//	 	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//	 
//	 \heuristics(userTaclets1)
//};
////
//readEventOnRelaxedNoW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(read, loc1, ts1)} relaxedNoW(loc2, ts2))
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))        
// 
//	 \replacewith(==> relaxedNoW(tempVar, tempTs))
//	 \add(tempVar = {\event(read, loc1, ts1)}loc2, tempTs = { \event(read, loc1, ts1)}ts2==> )
//	 \heuristics(userTaclets1)
//};
//
//writeEventOnRelaxednoW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1,ts2;
//	\schemaVar \skolemTerm LocSet tempVar;
//	\schemaVar \skolemTerm int tempTs;
//	
//	\find(==> {\event(write, loc1, ts1)} relaxedNoW(loc2,ts2))
//	\varcond(\new(tempVar, \dependingOn(loc1)),
//         \new(tempVar, \dependingOn(ts1)),
//         \new(tempVar, \dependingOn(loc2)),
//         \new(tempTs, \dependingOn(loc1)),
//         \new(tempTs, \dependingOn(ts1)),
//         \new(tempTs, \dependingOn(ts2)))
//         
//
//         
//	 \replacewith(==> relaxedNoW(tempVar, tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
//	 	intersect(tempVar, loc1) = empty ==> );
//	         
//	 \replacewith(==> relaxedNoW(tempVar, tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
//	 	!(intersect(tempVar, loc1) = empty), ts1 = tempTs ==> );
//	 
//	 \replacewith(==> relaxedNoW(tempVar, tempTs) & relaxedNoW(setMinus(tempVar,loc1), tempTs))
//	 \add(tempVar = {\event(write, loc1, ts1)}loc2, tempTs = {\event(write, loc1, ts1)}ts2,
//	 	!(intersect(tempVar, loc1) = empty), !(ts1 = tempTs) ==> )
//	 
//	 \heuristics(userTaclets1)
//};
//
//
////----------------------------------------Non Event Updates on Relaxed Data Dependence Predicates---------------------------------------
//simplifyNONEventUpdateOnRelaxedNoR{
//	\schemaVar \update u1, u2;
//	\schemaVar \term[rigid] LocSet loc;
//	\schemaVar \term[rigid] int ts;
//	
//	\find(==> {u1 || u2} relaxedNoR(loc, ts))
//	
//	\varcond(\noEventUpdate(u1))           
//	\replacewith(==> {u2}relaxedNoR(loc, ts))
//
//	\heuristics(update_apply)
//};
//
//simplifyNONEventUpdateOnRelaxedNoW{
//	\schemaVar \update u1, u2;
//	\schemaVar \term[rigid] LocSet loc;
//	\schemaVar \term[rigid] int ts;
//	
//	\find(==> {u1 || u2} relaxedNoW(loc, ts))
//	
//	\varcond(\noEventUpdate(u1))           
//	\replacewith(==> {u2}relaxedNoW(loc, ts))
//
//	\heuristics(update_apply)
//};
//
//simplifyNONEventUpdateOnRelaxedNoRaW{
//	\schemaVar \update u1, u2;
//	\schemaVar \term[rigid] LocSet loc;
//	\schemaVar \term[rigid] int ts;
//	
//	\find(==> {u1 || u2} relaxedNoRaW(loc, ts))
//	
//	\varcond(\noEventUpdate(u1))           
//	\replacewith(==> {u2}relaxedNoRaW(loc, ts))
//
//	\heuristics(update_apply)
//};
//
//simplifyNONEventUpdateOnRelaxedNoWaR{
//	\schemaVar \update u1, u2;
//	\schemaVar \term[rigid] LocSet loc;
//	\schemaVar \term[rigid] int ts;
//	
//	\find(==> {u1 || u2} relaxedNoWaR(loc, ts))
//	
//	\varcond(\noEventUpdate(u1))           
//	\replacewith(==> {u2}relaxedNoWaR(loc, ts))
//
//	\heuristics(update_apply)
//};
//simplifyNONEventUpdateOnRelaxedNoWaW{
//	\schemaVar \update u1, u2;
//	\schemaVar \term[rigid] LocSet loc;
//	\schemaVar \term[rigid] int ts;
//	
//	\find(==> {u1 || u2} relaxedNoRaW(loc, ts))
//	
//	\varcond(\noEventUpdate(u1))           
//	\replacewith(==> {u2}relaxedNoRaW(loc, ts))
//
//	\heuristics(update_apply)
//};
//
////---------------------------------------Spliting Rules---------------------------------------------------------------------------------
//splitRelaxedNoRaW {
//
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts;
//
//	\find(relaxedNoRaW(union(loc1,loc2), ts))
//	\replacewith(relaxedNoRaW(loc1, ts) & relaxedNoRaW(loc2, ts))
//};
//
//splitRelaxedNoWaR {
//
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts;
//
//	\find(relaxedNoWaR(union(loc1,loc2), ts))
//	\replacewith(relaxedNoWaR(loc1, ts) & relaxedNoWaR(loc2, ts))
//};
//
//splitRelaxedNoWaW {
//
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts;
//
//	\find(relaxedNoWaW(union(loc1,loc2), ts))
//	\replacewith(relaxedNoWaW(loc1, ts) & relaxedNoWaW(loc2, ts))
//};
//
//splitRelaxedNoR {
//
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts;
//
//	\find(relaxedNoR(union(loc1,loc2), ts))
//	\replacewith(relaxedNoR(loc1, ts) & relaxedNoR(loc2, ts))
//};
//
//splitRelaxedNoW {
//
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts;
//
//	\find(relaxedNoW(union(loc1,loc2), ts))
//	\replacewith(relaxedNoW(loc1, ts) & relaxedNoW(loc2, ts))
//};
//
////--------------------------------------------------Splitting Rules with Equality------------------------------------------ 
//
//splitRelaxedNoRaWEQ {
//	
//	\schemaVar \term LocSet EQ, loc1, loc2;
//	\schemaVar \term int ts;
//
//	\assumes (union(loc1,loc2) = EQ ==>)
//	\find(relaxedNoRaW(EQ, ts)) \sameUpdateLevel
//	\replacewith(relaxedNoRaW(loc1, ts) & relaxedNoRaW(loc2, ts))
//};
//
//splitRelaxedNoWaREQ {
//	
//	\schemaVar \term LocSet EQ, loc1, loc2;
//	\schemaVar \term int ts;
//
//	\assumes (union(loc1,loc2) = EQ ==>)
//	\find(relaxedNoWaR(EQ, ts)) \sameUpdateLevel
//	\replacewith(relaxedNoWaR(loc1, ts) & relaxedNoWaR(loc2, ts))
//};
//
//splitRelaxedNoWaWEQ {
//	
//	\schemaVar \term LocSet EQ, loc1, loc2;
//	\schemaVar \term int ts;
//
//	\assumes (union(loc1,loc2) = EQ ==>)
//	\find(relaxedNoWaW(EQ, ts)) \sameUpdateLevel
//	\replacewith(relaxedNoWaW(loc1, ts) & relaxedNoWaW(loc2, ts))
//};
//
//splitRelaxedNoWEQ {
//	
//	\schemaVar \term LocSet EQ, loc1, loc2;
//	\schemaVar \term int ts;
//
//	\assumes (union(loc1,loc2) = EQ ==>)
//	\find(relaxedNoW(EQ, ts)) \sameUpdateLevel
//	\replacewith(relaxedNoW(loc1, ts) & relaxedNoW(loc2, ts))
//};
//
//splitRelaxedNoREQ {
//	
//	\schemaVar \term LocSet EQ, loc1, loc2;
//	\schemaVar \term int ts;
//
//	\assumes (union(loc1,loc2) = EQ ==>)
//	\find(relaxedNoR(EQ, ts)) \sameUpdateLevel
//	\replacewith(relaxedNoR(loc1, ts) & relaxedNoR(loc2, ts))
//};
////-------------------------------------------------- ---------------------------------------------- 
//
//noReadORWriteAndRelaxedNoRaW{
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts, ts1, ts2;
//
//	\find(relaxedNoRaW(loc, ts))
//
//	\replacewith(\if(noR(loc) | noW(loc) | (relaxedNoR(loc, ts1) & ts1=ts) | (relaxedNoW(loc, ts2) & ts2=ts)) \then (true) \else  (relaxedNoRaW(loc, ts)))
//};
//
//
//noRaWKnownForSuperOrSubsetOfRelaxedNoRaW{
//	\schemaVar \term LocSet loc1, loc;
//	\schemaVar \term int ts;
//
//	\assumes(noRaW(loc1) ==> )
//	\find(relaxedNoRaW(loc,ts)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc,loc1)) \then(true) \else(relaxedNoRaW(setMinus(loc,loc1),ts)))
//};
//
//relaxedNoRaWKnownForSuperOrSubsetOfRelaxedNoRaW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//
//	\assumes(relaxedNoRaW(loc1,ts1) ==> )
//	\find(relaxedNoRaW(loc2,ts2)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(relaxedNoRaW(setMinus(loc2,loc1), ts2)))
//};
////----------------------------
//noReadORWriteAndRelaxedNoWaR{
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts, ts1, ts2;
//
//	\find(relaxedNoWaR(loc, ts))
//
//	\replacewith(\if(noR(loc) | noW(loc) | (relaxedNoR(loc, ts1) & ts1=ts) | (relaxedNoW(loc, ts2) & ts2=ts)) \then (true) \else  (relaxedNoWaR(loc, ts)))
//};
//
//noWaRKnownForSuperOrSubsetOfRelaxedNoWaR{
//	\schemaVar \term LocSet loc1, loc;
//	\schemaVar \term int ts;
//
//	\assumes(noWaR(loc1) ==> )
//	\find(relaxedNoWaR(loc,ts)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc,loc1)) \then(true) \else(relaxedNoWaR(setMinus(loc,loc1), ts)))
//};
//
//relaxedNoWaRKnownForSuperOrSubsetOfRelaxedNoWaR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//
//	\assumes(relaxedNoWaR(loc1,ts1) ==> )
//	\find(relaxedNoWaR(loc2,ts2)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(relaxedNoWaR(setMinus(loc2,loc1), ts2)))
//};
////----------------------------
//noWriteAndRelaxedNoWaW{
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts, ts1;
//
//	\find(relaxedNoWaW(loc, ts))
//
//	\replacewith(\if(noW(loc) | (relaxedNoW(loc, ts1) & ts1=ts)) \then (true) \else  (relaxedNoWaW(loc, ts)))
//};
//
//noWaWKnownForSuperOrSubsetOfRelaxedNoWaW{
//	\schemaVar \term LocSet loc1, loc;
//	\schemaVar \term int ts;
//
//	\assumes(noWaW(loc1) ==> )
//	\find(relaxedNoWaW(loc,ts)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc,loc1)) \then(true) \else(relaxedNoWaW(setMinus(loc,loc1), ts)))
//};
//
//relaxedNoWaWKnownForSuperOrSubsetOfRelaxedNoWaW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//
//	\assumes(relaxedNoWaW(loc1,ts1) ==> )
//	\find(relaxedNoWaW(loc2,ts2)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(relaxedNoWaW(setMinus(loc2,loc1), ts2)))
//};
////----------------------------
//noWriteAndRelaxedNoW{
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts, ts1;
//
//	\find(relaxedNoW(loc, ts))
//
//	\replacewith(\if(noW(loc) | (relaxedNoW(loc, ts1) & ts1=ts)) \then (true) \else  (relaxedNoW(loc, ts)))
//};
//
//noWKnownForSuperOrSubsetOfRelaxedNoW{
//	\schemaVar \term LocSet loc1, loc;
//	\schemaVar \term int ts;
//
//	\assumes(noW(loc1) ==> )
//	\find(relaxedNoW(loc,ts)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc,loc1)) \then(true) \else(relaxedNoW(setMinus(loc,loc1), ts)))
//};
//
//relaxedNoWKnownForSuperOrSubsetOfRelaxedNoW{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//
//	\assumes(relaxedNoW(loc1,ts1) ==> )
//	\find(relaxedNoW(loc2,ts2)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(relaxedNoW(setMinus(loc2,loc1), ts2)))
//};
////----------------------------
//noReadAndRelaxedNoR{
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts, ts1, ts2;
//
//	\find(relaxedNoRaW(loc, ts))
//
//	\replacewith(\if(noR(loc) | (relaxedNoR(loc, ts1) & ts1=ts)) \then (true) \else  (relaxedNoR(loc, ts)))
//};
//
//noRKnownForSuperOrSubsetOfRelaxedNoR{
//	\schemaVar \term LocSet loc1, loc;
//	\schemaVar \term int ts;
//
//	\assumes(noR(loc1) ==> )
//	\find(relaxedNoR(loc,ts)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc,loc1)) \then(true) \else(relaxedNoR(setMinus(loc,loc1),ts)))
//};
//
//relaxedNoRKnownForSuperOrSubsetOfRelaxedNoR{
//	\schemaVar \term LocSet loc1, loc2;
//	\schemaVar \term int ts1, ts2;
//
//	\assumes(relaxedNoR(loc1,ts1) ==> )
//	\find(relaxedNoR(loc2,ts2)) \sameUpdateLevel
//
//	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(relaxedNoR(setMinus(loc2,loc1), ts2)))
//};
//
////-------------------------------------------------- Eliminate Updates on Relaxed Predicates------------------------------------------
//elimStateUpdatesBeforeRelaxedNoRaW{
//	\schemaVar \update u;
//	\schemaVar \program Variable pv;
//	\schemaVar \term any t;
//	\schemaVar \term[rigid] LocSet rigLoc;
//	\schemaVar \term int ts;
//	
//	\find({pv:=t || u} relaxedNoRaW(rigLoc, ts))
//	\replacewith({u}relaxedNoRaW(rigLoc, ts))
//	\heuristics(update_elim)
//};
//elimStateUpdatesBeforeRelaxedNoWaR{
//	\schemaVar \update u;
//	\schemaVar \program Variable pv;
//	\schemaVar \term any t;
//	\schemaVar \term[rigid] LocSet rigLoc;
//	\schemaVar \term int ts;
//	
//	\find({pv:=t || u} relaxedNoWaR(rigLoc, ts))
//	\replacewith({u}relaxedNoWaR(rigLoc, ts))
//	\heuristics(update_elim)
//};
//elimStateUpdatesBeforeRelaxedNoWaW{
//	\schemaVar \update u;
//	\schemaVar \program Variable pv;
//	\schemaVar \term any t;
//	\schemaVar \term[rigid] LocSet rigLoc;
//	\schemaVar \term int ts;
//	
//	\find({pv:=t || u} relaxedNoWaW(rigLoc, ts))
//	\replacewith({u}relaxedNoWaW(rigLoc, ts))
//	\heuristics(update_elim)
//};
//elimStateUpdatesBeforeRelaxedNoW{
//	\schemaVar \update u;
//	\schemaVar \program Variable pv;
//	\schemaVar \term any t;
//	\schemaVar \term[rigid] LocSet rigLoc;
//	\schemaVar \term int ts;
//	
//	\find({pv:=t || u} relaxedNoW(rigLoc, ts))
//	\replacewith({u}relaxedNoW(rigLoc, ts))
//	\heuristics(update_elim)
//};
//elimStateUpdatesBeforeRelaxedNoR{
//	\schemaVar \update u;
//	\schemaVar \program Variable pv;
//	\schemaVar \term any t;
//	\schemaVar \term[rigid] LocSet rigLoc;
//	\schemaVar \term int ts;
//	
//	\find({pv:=t || u} relaxedNoR(rigLoc, ts))
//	\replacewith({u}relaxedNoR(rigLoc, ts))
//	\heuristics(update_elim)
//};
// 
////---------------------------------Non-Event Update Propagation Rules in Relaxed Data Dependence Predicates-----------------------------
//
//propagateNonEventUpdateONRelaxedNoRaW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts; 
//	
//	\find({u}relaxedNoRaW(loc,ts))
//	\varcond(\noEventUpdate(u)) 
//
//	\replacewith(relaxedNoRaW({u}loc, {u}ts))
//
//	\heuristics(update_apply)
//};
//
//propagateNonEventUpdateONRelaxedNoWaR{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts; 
//	
//	\find({u}relaxedNoWaR(loc,ts))
//	\varcond(\noEventUpdate(u)) 
//
//	\replacewith(relaxedNoWaR({u}loc, {u}ts))
//
//	\heuristics(update_apply)
//};
//
//propagateNonEventUpdateONRelaxedNoWaW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts; 
//	
//	\find({u}relaxedNoWaW(loc,ts))
//	\varcond(\noEventUpdate(u)) 
//
//	\replacewith(relaxedNoWaW({u}loc, {u}ts))
//
//	\heuristics(update_apply)
//};
//
//propagateNonEventUpdateONRelaxedNoR{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts; 
//	
//	\find({u}relaxedNoR(loc,ts))
//	\varcond(\noEventUpdate(u)) 
//
//	\replacewith(relaxedNoR({u}loc, {u}ts))
//
//	\heuristics(update_apply)
//};
//
//propagateNonEventUpdateONRelaxedNoW{
//	\schemaVar \update u;
//	\schemaVar \term LocSet loc;
//	\schemaVar \term int ts; 
//	
//	\find({u}relaxedNoW(loc,ts))
//	\varcond(\noEventUpdate(u)) 
//
//	\replacewith(relaxedNoW({u}loc, {u}ts))
//
//	\heuristics(update_apply)
//};
////-------------------------------------------------------------Axioms-------------------------------------------------------------------
//relaxedNoRaWOnEmptySet{
//	\schemaVar \term int ts;
// 	
// 	\find(relaxedNoRaW(empty, ts))
// 	\replacewith(true)
// 	
// 	\heuristics(concrete)
// };
//
//relaxedNoWaROnEmptySet{
//	\schemaVar \term int ts;
//	
// 	\find(relaxedNoWaR(empty, ts))
// 	\replacewith(true)
// 	
// 	\heuristics(concrete)
// };
// 
// relaxedNoWaWOnEmptySet{
//	\schemaVar \term int ts;
//	 
// 	\find(relaxedNoWaW(empty, ts))
// 	\replacewith(true)
// 	
// 	\heuristics(concrete)
// };
// 
// relaxedNoWOnEmptySet{
//	\schemaVar \term int ts;
//	
// 	\find(relaxedNoW(empty, ts))
// 	\replacewith(true)
// 	
// 	\heuristics(concrete)
// };
// 
// relaxedNoROnEmptySet{
//	\schemaVar \term int ts;
//	
// 	\find(relaxedNoR(empty, ts))
// 	\replacewith(true)
// 	
// 	\heuristics(concrete)
// }; 
//}
////


//-----------------------------------------------------------------------------------------
//                        Array Assignment Rules 
//-----------------------------------------------------------------------------------------

\rules(programRules:Java, runtimeExceptions:ban, dependencies:on) {
  assignment_read_length { 
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program ArrayLength #length;
		\schemaVar \formula post;
  		
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := length(#v)}
		      				//To Be Fixed. We need the LocSet here.
		      				/*{\event(read,singleton(length(#v)),timestamp)}
		                    {timestamp:=timestamp + 1}
		                    {\event(write,singleton(#v0),timestamp)}
		                    {timestamp:=timestamp + 1}*/
		      \modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_array_read_EventUpdate{
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;
				
		\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
                  \varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		   \replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}
		   					{\event(read,singleton(#v0,arr(#se)),timestamp)}
		                    //{timestamp:=timestamp + 1}
		   \modality{#allmodal}{.. ...}\endmodality(post))
		   //\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
        	;
		"Null Reference (#v0 = null)":
		   \replacewith(==> false)
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(==> false)
		   \add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
    	  
    	   \heuristics(simplify_prog, simplify_prog_subset)
  };
  
//\rules(programRules:Java, runtimeExceptions:allow, dependencies:off) {
//assignment_to_primitive_array_component {
//               \schemaVar \modalOperator { diamond, box } #normal; 
//               \find (\modality{#normal}{..#v[#se]=#se0;...}\endmodality(post)) \sameUpdateLevel
//		 \varcond(\not \isReferenceArray(#v))
//		 "Normal Execution (#v != null)":
//			\replacewith({heap:=store(heap,#v,arr(#se),#se0)}\modality{#normal}{.. ...}\endmodality(post))
//			\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>);
//               (permissions:on) {
//                 "Write Permission to #v[#se]":
//                   \replacewith(\modality{#normal}{.. assert false : "Access permission check-point (write)."; ...}\endmodality(post))
//                   \add(==> writePermission(Permission::select(permissions, #v, arr(#se))))
//               };
//		 "Null Reference (#v = null)":
//			\replacewith(\modality{#normal}{..
//			throw new java.lang.NullPointerException(); 
//			...}\endmodality(post))
//			\add (#v=null ==>);
//		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
//			\replacewith(\modality{#normal}{.. throw new java.lang.ArrayIndexOutOfBoundsException(); ...}\endmodality(post))
//			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
//	         \heuristics(simplify_prog, simplify_prog_subset)
//};
//}
	
	assignment_to_primitive_array_component_EventUpdate { 
		\schemaVar \program Variable #v;
		\schemaVar \program SimpleExpression #se,#se0;
		\schemaVar \formula post;
		
	    \schemaVar \modalOperator { diamond, box } #normal; 
	           \find (==> \modality{#normal}{..#v[#se]=#se0;...}\endmodality(post))
		 \varcond(\not \isReferenceArray(#v))
		 "Normal Execution (#v != null)":
			\replacewith(==> {heap:=store(heap,#v,arr(#se),#se0)}
								{\event(write,singleton(#v,arr(#se)),timestamp)}\modality{#normal}{.. ...}\endmodality(post))
			//\add (!(#v=null) & lt(#se, length(#v)) & geq(#se,0)==>)
			;
	           (permissions:on) {
	             "Write Permission to #v[#se]":
	               \replacewith(==> writePermission(Permission::select(permissions, #v, arr(#se))))
	           };
		 "Null Reference (#v = null)":
			\replacewith(==> false)
			\add (#v=null ==>);
		 "Index Out of Bounds (#v != null, but #se Out of Bounds!)":
			\replacewith(==> false)
			\add (!(#v=null) & (leq(length(#v), #se) | lt(#se,0)) ==>)
	       \heuristics(simplify_prog, simplify_prog_subset)
	};


//-----------------------------------------------------------------------------------------
//                        Some Common Assignment rules 
//-----------------------------------------------------------------------------------------


  assignment  { 
     \schemaVar \program Variable #loc;
     \schemaVar \program SimpleExpression #se;
     \schemaVar \formula post;
     
     \find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
     \replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post)) 
	
	 \heuristics(simplify_prog, simplify_prog_subset)
  };

  assignment_read_attribute { 
        \schemaVar \program Variable #v0, #v, #a;
        \schemaVar \formula post;
	
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		                       \event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		                       {timestamp:=timestamp + 1}
		                                      \modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };

 assignment_read_attribute_this { 
 		\schemaVar \program Variable #v0, #v, #a;
        \schemaVar \formula post;
 	
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		      				   \event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		                       {timestamp:=timestamp + 1}
		      \modality{#allmodal}{.. ...}\endmodality(post))
                
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
  
 /* assignment_read_length { 
  		\schemaVar \program Variable #v0, #v;
        \schemaVar \formula post;
  
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := length(#v)}
		      
		      \modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };*/  


  assignment_write_attribute { 
  
  		\schemaVar \program Variable #v, #a;
  		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;
		
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) || 
		      				   \event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		                       {timestamp:=timestamp + 1}
		      					\modality{#allmodal}{.. ...}\endmodality(post))
		      
		      //\add (==>(#v=null))
		      ;
                
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  

assignment_write_attribute_this { 
		
		\schemaVar \program Variable #v, #a;
  		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		      				   \event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		                       //{timestamp:=timestamp + 1}
		  				    \modality{#allmodal}{.. ...}\endmodality(post))
                
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };  
}
