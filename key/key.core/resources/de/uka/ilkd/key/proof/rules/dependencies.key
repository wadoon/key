\schemaVariables{
 \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
}

\functions{
}

\predicates {
  \nonRigid noRaW(LocSet);
  \nonRigid noWaR(LocSet);
  \nonRigid noWaW(LocSet);
  \nonRigid noR(LocSet);
  \nonRigid noW(LocSet);
}

\programVariables {
	int timestamp;
}


\rules { 
 
 applyUpdateOnEvent {
 	\schemaVar \update u;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term int ts;
 	
 	\find({u}(\event(rw, loc, ts)))
 	
 	\replacewith(\event({u}rw, {u}loc, {u}ts))
 	
 	\heuristics(update_apply_on_update)
 	
 };

//-----------------------------------------------------------------------------------------
//                        Event Elimination Rules 
//-----------------------------------------------------------------------------------------
 
 elimEventOnRigidTerm1 {
    \schemaVar \term[rigid] any t;
	\schemaVar \update u;
	
	\find({u}t)
	
	\replacewith(t)
	
	\heuristics(update_elim)
 };
 
 elimEventOnRigidTerm2 {
	\schemaVar \term any t, result;
	\schemaVar \update u;	
	
	\find({u}t)
	\varcond(\applyEventOnRigid(u, t, result))
	
	\replacewith(result)
	
	\heuristics(update_elim)
 };

 elimEventOnRigidFormula1 {  
    \schemaVar \formula[rigid] phi;
	\schemaVar \update u;
	
	\find({u}phi)
	
	\replacewith(phi)
	
	\heuristics(update_elim)
 };
 
 elimEventOnRigidFormula2 {
	\schemaVar \formula phi, result;
	\schemaVar \update u;
	
	\find({u}phi)
	\varcond(\applyEventOnRigid(u, phi, result))
	
	\replacewith(result)
	
	\heuristics(update_elim)
 };

 applyEventOnElementary {
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;	
	\schemaVar \term int ts;
	
	\find({\event(rw, loc, ts)}(pv := t))
	
	\replacewith((pv := {\event(rw, loc, ts)}t))
	
	\heuristics(update_apply_on_update)
 };
   
 elimEventOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
		
	\find({\event(rw, loc, ts)}pv)
	
	\replacewith(pv)
	
	\heuristics(update_elim)
 };
    
 elimEventOnSkip {
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
	
	\find({\event(rw, loc, ts)}skip)
	
	\replacewith(skip)
	
	\heuristics(update_elim)
 };

//-----------------------------------------------------------------------------------------
//                        Spliting Rules 
//-----------------------------------------------------------------------------------------

 splitNoRaW {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noRaW(union(loc1,loc2)))
    \replacewith(noRaW(loc1) & noRaW(loc2))
    
 };
 
 splitNoWaR {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noWaR(union(loc1,loc2)))
    \replacewith(noWaR(loc1) & noWaR(loc2))
    
 };
 
 splitNoWaW {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noWaW(union(loc1,loc2)))
    \replacewith(noWaW(loc1) & noWaW(loc2))
    
 };
 
 splitNoR {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noR(union(loc1,loc2)))
    \replacewith(noR(loc1) & noR(loc2))
    
 };
 
 splitNoW {
    
    \schemaVar \term LocSet loc1, loc2;
 
    \find(noW(union(loc1,loc2)))
    \replacewith(noW(loc1) & noW(loc2))
    
 };
 
//-------------------------------------------------- 

 splitNoRaWEQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noRaW(EQ)) \sameUpdateLevel
    \replacewith(noRaW(loc1) & noRaW(loc2))
  
 };
 
 splitNoWaREQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noWaR(EQ)) \sameUpdateLevel
    \replacewith(noWaR(loc1) & noWaR(loc2))
  
 };
 
 splitNoWaWEQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noWaW(EQ)) \sameUpdateLevel
    \replacewith(noWaW(loc1) & noWaW(loc2))
  
 };
 
 splitNoREQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noR(EQ)) \sameUpdateLevel
    \replacewith(noR(loc1) & noR(loc2))
  
 };
 
 
 splitNoWEQ {
    \schemaVar \term LocSet EQ, loc1, loc2;
 
    \assumes (union(loc1,loc2) = EQ ==>)
    \find(noW(EQ)) \sameUpdateLevel
    \replacewith(noW(loc1) & noW(loc2))
  
 };
 
//--------------------------------------------------  
 
  noReadORWriteAndNoRaW{
 	\schemaVar \term LocSet loc1;
 	
 	\find(noRaW(loc1))
 		
 	\replacewith(\if(noR(loc1) | noW(loc1)) \then (true) \else  (noRaW(loc1)))
 	
 	//\heuristics(userTaclets1)
 };
 
 noRaWKnownForSuperset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noRaW(loc1) ==> )
 	\find(noRaW(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noRaW(loc2)))
 	
 	
 };
  
 noRaWKnownForSuperOrSubset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noRaW(loc1) ==> )
 	\find(noRaW(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noRaW(setMinus(loc2,loc1))))
 	
 };
 
//------------------------noR 

  noReadKnownForSuperset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noR(loc1) ==> )
 	\find(noR(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noR(loc2)))
 	
 	
 };
 
  noReadKnownForSupersetOrSubset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noR(loc1) ==> )
 	\find(noR(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noR(setMinus(loc2,loc1))))
 	
 	\heuristics(dep_replace_known) 	
 };
//------------------------noW
 noWriteKnownForSuperset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noW(loc1) ==> )
 	\find(noW(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noW(loc2)))
 	
 	\heuristics(dep_replace_known) 	
 	
 };
 
  noWriteKnownForSupersetOrSubSet{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noW(loc1) ==> )
 	\find(noW(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noW(setMinus(loc2,loc1))))
 	
 	\heuristics(dep_replace_known) 	
 	
 };
//------------------------noWaR
 noReadORWriteAndNoWaR{
 	\schemaVar \term LocSet loc1;
 	
 	\find(noWaR(loc1))
 		
 	\replacewith(\if(noR(loc1) | noW(loc1)) \then (true) \else  (noWaR(loc1)))
 	
 	//\heuristics(userTaclets1)
 };
 noWriteAfterReadKnownForSuperset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noWaR(loc1) ==> )
 	\find(noWaR(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noWaR(loc2)))
 	
 	
 };
 
  noWriteAfterReadKnownForSupersetOrSubset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noWaR(loc1) ==> )
 	\find(noWaR(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noWaR(setMinus(loc2,loc1))))
 	
 	\heuristics(dep_replace_known) 	
 	
 };
 
 
 //------------------------noWaW
/*  noWriteAndNoWaW{
 	\schemaVar \term LocSet loc1;
 	
 	\find(noWaW(loc1))
 		
 	\replacewith(\if(noW(loc1)) \then (true) \else  (noWaW(loc1)))
 	
 	//\heuristics(userTaclets1)
 };*/
 
 noWriteAfterWriteKnownForSuperset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noWaW(loc1) ==> )
 	\find(noWaW(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noWaW(loc2)))
 	
 	
 };
 
  noWriteAfterWriteKnownForSupersetOrSubset{
 	\schemaVar \term LocSet loc1, loc2;
 	
 	\assumes(noWaW(loc1) ==> )
 	\find(noWaW(loc2)) \sameUpdateLevel
 	
 	\replacewith(\if(subset(loc2,loc1)) \then(true) \else(noWaW(setMinus(loc2,loc1))))
 	
 	\heuristics(dep_replace_known) 	
 	
 };
 
//-----------------------------------------------------------------------------------------
//                        Update Parallel to Event Rules 
//-----------------------------------------------------------------------------------------

 applyUpdateParallelToEventOnElementary {
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;	
	\schemaVar \term int ts;
	\schemaVar \update u;

	\find({u || \event(rw, loc, ts)}(pv := t))
	
	\replacewith((pv := {u || \event(rw, loc, ts)}t))
	
	\heuristics(update_apply_on_update)//userTaclets1)
 };
    
 applyUpdateParallelToEventOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
	\schemaVar \update u;
		
	\find({u || \event(rw, loc, ts)}pv)
	
	\replacewith({u}pv)
	
	\heuristics(update_apply)//userTaclets1)
 };
    
 applyUpdateParallelToEventOnSkip {
	\schemaVar \term EventMarker rw;
	\schemaVar \term LocSet loc;
	\schemaVar \term int ts;
	\schemaVar \update u;
	
	\find({u || \event(rw, loc, ts)}skip)
	
	\replacewith(skip)
	
	\heuristics(update_elim)//userTaclets1)
 };
//===================NoRaW=====================
elimStateUpdatesBeforeNoRaW{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noRaW(tr))
	\replacewith({u}noRaW(tr))
	\heuristics(update_elim)
};
elimStateUpdatesBeforeNoWaR{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noWaR(tr))
	\replacewith({u}noWaR(tr))
	\heuristics(update_elim)
};
elimStateUpdatesBeforeNoWaW{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noWaW(tr))
	\replacewith({u}noWaW(tr))
	\heuristics(update_elim)
};
elimStateUpdatesBeforeNoR{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noR(tr))
	\replacewith({u}noR(tr))
	\heuristics(update_elim)
};
elimStateUpdatesBeforeNoW{
	\schemaVar \update u;
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term[rigid] LocSet tr;
	
	\find({pv:=t || u} noW(tr))
	\replacewith({u}noW(tr))
	\heuristics(update_elim)
};






 updateParallelToReadEventOnNoRaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noRaW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noRaW(tempVar))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2, 
          intersect(loc1, tempVar) = empty ==> );  
     \replacewith(==> ({u}noW(tempVar)) & {u}noRaW(setMinus(tempVar, loc1)))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2, 
          !(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(userTaclets1)
 };
 
 updateParallelToWriteEventOnNoRaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noRaW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noRaW(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> )
     
     \heuristics(userTaclets1)
 };

//====================NoWaR====================

 updateParallelToWriteEventOnNoWaR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noWaR(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noWaR(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
     	intersect(tempVar, loc1) = empty ==> );
     \replacewith(==> ({u}noR(tempVar)) & {u}noWaR(setMinus(tempVar, loc1)))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
     	!(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(userTaclets1)
 };
 
 updateParallelToReadEventOnNoWaR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noWaR(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noWaR(tempVar))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==>)
     \heuristics(userTaclets1)
 };
 
//========================noWaW=======================

 updateParallelToWriteEventOnNoWaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noWaW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noWaW(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
     	intersect(tempVar, loc1) = empty ==> );
     \replacewith(==> {u}noW(tempVar) & {u}noWaW(setMinus(tempVar, loc1)))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2,
     	!(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(userTaclets1)
 };
 
 updateParallelToReadEventOnNoWaW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noWaW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noWaW(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> )
     \heuristics(userTaclets1)
 };
 
 //===================General=====================
 parallelUpdateAssociative {
    \schemaVar \update u1, u2, u3;
    
    \find (u1 || (u2 || u3))
    \replacewith(u1 || u2 || u3)
    
    \heuristics(simplify)
 };
 
 //===================NoR=====================
 updateParallelToReadEventOnNoR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noR(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noR(tempVar))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2, 
          intersect(loc1, tempVar) = empty ==> );  
     \replacewith(==> false)
     \add(tempVar = {u || \event(read, loc1, ts)}loc2, 
          !(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(userTaclets1)
 };
 
 updateParallelToWriteEventOnNoR{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noR(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noR(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2 ==> )
     
     \heuristics(userTaclets1)
 };

 //===================NoW=====================
 updateParallelToWriteEventOnNoW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(write, loc1, ts)} noW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     \replacewith(==> {u}noW(tempVar))
     \add(tempVar = {u || \event(write, loc1, ts)}loc2, 
          intersect(loc1, tempVar) = empty ==> );  
     \replacewith(==> false)
     \add(tempVar = {u || \event(write, loc1, ts)}loc2, 
          !(intersect(tempVar, loc1) = empty) ==> )
     \heuristics(userTaclets1)
 };
 
 updateParallelToReadEventOnNoW{
 	\schemaVar \update u;
	\schemaVar \term LocSet loc1, loc2;
	\schemaVar \term int ts;
	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {u || \event(read, loc1, ts)} noW(loc2))
 	//To Be Done: WE HAVE TO CHANGE SKOLEM TERM IN A WAY THAT IT CAN BE DEPENDENT ON UPDATES
 	\varcond(/*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> {u}noW(tempVar))
     \add(tempVar = {u || \event(read, loc1, ts)}loc2 ==> )
     
     \heuristics(userTaclets1)
 };

//-----------------------------------------------------------------------------------------
//                        Non-Event Update Propagation Rules 
//-----------------------------------------------------------------------------------------
    
 propagateNonEventUpdateONnoRaW{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noRaW(loc))
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noRaW({u}loc))
	
	\heuristics(update_apply)
 };
 
 propagateNonEventUpdateONnoWaR{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noWaR(loc))
	
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noWaR({u}loc))
	
	\heuristics(update_apply)
 };
 
 propagateNonEventUpdateONnoWaW{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noWaW(loc))
	
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noWaW({u}loc))
	
	\heuristics(update_apply)
 };
 
 propagateNonEventUpdateONnoR{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noR(loc))
	
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noR({u}loc))
	
	\heuristics(update_apply)
 };
 
 propagateNonEventUpdateONnoW{
	\schemaVar \update u;
	\schemaVar \term LocSet loc;
	
	\find({u}noW(loc))
	
	\varcond(\noEventUpdate(u)) 
	
	\replacewith(noW({u}loc))
	
	\heuristics(update_apply)
 };

//-----------------------------------------------------------------------------------------
//                        Event Shifting Rules 
//-----------------------------------------------------------------------------------------

 shiftEventParallelToUpdate {
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	\schemaVar \update u;
 	
 	\find(\event(rw, loc, ts) || u)
 	
 	\varcond(\noEventUpdate(u)) 
 	
 	\replacewith(u || \event(rw, loc, ts))
 	
 	\heuristics(update_apply)
 };

 shiftEventParallelToElementry {
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find(\event(rw, loc, ts) || pv:=t)
 	
 	\replacewith(pv:=t || \event(rw, loc, ts))
 	
 	\heuristics(update_apply)
 };

 shiftEventWithUpdateAtFirstPlace {
 	\schemaVar \update u;
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find(u || \event(rw, loc, ts) || pv:=t)
 	
 	\replacewith(u || pv:=t || \event(rw, loc, ts))
 	
 	\heuristics(update_apply)
 };

 shiftEventWithUpdateAtLastPlace {
 	\schemaVar \update u;
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find(\event(rw, loc, ts) || pv:=t || u)
 	
 	\replacewith(pv:=t || \event(rw, loc, ts) || u)
 	
 	\heuristics(update_apply)
 };

//----------------------------------Shifting rules for only events

 shiftOnlyEventParallelToElementry {
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \update evUp;
 	
 	\find(evUp || pv:=t)
 	\varcond(\onlyEventUpdates(evUp))
 	
 	\replacewith(pv:=t || evUp)
 	
 	\heuristics(update_apply)
 };

 shiftOnlyEventWithUpdateAtFirstPlace {
 	\schemaVar \update evUp;
 	\schemaVar \update u;
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find(u || evUp || pv:=t)
 	\varcond(\onlyEventUpdates(evUp))
 	
 	\replacewith(u || pv:=t || evUp)
 	
 	\heuristics(update_apply)
 };

 shiftOnlyEventWithUpdateAtLastPlace {
 	\schemaVar \update evUp;
 	\schemaVar \update u;
 	\schemaVar \program Variable pv;
 	\schemaVar \term any t;
 	\schemaVar \term EventMarker rw;
 	\schemaVar \term LocSet loc;
 	\schemaVar \term int ts;
 	
 	\find( pv:=t || evUp || u)
 	\varcond(\onlyEventUpdates(evUp))
 	
 	\replacewith(pv:=t || u || evUp)
 	
 	\heuristics(update_apply)
 };


//-----------------------------------------------------------------------------------------
//                        Simplification Rules 
//-----------------------------------------------------------------------------------------

 simplifyEventUpdateNoRaW {
	\schemaVar \update u1,u2;
	\schemaVar \term[rigid] LocSet loc;
 	\schemaVar \skolemTerm LocSet tempVar;
 	

	
	\find({u1||u2}noRaW(loc))
	
	\varcond(\noEventUpdate(u1),
	   /*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc)))   
	
	\replacewith({u2}noRaW(loc))
	
	\heuristics(update_apply)
        
   };
   
 simplifyEventUpdateNoWaR {
	\schemaVar \update u1,u2;
	\schemaVar \term[rigid] LocSet loc;
	\schemaVar \skolemTerm LocSet tempVar;

	
	\find({u1||u2}noWaR(loc))
	
	\varcond(\noEventUpdate(u1),
	   /*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc)))
	
	\replacewith({u2}noWaR(loc))
	
	\heuristics(update_apply)
        
   };
   
   simplifyEventUpdateNoWaW {
	\schemaVar \update u1,u2;
	\schemaVar \term[rigid] LocSet loc;
	\schemaVar \skolemTerm LocSet tempVar;

	
	\find({u1||u2}noWaW(loc))
	
	\varcond(\noEventUpdate(u1),
	   /*\new(tempVar, \dependingOn(u)),*/
             \new(tempVar, \dependingOn(loc)))
             
	\replacewith({u2}noWaW(loc))
	
	\heuristics(update_apply)
        
   };
   
 writeEventBeforeNoRaW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	\find({\event(write, loc1, ts)} noRaW(loc2))
 	
 	\replacewith(noRaW({\event(write, loc1, ts)}loc2))
 	
 	\heuristics(userTaclets1)
 };
 
 readEventBeforeNoRaW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find({\event(read, loc1, ts)} noRaW(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))
		
 	\replacewith(noRaW(tempVar))
 	\add(tempVar = {\event(read, loc1, ts)}loc2 & intersect(loc1, tempVar) = empty ==> );
 	
 	\replacewith(noW(tempVar) & noRaW(setMinus(tempVar,loc1)))
 	\add(tempVar = {\event(read, loc1, ts)}loc2 & !(intersect(loc1, tempVar) = empty) ==> )
 	
 	\heuristics(userTaclets1)
 };

 writeEventBeforeNoWaR {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find({\event(write, loc1, ts)} noWaR(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))
		
 	\replacewith(noWaR(tempVar))
 	\add(tempVar = {\event(write, loc1, ts)}loc2 & intersect(loc1, tempVar) = empty ==> );
 	
 	\replacewith(noR(tempVar) & noWaR(setMinus(tempVar,loc1)))
 	\add(tempVar = {\event(write, loc1, ts)}loc2 & !(intersect(loc1, tempVar) = empty) ==> )
 	
 	\heuristics(userTaclets1)
 };
 
 readEventBeforeNoWaR {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	\find({\event(read, loc1, ts)} noWaR(loc2))
 	
 	\replacewith( noWaR({\event(read, loc1, ts)}loc2))
 	
 	\heuristics(userTaclets1)
 };
 
 writeEventBeforeNoWaW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find({\event(write, loc1, ts)} noWaW(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))
		
 	\replacewith(noWaW(tempVar))
 	\add(tempVar = {\event(write, loc1, ts)}loc2 & intersect(loc1, tempVar) = empty ==> );
 	
 	\replacewith(noW(tempVar) & noWaW(setMinus(tempVar,loc1)))
 	\add(tempVar = {\event(write, loc1, ts)}loc2 & !(intersect(loc1, tempVar) = empty) ==> )
 	
 	\heuristics(userTaclets1)
 };
 
 readEventBeforeNoWaW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	\find({\event(read, loc1, ts)} noWaW(loc2))
 	
 	\replacewith( noWaW({\event(read, loc1, ts)}loc2))
 	
 	\heuristics(userTaclets1)
 };
 
 writeEventBeforeNoW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {\event(write, loc1, ts)} noW(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> noW(tempVar))
     \add(tempVar = {\event(write, loc1, ts)}loc2,
     	intersect(loc1, tempVar) = empty ==> );
     
     \replacewith(==> false)
     \add(tempVar = {\event(write, loc1, ts)}loc2,
     	!(intersect(loc1, tempVar) = empty) ==> )
     
 	\heuristics(userTaclets1)
 };
 
 readEventBeforeNoW {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	\find({\event(read, loc1, ts)} noW(loc2))
 	
 	
 	\replacewith( noW({\event(read, loc1, ts)}loc2))
 	
 	\heuristics(userTaclets1)
 };  
 
 writeEventBeforeNoR {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	
 	
 	\find({\event(write, loc1, ts)} noR(loc2))
 	
 	\replacewith(noR({\event(write, loc1, ts)}loc2))
 	
 //	\heuristics(userTaclets1)
 };
 
 readEventBeforeNoR {
 	\schemaVar \term LocSet loc1, loc2;
 	\schemaVar \term int ts;
 	\schemaVar \skolemTerm LocSet tempVar;
 	
 	\find(==> {\event(read, loc1, ts)} noR(loc2))
 	\varcond(\new(tempVar, \dependingOn(loc1)),
             \new(tempVar, \dependingOn(ts)),
             \new(tempVar, \dependingOn(loc2)))        
     
     \replacewith(==> noR(tempVar))
     \add(tempVar = {\event(read, loc1, ts)}loc2,
     	intersect(loc1, tempVar) = empty ==> );
     
     \replacewith(==> false)
     \add(tempVar = {\event(read, loc1, ts)}loc2,
     	!(intersect(loc1, tempVar) = empty) ==> )
     
 	\heuristics(userTaclets1)
 };
 
 
//-----------------------------------------------------------------------------------------
//                        Proof Closing Rules 
//-----------------------------------------------------------------------------------------

 noRaWOnEmptySet{
 	
 	\find(noRaW(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };

 noWaROnEmptySet{
 	
 	\find(noWaR(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };
 
 noWaWOnEmptySet{
 	
 	\find(noWaW(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };
 
 noWOnEmptySet{
 	
 	\find(noW(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };
 
 noROnEmptySet{
 	
 	\find(noR(empty))
 	\replacewith(true)
 	
 	\heuristics(concrete)
 };
  
  
    
}

//-----------------------------------------------------------------------------------------
//                        Event Star Rules 
//-----------------------------------------------------------------------------------------
\rules {
 
 applyUpdateOnEventStar{
  	\schemaVar \term int ts;
  	\schemaVar \term int unique;
  	\schemaVar \update u;
  	
  	\find({u}(\eventStar(ts, unique)))
  	\replacewith(\eventStar({u}ts, {u}unique))
  	
  	\heuristics(update_apply_on_update)
  	};
  	
  
 elimEventStarOnRigidTerm1 {
    \schemaVar \term[rigid] any t;
	\schemaVar \term int ts;
  	\schemaVar \term int unique;
	
	\find({\eventStar(ts, unique)}t)
	
	\replacewith(t)
	
	\heuristics(update_elim)
 };
 
 elimEventStarOnRigidFormula1 {
    \schemaVar \formula[rigid] phi;
	\schemaVar \term int ts;
  	\schemaVar \term int unique;
	
	\find({\eventStar(ts,unique)}phi)
	
	\replacewith(phi)
	
	\heuristics(update_elim)
 };

 elimEventStarOnElementary {
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term int ts;
  	\schemaVar \term int unique;
	
	\find({\eventStar(ts,unique)}(pv := t))
	
	\replacewith((pv := {\eventStar(ts,unique)}t))
	
	\heuristics(update_apply_on_update)
 };
   
 elimEventStarOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term int ts;
  	\schemaVar \term int unique;
		
	\find({\eventStar(ts, unique)}pv)
	
	\replacewith(pv)
	
	\heuristics(update_elim)
 };
    
 elimEventStarOnSkip {
	\schemaVar \term int ts;
  	\schemaVar \term int unique;
	
	\find({\eventStar(ts, unique)}skip)
	
	\replacewith(skip)
	
	\heuristics(update_elim)
 }; 	
  	
 applyUpdateParallelToEventStarOnElementary {
	\schemaVar \program Variable pv;
	\schemaVar \term any t;
	\schemaVar \term int ts;
	\schemaVar \update u;
  	\schemaVar \term int unique;
	
	\find({u || \eventStar(ts,unique)}(pv := t))
	
	\replacewith((pv := {u || \eventStar(ts,unique)}t))
	
	\heuristics(update_apply_on_update)
 };
    
 applyUpdateParallelToEventStarOnPV {
	\schemaVar \program Variable pv;
	\schemaVar \term int ts;
	\schemaVar \update u;
  	\schemaVar \term int unique;
		
	\find({u || \eventStar(ts,unique)}pv)
	
	\replacewith({u}pv)
	
	\heuristics(update_elim)
 };
    
 applyUpdateParallelToEventStarOnSkip {
	\schemaVar \term int ts;
	\schemaVar \update u;
  	\schemaVar \term int unique;
		
	\find({u || \eventStar(ts,unique)}skip)
	
	\replacewith({u}skip)
	
	\heuristics(update_elim)
 };
 
  shiftEventStarParallelToUpdate {
 	\schemaVar \term int ts;
 	\schemaVar \update u; 
   	\schemaVar \term int unique;
	
 	\find(\eventStar(ts,unique) || u)
	\varcond(\noEventUpdate(u)) 
 	\replacewith(u || \eventStar(ts,unique))
 	
 	\heuristics(userTaclets1)
 };

eventStarBeforNoR{
 	\schemaVar \term[rigid] LocSet loc1;
 	\schemaVar \term int ts;
  	\schemaVar \term int unique;
  	\schemaVar \update u;
  	
 	\find({u || \eventStar(ts,unique)} noR(loc1))
 	\varcond(\noEventUpdate(u))
 	
 	\replacewith({\eventStar(ts,unique)} noR(loc1))
 	\heuristics(userTaclets1)
 };
 
 eventStarBeforNoW{
 	\schemaVar \term[rigid] LocSet loc1;
 	\schemaVar \term int ts;
  	\schemaVar \term int unique;
  	\schemaVar \update u;
  	
 	\find({u || \eventStar(ts,unique)} noW(loc1))
 	\varcond(\noEventUpdate(u))
 	
 	\replacewith({\eventStar(ts,unique)} noW(loc1))
 	\heuristics(userTaclets1)
 };
 
 updateParallelToEventStarOnNoRaW{
 	\schemaVar \term LocSet loc1;
 	\schemaVar \term int ts;
  	\schemaVar \term int unique;
  	\schemaVar \update u;
  	
 	\find(==> {u || \eventStar(ts,unique)} noRaW(loc1))
 	\varcond(\noEventUpdate(u))
 	
 	\replacewith(==> noRaW({u || \eventStar(ts,unique)}loc1));
 	\add(==> {u || \eventStar(ts,unique)} (noR(loc1) | noW(loc1)))
 	
 	\heuristics(userTaclets1)
 };

}

//-----------------------------------------------------------------------------------------
//                        Array Assignment Rules 
//-----------------------------------------------------------------------------------------

\rules(programRules:Java, runtimeExceptions:ban, dependencies:on) {
  assignment_read_length { 
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program ArrayLength #length;
		\schemaVar \formula post;
  		
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := length(#v)}
		      				//To Be Fixed. We need the LocSet here.
		      				/*{\event(read,singleton(length(#v)),timestamp)}
		                    {timestamp:=timestamp + 1}
		                    {\event(write,singleton(#v0),timestamp)}
		                    {timestamp:=timestamp + 1}*/
		      \modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };  

  assignment_array2{
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;
				
		\find (==> \modality{#allmodal}{.. #v = #v0[#se]; ...}\endmodality(post))
                  \varcond(\hasSort(\elemSort(#v0), G))
		"Normal Execution (#v0 != null)":
		   \replacewith(==> {#v:=G::select(heap, #v0, arr(#se))}
		   					{\event(read,singleton(#v0,arr(#se)),timestamp)}
		                    {timestamp:=timestamp + 1}
		   \modality{#allmodal}{.. ...}\endmodality(post))
		   //\add (==>(#v0=null) | leq(length(#v0), #se) | lt(#se,0))
        	;
		"Null Reference (#v0 = null)":
		   \replacewith(==> false)
	           \add (#v0=null ==>);	
		"Index Out of Bounds (#v0 != null, but #se Out of Bounds!)":
	  	   \replacewith(==> false)
		   \add (!(#v0=null) & (leq(length(#v0), #se) | lt(#se,0)) ==>)
    	  
    	   \heuristics(simplify_prog, simplify_prog_subset)
  };
  
}

//-----------------------------------------------------------------------------------------
//                        Some Common Assignment rules 
//-----------------------------------------------------------------------------------------

\rules(programRules:Java, dependencies:on) {
  assignment  { 
     \schemaVar \program Variable #loc;
     \schemaVar \program SimpleExpression #se;
     \schemaVar \formula post;
     
     \find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post))
     \replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post)) 
	
	 \heuristics(simplify_prog, simplify_prog_subset)
  };

}


\rules(programRules:Java, runtimeExceptions:ban, dependencies:on) {
  assignment_read_attribute { 
        \schemaVar \program Variable #v0, #v, #a;
        \schemaVar \formula post;
	
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		                       \event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		                       {timestamp:=timestamp + 1}
		                                      \modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };

 assignment_read_attribute_this { 
 		\schemaVar \program Variable #v0, #v, #a;
        \schemaVar \formula post;
 	
		\find (==> \modality{#allmodal}{.. #v0 = #v.#a; ...}\endmodality(post))
 	        \varcond(\not \static(#a), \not \isArrayLength(#a), \hasSort(#a, G), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {#v0 := G::select(heap, #v, #memberPVToField(#a)) ||
		      				   \event(read,singleton(#v,#memberPVToField(#a)),timestamp)}
		                       {timestamp:=timestamp + 1}
		      \modality{#allmodal}{.. ...}\endmodality(post))
                
		      \heuristics(simplify_prog, simplify_prog_subset)
  };
  
 /* assignment_read_length { 
  		\schemaVar \program Variable #v0, #v;
        \schemaVar \formula post;
  
		\find (==> \modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {#v0 := length(#v)}
		      
		      \modality{#allmodal}{.. ...}\endmodality(post))
		      //\add (==>(#v=null))
		      ;
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	
		      \heuristics(simplify_prog, simplify_prog_subset)
  };*/  
}

\rules(programRules:Java, runtimeExceptions:ban, dependencies:on) {

  assignment_write_attribute { 
  
  		\schemaVar \program Variable #v, #a;
  		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;
		
		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \not\isThisReference(#v))
		"Normal Execution (#v != null)":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) || 
		      				   \event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		                       {timestamp:=timestamp + 1}
		      					\modality{#allmodal}{.. ...}\endmodality(post))
		      
		      //\add (==>(#v=null))
		      ;
                
		"Null Reference (#v = null)":
		      \replacewith(==> false)
		      \add (#v=null ==>)	 
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignment"
  };  

assignment_write_attribute_this { 
		
		\schemaVar \program Variable #v, #a;
  		\schemaVar \program SimpleExpression #se;
		\schemaVar \formula post;

		\find (==> \modality{#allmodal}{.. #v.#a=#se; ...}\endmodality(post))
	        \varcond(\not \static(#a), \isThisReference(#v))
		"Normal Execution":
		      \replacewith(==> {heap:=store(heap,#v,#memberPVToField(#a),#se) ||
		      				   \event(write,singleton(#v,#memberPVToField(#a)),timestamp)}
		                       {timestamp:=timestamp + 1}
		  				    \modality{#allmodal}{.. ...}\endmodality(post))
                
		      \heuristics(simplify_prog, simplify_prog_subset)
		      \displayname "assignmentThis"
  };  
   
}
