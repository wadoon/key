// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2013 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//

// This file contains only the RULES for the data type Ord
// of ordinals.
// The rules come in sections
//  * Core Axioms
//  * Definitional Extensions 
//  * Additional Axioms
//  * Derived  Taclets
// 

//
//  This is still for the greatest part the old file.
//  Needs to be changed for Tak.
//



\rules{


//--------------------------------------------------------------------------
//  
//  Core Axioms
//  
// Definitional extension with "oleq" and "lim" are included 
//  from the start.
//
//--------------------------------------------------------------------------

olt_trans_Axiom{ 
   \schemaVar \variables Ord nv, nv0, nv1;

   \add(  \forall nv;(\forall nv0; (\forall nv1;(
           (olt(nv,nv0) &  olt(nv0,nv1)) -> olt(nv,nv1)))) ==>)
  };

olt_irref_Axiom{ 
    \schemaVar \variables Ord nv;

  \add(  \forall nv;( (!olt(nv,nv))) ==>)
  };

olt_total_Axiom{ 
    \schemaVar \variables Ord nv, nv1;

  \add(  \forall nv;(  \forall nv1;(
           olt(nv,nv1) | nv = nv1 | olt(nv1,nv))) ==>)
  };

// Definition of less_or_equal relation

oleq_Def{ 
       \schemaVar \variables Ord nv, nv1;
            \schemaVar \term Ord i,i1;
       \find(oleq(i,i1))
       \add( \forall nv;( \forall nv1;(
         oleq(nv,nv1) <-> olt(nv,nv1) | nv = nv1)) ==> )
       };


oleq_zeroAxiom{ 
    \schemaVar \variables Ord nv;
    \add(  \forall nv;(  oleq(o_0, nv) ) ==>)
  };


// Definition of limit ordinal

olimDef{ 
      \schemaVar \variables Ord nv;
      \schemaVar \term Ord i;
      \find(lim(i))
      \varcond (\notFreeIn(nv,i))
      \replacewith(o_0!=i & !\exists nv;(i=oadd(nv,o_1)))};

omegaDef1{ 
    \find(omega)
    \add(lim(omega)==>)
    \heuristics(simplify_enlarging)   
};

omegaDefLeastInf{ 
    \schemaVar \variables Ord i,j;
    \add(\forall j;(
         ( olt(o_0,j)  
      &   \forall i;(olt(i,j) -> olt(oadd(i,o_1),j))
        )
      -> oleq(omega,j)) ==>)
};

oSucc{ 
     \schemaVar \variables Ord nv;
     \add(\forall nv;(olt(nv,oadd(nv,o_1)))==>)
};

oLeastSucc{ 
     \schemaVar \variables Ord nv, nv1;
     \add(\forall nv;(\forall nv1;(
       olt(nv,nv1) -> oleq(oadd(nv,o_1),nv1)))==>)
};

oIndBasic{ 
  \schemaVar \variables Ord nv,nv1,nv2;
  \schemaVar \formula phi;
  \find (==> \forall nv;phi)
  \varcond(\notFreeIn(nv1,phi),\notFreeIn(nv2,phi))
  \replacewith(==> 
   \forall nv1;(
    (\forall nv2;(olt(nv2,nv1) -> {\subst nv; nv2}phi))
   ->  {\subst nv; nv1}phi))
  };

oReplacementScheme{
  \schemaVar \variables Ord x,y,z,a,b;
  \schemaVar \formula phi;
   \find (==> \forall a;\exists b;\forall y;\forall x;(
      (phi & olt(x,a)) -> olt(y,b))
       ) 
   \varcond(\notFreeIn(z,phi), \notFreeIn(a,phi), \notFreeIn(b,phi))
 \replacewith( ==>
  \forall x;\forall y;\forall z;((phi & {\subst y;(z)}phi) -> y = z)
   )
  };


//--------------------------------------------------------------------------
//  
//   Derived Basic Lemmas 
//  
//--------------------------------------------------------------------------


// proofScript exists
\lemma
olimDefAdd{ 
      \schemaVar \variables Ord nv;
      \schemaVar \term Ord i;
      \find(lim(i) ==>)
      \varcond (\notFreeIn(nv,i))
      \add(o_0!=i & !\exists nv;(i=oadd(nv,o_1))==>)
};

// proofScript exists
\lemma
olimDefEquiv{ 
     \schemaVar \term Ord i;
     \schemaVar \variables  Ord ov;
   \find(lim(i))
  \varcond(\notFreeIn(ov,i))
   \replacewith(i!=o_0 & \forall ov;(olt(ov,i) -> olt(oadd(ov,o_1),i)))
};


// proofScript exists 
\lemma
oInd{ 
  \schemaVar \variables Ord nv,nv1;
  \schemaVar \formula phi;
  \find (==> \forall nv;phi)
  \varcond(\notFreeIn(nv1,phi))
  "Base Case":      \add (==> {\subst nv; o_0}phi );
  "Successor Case":  \add(==> \forall nv; (phi ->  {\subst nv; (oadd(nv,o_1))}phi));   
  "Limit Case":     \add(==> (\forall nv1; (
                         (lim(nv1) & \forall nv; (olt(nv,nv1) -> phi)) ->  {\subst nv; nv1}phi)))
};

// proofScript exists
\lemma
least_number_principle{ 
 \schemaVar \variable Ord i,k; 
 \schemaVar \formula phi; 
  \find(\exists i;phi)
  \varcond(\notFreeIn(k,phi))
  \replacewith(\exists i;(phi & \forall k;(olt(k,i) -> !({\subst i;k}phi))))
  };

// proofScript exists
\lemma
oSpecialReplacement{
  \schemaVar \variables Ord x,a,b;
  \schemaVar \term Ord to;
  \varcond(\notFreeIn(a,to), \notFreeIn(b,to))
  \add(
    \forall a;\exists b;\forall x;(
        olt(x,a) -> olt(to,b))
      ==>)
};

//--------------------------------------------------------------------------
//  
//   Definitional extension: constant o_1
//   and derived taclets.
//  
//--------------------------------------------------------------------------


one_Def{
    \add(oadd(o_0,o_1) = o_1 ==>)
    };

// proofScript exists
\lemma
olt_zero{ 
   \schemaVar \term Ord i;
   \find (olt(i, o_0))
   \replacewith (false) 
   \heuristics(concrete) 
};

// proofScript exists
\lemma
oadd01{ 
 \find(oadd(o_0,o_1))
 \replacewith(o_1)
 \heuristics(concrete)
};


// proofScript exists
\lemma
olt_O1{ 
   \find (olt(o_0, o_1))
   \replacewith(true)
   \heuristics(concrete) 
};

// proofScript exists
\lemma
oDiff01{ 
   \find(o_0=o_1)
   \replacewith(false)
   \heuristics(concrete)
};


// proofScript exists
\lemma
olt_discret{ 
    \schemaVar \term Ord i;
   \find (olt(o_0, i)) 
   \replacewith(oleq(o_1,i))
   \heuristics(simplify_enlarging) };



// proofScript exists
\lemma
olt_one{ 
   \schemaVar \term Ord i;
   \find (olt(i, o_1))
   \replacewith (i=o_0) 
   \heuristics(concrete) 
};


// proofScript exists
\lemma 
omegaZero{ 
   \find(olt(o_0,omega))
   \replacewith(true)
   \heuristics(concrete)
};



// proofScript exists
\lemma
omegaOne{ 
   \find(olt(o_1,omega))
   \replacewith(true)
   \heuristics(concrete)
};

// proofScript exists
\lemma
o0notSuccQ{
   \schemaVar \variables Ord i;
   \add(\forall i;(!oadd(i,o_1)=o_0)==>)
 };


// proofScript exists
\lemma
o0notSucc{
   \schemaVar \term Ord i;
   \find(oadd(i,o_1)=o_0)
   \replacewith(false)
   \heuristics(concrete)
 };


// proofScript 
oSuccInjective{ 
    \schemaVar \term Ord j,k;
    \find(oadd(j,o_1) = oadd(k,o_1) ==>)
    \add(j=k ==>)
   \heuristics(simplify_enlarging)
};



//--------------------------------------------------------------------------
//  
//  Definitional Extensions with sup and max
//  
//--------------------------------------------------------------------------


// osup{nv;}(j,i) is the least ordinal that is greater or equal
//  than any i for all nv < j. Typically, nv will be a
//  free variable in the term i.

osupDef{ 
  \schemaVar \variables Ord nv,nv1,nv2;
  \schemaVar \term Ord i,j;
  \find(osup{nv;}(j,i))
  \varcond(\notFreeIn(nv,j), \notFreeIn(nv1,j),\notFreeIn(nv2,j), \notFreeIn(nv1,i),\notFreeIn(nv2,i))
  \add(\forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), osup{nv;}(j,i))),
  \forall nv2;(
       \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), nv2)) ->
         oleq(osup{nv;}(j,i), nv2))   ==> )
  };

// maximum of two ordinals

omaxDef{ 
      \schemaVar \term Ord i,i1;
      \find(omax(i,i1))
      \replacewith(\if(oleq(i,i1))\then(i1)\else(i))
};

//--------------------------------------------------------------------------
//
// derived taclets for oleq
//
//--------------------------------------------------------------------------

// proofScript exists
\lemma
oleq_replace{ 
   \schemaVar \term Ord i,i1;
   \find(oleq(i,i1))
   \replacewith(olt(i,i1) | i = i1)
   \heuristics(simplify)
 };

// this is a practical version of the transitivity axiom
// avoiding manual instantiation of universal quantifiers.

// proofScript exists
\lemma
olt_trans{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (olt(i, i0) ==>) 
   \find (olt(i0, i1) ==>) 
   \add (olt(i, i1) ==>)};


// proofScript exists
\lemma
olt_transAut{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (olt(i, i0), olt(i0, i1)  ==>)
   \find (olt(i, i1)) 
   \inSequentState
   \replacewith(true)
   \heuristics(simplify)
};

// frequently occuring consequence from olt_irref_Axiom
// proofScript exists
\lemma
olt_irref{ 
    \schemaVar \term Ord i;
   \find (olt(i, i)) 
   \replacewith (false) 
   \heuristics(simplify) };


// proofScript exists
\lemma 
olt_0Min{ 
   \schemaVar \term Ord i;
   \find (olt(i, o_0))
   \replacewith(false)
   \heuristics(concrete) 
};

//  proofScript  exists
\lemma 
oleq_zero{ 
   \schemaVar \term Ord i;
   \find (oleq(o_0, i))
   \replacewith(true)
   \heuristics(concrete) 
};

// proofScript exists
\lemma 
olessPlusOne{ 
 \schemaVar \term Ord i,j;
 \find(olt(i,oadd(j,o_1)))
 \replacewith(olt(i,j)|i=j)
 \heuristics(simplify_enlarging)
};


// proofScript  exists
\lemma 
oleq_trans{ 
   \schemaVar \term Ord i, i0, i1;
  \assumes (oleq(i, i0) ==>) 
   \find (oleq(i0, i1) ==>) 
   \add (oleq(i, i1) ==>)
};

// proofScript  exists
\lemma 
oleq_transAut{ 
   \schemaVar \term Ord i, i0, i1;
  \assumes (oleq(i, i0), oleq(i0, i1) ==>)
   \find(oleq(i, i1))
   \inSequentState
   \replacewith(true)
   \heuristics(simplify)
};

// proofScript   exists
\lemma
oltleq_trans{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (oleq(i, i0) ==>) 
   \find (olt(i0, i1) ==>) 
   \add (olt(i, i1) ==>)
};

 // proofScript    exists
\lemma
oltleq_transAut{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (oleq(i, i0), olt(i0, i1) ==>) 
   \find (olt(i, i1)) 
   \inSequentState
   \replacewith(true)
   \heuristics(simplify)
};

// proofScript  exists
\lemma
oleqolt_trans{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (olt(i, i0) ==>) 
   \find (oleq(i0, i1) ==>) 
   \add (olt(i, i1) ==>)
}; 

// proofScript exists
\lemma
oleqolt_transAut{  
   \schemaVar \term Ord i, i0, i1; 
   \assumes (olt(i, i0), oleq(i0, i1) ==>) 
   \find (olt(i, i1)) 
   \inSequentState
   \replacewith(true)
   \heuristics(simplify)
};

// proofScript exists
\lemma
oleqolt_transQ{  
   \schemaVar \variables  Ord i, i0, i1; 
   \add (\forall i;(\forall i0;(\forall i1;(
    oleq(i, i0) & olt(i0,i1) -> olt(i,i1)))) ==>)
}; 

// proofScript exists
\lemma 
oleq_antisym{ 
  \schemaVar \term Ord i, i1; 
  \assumes(oleq(i,i1) ==>)
  \find(oleq(i1,i) ==>)
  \add(i=i1 ==>)  
  \heuristics(simplify)
  };

//--------------------------------------------------------------------------
//
// derived taclets for omax
//
//--------------------------------------------------------------------------

// proofScript exists
\lemma
omaxLess{ 
 \schemaVar \term Ord i, i0, i1; 
   \find(olt(i,omax(i0,i1)))
   \replacewith(olt(i,i0)|olt(i,i1))
   \heuristics(simplify)}
;

// proofScript exists
\lemma
omaxGreater{ 
 \schemaVar \term Ord i, i0, i1; 
   \find(olt(omax(i0,i1),i))
   \replacewith(olt(i0,i)&olt(i1,i))
   \heuristics(simplify)}
;

// proofScript exists
\lemma
omaxLeq{ 
 \schemaVar \term Ord i, i0, i1; 
   \find(oleq(i,omax(i0,i1)))
   \replacewith(oleq(i,i0)|oleq(i,i1))
   \heuristics(simplify)}
;

// proofScript exists
\lemma
omaxGeq{ 
 \schemaVar \term Ord i, i0, i1; 
   \find(oleq(omax(i0,i1),i))
   \replacewith(oleq(i0,i)&oleq(i1,i))
   \heuristics(simplify)}
;

// proofScript exists
\lemma
omax0Left{ 
 \schemaVar \term Ord i; 
 \find(omax(o_0,i))
  \replacewith(i)
  \heuristics(concrete)
};

// proofScript exists
\lemma
omax0Right{ 
 \schemaVar \term Ord i; 
 \find(omax(i,o_0))
  \replacewith(i)
  \heuristics(concrete)
};

// proofScript exists
\lemma
omaxLeft{ 
 \schemaVar \term Ord i0,i1; 
 \find(oleq(i0,omax(i0,i1)))
  \replacewith(true)
  \heuristics(concrete)
};

// proofScript exists
\lemma
omaxRight{ 
 \schemaVar \term Ord i0,i1; 
 \find(oleq(i1,omax(i0,i1)))
  \replacewith(true)
  \heuristics(concrete)
};

// This is a workaround for deficiencies
// of proofScript

// Proof exists (not proofScript)
\lemma
WRolteq{
  \schemaVar \variables Ord i0,i1,i2; 
  \add(\forall i0;\forall i1;\forall i2;(
          olt(i0,i1) & i1 = i2 -> olt(i0,i2)) ==>)
};

//proofScript exists
\lemma
omaxSymQ{
\schemaVar \variables Ord i0,i1; 
  \add(\forall i0;\forall i1;(
         omax(i0,i1) = omax(i1,i0))
          ==> )
};

//proofScript exists
\lemma
omaxPlusOnR{
   \schemaVar \term Ord t0,t1; 
   \assumes(olt(t1,t0) ==> )
   \find(omax(t0,oadd(t1,o_1))) \sameUpdateLevel 
   \replacewith(omax(t0,t1))
   \heuristics ( simplify )
};

//proofScript exists
\lemma
omaxPlusOnL{
   \schemaVar \term Ord t0,t1; 
   \assumes(olt(t0,t1) ==>)
   \find(omax(oadd(t0,o_1),t1)) \sameUpdateLevel 
   \replacewith(omax(t0,t1))
   \heuristics ( simplify )
};

//--------------------------------------------------------------------------
//
// derived taclets on osup
//
//--------------------------------------------------------------------------

// proofScript exists
\lemma
osupEQDef{  
  \schemaVar \variables Ord nv,nv1,nv2;
  \schemaVar \term Ord i,j,k;
  \find(==> osup{nv;}(j,i) = k)
  \varcond(\notFreeIn(nv,j), \notFreeIn(nv1,j),\notFreeIn(nv2,j), \notFreeIn(nv1,i),\notFreeIn(nv2,i),
           \notFreeIn(nv,k), \notFreeIn(nv1,k), \notFreeIn(nv2,k) )
  \replacewith( ==> 
  \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), k)) &
  \forall nv2;(
       \forall nv1;(olt(nv1,j) -> oleq(({\subst nv;(nv1)}i), nv2)) ->
         oleq(k, nv2)))
  };

// proofScript exists
\lemma
osup0{ 
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i;
  \find(osup{nv;}(o_0,i))
  \replacewith(o_0)
  \heuristics(simplify)
  };


// proofScript exists
\lemma
osup1{ 
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i;
  \find(osup{nv;}(o_1,i))
  \replacewith({\subst  nv; (o_0)}i)
 \heuristics(simplify)
  };

// proofScript exists
\lemma
oselfSup{ 
  \schemaVar \variables Ord nv, lambda;
 \add(\forall nv;(lim(nv) -> osup{lambda;}(nv,lambda) = nv)==>)
};

// proofScript exists
\lemma
oselfSupSucc{ 
  \schemaVar \variables Ord nv, lambda;
 \add(\forall nv; osup{lambda;}(oadd(nv,o_1),lambda) = nv==>)
};


// proofScript exists
\lemma
osupSucc{ 
  \schemaVar \variables Ord nv;
  \schemaVar \term Ord i, j;
  \find(osup{nv;}(oadd(j,o_1),i))
  \varcond(\notFreeIn(nv,j))
  \replacewith(omax(osup{nv;}(j,i),{\subst  nv;(j)}i))
  }; 

// proofScript exists
\lemma
osupEqualTerms{ 
   \schemaVar \variables Ord nv;
   \schemaVar \term Ord i1,i2,alpha;
   \find(\forall nv;(olt(nv,alpha) -> i1 = i2) ==>)
   \varcond(\notFreeIn(nv,alpha))
   \add(osup{nv;}(alpha,i1) = osup{nv;}(alpha,i2)==>)
};

// proofScript exists
\lemma 
osupMutualCofinal{ 
   \schemaVar \variables Ord nv1,nv2, i,j;
   \schemaVar \term Ord i1,i2,alpha1, alpha2;
  \find(==> osup{nv1;}(alpha1,i1) = osup{nv2;}(alpha2,i2))
    \varcond(
    \notFreeIn(nv1,alpha1), \notFreeIn(nv2,alpha2),
    \notFreeIn(nv1,alpha2), \notFreeIn(nv2,alpha1),
    \notFreeIn(i,alpha1), \notFreeIn(j,alpha2),
    \notFreeIn(i,alpha2), \notFreeIn(j,alpha1),
    \notFreeIn(i,i1), \notFreeIn(j,i2),
    \notFreeIn(j,i1), \notFreeIn(i,i2)
    )
   \replacewith(==>
    \forall i;(olt(i,alpha1)->\exists j;(olt(j,alpha2) & oleq({\subst nv1;i}i1,{\subst nv2;j}i2)))
    &
    \forall j;(olt(j,alpha2)->\exists i;(olt(i,alpha1) & oleq({\subst nv2;j}i2,{\subst nv1;i}i1))))
};

// proofScript exists
\lemma 
osupLocalLess{      \schemaVar \term Ord i1,i2,b;
     \schemaVar \variables Ord lambda;
     \find(\forall lambda;(olt(lambda,b) -> oleq(i1,i2)) ==>)
    \varcond(
    \notFreeIn(lambda,b)
     )
    \add(oleq(osup{lambda;}(b,i1),osup{lambda;}(b,i2)) ==>)
};

// proofScript exists
\lemma
osupShorter{ 
   \schemaVar \term Ord b1,b2,i;
  \schemaVar \variables Ord lambda;
  \find(oleq(b1,b2)==>)
      \varcond(
    \notFreeIn(lambda,b1), \notFreeIn(lambda,b2))
  \add( oleq(osup{lambda;}(b1,i), osup{lambda;}(b2,i)) ==>)
};

// proofScript exists
\lemma
osupOmega{ 
 \schemaVar \variables Ord lambda;
 \add(omega = osup{lambda;}(omega,lambda) ==>)
};


//--------------------------------------------------------------------------
//  
//  oltp less than relation between pairs of ordinals
//  succp  second pair is immediate successor of first pair 
//  limp  limit element in the ordering oltp
//  Definition and consequences
//  
//--------------------------------------------------------------------------

oltp_DefAxiom{ 
     \schemaVar \variables Ord nv1,nv2,nv3,nv4;
     \add(\forall nv1;(\forall nv2;(\forall nv3;(\forall nv4;(
      oltp(nv1,nv2,nv3,nv4) <-> 
       olt(omax(nv1,nv2),omax(nv3,nv4))                            |
      (omax(nv1,nv2) = omax(nv3,nv4) & olt(nv2,nv4))               |
      (omax(nv1,nv2) = omax(nv3,nv4) & nv2 = nv4 &  olt(nv1,nv3)))))) 
        ==> )
};

limp_Def{
   \schemaVar \term Ord t1,t2;
   \schemaVar \variables Ord nv3,nv4,nv5,nv6;
  \find(limp(t1,t2))
  \varcond(\notFreeIn(nv3,t1),\notFreeIn(nv4,t1),\notFreeIn(nv5,t1),\notFreeIn(nv6,t1), 
           \notFreeIn(nv3,t2),\notFreeIn(nv4,t2),\notFreeIn(nv5,t2),\notFreeIn(nv6,t2) )
  \replacewith(\forall nv3;\forall nv4;(oltp(nv3,nv4,t1,t2) ->
     \exists nv5;\exists nv6;(
    oltp(nv3,nv4,nv5,nv6)  & oltp(nv5,nv6,t1,t2)))
     )
};

succpDef{
 \schemaVar \term Ord t1,t2,s1,s2;
   \schemaVar \variables Ord nv2,nv3;
 \find(succp(t1,t2,s1,s2))
  \varcond(\notFreeIn(nv2,t1), \notFreeIn(nv2,t2), \notFreeIn(nv2,s1), \notFreeIn(nv2,s2),
           \notFreeIn(nv3,s1), \notFreeIn(nv3,s2), \notFreeIn(nv3,t1), \notFreeIn(nv3,t2))
 \replacewith(oltp(t1,t2,s1,s2) & 
   \forall nv2;\forall nv3;(oltp(t1,t2,nv2,nv3) ->
   ( (s1 = nv2 & s2 = nv3) | oltp(s1,s2,nv2,nv3))))
};


// proofScript exists
\lemma
oltp_Def{ 
     \schemaVar \term Ord t1,t2,t3,t4;
      \find(oltp(t1,t2,t3,t4))
     \replacewith( 
          olt(omax(t1,t2),omax(t3,t4))                            |
      (omax(t1,t2) = omax(t3,t4) & olt(t2,t4))                    |
      (omax(t1,t2) = omax(t3,t4) & t2 = t4 &  olt(t1,t3))
      )
};

// proofScript exists
\lemma
oltpLess10{
   \find(oltp(o_0,o_0,o_1,o_0))
    \replacewith(true)
    \heuristics(concrete)
};

// proofScript exists
\lemma
oltpLess011{
   \find(oltp(o_0,o_0,o_0,o_1))
    \replacewith(true)
    \heuristics(concrete)
};

// proofScript exists
\lemma
oltpLess012{
   \find(oltp(o_1,o_0,o_0,o_1))
    \replacewith(true)
    \heuristics(concrete)
};

// proofScript exists
\lemma
oltpLess013{
    \schemaVar \term Ord t;
   \find(oltp(o_0,t,o_0,o_1))
    \replacewith(t=o_0)
    \heuristics(concrete)
};


// proofScript exists
\lemma
oltpOne{
   \schemaVar \term Ord t1,t2;
   \find(oltp(t1,t2,o_1,o_0))
    \replacewith( t1=o_0 & t2=o_0)
    \heuristics(concrete)
};

// proofScript exists
\lemma
oltpTwo{
   \schemaVar \term Ord t1,t2;
   \find(oltp(t1,t2,o_0,o_1))
    \replacewith( (t1=o_0 & t2=o_0) |  (t1=o_1 & t2=o_0))
    \heuristics(concrete)
};


// proofScript exists
\lemma
oltp_irr{
     \schemaVar \term Ord t1,t2;
      \find(oltp(t1,t2,t1,t2))
     \replacewith(false) 
     \heuristics(concrete)
};


// proofScript exists
\lemma
oltp_transQ{
     \schemaVar \variables Ord nv1,nv2,nv3,nv4,nv5,nv6;
     \add(\forall nv1;(\forall nv2;(\forall nv3;(\forall nv4;(\forall nv5;(\forall nv6;(
     oltp(nv1,nv2,nv3,nv4) &  oltp(nv3,nv4,nv5,nv6)  ->
      oltp(nv1,nv2,nv5,nv6)))))))
     ==> )
};

// proofScript exists
\lemma
oltp_trans{
     \schemaVar \term Ord t1,t2,t3,t4,t5,t6;
     \assumes(oltp(t1,t2,t3,t4)==>)
     \find(oltp(t3,t4,t5,t6)==> )
     \add(oltp(t1,t2,t5,t6) ==>)
     \heuristics(simplify_enlarging)
};

// proofScript exists
\lemma
oltp_totalAxiom{ 
     \schemaVar \variables Ord nv1,nv2,nv3,nv4;
     \add(\forall nv1;(\forall nv2;(\forall nv3;(\forall nv4;(
      oltp(nv1,nv2,nv3,nv4) |
      oltp(nv3,nv4,nv1,nv2) |
      (nv1 = nv3 & nv2 = nv4)))))
        ==> )
};

// proofScript exists
\lemma
oltp_same2{
    \schemaVar \term Ord t1,t2,t3;
     \find(oltp(t1,t2,t3,t2)) 
     \replacewith(olt(t1,t3)) 
       \heuristics(concrete)
};

// proofScript exists
\lemma
oltp_same1{
    \schemaVar \term Ord t1,t2,t3;
     \find(oltp(t1,t2,t1,t3)) 
     \replacewith(olt(t2,t3)) 
       \heuristics(concrete)
};

// proofScript exists
\lemma
oltp_addOneL{ 
     \schemaVar \variables Ord nv1,nv2;
     \add(\forall nv1;(\forall nv2;(
      oltp(nv1,nv2,oadd(nv1,o_1),nv2))) 
        ==> )
};

// proofScript exists
\lemma
oltp_addOneR{ 
     \schemaVar \variables Ord nv1,nv2;
     \add(\forall nv1;(\forall nv2;(
      oltp(nv1,nv2,nv1,oadd(nv2,o_1)))) 
        ==> )
};

// proofScript exists
\lemma
limpSuccFalse{
  \schemaVar \term Ord t1,t2,s1,s2;
   \assumes(succp(t1,t2,s1,s2) ==> )
   \find(limp(s1,s2) ==>)  
   \add( ==> true) 
   \heuristics(concrete)
};


// proofScript exists
\lemma
oltpSuccEq{
  \schemaVar \variables Ord nv1,nv2,nv3;
    \add(\forall nv1;(oltp(nv1,nv1,oadd(nv1,o_1),o_0) &
   (\forall nv2;\forall nv3;(oltp(nv1,nv1,nv2,nv3)
       -> ( oltp(oadd(nv1,o_1),o_0,nv2,nv3) |
            (oadd(nv1,o_1) = nv2 & nv3 = o_0)))))
    ==>)
};

// proofScript exists
\lemma
oltpSuccEq2{
  \schemaVar \variables Ord nv1,nv2,nv3;
    \add(\forall nv1;(succp(nv1,nv1,oadd(nv1,o_1),o_0))
    ==>)
};


// proofScript exists
\lemma
oltpSuccMaxFirst{
  \schemaVar \variables Ord nv1,nv2,nv3,nv4;
    \add(\forall nv1;\forall nv2;(
     olt(oadd(nv2,o_1),nv1) -> oltp(nv1,nv2,nv1,oadd(nv2,o_1)) &
   (\forall nv3;\forall nv4;( oltp(nv1,nv2,nv3,nv4) 
       -> ( oltp(nv1,oadd(nv2,o_1),nv3,nv4) |
            (nv1 = nv3 & oadd(nv2,o_1) = nv4)))))
    ==>)
};

// proofScript exists
\lemma
oltpSuccMaxFirstA{
  \schemaVar \variables Ord nv1,nv2,nv3,nv4;
    \add(\forall nv1;\forall nv2;(
     olt(oadd(nv2,o_1),nv1) -> succp(nv1,nv2,nv1,oadd(nv2,o_1)))
    ==>)
};

// proofScript exists
\lemma
oltpSuccMaxFirst2{
  \schemaVar \variables Ord nv1,nv2,nv3,nv4;
    \add(\forall nv1;\forall nv2;(
     oadd(nv2,o_1)=nv1 -> oltp(nv1,nv2,o_0,oadd(nv2,o_1)) &
   (\forall nv3;\forall nv4;( oltp(nv1,nv2,nv3,nv4) 
       -> ( oltp(o_0,oadd(nv2,o_1),nv3,nv4) |
            (o_0= nv3 & oadd(nv2,o_1) = nv4)))))
    ==>)
};

// proofScript exists
\lemma
oltpSuccMaxFirst2A{
  \schemaVar \variables Ord nv1,nv2,nv3,nv4;
    \add(\forall nv1;\forall nv2;(
     oadd(nv2,o_1)=nv1 -> succp(nv1,nv2,o_0,oadd(nv2,o_1)))
    ==>)
};

// proofScript exists
\lemma
oltpSuccMaxSecond{
  \schemaVar \variables Ord nv1,nv2,nv3,nv4;
    \add(\forall nv1;\forall nv2;(
     olt(nv1,nv2) -> oltp(nv1,nv2,oadd(nv1,o_1),nv2) &
   (\forall nv3;\forall nv4;( oltp(nv1,nv2,nv3,nv4) 
       -> ( oltp(oadd(nv1,o_1),nv2,nv3,nv4) |
            (oadd(nv1,o_1) = nv3 & nv2 = nv4)))))
    ==>)
};

// proofScript exists
\lemma
oltpSuccMaxSecond2{
  \schemaVar \variables Ord nv1,nv2;
    \add(\forall nv1;\forall nv2;(
     olt(nv1,nv2) -> succp(nv1,nv2,oadd(nv1,o_1),nv2))
    ==>)
};

// proofScript exists
\lemma
limp_DefAlt{
   \schemaVar \term Ord t1,t2;
   \schemaVar \variables Ord nv3,nv4;
  \find(limp(t1,t2))
  \varcond(\notFreeIn(nv3,t1),\notFreeIn(nv4,t1), 
           \notFreeIn(nv3,t2),\notFreeIn(nv4,t2))
  \replacewith(!\exists nv3;\exists nv4;(succp(nv3,nv4,t1,t2))
     )
};

// proofScript exists
\lemma
oltpLimZeroZero{
    \find(limp(o_0,o_0))
    \replacewith(true)
    \heuristics(concrete)
};

// proofScript exists
\lemma
oltpLimR{
  \schemaVar \variables Ord nv1,nv2;
    \add(\forall nv1;\forall nv2;(
     (lim(nv2) & oleq(nv2,nv1))  -> limp(nv1,nv2))
      ==>)
};


// proofScript exists
\lemma
oltpLimL{
  \schemaVar \variables Ord nv1,nv2;
    \add(\forall nv1;\forall nv2;(
     (lim(nv1) & oleq(nv1,nv2))  -> limp(nv1,oadd(nv2,o_1)))
      ==>)
};

// proofScript exists
\lemma
oltpLimZeroR{
\schemaVar \variables Ord nv2;
    \add(\forall nv2;(
     lim(nv2)  -> limp(o_0,nv2))
      ==>)
};

// proofScript exists
\lemma
oltpLimZeroL{
\schemaVar \variables Ord nv1;
    \add(\forall nv1;(
     lim(nv1)  -> limp(nv1,o_0))
      ==>)
};

// proofScript exists
\lemma
oltpLimLim{
\schemaVar \variables Ord nv1,nv2;
    \add(\forall nv1;\forall nv2;(
     (lim(nv1) &  lim(nv2)) -> limp(nv1,nv2))
      ==>)
};

// proofScript exists
\lemma
oltpLeastPair{
  \schemaVar \variables Ord v1,v2,w1,w2;
  \schemaVar \formula phi;
   \varcond(\notFreeIn(w1,phi),\notFreeIn(w2,phi))
 \add(\exists v1;\exists v2;phi ->
   \exists v1;\exists v2;(phi & 
    \forall w1;\forall w2;(oltp(w1,w2,v1,v2) -> !{\subst v1; w1}{\subst v2; w2}phi))
    ==>)
};

// proofScript exists
// this has been added since the above taclet is useless
\lemma
oltpLeastPair2{
  \schemaVar \variables Ord v1,v2,w1,w2;
  \schemaVar \formula phi;
  \find(\exists v1;\exists v2;phi ==>)
  \varcond(\notFreeIn(w1,phi),\notFreeIn(w2,phi))
  \add(\exists v1;\exists v2;(phi & 
    \forall w1;\forall w2;(oltp(w1,w2,v1,v2) -> !{\subst v1; w1}{\subst v2; w2}phi))
    ==>)
};

// proofScript exists
\lemma
oltpInduction{ 
  \schemaVar \variables Ord v1,v2,nv1,nv2,nv3,nv4;
  \schemaVar \formula phi;
  \find (==> \forall v1;\forall v2;phi)
  \varcond(\notFreeIn(nv1,phi),\notFreeIn(nv2,phi),\notFreeIn(nv3,phi),\notFreeIn(nv4,phi))
  \replacewith(==> 
   \forall nv1;\forall nv2;
    (\forall nv3;(\forall nv4;(oltp(nv3,nv4,nv1,nv2) -> {\subst v1; nv3}{\subst v2; nv4}phi))
   ->  {\subst v1; nv1}{\subst v2; nv2}phi)
 //    \forall nv1;(\forall nv2;(
 //        \forall nv3;(\forall nv4;(oltp(nv3,nv4,nv1,nv2)))
 //    ->  {\subst v1; nv1}{\subst v2; nv2}phi))
    )
  };

// proofScript exists
\lemma
limpConseq{
  \schemaVar \variables Ord nv1,nv2,nv3;
  \add(
  \forall nv1;\forall nv2;(limp(nv1,nv2) ->
   ((nv1 = o_0     & nv2 = o_0) |
    (nv1 = o_0     & lim(nv2) ) |
    (lim(nv1)      & nv2 = o_0) |
    (lim(nv1)      & lim(nv2) ) |
    (oleq(nv2,nv1) & lim(nv2))  |
    (lim(nv1) & \exists nv3;(nv2 = oadd(nv3,o_1)) & olt(nv1,nv2))))
   ==>)
};


//--------------------------------------------------------------------------
//  
//   Definitional extension: encoding and decding of pairs of ordinals
//  
//--------------------------------------------------------------------------


encodeZero{
   \find(encode(o_0,o_0))
   \replacewith(o_0)
   \heuristics(concrete)
};

encodeRec{
   \schemaVar \variables Ord v1,v2,w1,w2;
//  \add((v1!=o_0 | v2!=o_0) -> encode(v1,v2) = osup{w1;}(omax(v1,v2),osup{w2;}(omax(v1,v2),encode(w1,w2))) ==>)
    \add(\forall v1;\forall v2;((v1!=o_0 | v2!=o_0) -> 
        encode(v1,v2) = oadd(osup{w1;}(oadd(omax(v1,v2),o_1),osup{w2;}(oadd(omax(v1,v2),o_1),
         \if (oltp(w1,w2,v1,v2)) \then (encode(w1,w2)) \else (o_0))),o_1))
    ==>)
};


// prooScript exists
\lemma
encodeOne{
 \find(encode(o_1,o_0))
   \replacewith(o_1)
   \heuristics(concrete)
};

encodeZeroV{
 \schemaVar \term Ord v1,v2;
 \find(encode(v1,v2) = o_0 ==>)
  \add(v1 = o_0, v2 = o_0 ==>)
  \heuristics(simplify_enlarging)
};

// for further "concrete" taclets on encode see "intOrdRules"

encodeMonotone{
     \schemaVar \variables Ord v1,v2,w1,w2;
     \add(\forall v1;\forall v2;\forall w1;\forall w2;(
      oltp(v1,v2,w1,w2) -> 
      olt(encode(v1,v2),encode(w1,w2)))
      ==>)
};

encodeweakMonotone{
     \schemaVar \variables Ord v1,v2,w1,w2;
     \add(\forall v1;\forall v2;\forall w1;\forall w2;(
      (oltp(v1,v2,w1,w2) | (v1=w1 & v2=w2)) -> 
      oleq(encode(v1,v2),encode(w1,w2)))
      ==>)
};

encodeInj{
     \schemaVar \variables Ord v1,v2,w1,w2;
     \add(\forall v1;\forall v2;\forall w1;\forall w2;(
      encode(v1,v2) = encode(w1,w2) 
      ->
     v1 = w1 & v2 = w2) 
     ==>)
 };


//--------------------------------------------------------------------------
//  
//  Definitional Extensions: Arithmetic
//  
//--------------------------------------------------------------------------



oadd_Def0Right{ 
     \schemaVar \term Ord i;
     \find(oadd(i,o_0))
     \replacewith(i)
     \heuristics(concrete)
     };

oadd_DefSucc{ 
     \schemaVar \term Ord i,i1;
     \find(oadd(i,oadd(i1,o_1)))
     \replacewith(oadd(oadd(i,i1),o_1))
     };

oadd_DefLim{ 
     \schemaVar \variables Ord nv;
     \schemaVar \term Ord i,i1;
     \assumes(lim(i1)==>) 
     \find(oadd(i,i1))  \sameUpdateLevel 
     \varcond (\notFreeIn(nv,i), \notFreeIn(nv,i1))
         \replacewith(osup{nv;}(i1,oadd(i,nv)))
     };

otimes_Def0Right{  
     \schemaVar \term Ord i;
     \find(otimes(i,o_0))
     \replacewith(o_0)
     \heuristics(concrete)
     };

otimes_DefSucc{ 
     \schemaVar \term Ord i,i1;
     \find(otimes(i,oadd(i1,o_1)))
     \replacewith(oadd(otimes(i,i1),i))
     };

otimes_DefLim{ 
     \schemaVar \variables Ord nv;
     \schemaVar \term Ord i,i1;
     \assumes(lim(i1)==>) 
     \find(otimes(i,i1))  \sameUpdateLevel 
     \varcond (\notFreeIn(nv,i), \notFreeIn(nv,i1))
         \replacewith(osup{nv;}(i1,otimes(i,nv)))
     };

oexp_Def0Right{  
     \schemaVar \term Ord i;
     \find(oexp(i,o_0))
     \replacewith(o_1)
     \heuristics(concrete)
     };

oexp_DefSucc{ 
     \schemaVar \term Ord i,i1;
     \find(oexp(i,oadd(i1,o_1)))
     \replacewith(otimes(oexp(i,i1),i))
     };

oexp_DefLim{ 
     \schemaVar \variables Ord nv;
     \schemaVar \term Ord i,i1;
     \assumes(lim(i1), olt(o_0,i) ==>) 
     \find(oexp(i,i1))  \sameUpdateLevel 
     \varcond (\notFreeIn(nv,i), \notFreeIn(nv,i1))
         \replacewith(osup{nv;}(i1,oexp(i,nv)))
     };

oexp_DefLim0{ 
     \schemaVar \term Ord i1;
     \assumes(lim(i1)==>) 
     \find(oexp(o_0,i1))  \sameUpdateLevel 
      \replacewith(o_0)
     };

//--------------------------------------------------------------------------
//  
//  Derived  taclets
//  
//--------------------------------------------------------------------------

// proofScript exists
// this lemma is a workaround for
// deficiencies of proofScript
otimes_DefLimQ{ 
     \schemaVar \variables Ord nv, i, j;
     \add(\forall i;(\forall j;(lim(j) ->  
          otimes(i,j) =  osup{nv;}(j,otimes(i,nv))))==>)
        };



// proofScript exists
notLim1{ 
 \schemaVar \term Ord i,j;
 \assumes(lim(i)==>)
 \find(i=oadd(j,o_1)==>)
 \inSequentState
 \closegoal
  \heuristics(closure)
};

// proofScript exists
notLim2{ 
 \schemaVar \term Ord i,j;
 \assumes(lim(i)==>)
 \find(oadd(j,o_1)=i==>)
 \inSequentState
 \closegoal
  \heuristics(closure)
};

// proofScript exists
irrByolt{ 
 \schemaVar \term Ord i,j; 
 \assumes(olt(i,j) ==>)
  \find(olt(j,i) ==>)
  \inSequentState
  \closegoal
  \heuristics(closure)
};

// proofScript exists
irrByoltleq{ 
 \schemaVar \term Ord i,j; 
 \assumes(oleq(i,j) ==>)
  \find(olt(j,i) ==>)
  \inSequentState
  \closegoal
  \heuristics(closure)
};



// proofScript exists
olt2oleq{
   \schemaVar \term Ord i,j;
   \assumes(olt(i,j)==>)
   \find(==>oleq(i,j))
   \inSequentState
   \replacewith(==>true)
   \heuristics(simplify)
 };




//--------------------------------------------------------------------------
//
// derived taclets for addition and order
//
//--------------------------------------------------------------------------

// proofScript exists
oaddStrictMonotone{ 
\schemaVar \variables Ord x,y;
  \add( \forall x; \forall y;(
       y!=o_0 -> olt(x,oadd(x,y)))  ==>)
};

// proofScript exists
oaddMonotone{ 
\schemaVar \variables Ord x,y;
  \add( \forall x; \forall y;oleq(x,oadd(x,y))  ==>)
};

// proofScript exists
oaddLeftMonotone{ 
\schemaVar \variables Ord x,y;
  \add( \forall x; \forall y;oleq(y,oadd(x,y))  ==>)
};

// proofScript exists
// but needs manual interaction at the end
zerosum{
   \schemaVar \term Ord i,j;
   \find(oadd(i,j)=o_0)
   \replacewith(i=o_0 & j=o_0)
   \heuristics(simplify)
};

// proofScript exists
oltAddLessLeft{ 
   \schemaVar \term Ord i,j;
 \schemaVar \variables Ord k;
  \find(olt(i,j) ==>)
 \varcond(\notFreeIn(k,i), \notFreeIn(k,j))
  \add(\forall k;olt(oadd(k,i),oadd(k,j))==>) 
};

// proofScript exists
oleqAddLessLeft{ 
   \schemaVar \term Ord i,j;
 \schemaVar \variables Ord k;
  \find(oleq(i,j) ==>)
 \varcond(\notFreeIn(k,i), \notFreeIn(k,j))
  \add(\forall k;oleq(oadd(k,i),oadd(k,j))==>) 
};



// proofScript exists
oleqAddLessRight{ 
   \schemaVar \term Ord i,j;
 \schemaVar \variables Ord k;
  \find(oleq(i,j) ==>)
 \varcond(\notFreeIn(k,i), \notFreeIn(k,j))
  \add(\forall k;oleq(oadd(i,k),oadd(j,k))==>)
};

// there is something wrong with the previous taclet
// it seems to be hidden by taclet oleqAddLessLeft
// and neither shown for interactive selection nor
// automatically applied
// 
// proofScript exists
oleqAddLessRightQ{ 
 \schemaVar \variables Ord i, j, k;
 \add(\forall i;\forall j;\forall k;
      (oleq(i,j) -> oleq(oadd(i,k),oadd(j,k)))==>)
};

// proofScript exists
oadd2olt{
 \schemaVar \term Ord i1, i2, j1, j2;
 \assumes(olt(i1,j1)==>)
 \find(olt(i2,j2)==>) 
 \inSequentState
 \add(olt(oadd(i1,i2), oadd(j1,j2))==>)
};

oadd2oleq{
 \schemaVar \term Ord i1, i2, j1, j2;
 \assumes(oleq(i1,j1)==>)
 \find(oleq(i2,j2)==>)
 \inSequentState
 \add(oleq(oadd(i1,i2), oadd(j1,j2))==>)

};

// proofScript exists
omaxAddL{ 
 \schemaVar \term Ord i,j,k;
  \find(omax(oadd(k,i),oadd(k,j)))
  \replacewith(oadd(k,omax(i,j)))
  \heuristics(simplify)  
};

// proofScript exists
omaxAddR{ 
 \schemaVar \term Ord i,j,k;
  \find(omax(oadd(i,k),oadd(j,k)))
  \replacewith(oadd(omax(i,j),k))
  \heuristics(simplify)  
};

//--------------------------------------------------------------------------
//  
//  Derived  taclets on addition oadd
//  
//--------------------------------------------------------------------------


// proofScript exists
olimAddolim{ 
   \schemaVar \term Ord lambda;
    \schemaVar \variables  Ord ov;
   \find(lim(lambda) ==>)
   \varcond(\notFreeIn(ov,lambda))
   \add(\forall ov;(lim(oadd(ov,lambda)))==>)
};


// proofScript exists
omegaLeastLim1{
  \schemaVar \term Ord lambda;
  \find(lim(lambda)==>)
  \add(oleq(omega,lambda)==>)
 };

// proofScript exists
omegaLeastLim2{
  \schemaVar \term Ord lambda;
  \assumes(lim(lambda)==>)
  \find(olt(lambda,omega)==>)
  \inSequentState
   \closegoal
  \heuristics(closure)
};

// proofScript exists
omegaLeastLim3{
  \schemaVar \term Ord lambda;
  \assumes(lim(lambda)==>)
  \find(oleq(lambda,omega)==>)
  \inSequentState
   \add(lambda=omega==>)
  \heuristics(simplify)
};
// proofScript exists

limitZero{ 
   \schemaVar \term Ord lambda;
   \assumes(lim(lambda)==>)
   \find(olt(o_0,lambda))
   \inSequentState
   \replacewith(true)
   \heuristics(concrete)
};

// proofScript exists
limitOne{ 
   \schemaVar \term Ord lambda;
   \assumes(lim(lambda)==>)
   \find(olt(o_1,lambda))
   \inSequentState
   \replacewith(true)
   \heuristics(concrete)
};


// proofScript exists
oaddRightInjective{ 
    \schemaVar \term Ord i,j,k;
    \find(oadd(k,i) = oadd(k,j) ==>)
    \add(i=j ==>)
   \heuristics(simplify_enlarging)
};

// proofScript exists
olimDedekind{ 
    \schemaVar \term Ord j;
    \schemaVar \variables Ord i;
    \assumes(lim(j)==>)
    \varcond(\notFreeIn(i,j))
    \add(\forall i;(olt(i,j) -> olt(oadd(i,o_1),j))==>)
};

// proofScript exists
oaddLessOmega{ 
    \schemaVar \term Ord i,j;
    \assumes(olt(i,omega) ==>)
    \find(olt(j,omega)==>)
    \add(olt(oadd(i,j),omega)==>)
};

// The following taclet is a workaround
// for deficiencies of proofScript
// which cannot apply the previous taclet
// proofScript exists
oaddLessOmegaAxiom{ 
    \schemaVar \variables Ord i,j;
    \add(\forall i;(\forall j;(olt(i,omega) & olt(j,omega) -> olt(oadd(i,j),omega)))==>)
};

// proofScript exists
oadd0Left{ 
 \schemaVar \term Ord i;
 \find(oadd(o_0,i))
 \replacewith(i)
 \heuristics(concrete)
};


// proofScript exists
oaddLeftomega{ 
    \schemaVar \term Ord i;
    \assumes(olt(i,omega) ==>)
   \find(oadd(i,omega))
   \inSequentState
   \replacewith(omega)
   \heuristics(concrete)
};

// proofScript exists
oaddLeftAbsorb{ 
    \schemaVar \term Ord i,lambda;
    \assumes(olt(i,omega) & oleq(omega,lambda) ==>)
   \find(oadd(i,lambda))
   \inSequentState
   \replacewith(lambda)
};

// proofScript exists
repLimPlusNat{ 
    \schemaVar \variables Ord ov, lambda, n;
   \add(\forall ov ;(oleq(omega,ov) ->
       \exists lambda;\exists n;(lim(lambda) & olt(n,omega) & ov = oadd(lambda,n)))
        ==>)
};

// proofScript exists
ordDiff{ 
  \schemaVar \term Ord i,j;
  \schemaVar \variables Ord k;
  \find(oleq(i,j)==>)
   \varcond(\notFreeIn(k,i),\notFreeIn(k,j))
  \add(\exists k;(oadd(i,k)=j)  ==>)
};

// proofScript exists
oltPlusOne{ 
  \schemaVar \term Ord i,j;
   \find(olt(i,j)==>)
  \add( olt(oadd(i,o_1),oadd(j,o_1))  ==>)
};

// proofScript exists
oAddOneInj{ 
  \schemaVar \term Ord i,j;
   \find(oadd(i,o_1) = oadd(j,o_1) ==>)
  \add(i=j  ==>)
   \heuristics(simplify_enlarging)
};

// proofScript exists
oAddOltPreserv{ 
  \schemaVar \term Ord i,j,k;
   \find(olt(oadd(i,j),oadd(i,k)) ==>)
  \add(olt(j,k)  ==>)
   \heuristics(simplify_enlarging)
};

// proofScript exists
osupAddStaticTerm{ 
   \schemaVar \term Ord i,j,b;
   \schemaVar \variables Ord lambda;
    \assumes(b!=o_0 ==>)
   \find(osup{lambda;}(b,oadd(i,j)))
   \inSequentState
    \varcond(\notFreeIn(lambda,b),  
             \notFreeIn(lambda,i))
   \replacewith(oadd(i,osup{lambda;}(b,j)))
}; 

// proofScript exists
oaddAssoc{ 
   \schemaVar \term Ord i,j,k;
   \find(oadd(i,oadd(j,k)))
   \replacewith(oadd(oadd(i,j),k))
};

// proofScript exists
oaddFiniteComOne{ 
   \schemaVar \term Ord j;
   \assumes(olt(j,omega) ==>)
   \find(oadd(o_1,j))
       \inSequentState
   \replacewith(oadd(j,o_1))
};

// proofScript exists
oaddFiniteCom{ 
   \schemaVar \term Ord i,j;
   \assumes(olt(i,omega), olt(j,omega) ==>)
   \find(oadd(i,j))
       \inSequentState
   \replacewith(oadd(j,i))
};

//--------------------------------------------------------------------------
//  
//  Derived  taclets on multiplication  otimes 
//  
//--------------------------------------------------------------------------

// proofScript exists
otimesOneRight{ 
  \schemaVar \term Ord i;
   \find(otimes(i,o_1))
   \replacewith(i)
   \heuristics(concrete)
};

// proofScript exists
otimesOneLeft{ 
  \schemaVar \term Ord i;
   \find(otimes(o_1,i))
   \replacewith(i)
   \heuristics(concrete)
};

// proofScript exists
otimesZeroLeft{ 
  \schemaVar \term Ord i;
   \find(otimes(o_0,i))
   \replacewith(o_0)
   \heuristics(concrete)
};

// proofScript exists
otimesMonotoneQ{
 \schemaVar \variables Ord i,j, k;
 \add(\forall k;\forall i;\forall j;((olt(o_0,k) & olt(i,j)) -> olt(otimes(k,i),otimes(k,j)))==>)
};


// proofScript exists
otimesWeakMonotoneQ{
 \schemaVar \variables Ord i,j, k;
 \add(\forall k;\forall i;\forall j;((oleq(i,j)) -> oleq(otimes(k,i),otimes(k,j)))==>)
};


// proofScript exists
otimesMonotone{
 \schemaVar \term Ord i,j,k;
 \assumes(olt(o_0,k)==>)
 \find(olt(i,j)==>)
 \inSequentState
 \add(olt(otimes(k,i),otimes(k,j))==>)
};


// proofScript exists
// but needs manual interaction at the end
otimesMonotoneRev{
 \schemaVar \term Ord i,j,k;
 \find(olt(otimes(k,i),otimes(k,j))==>)
 \add(olt(o_0,k) & olt(i,j)  ==>)
};


// proofScript exists
otimesLeftInjective{
  \schemaVar \term Ord i,j,k;
  \assumes(olt(o_0,k)==>)
  \find(otimes(k,i)=otimes(k,j)==>)
  \inSequentState
  \add(i=j==>)
  \heuristics(simplify_enlarging)
};

// proofScript exists
otimesLeftMonotone{
 \schemaVar \term Ord i,j;
 \schemaVar \variables Ord k;
 \find(oleq(i,j)==>)
 \varcond(\notFreeIn(k,i),\notFreeIn(k,j))
 \add(\forall k;oleq(otimes(i,k),otimes(j,k))==>)
};

// proofScript exists
otimesRightMonotoneQ{
 \schemaVar \variables Ord i,j;
 \add(\forall i;\forall j;((o_0 != i -> oleq(j,otimes(i,j))))==>)
};

// proofScript exists
// but needs manual interaction at the end
otimesZero{
 \schemaVar \term Ord i,j;
 \find(otimes(i,j)=o_0)
 \replacewith(i=o_0 | j=o_0)
 \heuristics(simplify)
};

// proofScript exists
otimesOne{
 \schemaVar \term Ord i,j;
 \find(otimes(i,j)=o_1)
 \replacewith(i=o_1 & j=o_1)
 \heuristics(simplify)
};


// The following taclet is a workaround
// for deficiencies of proofScript
// which cannot apply the next taclet
// proofScript exists
otimesFiniteAxiom{
 \schemaVar \variables Ord x,y;
 \add(\forall x;\forall y;(olt(x,omega) & olt(y,omega) -> olt(otimes(x,y),omega)) ==>)
};

// proofScript exists
otimesFinite{
 \schemaVar \term Ord i,j;
 \assumes(olt(i,omega)==>)
 \find(olt(j,omega)==>)
 \inSequentState
 \add(olt(otimes(i,j),omega)==>)
};

// proofScript exists
otimesNomegaQ{
   \schemaVar \variables Ord i;
   \add(\forall i;(
       (olt(i,omega) & !i=o_0) -> otimes(i,omega) = omega)==>)
};

// proofScript exists
otimesNomega{
   \schemaVar \term Ord i;
   \assumes(olt(i,omega)==>)
   \find(otimes(i,omega))
   \inSequentState
   \replacewith(\if(i=o_0)\then(o_0)\else(omega))
   \heuristics(concrete)
};


//proofScript exits
// requires trivial manual interaction at the end 
omaxTimesL{ 
 \schemaVar \term Ord i,j,k;
  \find(omax(otimes(k,i),otimes(k,j)))
  \replacewith(otimes(k,omax(i,j)))
  \heuristics(simplify)  
};

//proofScript exits
// requires trivial manual interaction at the end 
omaxTimesR{ 
 \schemaVar \term Ord i,j,k;
  \find(omax(otimes(i,k),otimes(j,k)))
  \replacewith(otimes(omax(i,j),k))
  \heuristics(simplify)  
};

// proofScript exists
osupTimesStaticTerm{ 
   \schemaVar \term Ord i,j,b;
   \schemaVar \variables Ord lambda;
   \find(osup{lambda;}(b,otimes(i,j)))
   \inSequentState
    \varcond(\notFreeIn(lambda,b),  
             \notFreeIn(lambda,i))
   \replacewith(otimes(i,osup{lambda;}(b,j)))
}; 


// proofScript exists
odistributiveQ{
   \schemaVar \variables Ord i,j,k;
   \add(\forall i;\forall j;\forall k;(
         otimes(i,oadd(j,k)) = oadd(otimes(i,j),otimes(i,k)))
       ==>)
};

// proofScript exists
odistributive{
   \schemaVar \term Ord i,j,k;
   \find(otimes(i,oadd(j,k)))
   \replacewith(oadd(otimes(i,j),otimes(i,k)))
};

// proofScript exists
odistributiveFinite{
   \schemaVar \term Ord i,j,k;
   \assumes(olt(i,omega),olt(j,omega),olt(k,omega)==>)
   \find(otimes(oadd(i,j),k))
  \inSequentState
   \replacewith(oadd(otimes(i,k),otimes(j,k)))
};

// proofScript exists
otimesAssocQ{ 
   \schemaVar \variables Ord i,j,k;
   \add(\forall i;\forall j;\forall k;(otimes(i,otimes(j,k))=otimes(otimes(i,j),k))
    ==>)
};

// proofScript exists
otimesAssoc{ 
   \schemaVar \term Ord i,j,k;
   \find(otimes(i,otimes(j,k)))
   \replacewith(otimes(otimes(i,j),k))
};

// proofScript exists
otimesFiniteCom{ 
   \schemaVar \term Ord i,j;
   \assumes(olt(i,omega),olt(j,omega) ==>)
   \find(otimes(i,j))
   \inSequentState
   \replacewith(otimes(j,i))
};

// proofScript exists
oltomegatimes{
    \schemaVar \term Ord i, j;
    \assumes(olt(i,omega), olt(j,omega) ==>)
    \find(olt(otimes(omega,i), otimes(omega,j)))
    \inSequentState
    \replacewith(olt(i,j))
    \heuristics(simplify_enlarging)
};

// proofScript exists
oltlexicographic{
    \schemaVar \term Ord i1, i2, j1, j2;
    \assumes(olt(i1,omega), olt(j1,omega), olt(i2,omega), olt(j2,omega) ==>)
    \find(olt(oadd(otimes(omega,i1),j1), oadd(otimes(omega,i2),j2)))
    \inSequentState
    \replacewith(
       olt(otimes(omega,i1), otimes(omega,i2))
       |
       (otimes(omega,i1) = otimes(omega,i2) & olt(j1, j2)))
};

// proofScript exists
oleqAddTimes{
 \schemaVar \variable Ord i, j;
 \add(\forall i;\forall j;((olt(o_1,i) & olt(o_1,j)) -> oleq(oadd(i,j),otimes(i,j))) ==>) 
};

// proofScript exists
olimtimes1Q{
 \schemaVar \variables Ord i, j;
  \add(\forall i;\forall j;(olt(o_0,i) & lim(j) -> lim(otimes(i,j))) ==>)
 };

// proofScript exists
olimtimes1{
 \schemaVar \term Ord i, j;
  \assumes(olt(o_0,i) , lim(j) ==> )
  \add(lim(otimes(i,j)) ==>)
 };

// proofScript exists
olimtimes2Q{
 \schemaVar \variables Ord i, j;
  \add(\forall i;\forall j;(olt(o_0,j) & lim(i) -> lim(otimes(i,j))) ==>)
 };

// proofScript exists
olimtimes2{
 \schemaVar \term Ord i, j;
  \assumes(olt(o_0,j) , lim(i) ==> )
  \add(lim(otimes(i,j)) ==>)
 };


//--------------------------------------------------------------------------
//  
//  Derived  taclets on decomposition I
//  
//--------------------------------------------------------------------------

// proofScript exists
oleastMultiple{
   \schemaVar \variables Ord i,j,k;
   \add(\forall i;(\forall j;(j!=o_0 ->
        \exists k;(oleq(otimes(j,k),i) & olt(i,otimes(j,oadd(k,o_1)))))) 
       ==>)
};

// proofScript exists
odivQ{
   \schemaVar \variables Ord i,j,d,r;
   \add(\forall i;(\forall j;(j!=o_0 ->
        \exists d;\exists r;(i = oadd(otimes(j,d),r) & olt(r,j))))
       ==>)
};

// proofScript exists
odivLim{
   \schemaVar \variables Ord d;
   \schemaVar \term Ord lambda;
   \find(lim(lambda) ==>)
  \varcond(\notFreeIn(d,lambda))
   \add(\exists d;(lambda = otimes(omega,d))==>)
};

//--------------------------------------------------------------------------
//  
//  More derived  taclets on multiplication  otimes 
//  
//--------------------------------------------------------------------------


// proofScript exists
// auxiliary lemma form Klaua's book
Klaua26c1a{
   \schemaVar \variables Ord i,j;
   \add(\forall i;(\forall j;((i!=o_0 & olt(j,omega)) -> otimes(oadd(i,j),omega) = otimes(i,omega)))==>)
};

// proofScript exists
// auxiliary lemma form Klaua's book
Klaua26c1{
   \schemaVar \variables Ord i,j,k;
   \add(\forall i;(\forall j;(\forall k;((i!=o_0 & olt(j,omega) & lim(k)) -> 
        otimes(oadd(i,j),k) = otimes(i,k))))==>)
};

// proofScript exists
otimesNlimit{
   \schemaVar \term Ord i, lambda;
   \assumes(olt(i,omega), lim(lambda) ==>)
   \find(otimes(i,lambda))
   \inSequentState
   \replacewith(\if(i=o_0)\then(o_0)\else(lambda))
   \heuristics(simplify)
};



//--------------------------------------------------------------------------
//  
//  Derived  taclets on exponentiation   oexp
//  
//--------------------------------------------------------------------------

// proofScript exists
oexpOne{
   \schemaVar \term Ord i;
    \find(oexp(i,o_1))
   \replacewith(i)
   \heuristics(simplify)
};

// proofScript exists
oexpZeroBase{
   \schemaVar \term Ord i;
    \assumes(olt(o_0,i)==>)
    \find(oexp(o_0,i))
   \inSequentState
   \replacewith(o_0)
   \heuristics(concrete)
};

// proofScript exists
oexpOneBase{
   \schemaVar \term Ord i;
     \find(oexp(o_1,i))
    \replacewith(o_1)
   \heuristics(concrete)
};

// proofScript exists
oexpLeftIncreasing{
   \schemaVar \variable  Ord x,y;
   \add(\forall x;\forall y;((olt(o_1,x) & olt(o_1,y)) -> olt(x,oexp(x,y)))==>)
};

// proofScript exists
oexpLeftWeakIncreasing{
   \schemaVar \variable  Ord x,y;
   \add(\forall x;\forall y;(olt(o_0,y) -> oleq(x,oexp(x,y)))==>)
};

//  proofScript exists
oexpGreaterOne{
   \schemaVar \variable  Ord x,y;
   \add(\forall x;\forall y;(
       (olt(o_1,x) & olt(o_0,y)) -> olt(o_1,oexp(x,y))) ==>)
};

// proofScript exists
oexpGreaterEqualOne{
   \schemaVar \variable  Ord x,y;
   \add(\forall x;\forall y;(
       olt(o_0,x)  -> oleq(o_1,oexp(x,y))) ==>)
};

// proofScript exists
oexpGreatertimes{
   \schemaVar \variable  Ord x,y;
   \add(\forall x;\forall y;( o_1 != x -> oleq(otimes(x,y), oexp(x,y)))==>)
};

// proofScript exists
oexpRightNondecreasing{
   \schemaVar \variable  Ord x,y;
   \add(\forall x;\forall y;(olt(o_1,x)  -> oleq(y,oexp(x,y)))==>)
};

// proofScript exists
// warning!
// running automatic proof search on this formula runs into a 
// potentially infinite loop.
// instantiate quantifiers first
oexpRightMonotoneQ{
     \schemaVar \variable  Ord x, y1, y2;
     \add(\forall x;\forall y1;\forall y2;(olt(o_1,x) & olt(y1,y2) -> olt(oexp(x,y1),oexp(x,y2)))==>)
};


// proofScript exists
oexpRightWeakMonotoneQ{
     \schemaVar \variable  Ord x, y1, y2;
     \add(\forall x;\forall y1;\forall y2;(olt(o_0,x) & oleq(y1,y2) -> oleq(oexp(x,y1),oexp(x,y2)))==>)
};

// proofScript exists
oexpEqualsZero{
 \schemaVar \term Ord i,j;
 \find(oexp(i,j)=o_0)
 \replacewith(i=o_0 & j!=o_0)
 \heuristics(concrete) 
};


// proofScript exists
oexpEqualsOne{
 \schemaVar \term Ord i,j;
 \find(oexp(i,j)=o_1)
 \replacewith(j=o_0 | i=o_1 )
 \heuristics(concrete) 
};

// proofScript exists
oexpRightMonotoneRevQ{
     \schemaVar \variable  Ord x, y1, y2;
     \add(\forall x;\forall y1;\forall y2;(olt(o_0,x) &  olt(oexp(x,y1),oexp(x,y2))
     ->  olt(y1,y2)) ==>)
};


// The following taclet is a workaround
// for deficiencies of proofScript
// which cannot apply the next taclet
// proofScript exists
oexpFiniteAxiom{
 \schemaVar \variables Ord x,y;
 \add(\forall x;\forall y;(olt(x,omega) & olt(y,omega) -> olt(oexp(x,y),omega)) ==>)
};

//  proofScript exists
oexpFinite{
 \schemaVar \term Ord i,j;
 \assumes(olt(i,omega)==>)
 \find(olt(j,omega)==>)
 \inSequentState
 \add(olt(oexp(i,j),omega)==>)
};

//  proofScript exists
oexpNOmega{
\schemaVar \term Ord i;
 \assumes(olt(o_1,i), olt(i,omega)==>)
 \find(oexp(i,omega))
 \inSequentState
 \replacewith(omega)
 \heuristics(concrete)
};

//  proofScript exists
oexpLeftMonotoneQ{
     \schemaVar \variable  Ord x1, x2, y;
     \add(\forall x1;\forall x2;\forall y;(olt(x1,x2) -> 
      oleq(oexp(x1,y),oexp(x2,y)))==>)
};

//  proofScript exists
oexpLeftSuccessorMonotoneQ{
     \schemaVar \variable  Ord x1, x2, y;
     \add(\forall x1;\forall x2;\forall y;(olt(x1,x2) & !lim(y) & olt(o_0,y) -> 
      olt(oexp(x1,y),oexp(x2,y)))==>)
};




//--------------------------------------------------------------------------
//  
//  Derived  taclets on decomposition I
//  
//--------------------------------------------------------------------------

// proofScript exists
oleastExponent{
   \schemaVar \variables Ord i,j,k;
   \add(\forall i;(\forall j;(olt(o_0,i) &  olt(o_1,j) ->
        \exists k;(oleq(oexp(j,k),i) & olt(i,oexp(j,oadd(k,o_1))))))
       ==>)
};

//--------------------------------------------------------------------------
//  
//  Derived  taclets on exponentiation   oexp
//  
//--------------------------------------------------------------------------

//  proofScript exists
olimexp2lim{
\schemaVar \term Ord i,j;
  \assumes(olt(o_1,i), lim(j) ==>)
  \add(lim(oexp(i,j))==>)
};

// This taclet is a work around
// proofScripts deficiency to apply
// the previous taclet.
//  proofScript exists
olimexp2limQ{
\schemaVar \variables Ord i,j;
  \add(\forall i;\forall j;(lim(j) & olt(o_1,i) -> lim(oexp(i,j)))==>)
};

//  proofScript exists
olimexp1limQ{
\schemaVar \variables Ord i,j;
  \add(\forall i;\forall j;(lim(i) & olt(o_0,j) -> lim(oexp(i,j))) ==>)
};

//  proofScript exists
olimexp1lim{
\schemaVar \term Ord i,j;
  \assumes(olt(o_0,j), lim(i) ==>)
  \add(lim(oexp(i,j))==>)
};

//  proofScript exists
// but need manual interaction at the end
oexpDistr{
\schemaVar \variables Ord i,j,k;
  \add(\forall i;\forall j;\forall k;( oexp(i,oadd(j,k)) = otimes(oexp(i,j),oexp(i,k))) ==>)
};

// proofScript exists
osupExpStaticTerm{ 
   \schemaVar \term Ord i,j,b;
   \schemaVar \variables Ord lambda ;
   \find(osup{lambda;}(b,oexp(i,j)))
   \varcond(\notFreeIn(lambda,b), \notFreeIn(lambda,i))
   \add((olt(o_0,b) & (olt(o_0,i) | \forall lambda;(olt(lambda,b) -> olt(o_0,j))))
      -> osup{lambda;}(b,oexp(i,j)) = oexp(i,osup{lambda;}(b,j)) ==>)
}; 

// proofScript exists
oexpTripleQ{
  \schemaVar \variables Ord i,j,k;
  \add(\forall i;\forall j;\forall k;(
      oexp(oexp(i,j),k) = oexp(i,otimes(j,k))) ==>)
};

//--------------------------------------------------------------------------
//  
//  Derived  taclets on decomposition I
//  
//--------------------------------------------------------------------------

// proofScript exists
oabsorbGreaterExQ{
 \schemaVar \variables Ord x,i,j,k,l;
  \add(\forall x;\forall i;\forall j;\forall k;\forall l;(
    olt(k,omega) & oleq(omega,otimes(x,l)) & olt(i,j) ->
    oadd(otimes(oexp(x,i),k),otimes(oexp(x,j),l)) =
     otimes(oexp(x,j),l)) ==>)
};

// proofScript exists
oabsorbGreaterExp{
   \schemaVar \term Ord i,j,k,l;
  \assumes(olt(k,omega), olt(i,j), olt(o_0,l) ==>)
  \find(oadd(otimes(oexp(omega,i),k),otimes(oexp(omega,j),l)))
  \inSequentState
  \replacewith(otimes(oexp(omega,j),l))
  \heuristics(simplify)

};


// This taclet serves purely theoretical purposes
// proofScript exists
oCNFAux{
 \schemaVar \variables Ord x,y,z,z1,m;
 \add(\forall x;\forall y;\forall m;((lim(x) & olt(o_0,y) & olt(o_0,m) & olt(m,omega)) ->
       \forall z;(olt(o_0,z) -> 
       (\exists z1;(z = oadd(z1,o_1) & oexp(otimes(oexp(x,y),m),z) = otimes(oexp(x,otimes(y,z)),m)))
       |
       (lim(z) &  oexp(otimes(oexp(x,y),m),z) = oexp(x,otimes(y,z))))) ==> )
};

// proofScript exists
oCNFAuxSucc{
 \schemaVar \variables Ord x,y,z,z1,m;
 \add(\forall x;\forall y;\forall m;\forall z;(
        (lim(x) & olt(o_0,y) & olt(o_0,m) & olt(m,omega)& \exists z1;(z = oadd(z1,o_1))) 
         ->  oexp(otimes(oexp(x,y),m),z) = otimes(oexp(x,otimes(y,z)),m))==>)
};

// proofScript exists
oCNFAuxLim{
 \schemaVar \variables Ord x,y,z,z1,m;
 \add(\forall x;\forall y;\forall m;\forall z;(
        (lim(x) & olt(o_0,y) & olt(o_0,m) & olt(m,omega) & lim(z))
        -> oexp(otimes(oexp(x,y),m),z) = oexp(x,otimes(y,z))) ==> )
};


}


 


 