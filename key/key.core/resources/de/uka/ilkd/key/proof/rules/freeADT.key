// -----------------------------------------------------------------------------
// This is the bare bone of the Free data type.
// It is used for 'quick and (not completely) dirty' addition of user-defined
// theories which can be given in the taclet language. The data type is built-in
// into KeY and can be accessed in JML as \free. It always contains at least one
// unique function 'atom', the neutral element. Otherwise, you can define your
// theory around it by adding functions, predicates, and rules. To conform with
// KeY's guidelines, please mark your rules as either axiomatic or lemma. In
// order to prove lemma rules in KeY, axiomatic rules need to syntactically
// appear before others in the file. Example theories can be found under
// $key_maindir/examples/theories. Copy one of these files to this location and
// run 'make copy' or 'ant copy' in $key_maindir/system.
//
// @author bruns
// -----------------------------------------------------------------------------

\sorts { Free; \generic G; }

\functions {
    \unique Free atom;
}

// \rules {  
//    Please add rules to another file and add this to standardRules.key using "\include"
// }



\functions {
  \unique Free snapshot(Heap, any);
}

\predicates {
  congruent(Heap, any, Free);
}

\rules {

  congruentInt {
     \schemaVar \term int onew;
     \schemaVar \term int oold;
     \schemaVar \term Heap hold;
     \schemaVar \term Heap hnew;
     //     \assumes( int::instance(onew)=TRUE ==> )
     \find( congruent(hnew, onew, snapshot(hold, oold)) ==> )
     \replacewith( onew = oold ==> )
  };

  congruentNull1 {
     \schemaVar \term any onew;
     \schemaVar \term any oold;
     \schemaVar \term Heap hold;
     \schemaVar \term Heap hnew;
     \find( congruent(hnew, onew, snapshot(hold, oold)) ==> )
     \add( onew=null <-> oold=null ==> )
  };

  congruentNull2 {
     \schemaVar \term any onew;
     \schemaVar \term any oold;
     \schemaVar \term Heap hold;
     \schemaVar \term Heap hnew;
     \assumes( onew=null, congruent(hnew, onew, snapshot(hold, oold)) ==> )
     \find( oold )
     \replacewith( null )
  };

  congruentObject {
     \schemaVar \term Object onew;
     \schemaVar \term Object oold;
     \schemaVar \term Heap hold;
     \schemaVar \term Heap hnew;
     \schemaVar \term Field f;
     \assumes( congruent(hnew, onew, snapshot(hold, oold)) ==> )
     \find( G::select(hnew, onew, f) )     
     \add( congruent(hnew, G::select(hnew, onew, f), snapshot(hold, G::select(hold, oold, f))) ==> )
  };

  congruentType {
     \schemaVar \term any onew;
     \schemaVar \term any oold;
     \schemaVar \term Heap hold;
     \schemaVar \term Heap hnew;
     \assumes( congruent(hnew, onew, snapshot(hold, oold)) ==> )
     \find( G::instance(oold)=TRUE ==> )     
     \add( G::instance(onew)=TRUE ==> )
  };

  congruentType2 {
     \schemaVar \term any onew;
     \schemaVar \term any oold;
     \schemaVar \term Heap hold;
     \schemaVar \term Heap hnew;
     \assumes( congruent(hnew, onew, snapshot(hold, oold)) ==> )
     \find( G::instance(onew)=TRUE ==> )     
     \add( G::instance(oold)=TRUE ==> )
  };
  
}

