\schemaVariables{
	\term Seq histTerm;
	\term Seq histTerm2;
	\term Event event;
	\term Event event2;
	\term any any1;
	\term any any2;
	\term Heap heap2;

 	\term EventType type;
 	\term Object caller;
 	\term Object callee;
	\term MethodIdentifier service;
	\term Seq content;
	\term Heap heap;

	\variables int i;
	\variables int j;
	\variables Field f;

//	\term Object arr1;
//	\term Object arr2;
}

\rules(sequences:on) {
	//destructor definitions
	evTypeDef {
		\find (evType(event(type, caller, callee, service, content, heap)))
		\replacewith (type)
		\heuristics (simplify)
	};
	evCallerDef {
		\find (evCaller(event(type, caller, callee, service, content, heap)))
		\replacewith (caller)
		\heuristics (simplify)
	};
	evCalleeDef {
		\find (evCallee(event(type, caller, callee, service, content, heap)))
		\replacewith (callee)
		\heuristics (simplify)
	};
	evServiceDef {
		\find (evService(event(type, caller, callee, service, content, heap)))
		\replacewith (service)
		\heuristics (simplify)
	};
	evContentDef {
		\find (evContent(event(type, caller, callee, service, content, heap)))
		\replacewith (content)
		\heuristics (simplify)
	};
	evHeapDef {
		\find (evHeap(event(type, caller, callee, service, content, heap)))
		\replacewith (heap)
		\heuristics (simplify)
	};

	//wellFormedHist definition
	wfHistDef {
		\find (wfHist(histTerm))
		\replacewith (true)
		\heuristics (simplify)
	};

	//similarHist definition
	similarHistDef {
		\find (similarHist(callee, histTerm, histTerm2))
		\varcond(\notFreeIn(i, histTerm, histTerm2, callee),
				 \notFreeIn(j, histTerm, histTerm2))
		\replacewith (\forall i;
						((0 <= i &
						  i < seqLen(histTerm) &
						  evCallee(Event::seqGet(histTerm, i)) = callee) ->
		             		(\exists j;
		             			(0 <= j &
		             			 j < seqLen(histTerm2) &
		                         similarEvent(Event::seqGet(histTerm, i), Event::seqGet(histTerm2, j))))))
	};

	//similarEvent definition
	similarEventDef {
		\find (similarEvent(event, event2))
		\varcond(\notFreeIn(i, event, event2))
		\replacewith (evType(event) = evType(event2) &
		              evCaller(event) = evCaller(event2) &
		              evCallee(event) = evCallee(event2) &
		              evService(event) = evService(event2) &
		              seqLen(evContent(event)) = seqLen(evContent(event2)) &
		              (\forall i; ((0 <= i &
		            				i < seqLen(evContent(event))) ->
		                        		similar(any::seqGet(evContent(event), i), any::seqGet(evContent(event2), i), evHeap(event), evHeap(event2)))))
	};

	//similar definition(s)
	similarDef {
		\find (similar(any1, any2, heap, heap2))
		\varcond(\notFreeIn(f, any1, any2, heap, heap2),
		         \not \isArray(any1),
		         \not \isArray(any2))
		\replacewith (sameType(any1, any2) &
		              ((int::exactInstance(any1) = TRUE | boolean::exactInstance(any1) = TRUE) -> any1 = any2) &
		              (Object::instance(any1) = TRUE -> (\forall f; (similar(((Object)any1).f@heap, ((Object)any2).f@heap2, heap, heap2)))) &
                      (int::exactInstance(any1) = TRUE | boolean::exactInstance(any1) = TRUE | Object::instance(any1) = TRUE))
	};
	similarDefArr {
		\find (similar(any1, any2, heap, heap2))
		\varcond(\isArray(any1),
		         \isArray(any2),
		         \hasSort(\elemSort(any1), beta),
		         \notFreeIn(i, any1, any2, heap, heap2))
		\replacewith (sameType(any1, any2) &
		              length((Object)any1) = length((Object)any2) &
                      (\forall i; ((0 <= i & i < length((Object)any1)) -> similar(beta::select(heap, (Object)any1, arr(i)), beta::select(heap2, (Object)any2, arr(i)), heap, heap2))))
	};

	//Additional rules, mainly for NI
	callTermInequal {
		\find(serviceTermination = serviceCall)
		\replacewith(false)
		\heuristics(simplify)
	};

	callTermInequal2 {
		\find(serviceCall = serviceTermination)
		\replacewith(false)
		\heuristics(simplify)
	};

	//History wellformedness (To be proven. Does not take cooperativeness into consideration, since this is an assumption, which can not be proven(?))
	//TODO Empty histories aren't wellformed - at least initial call (and corresponding termination) have to be there... is that ok?
	defOfCorrespondingEvents {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;

		\find(correspondingEvents(e1,e2))
		\replacewith(evType(e1) = serviceCall & evType(e2) = serviceTermination	& evCaller(e1) = evCaller(e2) & evCallee(e1) = evCallee(e2))
		\heuristics(simplify)
	};

	//TODO JK this assumes a very specific structure of histories which is not yet generated correctly
	defOfHistoryWellformednessWithMiddle {
		\schemaVar \term Event a;
		\schemaVar \term Event z;
		\schemaVar \term Seq s;

		\find(wellformedList(seqConcat(seqConcat(seqSingleton(a), s), seqSingleton(z))))
		\replacewith(correspondingEvents(a, z)
			& wellformedListMiddle(s))
		\heuristics(simplify)
	};

	defOfHistoryWellformednessWithoutMiddle {
		\schemaVar \term Event a;
		\schemaVar \term Event z;
		\schemaVar \term Seq s;

		\find(wellformedList(seqConcat(seqSingleton(a), seqSingleton(z))))
		\replacewith(correspondingEvents(a,z))
		\heuristics(simplify)
	};

	defOfHistoryWellformedMiddleEmpty {
		\find(wellformedListMiddle(seqEmpty))
		\replacewith(true)
		\heuristics(simplify)
	};

	defOfHistoryWellformedMiddle {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;
		\schemaVar \term Seq s;

		\find(wellformedListMiddle(seqConcat(seqConcat(s, seqSingleton(e1)), seqSingleton(e2))))
		\replacewith(correspondingEvents(e1, e2) & wellformedListMiddle(s))
		\heuristics(simplify)
	};

	defOfHistoryWellformedMiddleSingle {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;

		\find(wellformedListMiddle(seqConcat(seqSingleton(e1), seqSingleton(e2))))
		\replacewith(correspondingEvents(e1, e2))
		\heuristics(simplify)
	};

}
