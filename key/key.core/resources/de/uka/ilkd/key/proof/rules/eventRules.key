\schemaVariables{
	\term Seq histTerm;
	\term Seq histTerm2;
	\term Event event;
	\term Event event2;
	\term any any1;
	\term any any2;
	\term Heap heap2;

 	\term EventType type;
 	\term Object caller;
 	\term Object callee;
	\term MethodIdentifier service;
	\term Seq content;
	\term Heap heap;

	\variables int i;
	\variables int j;
	\variables Field f;

//	\term Object arr1;
//	\term Object arr2;
}

\rules(sequences:on) {
	//destructor definitions
	evTypeDef {
		\find (evType(event(type, caller, callee, service, content, heap)))
		\replacewith (type)
		\heuristics (simplify)
	};
	evCallerDef {
		\find (evCaller(event(type, caller, callee, service, content, heap)))
		\replacewith (caller)
		\heuristics (simplify)
	};
	evCalleeDef {
		\find (evCallee(event(type, caller, callee, service, content, heap)))
		\replacewith (callee)
		\heuristics (simplify)
	};
	evServiceDef {
		\find (evService(event(type, caller, callee, service, content, heap)))
		\replacewith (service)
		\heuristics (simplify)
	};
	evContentDef {
		\find (evContent(event(type, caller, callee, service, content, heap)))
		\replacewith (content)
		\heuristics (simplify)
	};
	evHeapDef {
		\find (evHeap(event(type, caller, callee, service, content, heap)))
		\replacewith (heap)
		\heuristics (simplify)
	};

	//wellFormedHist definition
//	wfHistDef {
//		\find (wfHist(histTerm))
//		\replacewith (true)
//		\heuristics (simplify)
//	};

	//similarHist definition
	similarHistDef {
		\find (similarHist(callee, histTerm, histTerm2))
		\varcond(\notFreeIn(i, histTerm, histTerm2, callee),
				 \notFreeIn(j, histTerm, histTerm2))
		\replacewith (\forall i;
						((0 <= i &
						  i < seqLen(histTerm) &
						  evCallee(Event::seqGet(histTerm, i)) = callee) ->
		             		(\exists j;
		             			(0 <= j &
		             			 j < seqLen(histTerm2) &
		                         similarEvent(Event::seqGet(histTerm, i), Event::seqGet(histTerm2, j))))))
	};

	//similarEvent definition
	similarEventDef {
		\find (similarEvent(event, event2))
		\varcond(\notFreeIn(i, event, event2))
		\replacewith (evType(event) = evType(event2) &
		              evCaller(event) = evCaller(event2) &
		              evCallee(event) = evCallee(event2) &
		              evService(event) = evService(event2) &
		              seqLen(evContent(event)) = seqLen(evContent(event2)) &
		              (\forall i; ((0 <= i &
		            				i < seqLen(evContent(event))) ->
		                        		similar(any::seqGet(evContent(event), i), any::seqGet(evContent(event2), i), evHeap(event), evHeap(event2)))))
	};

	//similar definition(s)
	similarDef {
		\find (similar(any1, any2, heap, heap2))
		\varcond(\notFreeIn(f, any1, any2, heap, heap2),
		         \not \isArray(any1),
		         \not \isArray(any2))
		\replacewith (sameType(any1, any2) &
		              ((int::exactInstance(any1) = TRUE | boolean::exactInstance(any1) = TRUE) -> any1 = any2) &
		              (Object::instance(any1) = TRUE -> (\forall f; (similar(((Object)any1).f@heap, ((Object)any2).f@heap2, heap, heap2)))) &
                      (int::exactInstance(any1) = TRUE | boolean::exactInstance(any1) = TRUE | Object::instance(any1) = TRUE))
	};
	similarDefArr {
		\find (similar(any1, any2, heap, heap2))
		\varcond(\isArray(any1),
		         \isArray(any2),
		         \hasSort(\elemSort(any1), beta),
		         \notFreeIn(i, any1, any2, heap, heap2))
		\replacewith (sameType(any1, any2) &
		              length((Object)any1) = length((Object)any2) &
                      (\forall i; ((0 <= i & i < length((Object)any1)) -> similar(beta::select(heap, (Object)any1, arr(i)), beta::select(heap2, (Object)any2, arr(i)), heap, heap2))))
	};

	//Additional rules, mainly for NI
	callTermInequal {
		\find(serviceTermination = serviceCall)
		\replacewith(false)
		\heuristics(simplify)
	};

	callTermInequal2 {
		\find(serviceCall = serviceTermination)
		\replacewith(false)
		\heuristics(simplify)
	};

	//History wellformedness (To be proven. Does not take cooperativeness into consideration, since this is an assumption, which can not be proven(?))
	//TODO Empty histories aren't wellformed - at least initial call (and corresponding termination) have to be there... is that ok?
	defOfCorrespondingEvents {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;

		\find(correspondingEvents(e1,e2))
		\replacewith(evType(e1) = serviceCall & evType(e2) = serviceTermination	& evCaller(e1) = evCaller(e2) & evCallee(e1) = evCallee(e2) & evService(e1) = evService(e2))
		\heuristics(simplify)
	};

	//TODO JK this assumes a very specific structure of histories which is not yet generated correctly
	defOfHistoryWellformednessWithMiddle {
		\schemaVar \term Event a;
		\schemaVar \term Event z;
		\schemaVar \term Seq s;

		\find(wellformedList(seqConcat(seqConcat(seqSingleton(a), s), seqSingleton(z))))
		\replacewith(correspondingEvents(a, z)
			& wellformedListInternal(s))
		\heuristics(simplify)
	};

	defOfHistoryWellformednessWithoutMiddle {
		\schemaVar \term Event a;
		\schemaVar \term Event z;
		\schemaVar \term Seq s;

		\find(wellformedList(seqConcat(seqSingleton(a), seqSingleton(z))))
		\replacewith(correspondingEvents(a,z))
		\heuristics(simplify)
	};

	defOfHistoryWellformedInternalEmpty {
		\find(wellformedListInternal(seqEmpty))
		\replacewith(true)
		\heuristics(simplify)
	};

	defOfHistoryWellformedInternal {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;
		\schemaVar \term Seq s;

		\find(wellformedListInternal(seqConcat(seqConcat(s, seqSingleton(e1)), seqSingleton(e2))))
		\replacewith(correspondingEvents(e1, e2) & wellformedListInternal(s))
		\heuristics(simplify)
	};

	defOfHistoryWellformedInternalSingle {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;

		\find(wellformedListInternal(seqConcat(seqSingleton(e1), seqSingleton(e2))))
		\replacewith(correspondingEvents(e1, e2))
		\heuristics(simplify)
	};

	//coop environment stuff

	defOfCorrespondingEventsCoop {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;

		\find(correspondingEventsCoop(e1,e2))
		\replacewith(evType(e1) = serviceCall & evType(e2) = serviceTermination	& (invEvent(e1) <-> invEvent(e2)))
		\heuristics(simplify)
	};

	defOfHistoryWfcoopEmpty {
    \find(wellformedListCoop(seqEmpty))
    \replacewith(true)
    \heuristics(simplify)
  };

	//defOfHistoryWfcoopWithoutMiddle { //just true, we don't do assumptions for the termination event obviously
  //  \schemaVar \term Event e1;
	//	\schemaVar \term Event e2;
  //  \find(wellformedListCoop(seqConcat(seqSingleton(e1),seqSingleton(e2))))
  //  \replacewith(true)
  //  \heuristics(simplify)
  //};

	defOfHistoryWfcoopWithMiddle {
	\schemaVar \term Event a;
	\schemaVar \term Event z;
	\schemaVar \term Seq s;
    \find(wellformedListCoop(seqConcat(seqConcat(seqSingleton(a), s), seqSingleton(z))))
    \replacewith(wellformedListCoopInternal(s))
    \heuristics(simplify)
  };

	defOfHistoryWfcoopInternalEmpty {
    \find(wellformedListCoopInternal(seqEmpty))
    \replacewith(true)
    \heuristics(simplify)
  };

	defOfHistoryWfcoopInternalSingle {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;

    \find(wellformedListCoopInternal(seqConcat(seqSingleton(e1), seqSingleton(e2))))
    \replacewith(correspondingEventsCoop(e1, e2))
    \heuristics(simplify)
  };

	defOfHistoryWfcoopInternal {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;
		\schemaVar \term Seq s;
    \find(wellformedListCoopInternal(seqConcat(seqConcat(s,seqSingleton(e1)), seqSingleton(e2))))
    \replacewith(correspondingEventsCoop(e1, e2) & wellformedListCoopInternal(s))
    \heuristics(simplify)
  };

	//visibility filtering
	defOfFilterVisibleConcat {
	  \schemaVar \term Seq s1, s2;
	  \find(filterVisible(seqConcat(s1, s2)))
	  \replacewith(seqConcat(filterVisible(s1), filterVisible(s2)))
	  \heuristics(simplify)
	};
	
	/*defOfFilterVisibleOuterStructure {
		\schemaVar \term Event a;
		\schemaVar \term Event z;
		\schemaVar \term Seq s;

		\find(filterVisible(seqConcat(seqConcat(seqSingleton(a), s), seqSingleton(z))))
		\replacewith((seqConcat(seqConcat(filterVisible(seqSingleton(a)), filterVisible(s)), filterVisible(seqSingleton(z)))))
		\heuristics(simplify)
	};*/

	/*defOfFilterVisible {
		\schemaVar \term Event e;
		\schemaVar \term Seq s;

		\find(filterVisible(seqConcat(s, seqSingleton(e))))
		\replacewith(seqConcat(filterVisible(s), filterVisible(seqSingleton(e))))
		\heuristics(simplify)
	};*/

	defOfFilterVisibleEmpty{
		\find(filterVisible(seqEmpty))
		\replacewith(seqEmpty)
		\heuristics(simplify)
	};


	defOfFilterVisibleSingle1 {
		\schemaVar \term Event e;

		\assumes(invEvent(e) ==>)
		\find(filterVisible(seqSingleton(e)))
		\replacewith(seqEmpty)
		\heuristics(concrete)
	};

	defOfFilterVisibleSingle2 {
		\schemaVar \term Event e;

		\assumes(==> invEvent(e))
		\find(filterVisible(seqSingleton(e)))
		\replacewith(seqSingleton(e))
		\heuristics(concrete)
	};

	filterVisibleCut {
      \schemaVar \term Event e;
      \schemaVar \term Seq p;

      \find(filterVisible(seqSingleton(e)))
      \add(==> invEvent(e));\add(invEvent(e)==> )
      \heuristics(simplify_ENLARGING)
  };
  
  defOfFilterVisibleIf {
    \schemaVar \term Event e; 
    
    \find(filterVisible(seqSingleton(e)))
    \replacewith(\if(invEvent(e)) \then(seqEmpty) \else(seqSingleton(e)))
    
    \heuristics(simplify)
  };

	//history equivalence
	defOfHistoryEquivInternalToFilteredVersion {
		\schemaVar \term Seq hist1;
		\schemaVar \term Seq hist2;

		\find(equivHistoryInternal( hist1, hist2 ))
		\replacewith(equivHistoryFilteredInternal(filterVisible(hist1),filterVisible(hist2)))
		\heuristics(simplify)
	};

	/*defOfHistoryEquivFilteredInternal {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;
		\schemaVar \term Seq s1;
		\schemaVar \term Seq s2;

		\find(equivHistoryFilteredInternal(seqConcat(s1, seqSingleton(e1)), seqConcat(s2, seqSingleton(e2))))
		\replacewith(equivEvent(e1, e2) & equivHistoryFilteredInternal(s1,s2))
		\heuristics(simplify)
 	};*/
 	
 	defOfHistoryEquivFilteredInternal {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;
		\schemaVar \term Seq s1;
		\schemaVar \term Seq s2;

		\find(equivHistoryFilteredInternal(seqConcat(seqSingleton(e1), s1), seqConcat(seqSingleton(e2), s2)))
		\replacewith(equivEvent(e1, e2) & equivHistoryFilteredInternal(s1,s2))
		\heuristics(concrete)
 	};

	defOfHistoryEquivFilteredSingle {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;

		\find(equivHistoryFilteredInternal(seqSingleton(e1), seqSingleton(e2)))
		\replacewith(equivEvent(e1, e2))
		\heuristics(concrete)
 	};
 	
 	//Two rules for error cases, when the histories can not be equal, however, a contradiction may be derived
 	defOfHistoryEquivFilteredInternalE1 {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;
		\schemaVar \term Seq s2;

		\find(equivHistoryFilteredInternal(seqSingleton(e1), seqConcat(seqSingleton(e2), s2)))
		\replacewith(equivEvent(e1, e2) & equivHistoryFilteredInternal(seqEmpty ,s2))
		\heuristics(concrete)
 	};
 	
 	defOfHistoryEquivFilteredInternalE2 {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;
		\schemaVar \term Seq s1;

		\find(equivHistoryFilteredInternal(seqConcat(seqSingleton(e1), s1), seqSingleton(e2)))
		\replacewith(equivEvent(e1, e2) & equivHistoryFilteredInternal(s1,seqEmpty))
		\heuristics(concrete)
 	};
 	

	defOfHistoryEquivFilteredEmpty {
		\schemaVar \term Event e1;
		\schemaVar \term Event e2;

		\find(equivHistoryFilteredInternal(seqEmpty, seqEmpty))
		\replacewith(true)
		\heuristics(simplify)
 	};

	defOfCoopListEquivInternalToFilteredVersion {
		\schemaVar \term Seq hist1;
		\schemaVar \term Seq hist2;

		\find(coopListEquivInternal( hist1, hist2 ))
		\replacewith(coopListEquivFilteredInternal(filterVisible(hist1),filterVisible(hist2)))
		\heuristics(simplify)
 	};

	/*defOfCoopListEquivFilteredInternal {
		\schemaVar \term Seq hist1;
		\schemaVar \term Seq hist2;
		\schemaVar \term Event e1a;
		\schemaVar \term Event e1b;
		\schemaVar \term Event e2a;
		\schemaVar \term Event e2b;

		\find(coopListEquivFilteredInternal(
			seqConcat(seqConcat(hist1, seqSingleton(e1a)), seqSingleton(e1b)),
			seqConcat(seqConcat(hist2, seqSingleton(e2a)), seqSingleton(e2b))
		))
		\replacewith(
			(equivEvent(e1a, e2a) -> equivEvent(e1b, e2b)) &
			coopListEquivInternal(hist1,hist2))
		\heuristics(simplify)
 	};*/
 	
 	defOfCoopListEquivFilteredInternal {
 	
 	  \schemaVar \term Seq sA;
 	  \schemaVar \term Seq sB;
 	  \schemaVar \term Event e1A;
 	  \schemaVar \term Event e2A;
 	  \schemaVar \term Event e1B;
 	  \schemaVar \term Event e2B;
 	  
 	  \find(coopListEquivFilteredInternal(seqConcat(seqSingleton(e1A), seqConcat(seqSingleton(e2A), sA)),
 	                                      seqConcat(seqSingleton(e1B), seqConcat(seqSingleton(e2B), sB)) ))
      \replacewith((equivEvent(e1A, e1B) -> equivEvent(e2A, e2B)) & 
                   coopListEquivFilteredInternal(sA,sB))
      \heuristics(simplify)
 	
 	};
 	
    //these two rules are used for a case which must not occure.
 	// However, the case can occure, if equivalence leads to contradiction
 	// And therefore the equivalence of the events leads to a contradiction with the symbolic execution.
 	
 	defOfCoopListEquivFilteredInternalE1 {
 	
 	  \schemaVar \term Seq sB;
 	  \schemaVar \term Event e1A;
 	  \schemaVar \term Event e2A;
 	  \schemaVar \term Event e1B;
 	  \schemaVar \term Event e2B;
 	  
 	  \find(coopListEquivFilteredInternal(seqConcat(seqSingleton(e1A), seqSingleton(e2A)),
 	                                      seqConcat(seqSingleton(e1B), seqConcat(seqSingleton(e2B), sB)) ))
      \replacewith((equivEvent(e1A, e1B) -> equivEvent(e2A, e2B)) & 
                   coopListEquivFilteredInternal(seqEmpty,sB))
      \heuristics(simplify)
 	
 	};
 	
    defOfCoopListEquivFilteredInternalE2 {
 	
 	  \schemaVar \term Seq sA;
 	  \schemaVar \term Event e1A;
 	  \schemaVar \term Event e2A;
 	  \schemaVar \term Event e1B;
 	  \schemaVar \term Event e2B;
 	  
 	  \find(coopListEquivFilteredInternal(seqConcat(seqSingleton(e1A), seqConcat(seqSingleton(e2A), sA)),
 	                                      seqConcat(seqSingleton(e1B), seqSingleton(e2B)) ))
      \replacewith((equivEvent(e1A, e1B) -> equivEvent(e2A, e2B)) & 
                   coopListEquivFilteredInternal(sA,seqEmpty))
      \heuristics(simplify)
 	
 	};
 	

	defOfCoopListEquivFilteredInternalSingle {
		\schemaVar \term Event e1a;
		\schemaVar \term Event e1b;
		\schemaVar \term Event e2a;
		\schemaVar \term Event e2b;

		\find(coopListEquivFilteredInternal(
			seqConcat(seqSingleton(e1a), seqSingleton(e1b)),
			seqConcat(seqSingleton(e2a), seqSingleton(e2b))
		))
		\replacewith(
			equivEvent(e1a, e2a) -> equivEvent(e1b, e2b))
		\heuristics(simplify)
 	};

	defOfCoopListEquivFilteredInternalEmpty {

		\find(coopListEquivFilteredInternal(
			seqEmpty, seqEmpty
		))
		\replacewith(
			true)
		\heuristics(simplify)
 	};

		//TODO JK SOUND? Are additional restrictions needed for soundness?
		definitionOfAgreeBasic {
			\schemaVar \term Seq a, b;

			\find(agreeBasic(a, b))
			\varcond ( \notFreeIn(i, a), \notFreeIn(i, b))

			\replacewith(
						\forall i;
						(   (0 <= i & i < seqLen(a))
						 ->(
							 		(
							 				(
							 						java.lang.Object::instance(any::seqGet(a, i)) = FALSE
							 					& Seq::instance(any::seqGet(a, i)) = FALSE
											)
									 		-> any::seqGet(a, i) = any::seqGet(b, i)
									)

								& (
										Seq::instance(any::seqGet(a, i)) = TRUE
								 		-> agreeBasic(Seq::seqGet(a, i), Seq::seqGet(b, i))
									)
							)
						)
			)

			\heuristics(simplify_enlarging)
		};
		
		
  ///// Additional rules for handling history-related stuff
  
  addEventsToEquivLeft {
    \schemaVar \term Event eA, eB, eAlong;
    \assumes(eAlong = eA ==>)
    \find(equivEvent(eA, eB))
    \replacewith(equivEvent(eAlong, eB))
    \heuristics(simplify)
  };
  
  addEventsToEquivRight {
    \schemaVar \term Event eA, eB, eBlong;
    \assumes(eBlong = eB ==>)
    \find(equivEvent(eA, eB))
    \replacewith(equivEvent(eA, eBlong))
    \heuristics(simplify)
  };
  
  addEventsToInvEvent {
    \schemaVar \term Event e, elong;
    \assumes(elong = e ==>)
    \find(invEvent(e))
    \replacewith(invEvent(elong))
    \heuristics(simplify)
  };
  
  expandHeapjoin {
    \schemaVar \term Heap h1, h, ho;
	\schemaVar \term Object o, selfO;
	\schemaVar \term Seq s;
	\schemaVar \term Field ff;
	
	\assumes(h1 = heapjoin(h, ho, s, selfO) ==>)
	\find(beta::select(h1, o, ff))
	
	\replacewith(beta::select(heapjoin(h, ho, s, selfO), o, ff))
	\heuristics(simplify_enlarging)
  };
  
  selectOfheapjoinSelf {
	\schemaVar \term Heap h, ho;
	\schemaVar \term Object o, selfO;
	\schemaVar \term Seq s;
	\schemaVar \term Field ff;
	
	\find(beta::select(heapjoin(h, ho, s, selfO), o, ff))
	
    \varcond(\selfExpression(o, selfO))

	\replacewith(beta::select(ho, o, ff))
	\heuristics(concrete)
   };
   
   selectOfheapjoinSelfInd {
	\schemaVar \term Heap h1, h, ho;
	\schemaVar \term Object o, selfO;
	\schemaVar \term Seq s;
	\schemaVar \term Field ff;
	
	\assumes(h1 = heapjoin(h, ho, s, selfO) ==>)
	\find(beta::select(h1, o, ff))
	
    \varcond(\selfExpression(o, selfO))

	\replacewith(beta::select(ho, o, ff))
	\heuristics(concrete)
   };
   
   
   selectOfheapjoinParam {
	\schemaVar \term Heap h, ho;
	\schemaVar \term Object o, selfO;
	\schemaVar \term Seq s;
	\schemaVar \term Field ff;
	
	\find(beta::select(heapjoin(h, ho, s, selfO), o, ff))
	
    \varcond(\paramExpression(o, s))

	\replacewith(beta::select(h, o, ff))
	\heuristics(concrete)
   };
   
   
  selectOfheapjoinParamInd {
	\schemaVar \term Heap h1, h, ho;
	\schemaVar \term Object o, selfO;
	\schemaVar \term Seq s;
	\schemaVar \term Field ff;
	
	\assumes(h1 = heapjoin(h, ho, s, selfO) ==>)
	\find(beta::select(h1, o, ff))
	
    \varcond(\paramExpression(o, s))

	\replacewith(beta::select(h, o, ff))
	\heuristics(concrete)
   };
   
   //--------------------------------------
   // Rules for deserialisation equivalence 
   //--------------------------------------
   
   deserialType {
     //Type equivalence of desrialized objects
     \schemaVar \term DeserialMap isomap;
     \schemaVar \term any a;
     
     \assumes(beta::instance(a) = TRUE ==>)
     \find(deserial(isomap, a))
     \add(beta::instance(deserial(isomap, a)) = TRUE ==>)
   
     \heuristics(simplify)
   };
   
   deserialTypeExact {
     //Type equivalence of desrialized objects
     \schemaVar \term DeserialMap isomap;
     \schemaVar \term any a;
     
     \assumes(beta::exactInstance(a) = TRUE ==>)
     \find(deserial(isomap, a))
     \add(beta::exactInstance(deserial(isomap, a)) = TRUE ==>)
   
     \heuristics(simplify)
   };
   
   deserialNullEquiv {
     \schemaVar \term DeserialMap isomap;
     \schemaVar \term any a;
     
     \assumes(a = null ==>)
     \find(deserial(isomap, a))
     \add(deserial(isomap, a) = null ==>)
   
     \heuristics(simplify)
   };
   
   deserialNonNullEquiv {
     \schemaVar \term DeserialMap isomap;
     \schemaVar \term any a;
     
     \assumes(==> a = null)
     \find(deserial(isomap, a))
     \add(==> deserial(isomap, a) = null)
   
     \heuristics(simplify)
   };
  
   deserialEquivNull {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term Object ar, as;
     \schemaVar \term Heap hr, hs;
     \assumes(ar = null ==>)
     \find(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     
     \add(as = null ==>)
   
     \heuristics(simplify)
   };
   
   deserialEquivNull2 {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term Object ar, as;
     \schemaVar \term Heap hr, hs;
     \assumes(as = null ==>)
     \find(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     
     \add(ar = null ==>)
   
     \heuristics(simplify)
   };
   
   deserialEquivNonNull {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term Object ar, as;
     \schemaVar \term Heap hr, hs;
     \assumes(==> ar = null)
     \find(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     
     \add(==> as = null)
   
     \heuristics(simplify)
   };
   
   deserialEquivNonNull2 {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term Object ar, as;
     \schemaVar \term Heap hr, hs;
     \assumes(==> as = null)
     \find(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     
     \add(==> ar = null)
   
     \heuristics(simplify)
   };
  
   deserialEquivSelect {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term Object ar, as;
     \schemaVar \term Heap hr, hs;
     \schemaVar \term Field fi;
     
     \assumes(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \find(beta::select(hr, ar, fi))
     
     \add(deserialEquiv(isoMap, beta::select(hr, ar, fi), hr, beta::select(hs, as, fi), hs) ==>)
    
     \heuristics(simplify)
   };
   
   deserialEquivSelect2 {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term Object ar, as;
     \schemaVar \term Heap hr, hs;
     \schemaVar \term Field fi;
     
     \assumes(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \find(beta::select(hs, as, fi))
     
     \add(deserialEquiv(isoMap, beta::select(hr, ar, fi), hr, beta::select(hs, as, fi), hs) ==>)
    
     \heuristics(simplify)
   };
   
   deserialEquivSelectCast {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term any ar, as;
     \schemaVar \term Heap hr, hs;
     \schemaVar \term Field fi;
     
     \assumes(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \find(beta::select(hr, (java.lang.Object)ar, fi))
     
     \add(deserialEquiv(isoMap, beta::select(hr, (java.lang.Object)ar, fi), hr, beta::select(hs, (java.lang.Object)as, fi), hs) ==>)
    
     \heuristics(simplify)
   };
   
   deserialEquivLength {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term Object ar, as;
     \schemaVar \term Heap hr, hs;
     \schemaVar \term Field fi;
     
     \assumes(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \find(length(ar))
     
     \add(length(ar) = length(as) ==>)
    
     \heuristics(simplify)
   };
   
   deserialEquivLength2 {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term Object ar, as;
     \schemaVar \term Heap hr, hs;
     \schemaVar \term Field fi;
     
     \assumes(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \find(length(as))
     
     \add(length(ar) = length(as) ==>)
    
     \heuristics(simplify)
   };
   
   deserialEquivSelectCast2 {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term any ar, as;
     \schemaVar \term Heap hr, hs;
     \schemaVar \term Field fi;
     
     \assumes(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \find(beta::select(hs, (java.lang.Object)as, fi))
     
     \add(deserialEquiv(isoMap, beta::select(hr, (java.lang.Object)ar, fi), hr, beta::select(hs, (java.lang.Object)as, fi), hs) ==>)
    
     \heuristics(simplify)
   };
   
   deserialEquivConcreteInt {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term any ar, as;
     \schemaVar \term Heap hr, hs;
   
     \assumes(int::instance(ar) = TRUE ==>)
     \find(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \add(ar = as ==>)
   
     \heuristics(concrete)
   };
   
   deserialEquivConcreteInt2 {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term any ar, as;
     \schemaVar \term Heap hr, hs;
   
     \assumes(int::instance(as) = TRUE ==>)
     \find(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \add(ar = as ==>)
   
     \heuristics(concrete)
   };
   
   deserialEquivConcreteBool {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term any ar, as;
     \schemaVar \term Heap hr, hs;
   
     \assumes(boolean::instance(ar) = TRUE ==>)
     \find(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \add(ar = as ==>)
   
     \heuristics(concrete)
   };
   
   deserialEquivConcreteBool2 {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term any ar, as;
     \schemaVar \term Heap hr, hs;
   
     \assumes(boolean::instance(as) = TRUE ==>)
     \find(deserialEquiv(isoMap, ar, hr, as, hs) ==>)
     \add(ar = as ==>)
   
     \heuristics(concrete)
   };
   
   deserialEquals {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term any ar, as, ar2, as2;
     \schemaVar \term Heap hr, hs;
     
     \assumes(deserialEquiv(isoMap, ar, hr, as, hs), deserialEquiv(isoMap, ar2, hr, as2, hs) ==>)
     \find(ar = ar2 ==>)
     
     \add(as = as2 ==>)
     
     \heuristics(simplify)
   };
   
   deserialEquals2 {
     \schemaVar \term DeserialMap isoMap;
     \schemaVar \term any ar, as, ar2, as2;
     \schemaVar \term Heap hr, hs;
     
     \assumes(deserialEquiv(isoMap, ar, hr, as, hs), deserialEquiv(isoMap, ar2, hr, as2, hs) ==>)
     \find(as = as2 ==>)
     
     \add(ar = ar2 ==>)
     
     \heuristics(simplify)
   };
   
   //--------------------------------------
   // Rules for transitive fresh 
   //--------------------------------------

   transitiveFreshBase {
     \schemaVar \term any a;
     \schemaVar \term Heap hnew, hold;
     
     \find(transfresh(a, hnew, hold) ==>)
     \add(Object::instance(a) = TRUE -> !(boolean::select(hold, (Object)a, java.lang.Object::<created>)=TRUE) ==>)
     
     \heuristics(concrete)
   
   };
   
   transitiveFreshWalk {
     \schemaVar \term Object o;
     \schemaVar \term Field fi;
     \schemaVar \term Heap hnew, hold;
     
     \assumes(transfresh(o, hnew, hold) ==>)
     \find(beta::select(hnew, o, fi))
     
     \add(Object::instance(beta::select(hnew, o, fi)) = TRUE -> transfresh(beta::select(hnew, o, fi) ,hnew, hold) ==>)
     
     \heuristics(simplify)
   };
   
   //---------------------------------------
   // Sequence simplification rules 
   //---------------------------------------
   normalizeSequence {
     //move out the singleton, such that we gain a normal form, where singletons are firsts
     \schemaVar \term Seq s1, s2;
     \schemaVar \term any a;
     
     \find(seqConcat(seqConcat(seqSingleton(a), s1), s2))
     \replacewith(seqConcat(seqSingleton(a), seqConcat(s1, s2)))
    
     \heuristics(concrete)
   };
   
   //----------------------------------------
   // Scheben defined the sameTypes predicate only for rhs.
   // Assumption: left hand side not needed.
   // We do need it for events, therefore, we also ass a rule for lhs.
   //----------------------------------------
   
   	definitionOfSameTypes2 {
		\schemaVar \term Seq s1, s2;
		\schemaVar \variables int ii;

		\find(sameTypes(s1, s2) ==>)
		\varcond ( \notFreeIn(ii, s1), \notFreeIn(ii, s2) )

		\replacewith(
					   seqLen(s1) = seqLen(s2)
					 & \forall ii;
					   (   (0 <= ii & ii < seqLen(s1))
						 -> (   (   sameType(any::seqGet(s1, ii), any::seqGet(s2, ii)) )
							  & (   Seq::instance(any::seqGet(s1, ii)) = TRUE
								 -> sameTypes(Seq::seqGet(s1, ii), Seq::seqGet(s2, ii)) ) ) ) ==>)

		\heuristics(comprehensions)
	};
   
}
