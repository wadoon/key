\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
    \generic G;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    
    \formula fml, post;
    \update upd;
    
    \program AbstractProgram #absProg;
    \program[list] Statement #slist;
    \program Statement #s;
    \program Expression #e;
    \program Variable #exc, #returned, #result;
    \program Variable #v, #v1;
    \program[list] Variable #vars;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label;
    \program[list] Label #labels;
}

\heuristicsDecl {
    abstractExecution;
    abstrUpdPriorityRules;
    abstrUpdLowPrioRules;
    abstrUpdLowestPrioRules;
    abstr_upd_commute;
}

\rules(programRules:Java) {
    /* 
      TODOS
      =====
      
      - (DS, 2018-11-12) Support abstract programs inside loop scopes -- then,
        we also have to consider labeled continues.
    */

    abstractExecutionNonVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \formula [nonrigid] C;
        \schemaVar \update U;
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returned \freshFor(#absProg);
        \schemaVar \skolemTerm any result \freshFor(#absProg);
        \schemaVar \termlabel abstrExecTermLabel;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        // TODO (DS, 2019-01-18): Add own rule for loop scope blocks, then comment
        //   line below in again. Dedicated rule has to "continue;", also to a
        //   loop label, and "break".
        //\varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
        
        // Check that we're in a non-void method, extract result variable
        \varcond(\storeResultVarIn(#v))
        \varcond(\isDefined(#v))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        
        // Program variables for modeling abnormal termination
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        \varcond(\newPV(#returned, "returned", boolean \freshFor(#absProg)))
        \varcond(\newPV(#result, "result", \typeof(#v) \freshFor(#absProg)))
        
        // Parametric Skolem update and path condition initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets). The path condition receives as argument the
        // location set of its accessible values, including the exception, returned, 
        // and result flags.
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
        \varcond(\initializeParametricSkolemPathCondition(C, #absProg, #exc, #returned, #result))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {#AELabel(U, #absProg)}{   #exc:=#AELabel(exc, #absProg)
                                     || #returned:=#AELabel(returned, #absProg) 
                                     || #result:=#addCast(#AELabel(result, #absProg),#result)}
               (  #AELabel(C, #absProg) 
                & #mutualExclusionFormula3(#returned, #exc, #vars) 
                & #returnSpec(#absProg, #returned)
                & #excSpec(#absProg, #exc)) ->
             {#AELabel(U, #absProg)}{   #exc:=#AELabel(exc, #absProg) 
                                     || #returned:=#AELabel(returned, #absProg) 
                                     || #result:=#addCast(#AELabel(result, #absProg),#result)}
               \modality{#allmodal}{
                 ..
                 if (#returned) {
                     return #result;
                 }
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \formula [nonrigid] C;
        \schemaVar \update U;
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returned \freshFor(#absProg);
        \schemaVar \termlabel abstrExecTermLabel;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
        
        // Check that we're in a void method
        \varcond(\storeResultVarIn(#v))
        \varcond(\not\isDefined(#v))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        
        // Program variables for modeling abnormal termination
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        \varcond(\newPV(#returned, "returned", boolean \freshFor(#absProg)))
        
        // Parametric Skolem update and path condition initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets). The path condition receives as argument the
        // location set of its accessible values, including the exception and returned 
        // flags.
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
        \varcond(\initializeParametricSkolemPathCondition(C, #absProg, #exc, #returned))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {#AELabel(U, #absProg)}{#exc:=#AELabel(exc, #absProg) || #returned:=#AELabel(returned, #absProg)}
               (  #AELabel(C, #absProg) 
                & #mutualExclusionFormula3(#returned, #exc, #vars) 
                & #returnSpec(#absProg, #returned)
                & #excSpec(#absProg, #exc)) ->
             {#AELabel(U, #absProg)}{   #exc:=#AELabel(exc, #absProg) 
                                     || #returned:=#AELabel(returned, #absProg)}
               \modality{#allmodal}{
                 ..
                 if (#returned) {
                     return;
                 }
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionNoMethod {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \formula [nonrigid] C;
        \schemaVar \update U;
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \termlabel abstrExecTermLabel;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're not inside a method frame
        \varcond(\not\prefixContainsElement("MethodFrame"))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        
        // Program variables for modeling abnormal termination
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        
        // Parametric Skolem update and path condition initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets). The path condition receives as argument the
        // location set of its accessible values, including the exception and returned 
        // flags.
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
        \varcond(\initializeParametricSkolemPathCondition(C, #absProg, #exc))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {#AELabel(U, #absProg)}{#exc:=#AELabel(exc, #absProg)}
               (  #AELabel(C, #absProg) 
                & #mutualExclusionFormula2(#exc, #vars) 
                & #excSpec(#absProg, #exc)) ->
             {#AELabel(U, #absProg)}{#exc:=#AELabel(exc, #absProg)}
               \modality{#allmodal}{
                 ..
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };

    // //////////////////////////////////
    // Special rules for abstract updates
    // //////////////////////////////////
   
    // The following quantifier rules allow quantifier treatment
    // below multiple updates, which we need for abstract execution
    // where updates cannot be always be merged to one. This is,
    // however, no nice solution: It would be better to have generic
    // "update context" SVs (and corresponding notations) in which
    // preceding updates can explicitly be stored. 
    
    allLeftUpdLevel1 {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find ({u1} (\forall v; phi) ==>)
  	  \add  ({u1} ({\subst v; t}(phi)) ==>)
  	  \heuristics(gamma)
    };
    
    allLeftUpdLevel2 {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1, u2;
      
  	  \find ({u1}{u2} (\forall v; phi) ==>)
  	  \add  ({u1}{u2} ({\subst v; t}(phi)) ==>)
    };
    
    allLeftUpdLevel2a {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find ({u1} (\modality{#allmodal}{.. ...}\endmodality(\forall v; phi)) ==>)
  	  \add  ({u1} (\modality{#allmodal}{.. ...}\endmodality({\subst v; t}(phi))) ==>)
    };
    
    allLeftHideUpdLevel2a {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find         ({u1} (\modality{#allmodal}{.. ...}\endmodality(\forall v; phi)) ==>)
  	  \replacewith  ({u1} (\modality{#allmodal}{.. ...}\endmodality({\subst v; t}(phi))) ==>)
      \addrules (insert_hidden { \add ({u1} (\modality{#allmodal}{.. ...}\endmodality(\forall v; phi)) ==>) })
    };
    
    // Abstract update simplification rules
   
    // NOTE (DS, 2019-02-01): Also this would be much nicer if we had
    // a mechanism to capture a sequence of update applications (without
    // the targets, i.e., only the {...}{...}...{...}). 
    // TODO (DS, 2019-02-01): Somehow generalize to
    //     {... || x := t || ...} {Ua1} ... {Uan} {... || x := t || ...} phi
    //   ->
    //     {... || x := t || ...} {Ua1} ... {Uan} {... || ...} phi
    dropIneffectiveSingleLaterUpd {
      \schemaVar \update abstrUpd;
      \schemaVar \program Variable x;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      
      \find ({x:=t}{abstrUpd}{x:=t} phi)
      
      \varcond(\abstractUpdate(abstrUpd))
      \varcond(\not\assigns(abstrUpd, x))
      
      \replacewith ({x:=t}{abstrUpd} phi)
      
      \heuristics(update_elim)
    };
    
    sequentialToConcatenatedAbs {
        \schemaVar \update u, u2;
        \schemaVar \formula phi;    
    
        \find({u}{u2} phi)
        \varcond(\abstractUpdate(u))
        \varcond(\abstractUpdate(u2))
    
        \replacewith({u ++ u2} phi)
    
        \heuristics(abstrUpdLowPrioRules)
    };
   
    // Simplifies an update cascade like
    //
    //   {... || y := t || ...}
    //     {U_P(..., y, ... := ..., y, ...)}
    //        {... || x := y || ...}
    //          phi(x)
    //
    // (where phi does not contain y) to
    //
    //   {... || x := t || ...}
    //     {U_P(..., x, ... := ..., x, ...)}
    //        {... || ...}
    //          phi(x)
    //
    // i.e. eliminates the renaming substitution "y for x". Since phi does not
    // contain y, this is sound: it holds for every concrete update you could
    // substitute for U_P.
   
    // NOTE (DS, 2019-02-05): We eventually might need to generalize that
    // rule; there could be a more complicated sequence of abstract and
    // concrete update in between the renaming concrete updates that we
    // have to handle, e.g., if in an extracted method, there are more abstract
    // statements, maybe interleaved with concrete assignments. 
    simplifyAbstractUpdateRenameSubst {
        \schemaVar \update u1, u2, u3;
        \schemaVar \formula phi, result;
       
        \find({u1}{u2}{u3}phi) 
        
        \varcond(\not\abstractUpdate(u1))
        \varcond(\abstractUpdate(u2))
        \varcond(\not\abstractUpdate(u3))
        
        \varcond(\simplifyAbstractUpdateRenameSubst(u1, u2, u3, phi, result))
        
        \replacewith(result)
        \heuristics(abstrUpdPriorityRules)
    };
   
    // Simplifies an update cascade like
    //
    //     {x1 := t1 || x2 := y || ...}
    //       {U_P(..., x1, ... := ... \cup x2 \cup ...)}
    //         phi
    //
    // to
    //
    //     {x1 := t1 || ...}
    //       {U_P(..., x1, ... := ... \cup y \cup ...)}
    //         {x2 := y}
    //           phi
    //
    // i.e. applies variable assignments to the accessibles of the abstract
    // update and pushes through elementaries that are not assigned by the
    // abstract update. Dropping ineffective assignments is not in the
    // responsibility of this rule (check simplifyUpdate1/2).
    
    sequentialAbstrUpdateSimpl {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result;
       
        \find({u1}{u2}phi) 
        
        \varcond(\not\abstractUpdate(u1))
        \varcond(\abstractUpdate(u2))
        
        \varcond(\sequentialUpdateSimplAbstr(u1, u2, phi, result))
        
        \replacewith(result)
        \heuristics(update_elim)
    };

    simplifyAbstractUpdate1 {
        \schemaVar \update u, result;
        \schemaVar \term [nonrigid] any t;
       
        \find({u}t) 
        
        \varcond(\abstractUpdate(u))
        \varcond(\dropEffectlessAbstractUpdateAssignments(u, t, result))
        
        \replacewith({result}t)
        \heuristics(update_elim)
    };

    simplifyAbstractUpdate2 {
        \schemaVar \update u, result;
        \schemaVar \formula [nonrigid] phi;
       
        \find({u}phi) 
        
        \varcond(\abstractUpdate(u))
        \varcond(\dropEffectlessAbstractUpdateAssignments(u, phi, result))
        
        \replacewith({result}phi)
        \heuristics(update_elim)
    };

    commuteConcatenatedAbstractUpdates1 {
        \schemaVar \update uleft, uright;
        
        \find(uleft ++ uright)
        
        \varcond(\abstractUpdate(uleft))
        \varcond(\abstractUpdate(uright))
        \varcond(\abstrUpdatesIndependent(uleft, uright))
        
        \replacewith(uright ++ uleft)
        
        \heuristics(abstr_upd_commute)
    };
    
    commuteConcatenatedAbstractUpdates2 {
        \schemaVar \update uleft, uright, r;
        
        \find((r ++ uleft) ++ uright)
        
        \varcond(\abstractUpdate(uleft))
        \varcond(\abstractUpdate(uright))
        \varcond(\abstrUpdatesIndependent(uleft, uright))
        
        \replacewith((r ++ uright) ++ uleft)
        
        \heuristics(abstr_upd_commute)
    };
    
    concatenatedAbstractUpdatesAssoc {
        \schemaVar \update uleft, uright, r;
        
        \find(uleft ++ (uright ++ r))
        
        \varcond(\abstractUpdate(uleft))
        \varcond(\abstractUpdate(uright))
        
        \replacewith(uleft ++ uright ++ r)
        
        \heuristics(update_elim)
    };
    
    // The following are rules preprocessing formulas such that they are
    // processable by succedent/antecedent taclets that normally only apply
    // to formulas under at most one update. We need this because with
    // abstract updates, we cannot / do not always simplify them to one
    // update, such that we often have nested update applications at the end.
    
    splitImp {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi -> psi))
        \replacewith({u}phi -> {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitAnd {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi & psi))
        \replacewith({u}phi & {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitOr {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi | psi))
        \replacewith({u}phi | {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 

    splitBiimp {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi <-> psi))
        \replacewith({u}phi <-> {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitNot {
        \schemaVar \update u;
        \schemaVar \formula phi;
        
        \find({u}(!phi))
        \replacewith(!{u}phi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
}

//\rules(programRules:Java, lazySymbExec:on) {
//     lazyLoop {
//         \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
//         \varcond(\freshAbstractProgram(#absProg))
//         \replacewith (\modality{#allmodal}{.. #absProg ...}\endmodality(post))
//         \heuristics(simplify_prog)
//     };
//}
