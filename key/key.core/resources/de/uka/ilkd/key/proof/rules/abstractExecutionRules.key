\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    
    \formula fml, post;
    \update upd;
    
    \program AbstractProgram #absProg;
    \program[list] Statement #slist;
    \program Statement #s;
    \program Expression #e;
    \program Variable #exc, #returned, #result;
    \program Variable #v, #v1;
    \program[list] Variable #vars;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label;
    \program[list] Label #labels;
}

\rules(programRules:Java) {
    /* 
      TODOS
      =====
      
      - (DS, 2018-11-12) Support abstract programs inside loop scopes -- then,
        we also have to consider labeled continues.
      - (DS, 2018-11-12) For each abstract program with the same symbol (such
        as the "P" in "abstract-program P", there should be created the same
        fresh variables (such that after the first creation, they aren't fresh
        any more, but still unique for "P"). Then we can do relational reasoning
        about programs containing the same abstract programs, e.g., for refactoring.
    */

    abstractExecutionRet {
        \schemaVar \skolemFormula C_sk \freshFor(#absProg);
        \schemaVar \skolemUpdate  U_sk \freshFor(#absProg);
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returned \freshFor(#absProg);
        \schemaVar \skolemTerm any result \freshFor(#absProg);
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        
        \varcond(\storeResultVarIn(#v))
        \varcond(\not\isnull(#v))
        
        \varcond(\storeContextLabelsIn(#labels))
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
 
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returned, boolean))
        \varcond(\new(#result, \typeof(#v)))
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith (
             {U_sk}{#exc:=exc || #returned:=returned}
               (C_sk & #mutualExclusionFormula3(#returned, #exc, #vars)) ->
             {U_sk}{#exc:=exc || #returned:=returned || #result:=#addCast(result,#result)}
               \modality{#allmodal}{
                 ..
                 if (#returned) {
                     return #result;
                 }
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(simplify_prog)
    };
    
    abstractExecutionNoRet {
        \schemaVar \skolemFormula C_sk \freshFor(#absProg);
        \schemaVar \skolemUpdate  U_sk \freshFor(#absProg);
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        
        \varcond(\storeResultVarIn(#v))
        \varcond(\isnull(#v))
        
        \varcond(\storeContextLabelsIn(#labels))
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
 
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith (
            {U_sk}{#exc:=exc}(C_sk & #mutualExclusionFormula2(#exc, #vars)) ->
            {U_sk}{#exc:=exc}\modality{#allmodal}{
              ..
              if (#exc != null) {
                  throw #exc;
              }
              #foreach (#v1, #label in #vars, #labels) { 
                  if (#v1) {
                      break #label;
                  }
              }
              ...
            }\endmodality(post))
   
        \heuristics(simplify_prog)
    };
}

\rules(programRules:Java, lazySymbExec:on) {
     lazyLoop {
         \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
         \replacewith (\modality{#allmodal}{.. abstract-program P; ...}\endmodality(post))
         \heuristics(simplify_prog)
     };
}
