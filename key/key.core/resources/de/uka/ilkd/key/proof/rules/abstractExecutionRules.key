\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    
    \formula fml, post;
    \update upd;
    
    \skolemFormula C_sk;
    \skolemUpdate U_sk;
    
    \program AbstractProgram #absProg;
    \program[list] Statement #slist;
    \program Statement #s;
    \program Expression #e;
    \program Variable #exc, #returned, #result;
    \program Variable #v, #v1;
    \program[list] Variable #vars;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label;
    \program[list] Label #labels;
}

\rules(programRules:Java) {
    // TODO (2018-11-18): These rules ignore (labeled and unlabeled)
    // breaks and continues. It will be a bit of work to consider 
    // that in a taclet (there might be breaks to any outer label
    // etc.). Also, continuing only makes sense if we're inside a 
    // loop. This taclet is sound nevertheless since the abstract
    // program occurs as first statement and can therefore not be
    // part of a loop, labeled block etc. We will have to create
    // further taclets or extend this one to be complete... 
    
    abstractExecutionRet {
        \find (==> {upd}\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
        
        \varcond(\storeResultVarIn(#v))
        \varcond(\not\isnull(#v))
        
        \varcond(\storeContextLabelsIn(#labels))
                
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returned, boolean))
        \varcond(\new(#result, \typeof(#v)))
        
        \replacewith (==> {upd}{U_sk}\modality{#allmodal}{..
            if (#returned) {
                return #result;
            }
            if (#exc != null) {
                throw #exc;
            }
         ...}\endmodality(post))
         
        \add ({upd}{U_sk} (C_sk & (
              #returned = FALSE & #exc = null
            | #returned = TRUE  & #exc = null
            | #returned = FALSE & !#exc = null
        )) ==>)
   
        \heuristics(simplify_prog)
    };

    abstractExecutionNoRet {
        \find (==> {upd}\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        
        \varcond(\storeResultVarIn(#v))
        \varcond(\isnull(#v))
        
        \varcond(\storeContextLabelsIn(#labels))
 
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean))
        
        \varcond(\createMutualExclusionFormula(fml, #exc, #vars))
        
        \replacewith (==> {upd}{U_sk}\modality{#allmodal}{..
            if (#exc != null) {
                throw #exc;
            }
            #foreach (#v1, #label in #vars, #labels) { 
                if (#v1) {
                    break #label;
                }
            };
         ...}\endmodality(post))
         
        \add ({upd}{U_sk} (C_sk & fml) ==>)
   
        \heuristics(simplify_prog)
    };
}

\rules(programRules:Java, lazySymbExec:on) {
     lazyLoop {
         \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
         \replacewith (\modality{#allmodal}{.. abstract-program P; ...}\endmodality(post))
         \heuristics(simplify_prog)
     };
}
