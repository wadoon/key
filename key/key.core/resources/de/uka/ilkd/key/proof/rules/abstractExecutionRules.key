\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    
    \formula fml, post;
    \update upd;
    
    \program AbstractProgram #absProg;
    \program[list] Statement #slist;
    \program Statement #s;
    \program Expression #e;
    \program Variable #exc, #returned, #result;
    \program Variable #v, #v1;
    \program[list] Variable #vars;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label;
    \program[list] Label #labels;
}

\heuristicsDecl {
    abstractExecution;
}

\rules(programRules:Java) {
    /* 
      TODOS
      =====
      
      - (DS, 2018-11-12) Support abstract programs inside loop scopes -- then,
        we also have to consider labeled continues.
    */

    abstractExecutionNonVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        //\schemaVar \skolemFormula [nonrigid] C \freshFor(#absProg);
        //\schemaVar \skolemUpdate             U \freshFor(#absProg);
        \schemaVar \formula [nonrigid] C;
        \schemaVar \update U;
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returned \freshFor(#absProg);
        \schemaVar \skolemTerm any result \freshFor(#absProg);
        \schemaVar \termlabel abstrExecTermLabel;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
        
        // Check that we're in a non-void method, extract result variable
        \varcond(\storeResultVarIn(#v))
        \varcond(\isDefined(#v))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        
        // Program variables for modeling abnormal termination
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        \varcond(\newPV(#returned, "returned", boolean \freshFor(#absProg)))
        \varcond(\newPV(#result, "result", \typeof(#v) \freshFor(#absProg)))
        
        // Parametric Skolem update and path condition initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets). The path condition receives as argument the
        // location set of its accessible values, including the exception, returned, 
        // and result flags.
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
        \varcond(\initializeParametricSkolemPathCondition(C, #absProg, #exc, #returned, #result))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {#AELabel(U, #absProg)}{#exc:=#AELabel(exc, #absProg) || #returned:=#AELabel(returned, #absProg)}
               (#AELabel(C, #absProg) & #mutualExclusionFormula3(#returned, #exc, #vars) & #returnSpec(#absProg, #returned)) ->
             {#AELabel(U, #absProg)}{   #exc:=#AELabel(exc, #absProg) 
                                     || #returned:=#AELabel(returned, #absProg) 
                                     || #result:=#addCast(#AELabel(result, #absProg),#result)}
               \modality{#allmodal}{
                 ..
                 if (#returned) {
                     return #result;
                 }
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \skolemFormula [nonrigid] C_sk \freshFor(#absProg);
        \schemaVar \skolemUpdate             U_sk \freshFor(#absProg);
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returned \freshFor(#absProg);
        
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
               
        // Check that we're outside a loop scope 
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
       
        // Check that we're in a void method 
        \varcond(\storeResultVarIn(#v))
        \varcond(\not\isDefined(#v))
       
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))

        // Program variables for modeling abnormal termination 
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returned, boolean))
       
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith (
            {U_sk}{#exc:=exc || #returned:=returned}
              (C_sk & #mutualExclusionFormula3(#returned, #exc, #vars) & #returnSpec(#absProg, #returned)) ->
            {U_sk}{#exc:=exc || #returned:=returned}\modality{#allmodal}{
              ..
              if (#returned) {
                  return;
              }
              if (#exc != null) {
                  throw #exc;
              }
              #foreach (#v1, #label in #vars, #labels) { 
                  if (#v1) {
                      break #label;
                  }
              }
              ...
            }\endmodality(post))
   
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionNoMethod {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \skolemFormula [nonrigid] C_sk \freshFor(#absProg);
        \schemaVar \skolemUpdate             U_sk \freshFor(#absProg);
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
               
        // Check that we're outside a loop scope 
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're outside a method frame (so we cannot return)
        \varcond(\not\prefixContainsElement("MethodFrame"))
       
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))

        // Program variables for modeling abnormal termination 
        \varcond(\new(#exc, java.lang.Throwable))
       
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith (
            {U_sk}{#exc:=exc}(C_sk & #mutualExclusionFormula2(#exc, #vars)) ->
            {U_sk}{#exc:=exc}\modality{#allmodal}{
              ..
              if (#exc != null) {
                  throw #exc;
              }
              #foreach (#v1, #label in #vars, #labels) { 
                  if (#v1) {
                      break #label;
                  }
              }
              ...
            }\endmodality(post))
   
        \heuristics(abstractExecution, simplify_prog)
    };

    // //////////////////////////////////
    // Special rules for abstract updates
    // //////////////////////////////////
    
    //sequentialToConcatenatedAbs {
    //    \schemaVar \update u, u2;
    //    \schemaVar \formula phi;    
    //
    //    \find({u}{u2} phi)
    //    \varcond(\abstractUpdate(u2))
    //    \varcond(\abstractUpdate(u))
    //
    //    \replacewith({u ++ u2} phi)
    //
    //    \heuristics(update_join)
    //};

    // Merges two updates in an application cascade like
    //
    //   {... || x_k := t_k || ... || x_l := t_l || ...}
    //      {U_P(x_1 \cup ... \cup x_k \cup ... :=
    //           t_1 \cup ... \cup x_l \cup ...)}
    //     phi
    //
    // to
    //
    //   {   (... || x_l := t_l || ...) 
    //    ++ U_P(x_1 \cup ... := t1 \cup ... \cup t_l)} 
    //     phi
    //
    // i.e. applies the concrete update to the accessibles of
    // the abstract update and drops elementaries of the concrete
    // update which are overwritten by the abstract update.
    // Accessibles in the abstract update that are then concrete
    // literals are removed.
    // The resulting abstract update is then concatenated to the
    // resulting concrete update.
    //
    // Example:
    //     {x1 := 2 || x2 := y || x5 := z}
    //       {U_P(x1 \cup x2 \cup x4 := 
    //            x1 \cup x2 \cup x3)}
    //         phi
    //   -->
    //     {x5 := z ++ U_P(x1 \cup x2 \cup x4 := y \cup x3)}
    //         phi
    //
    // This should have lower priority then the normal sequentialToParallel 
    // rules for concrete updates etc.
    
    //mergeConcreteWithAbstractUpdate {
    //    \schemaVar \update u, u2, result;
    //    \schemaVar \formula phi;    
    //
    //    \find({u}{u2}phi)
    //    \varcond(\not\abstractUpdate(u))
    //    \varcond(\abstractUpdate(u2))
    //    \varcond(\mergeConcreteWithAbstractUpdate(u, u2, result))
    //
    //    \replacewith({result}phi)
    //
    //    \heuristics(update_elim)
    //};
}

\rules(programRules:Java, lazySymbExec:on) {
     lazyLoop {
         \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
         \varcond(\freshAbstractProgram(#absProg))
         \replacewith (\modality{#allmodal}{.. #absProg ...}\endmodality(post))
         \heuristics(simplify_prog)
     };
}