\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    
    \formula fml, post;
    \update upd;
    
    \skolemFormula C_sk;
    \skolemUpdate U_sk;
    
    \program AbstractProgram #absProg;
    \program[list] Statement #slist;
    \program Statement #s;
    \program Expression #e;
    \program Variable #exc, #returned, #result;
    \program Variable #v, #v1;
    \program[list] Variable #vars;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label;
    \program[list] Label #labels;
}

\rules(programRules:Java) {
    /* 
      TODOS
      =====
      
      - (DS, 2018-11-12) Support abstract programs inside loop scopes -- then,
        we also have to consider labeled continues.
      - (DS, 2018-11-12) For each abstract program with the same symbol (such
        as the "P" in "abstract-program P", there should be created the same
        fresh variables (such that after the first creation, they aren't fresh
        any more, but still unique for "P"). Then we can do relational reasoning
        about programs containing the same abstract programs, e.g., for refactoring.
      - (DS, 2018-12-02): Support multiple updates before a modality, i.e., don't
        match the update explicitly but use a schema variable approach to storeall
        leading updates in a variable. That will also make it possible to apply
        the rules on the statement and not only on the sequent.
    */

    abstractExecutionRet {
        \find ({upd}\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        
        \varcond(\storeResultVarIn(#v))
        \varcond(\not\isnull(#v))
        
        \varcond(\storeContextLabelsIn(#labels))
 
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returned, boolean))
        \varcond(\new(#result, \typeof(#v)))
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean))
        
        \replacewith (
             {upd}{U_sk}\modality{#allmodal}{
               ..
               if (#returned) {
                   return #result;
               }
               if (#exc != null) {
                   throw #exc;
               }
               #foreach (#v1, #label in #vars, #labels) { 
                   if (#v1) {
                       break #label;
                   }
               }
               ...
             }\endmodality(post))
   
        \add ({upd}{U_sk}(C_sk & #mutualExclusionFormula3(#returned, #exc, #vars)))
        
        \heuristics(simplify_prog)
    };
    
    abstractExecutionNoRet {
        \find ({upd}\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        
        \varcond(\storeResultVarIn(#v))
        \varcond(\isnull(#v))
        
        \varcond(\storeContextLabelsIn(#labels))
 
        \varcond(\new(#exc, java.lang.Throwable, \freshFor(#absProg)))
        \varcond(\new(#v1, boolean, \freshFor(#absProg)))
        \varcond(\newLabel(#label))
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean))
        
        \replacewith (
            {upd}{U_sk}\modality{#allmodal}{
              ..
              if (#exc != null) {
                  throw #exc;
              }
              #foreach (#v1, #label in #vars, #labels) { 
                  if (#v1) {
                      break #label;
                  }
              }
              ...
            }\endmodality(post))
        
        \add ({upd}{U_sk}(C_sk & #mutualExclusionFormula2(#exc, #vars)) ==>)
   
        \heuristics(simplify_prog)
    };
}

\rules(programRules:Java, lazySymbExec:on) {
     lazyLoop {
         \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
         \replacewith (\modality{#allmodal}{.. abstract-program P; ...}\endmodality(post))
         \heuristics(simplify_prog)
     };
}
