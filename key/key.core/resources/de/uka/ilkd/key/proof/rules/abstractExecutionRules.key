\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    
    \formula fml, post;
    \update upd;
    
    \program AbstractProgram #absProg;
    \program[list] Statement #slist;
    \program Statement #s;
    \program Expression #e;
    \program Variable #exc, #returned, #result;
    \program Variable #v, #v1;
    \program[list] Variable #vars;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label;
    \program[list] Label #labels;
}

\heuristicsDecl {
    abstractExecution;
}

\rules(programRules:Java) {
    /* 
      TODOS
      =====
      
      - (DS, 2018-11-12) Support abstract programs inside loop scopes -- then,
        we also have to consider labeled continues.
    */

    abstractExecutionNonVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \skolemFormula [nonrigid] C \freshFor(#absProg);
        \schemaVar \skolemUpdate             U \freshFor(#absProg);
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returned \freshFor(#absProg);
        \schemaVar \skolemTerm any result \freshFor(#absProg);
        \schemaVar \termlabel abstrExecTermLabel;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
        
        // Check that we're in a non-void method, extract result variable
        \varcond(\storeResultVarIn(#v))
        \varcond(\isDefined(#v))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
 
        // Program variables for modeling abnormal termination 
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        \varcond(\newPV(#returned, "returned", boolean \freshFor(#absProg)))
        \varcond(\newPV(#result, "result", \typeof(#v) \freshFor(#absProg)))
        
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {#AELabel(U, #absProg)}{#exc:=exc || #returned:=returned}
               (#AELabel(C, #absProg) & #mutualExclusionFormula3(#returned, #exc, #vars)) ->
             {#AELabel(U, #absProg)}{#exc:=exc || #returned:=returned || #result:=#addCast(result,#result)}
               \modality{#allmodal}{
                 ..
                 if (#returned) {
                     return #result;
                 }
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \skolemFormula [nonrigid] C_sk \freshFor(#absProg);
        \schemaVar \skolemUpdate             U_sk \freshFor(#absProg);
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returned \freshFor(#absProg);
        
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
               
        // Check that we're outside a loop scope 
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
       
        // Check that we're in a void method 
        \varcond(\storeResultVarIn(#v))
        \varcond(\not\isDefined(#v))
       
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))

        // Program variables for modeling abnormal termination 
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returned, boolean))
       
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith (
            {U_sk}{#exc:=exc || #returned:=returned}(C_sk & #mutualExclusionFormula3(#returned, #exc, #vars)) ->
            {U_sk}{#exc:=exc || #returned:=returned}\modality{#allmodal}{
              ..
              if (#returned) {
                  return;
              }
              if (#exc != null) {
                  throw #exc;
              }
              #foreach (#v1, #label in #vars, #labels) { 
                  if (#v1) {
                      break #label;
                  }
              }
              ...
            }\endmodality(post))
   
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionNoMethod {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \skolemFormula [nonrigid] C_sk \freshFor(#absProg);
        \schemaVar \skolemUpdate             U_sk \freshFor(#absProg);
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
               
        // Check that we're outside a loop scope 
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're outside a method frame (so we cannot return)
        \varcond(\not\prefixContainsElement("MethodFrame"))
       
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))

        // Program variables for modeling abnormal termination 
        \varcond(\new(#exc, java.lang.Throwable))
       
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith (
            {U_sk}{#exc:=exc}(C_sk & #mutualExclusionFormula2(#exc, #vars)) ->
            {U_sk}{#exc:=exc}\modality{#allmodal}{
              ..
              if (#exc != null) {
                  throw #exc;
              }
              #foreach (#v1, #label in #vars, #labels) { 
                  if (#v1) {
                      break #label;
                  }
              }
              ...
            }\endmodality(post))
   
        \heuristics(abstractExecution, simplify_prog)
    };

    sequentialToConcatenatedAbs {
	    \schemaVar \update u, u2;
	    \schemaVar \formula phi;	
	
	    \find({u}{u2} phi)
	    \varcond(\abstractUpdate(u2))
	    \varcond(\abstractUpdate(u))
	
	    \replacewith({u ++ u2} phi)
	
	    \heuristics(update_join)
    };
}

\rules(programRules:Java, lazySymbExec:on) {
     lazyLoop {
         \find (\modality{#allmodal}{.. while(#e) #s ...}\endmodality(post))
         \varcond(\freshAbstractProgram(#absProg))
         \replacewith (\modality{#allmodal}{.. #absProg ...}\endmodality(post))
         \heuristics(simplify_prog)
     };
}