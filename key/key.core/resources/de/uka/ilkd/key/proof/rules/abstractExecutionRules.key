\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
    \generic G;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    \modalOperator { diamond, diamond_transaction } #dia;
    \modalOperator { box, box_transaction } #box;
    
    \formula fml, post;
    \update upd;
    
    \program AbstractProgram #absProg;
    \program[list] Statement #slist, #slist1, #slist2;
    \program Statement #s;
    \program Expression #e, #e1, #e2;
    \program Variable #exc, #returns, #result, #breaks, #continues;
    \program Variable #v, #v1;
    \program[list] Variable #vars, #vars1;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label, #label1;
    \program[list] Label #labels, #labels1;

    \program SimpleExpression #se;
    \program LeftHandSide #lhs;
    \program Statement #body;
    \program Variable #x;
}

\heuristicsDecl {
    abstractExecution;
    abstrUpdPriorityRules;
    abstrUpdLowPrioRules;
    abstrUpdLowestPrioRules;
    abstr_upd_commute;
}

\rules(programRules:Java) {
    abstractExecutionNonVoidLoopScope {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \formula [nonrigid] C;
        \schemaVar \update U;
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returns \freshFor(#absProg);
        \schemaVar \skolemTerm any result \freshFor(#absProg);
        \schemaVar \skolemTerm boolean breaks \freshFor(#absProg);
        \schemaVar \skolemTerm boolean continues \freshFor(#absProg);
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))

        // Check that we're inside a loop scope               
        \varcond(\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
        
        // Check that we're in a non-void method, extract result variable
        \varcond(\storeResultVarIn(#v))
        \varcond(\isDefined(#v))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Surrounding loop labels 
        \varcond(\storeContextLoopLabelsIn(#labels1))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        \varcond(\instantiateVarsFresh(#vars1, #labels1, "continues", boolean \freshFor(#absProg)))
        
        // Program variables for modeling irregular termination
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        \varcond(\newPV(#returns, "returns", boolean \freshFor(#absProg)))
        \varcond(\newPV(#result, "result", \typeof(#v) \freshFor(#absProg)))
        \varcond(\newPV(#breaks, "breaks", boolean \freshFor(#absProg)))
        \varcond(\newPV(#continues, "continues", boolean \freshFor(#absProg)))
        
        // Parametric Skolem update and path condition initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets). The path condition receives as argument the
        // location set of its accessible values, including the exception, returns, 
        // result, breaks and continues flags.
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
        \varcond(\initializeParametricSkolemPathCondition(C, #absProg))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {U}{#exc:=exc || #returns:=returns || #result:=#addCast(result,#result) || #breaks:=breaks || #continues:=continues}
               (  C 
                & #mutualExclusionFormula5(#returns, #exc, #breaks, #continues, #vars) 
                & #returnSpec(#absProg, #returns)
                & #excSpec(#absProg, #exc)
                & #breaksSpec(#absProg, #breaks)
                & #continuesSpec(#absProg, #continues)
               ) ->
             {U}{#exc:=exc || #returns:=returns || #result:=#addCast(result,#result) || #breaks:=breaks || #continues:=continues}
               \modality{#allmodal}{ ..
                   if (#returns) {
                       return #result;
                   }
                   if (#exc != null) {
                       throw #exc;
                   }
                   if (#continues) {
                       continue;
                   }
                   if (#breaks) {
                       break;
                   }
                   #foreach (#v1, #label in #vars, #labels) { 
                       if (#v1) {
                           break #label;
                       }
                   }
                   #foreach (#v1, #label1 in #vars1, #labels1) { 
                       if (#v1) {
                           continue #label1;
                       }
                   }
               ... }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionNonVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \formula [nonrigid] C;
        \schemaVar \update U;
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returns \freshFor(#absProg);
        \schemaVar \skolemTerm any result \freshFor(#absProg);
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
        
        // Check that we're in a non-void method, extract result variable
        \varcond(\storeResultVarIn(#v))
        \varcond(\isDefined(#v))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        
        // Program variables for modeling irregular termination
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        \varcond(\newPV(#returns, "returns", boolean \freshFor(#absProg)))
        \varcond(\newPV(#result, "result", \typeof(#v) \freshFor(#absProg)))
        
        // Parametric Skolem update and path condition initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets). The path condition receives as argument the
        // location set of its accessible values, including the exception, returns, 
        // and result flags.
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
        \varcond(\initializeParametricSkolemPathCondition(C, #absProg))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {U}{#exc:=exc || #returns:=returns || #result:=#addCast(result,#result)}
               (  C 
                & #mutualExclusionFormula3(#returns, #exc, #vars) 
                & #returnSpec(#absProg, #returns)
                & #excSpec(#absProg, #exc)) ->
             {U}{#exc:=exc || #returns:=returns || #result:=#addCast(result,#result)}
               \modality{#allmodal}{
                 ..
                 if (#returns) {
                     return #result;
                 }
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \formula [nonrigid] C;
        \schemaVar \update U;
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
        \schemaVar \skolemTerm boolean returns \freshFor(#absProg);
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
        
        // Check that we're in a void method
        \varcond(\storeResultVarIn(#v))
        \varcond(\not\isDefined(#v))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        
        // Program variables for modeling irregular termination
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        \varcond(\newPV(#returns, "returns", boolean \freshFor(#absProg)))
        
        // Parametric Skolem update and path condition initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets). The path condition receives as argument the
        // location set of its accessible values, including the exception and returns 
        // flags.
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
        \varcond(\initializeParametricSkolemPathCondition(C, #absProg))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {U}{#exc:=exc || #returns:=returns}
               (  C 
                & #mutualExclusionFormula3(#returns, #exc, #vars) 
                & #returnSpec(#absProg, #returns)
                & #excSpec(#absProg, #exc)) ->
             {U}{#exc:=exc || #returns:=returns}
               \modality{#allmodal}{
                 ..
                 if (#returns) {
                     return;
                 }
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionNoMethod {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \formula [nonrigid] C;
        \schemaVar \update U;
        \schemaVar \skolemTerm java.lang.Throwable exc \freshFor(#absProg);
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're not inside a method frame
        \varcond(\not\prefixContainsElement("MethodFrame"))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        
        // Program variables for modeling irregular termination
        \varcond(\newPV(#exc, "exc", java.lang.Throwable \freshFor(#absProg)))
        
        // Parametric Skolem update and path condition initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets). The path condition receives as argument the
        // location set of its accessible values, including the exception flag.
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
        \varcond(\initializeParametricSkolemPathCondition(C, #absProg))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {U}{#exc:=exc}
               (  C 
                & #mutualExclusionFormula2(#exc, #vars) 
                & #excSpec(#absProg, #exc)) ->
             {U}{#exc:=exc}
               \modality{#allmodal}{
                 ..
                 if (#exc != null) {
                     throw #exc;
                 }
                 #foreach (#v1, #label in #vars, #labels) { 
                     if (#v1) {
                         break #label;
                     }
                 }
                 ...
               }\endmodality(post))
        
        \heuristics(abstractExecution, simplify_prog)
    };

    // /////////////////////////////////////////////////////////////
    // Special loop treatment for program equivalence proofs with AE
    // /////////////////////////////////////////////////////////////

    loopScopeInvDiaAEEquiv {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \term any variantTerm;
      \schemaVar \formula loopFormula;
      \schemaVar \program Variable #variant;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
       
      \find ( (\modality{#dia} {.. while (#e) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#variant, any))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
     
      \varcond(\hasInvariant(#dia)) 
      \varcond(\not\hasLoopLabel) 
      \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#e) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #dia))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\getVariant(variantTerm))
      \varcond(\hasAEPredicate(post))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            {#variant:=variantTerm}
              (inv & freeInv ->
                 (\modality{#dia}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#e) { 
                        #body
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv & freeInv
                      & #setLastComponentOfAEPredsToFalse(post)
                      // The change to the original rule is the above additional subformula:
                      // We strengthen the invariant to show it by also keeping the post
                      // condition there. This has the effect to actually make relational
                      // proofs simpler, since the actual invariant can be weakened (e.g.,
                      // only termination- related stuff), and the post condition (with 
                      // modified termination information) can be proved by the 
                      // assumption (the other program).
                      & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                      & prec(variantTerm, #variant))
                   )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    loopScopeInvDiaLabelAEEquiv {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \term any variantTerm;
      \schemaVar \formula loopFormula;
      \schemaVar \program Variable #variant;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
       
      \find ( (\modality{#dia} {.. #label: while (#e) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#variant, any))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
     
      \varcond(\hasInvariant(#dia)) 
      \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#e) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #dia))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\getVariant(variantTerm))
      \varcond(\hasAEPredicate(post))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            {#variant:=variantTerm}
              (inv & freeInv ->
                 (\modality{#dia}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#e) #label: { 
                        #body
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv & freeInv
                      & #setLastComponentOfAEPredsToFalse(post)
                      & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                      & prec(variantTerm, #variant))
                   )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    loopScopeInvBoxAEEquiv {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \formula loopFormula;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
       
      \find ( (\modality{#box} {.. while (#e) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
      
      \varcond(\hasInvariant(#box)) 
      \varcond(\not\hasLoopLabel) 
      \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#e) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #box))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\hasAEPredicate(post))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            (inv & freeInv ->
               (\modality{#box}{
                  ..
                  boolean #x;
                  #x = true;
                  loop-scope(#x) {
                    if (#e) { 
                      #body
                      #x = false;
                    }
                  }
                  ...
                }\endmodality(
                  (#x<<loopScopeIndex>> = TRUE -> post) & 
                  (#x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #setLastComponentOfAEPredsToFalse(post)
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP))
                 )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    loopScopeInvBoxLabelAEEquiv {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \formula loopFormula;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
       
      \find ( (\modality{#box} {.. #label: while (#e) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
      
      \varcond(\hasInvariant(#box)) 
      \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#e) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #box))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\hasAEPredicate(post))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
              (inv & freeInv ->
                 (\modality{#box}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#e) #label: { 
                        #body
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv & freeInv
                      & #setLastComponentOfAEPredsToFalse(post)
                      & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP))
                   )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };

    loopScopeInvDiaAEEquivUnroll {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \term any variantTerm;
      \schemaVar \formula loopFormula;
      \schemaVar \program Variable #variant;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
    
      \schemaVar \term int i;
      \schemaVar \program Expression #i;
       
      \find ( (\modality{#dia} {.. while (#e) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#variant, any))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
     
      \varcond(\hasInvariant(#dia)) 
      \varcond(\not\hasLoopLabel) 
      \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#e) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #dia))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\getVariant(variantTerm))
      \varcond(\hasAEPredicate(post))
      \varcond(\initializeExpression(#i, int, i))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            {#variant:=variantTerm}
              (inv & freeInv & i = i // NOTE (DS, 2019-02-22): That's a hack to make KeY understand that
                                     //   this term is not instantiated yet and we have to supply a value.
                                     //   If i does not occur anywhere, it's simply ignored.
                ->
                 (\modality{#dia}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#e) { 
                        { 
                          #repeat(#i) {
                            if (#e)  
                              #body
                            else
                              break;
                          }
                        }
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv & freeInv
                      & #setLastComponentOfAEPredsToFalse(post)
                      & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                      & prec(variantTerm, #variant))
                   )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    loopScopeInvDiaAEEquivUnrollSplit {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \term any variantTerm;
      \schemaVar \formula loopFormula;
      \schemaVar \program Variable #variant;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
    
      \schemaVar \term int i;
      \schemaVar \program Expression #i;
       
      \find ( (\modality{#dia} {.. while (#e1 && #e2) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#variant, any))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
     
      \varcond(\hasInvariant(#dia)) 
      \varcond(\not\hasLoopLabel) 
      \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#e1 && #e2) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #dia))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\getVariant(variantTerm))
      \varcond(\hasAEPredicate(post))
      \varcond(\initializeExpression(#i, int, i))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            {#variant:=variantTerm}
              (inv & freeInv & i = i // NOTE (DS, 2019-02-22): That's a hack to make KeY understand that
                                     //   this term is not instantiated yet and we have to supply a value.
                                     //   If i does not occur anywhere, it's simply ignored.
                ->
                 (\modality{#dia}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#e1 && #e2) { 
                        { 
                          #repeat(#i) {
                            if (#e1) { 
                              if (#e2) #body
                            }
                            else break;
                          }
                        }
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv & freeInv
                      & #setLastComponentOfAEPredsToFalse(post)
                      & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                      & prec(variantTerm, #variant))
                   )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    loopScopeInvDiaLabelAEEquivUnroll {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \term any variantTerm;
      \schemaVar \formula loopFormula;
      \schemaVar \program Variable #variant;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
    
      \schemaVar \term int i;
      \schemaVar \program Expression #i;
       
      \find ( (\modality{#dia} {.. #label: while (#e) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#variant, any))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
     
      \varcond(\hasInvariant(#dia)) 
      \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#e) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #dia))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\getVariant(variantTerm))
      \varcond(\hasAEPredicate(post))
      \varcond(\initializeExpression(#i, int, i))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            {#variant:=variantTerm}
              (inv & freeInv & i = i // NOTE (DS, 2019-02-22): That's a hack to make KeY understand that
                                     //   this term is not instantiated yet and we have to supply a value.
                                     //   If i does not occur anywhere, it's simply ignored.
                ->
                 (\modality{#dia}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#e) #label: { 
                        { 
                          #repeat(#i) {
                            if (#e)  
                              #body
                            else
                              break;
                          }
                        }
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv & freeInv
                      & #setLastComponentOfAEPredsToFalse(post)
                      & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                      & prec(variantTerm, #variant))
                   )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    loopScopeInvBoxAEEquivUnroll {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \formula loopFormula;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
    
      \schemaVar \term int i;
      \schemaVar \program Expression #i;
       
      \find ( (\modality{#box} {.. while (#e) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
      
      \varcond(\hasInvariant(#box)) 
      \varcond(\not\hasLoopLabel) 
      \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#e) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #box))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\hasAEPredicate(post))
      \varcond(\initializeExpression(#i, int, i))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            (inv & freeInv & i = i // NOTE (DS, 2019-02-22): That's a hack to make KeY understand that
                                   //   this term is not instantiated yet and we have to supply a value.
                                   //   If i does not occur anywhere, it's simply ignored.
                ->
               (\modality{#box}{
                  ..
                  boolean #x;
                  #x = true;
                  loop-scope(#x) {
                    if (#e) { 
                        { 
                          #repeat(#i) {
                            if (#e)  
                              #body
                            else
                              break;
                          }
                        }
                      #x = false;
                    }
                  }
                  ...
                }\endmodality(
                  (#x<<loopScopeIndex>> = TRUE -> post) & 
                  (#x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #setLastComponentOfAEPredsToFalse(post)
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP))
                 )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    loopScopeInvBoxAEEquivUnrollSplit {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \formula loopFormula;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
    
      \schemaVar \term int i;
      \schemaVar \program Expression #i;
       
      \find ( (\modality{#box} {.. while (#e1 && #e2) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
      
      \varcond(\hasInvariant(#box)) 
      \varcond(\not\hasLoopLabel) 
      \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#e1 && #e2) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #box))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\hasAEPredicate(post))
      \varcond(\initializeExpression(#i, int, i))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            (inv & freeInv & i = i // NOTE (DS, 2019-02-22): That's a hack to make KeY understand that
                                   //   this term is not instantiated yet and we have to supply a value.
                                   //   If i does not occur anywhere, it's simply ignored.
                ->
               (\modality{#box}{
                  ..
                  boolean #x;
                  #x = true;
                  loop-scope(#x) {
                    if (#e1 && #e2) { 
                        { 
                          #repeat(#i) {
                            if (#e1) { 
                              if (#e2) { #body }
                            }
                            else break;
                          }
                        }
                      #x = false;
                    }
                  }
                  ...
                }\endmodality(
                  (#x<<loopScopeIndex>> = TRUE -> post) & 
                  (#x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #setLastComponentOfAEPredsToFalse(post)
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP))
                 )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    loopScopeInvBoxLabelAEEquivUnroll {
      \schemaVar \formula inv;
      \schemaVar \formula freeInv;
      \schemaVar \formula loopFormula;
      
      \schemaVar \skolemTerm Heap anon_heap_LOOP; 
      \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
      \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
       
      \schemaVar \program Variable #heapBefore_LOOP; 
      \schemaVar \program Variable #savedHeapBefore_LOOP; 
      \schemaVar \program Variable #permissionsBefore_LOOP; 
    
      \schemaVar \term int i;
      \schemaVar \program Expression #i;
       
      \find ( (\modality{#box} {.. #label: while (#e) #body ... }\endmodality(post)) )

      \varcond(\new(#x, boolean))
      \varcond(\new(#heapBefore_LOOP, Heap))
      \varcond(\new(#savedHeapBefore_LOOP, Heap))
      \varcond(\new(#permissionsBefore_LOOP, Heap))
      
      \varcond(\hasInvariant(#box)) 
      \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#e) #body }\endmodality(post)))
      \varcond(\getInvariant(inv, #box))
      \varcond(\getFreeInvariant(freeInv, #dia))
      \varcond(\hasAEPredicate(post))
      \varcond(\initializeExpression(#i, int, i))

      "Invariant Initially Valid":
        \replacewith(inv);

      "Invariant Preserved and Used":
        \replacewith (
          {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
           || #createLocalAnonUpdate(loopFormula)
           || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
              (inv & freeInv & i = i // NOTE (DS, 2019-02-22): That's a hack to make KeY understand that
                                     //   this term is not instantiated yet and we have to supply a value.
                                     //   If i does not occur anywhere, it's simply ignored.
                ->
                 (\modality{#box}{
                    ..
                    boolean #x;
                    #x = true;
                    loop-scope(#x) {
                      if (#e) #label: { 
                        { 
                          #repeat(#i) {
                            if (#e)  
                              #body
                            else
                              break;
                          }
                        }
                        #x = false;
                      }
                    }
                    ...
                  }\endmodality(
                    (#x<<loopScopeIndex>> = TRUE -> post) & 
                    (#x<<loopScopeIndex>> = FALSE -> 
                        inv & freeInv
                      & #setLastComponentOfAEPredsToFalse(post)
                      & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP))
                   )))
        )
        
        \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
      \heuristics(abstractExecution, loop_scope_inv_taclet)
    };
  
    // //////////////////////////////////
    // Special rules for abstract updates
    // //////////////////////////////////
    
    // The following are heap rules which are only allowed in abstract
    // update scope. Normally, we have to perform a pull out before, but
    // this does not work with abstract updates because generally, we can
    // never substitute the simplified value back and therefore won't be
    // able to close the proofs.
    
    selectOfStoreAbstrUpdScope {
	  \schemaVar \term Heap h;
	  \schemaVar \term Object o, o2;
	  \schemaVar \term Field f, f2;
	  \schemaVar \term alpha x;

	  \find(beta::select(store(h, o, f, x), o2, f2))
	  \inAbstractUpdateScope

	  \replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                   \then((beta)x)
                   \else(beta::select(h, o2, f2)))
	  \heuristics(simplify)
    };

   
    // The following quantifier rules allow quantifier treatment
    // below multiple updates, which we need for abstract execution
    // where updates cannot be always be merged to one. This is,
    // however, no nice solution: It would be better to have generic
    // "update context" SVs (and corresponding notations) in which
    // preceding updates can explicitly be stored. 
    
    allLeftUpdLevel1 {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find ({u1} (\forall v; phi) ==>)
  	  \add  ({u1} ({\subst v; t}(phi)) ==>)
  	  \heuristics(gamma)
    };
    
    allLeftUpdLevel2 {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1, u2;
      
  	  \find ({u1}{u2} (\forall v; phi) ==>)
  	  \add  ({u1}{u2} ({\subst v; t}(phi)) ==>)
    };
    
    allLeftUpdLevel2a {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find ({u1} (\modality{#allmodal}{ #slist }\endmodality(\forall v; phi)) ==>)
  	  \add  ({u1} (\modality{#allmodal}{ #slist }\endmodality({\subst v; t}(phi))) ==>)
    };
    
    allLeftHideUpdLevel2a {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find         ({u1} (\modality{#allmodal}{ #slist }\endmodality(\forall v; phi)) ==>)
  	  \replacewith  ({u1} (\modality{#allmodal}{ #slist }\endmodality({\subst v; t}(phi))) ==>)
      \addrules (insert_hidden { \add ({u1} (\modality{#allmodal}{ #slist }\endmodality(\forall v; phi)) ==>) })
    };
    
    // Abstract update simplification rules
   
    sequentialToConcatenatedAbs {
        \schemaVar \update u, u2;
        \schemaVar \formula phi;    
    
        \find({u}{u2} phi)
        \varcond(\abstractUpdate(u))
        \varcond(\abstractUpdate(u2))
    
        \replacewith({u ++ u2} phi)
    
        \heuristics(abstrUpdLowestPrioRules)
    };
   
    sequentialToConcatenated {
        \schemaVar \update u, u2;
        \schemaVar \formula phi;    
    
        \find({u}{u2} phi)
    
        \replacewith({u ++ u2} phi)
    };
   
    applyAbstrOnConcrUpd {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result;
       
        \find({u1}{u2}phi) 
        
        \varcond(\abstractUpdate(u1))
        \varcond(\not\abstractUpdate(u2))
        
        \varcond(\applyAbstrOnConcrUpdate(u1, u2, phi, result))
        
        \replacewith(result)
        \heuristics(abstrUpdPriorityRules)
    };

    applyConcrOnAbstrUpd {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result;
       
        \find({u1}{u2}phi) 
        
        \varcond(\not\abstractUpdate(u1))
        \varcond(\abstractUpdate(u2))
        
        \varcond(\applyConcrOnAbstrUpdate(u1, u2, phi, result))
        
        \replacewith(result)
        \heuristics(abstrUpdLowPrioRules)
    };

    simplifyAbstractUpdate1 {
        \schemaVar \update u, result;
        \schemaVar \term [nonrigid] any t;
       
        \find({u}t) 
        
        \varcond(\abstractUpdate(u))
        \varcond(\dropEffectlessAbstractUpdateAssignments(u, t, result))
        
        \replacewith({result}t)
        \heuristics(abstrUpdPriorityRules)
    };

    simplifyAbstractUpdate2 {
        \schemaVar \update u, result;
        \schemaVar \formula [nonrigid] phi;
       
        \find({u}phi) 
        
        \varcond(\abstractUpdate(u))
        \varcond(\dropEffectlessAbstractUpdateAssignments(u, phi, result))
        
        \replacewith({result}phi)
        \heuristics(abstrUpdPriorityRules)
    };

    commuteConcatenatedAbstractUpdates1 {
        \schemaVar \update uleft, uright;
        
        \find(uleft ++ uright)
        
        \varcond(\abstractUpdate(uleft))
        \varcond(\abstractUpdate(uright))
        \varcond(\abstrUpdatesIndependent(uleft, uright))
        
        \replacewith(uright ++ uleft)
        
        \heuristics(abstr_upd_commute)
    };
    
    commuteConcatenatedAbstractUpdates2 {
        \schemaVar \update uleft, uright, r;
        
        \find((r ++ uleft) ++ uright)
        
        \varcond(\abstractUpdate(uleft))
        \varcond(\abstractUpdate(uright))
        \varcond(\abstrUpdatesIndependent(uleft, uright))
        
        \replacewith((r ++ uright) ++ uleft)
        
        \heuristics(abstr_upd_commute)
    };
    
    updateConcatAssoc {
        \schemaVar \update uleft, uright, r;
        
        \find(uleft ++ (uright ++ r))
        
        \replacewith(uleft ++ uright ++ r)
        
        \heuristics(abstrUpdPriorityRules)
    };
    
    // The following are rules preprocessing formulas such that they are
    // processable by succedent/antecedent taclets that normally only apply
    // to formulas under at most one update. We need this because with
    // abstract updates, we cannot / do not always simplify them to one
    // update, such that we often have nested update applications at the end.
    
    splitImp {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi -> psi))
        \replacewith({u}phi -> {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitAnd {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi & psi))
        \replacewith({u}phi & {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitOr {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi | psi))
        \replacewith({u}phi | {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 

    splitBiimp {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi <-> psi))
        \replacewith({u}phi <-> {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitNot {
        \schemaVar \update u;
        \schemaVar \formula phi;
        
        \find({u}(!phi))
        \replacewith(!{u}phi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
}