\sorts {
    Nat \extends java.lang.Object;
    /*! @defaultValue(tip) */
    NatSet;
}
\functions {
    \unique Nat Nat(int);
    NatSet tip;
    NatSet bin(Nat, NatSet);
    NatSet remove(NatSet, Nat);
    boolean eqv(NatSet, NatSet);
    boolean contains(NatSet, Nat);
    int len(NatSet);
}
\axioms {
    natset_induction {
        \schemaVar \formula phi;
        \schemaVar \variable NatSet base;
        \schemaVar \variable Nat e;

        \find( ==> \forall base; phi )
        \varcond( \notFreeIn(e,phi) )

        "1. case": \replacewith( ==>  ( {\subst base; tip} phi ) );
        "2. case": \replacewith( ==> \forall e; \forall base;  (  phi -> {\subst base; bin(e, base)} phi ) )
    };
    natset_ctor_split {
        \schemaVar \term NatSet natset;
        \schemaVar \skolemTerm Nat e;
        \schemaVar \skolemTerm NatSet els;
        \find(natset) \sameUpdateLevel
        \varcond(\new(e, \dependingOn(natset)), \new(els, \dependingOn(natset)))
        \replacewith(tip) \add(natset = tip ==>);
        \replacewith(bin(e, els)) \add(natset = bin(e, els) ==>)
    };
    eqv_tip_tip {
        \find( eqv(tip, tip) )
        \replacewith( true )
    };
    eqv_s1_s2_contains_s1_n {
        \schemaVar \term Nat n;
        \schemaVar \term NatSet s1;
        \schemaVar \term NatSet s2;
        \find( eqv(s1, s2) )
        \replacewith( contains(s1, n) = contains(s2, n) )
    };
    contains_bin_n_s_n {
        \schemaVar \term NatSet s;
        \schemaVar \term Nat n;
        \find( contains(bin(n, s), n) )
        \replacewith( true )
    };
    contains_bin_n1_s_n2_contains_s_n2_n1 {
        \schemaVar \term NatSet s;
        \schemaVar \term Nat n1;
        \schemaVar \term Nat n2;
        \find( contains(bin(n1, s), n2) )
        \replacewith( contains(s, n2) | n1 = n2 )
    };
    eq_NatSet_n1_n2 {
        \schemaVar \term NatSet n1;
        \schemaVar \term NatSet n2;
        \find( n1 = n2 )
        \replacewith( eqv(n1, n2) )
        \heuristics( eqv )
    };
}
\javaSource ".";
\chooseContract
