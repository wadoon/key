### Comment

Essentially the same test case as seqDef1 but with an additional artificial
free variable

### KeY

\problem {
   \forall int x; (x > 3 -> int::seqGet(seqDef{int i;}(1, x, i*i), 2) = 9)
}

### contains.1

(assert (not (forall ((var_x U)) (=> (instanceof var_x sort_int) (=> (> (u2i var_x) 3) (= (cast (k_seqGet (seqDef1 var_x) (i2u 2)) sort_int) (i2u 9)))))))

### contains.2

(assert (forall ((var_0 U)) (! (instanceof (seqDef1 var_0) sort_Seq) :pattern (seqDef1 var_0))))

### contains.3

(assert (forall ((var_x U) (var_i U)) (=> (and (instanceof var_x sort_int) (<= 0 (u2i var_i)) (< (u2i var_i) (- (u2i var_x) 1))) (= (k_seqGet (seqDef1 var_x) var_i) (let ((var_i (i2u (+ (u2i var_i) 1)))) (i2u (* (u2i var_i) (u2i var_i))))))))

### contains.4

(assert (forall ((var_x U)) (= (k_seqLen (seqDef1 var_x)) (ite (>= (- (u2i var_x) 1) 0) (i2u (- (u2i var_x) 1)) (i2u 0)))))

### expected

valid

