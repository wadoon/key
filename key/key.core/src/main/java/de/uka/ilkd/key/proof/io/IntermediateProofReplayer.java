package de.uka.ilkd.key.proof.io;

import de.uka.ilkd.key.axiom_abstraction.AbstractDomainElement;
import de.uka.ilkd.key.axiom_abstraction.predicateabstraction.AbstractPredicateAbstractionLattice;
import de.uka.ilkd.key.axiom_abstraction.predicateabstraction.AbstractionPredicate;
import de.uka.ilkd.key.axiom_abstraction.predicateabstraction.SimplePredicateAbstractionLattice;
import de.uka.ilkd.key.java.ProgramElement;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Named;
import de.uka.ilkd.key.logic.Namespace;
import de.uka.ilkd.key.logic.NamespaceSet;
import de.uka.ilkd.key.logic.PosInOccurrence;
import de.uka.ilkd.key.logic.PosInTerm;
import de.uka.ilkd.key.logic.Sequent;
import de.uka.ilkd.key.logic.SequentFormula;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.ProgramSV;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.logic.op.SchemaVariable;
import de.uka.ilkd.key.logic.op.SkolemTermSV;
import de.uka.ilkd.key.logic.op.VariableSV;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.parser.DefaultTermParser;
import de.uka.ilkd.key.parser.ParserException;
import de.uka.ilkd.key.pp.AbbrevMap;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.proof.Node;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.ProblemInitializer;
import de.uka.ilkd.key.proof.io.intermediate.AppNodeIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.BranchNodeIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.BuiltInAppIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.MergeAppIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.MergePartnerAppIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.NodeIntermediate;
import de.uka.ilkd.key.proof.io.intermediate.TacletAppIntermediate;
import de.uka.ilkd.key.rule.AbstractContractRuleApp;
import de.uka.ilkd.key.rule.AntecTaclet;
import de.uka.ilkd.key.rule.BuiltInRule;
import de.uka.ilkd.key.rule.IBuiltInRuleApp;
import de.uka.ilkd.key.rule.IfFormulaInstDirect;
import de.uka.ilkd.key.rule.IfFormulaInstSeq;
import de.uka.ilkd.key.rule.IfFormulaInstantiation;
import de.uka.ilkd.key.rule.NoPosTacletApp;
import de.uka.ilkd.key.rule.OneStepSimplifierRuleApp;
import de.uka.ilkd.key.rule.SuccTaclet;
import de.uka.ilkd.key.rule.Taclet;
import de.uka.ilkd.key.rule.TacletApp;
import de.uka.ilkd.key.rule.UseDependencyContractRule;
import de.uka.ilkd.key.rule.UseOperationContractRule;
import de.uka.ilkd.key.rule.merge.MergePartner;
import de.uka.ilkd.key.rule.merge.MergeProcedure;
import de.uka.ilkd.key.rule.merge.MergeRuleBuiltInRuleApp;
import de.uka.ilkd.key.rule.merge.procedures.MergeWithPredicateAbstraction;
import de.uka.ilkd.key.rule.merge.procedures.MergeWithPredicateAbstractionFactory;
import de.uka.ilkd.key.settings.DefaultSMTSettings;
import de.uka.ilkd.key.settings.GeneralSettings;
import de.uka.ilkd.key.settings.ProofIndependentSettings;
import de.uka.ilkd.key.smt.RuleAppSMT;
import de.uka.ilkd.key.smt.SMTProblem;
import de.uka.ilkd.key.smt.SMTSolverResult.ThreeValuedTruth;
import de.uka.ilkd.key.smt.SolverLauncher;
import de.uka.ilkd.key.smt.SolverTypeCollection;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.OperationContract;
import de.uka.ilkd.key.util.Pair;
import de.uka.ilkd.key.util.ProgressMonitor;
import de.uka.ilkd.key.util.Triple;
import de.uka.ilkd.key.util.mergerule.MergeRuleUtils;
import org.key_project.util.collection.DefaultImmutableSet;
import org.key_project.util.collection.ImmutableList;
import org.key_project.util.collection.ImmutableSLList;
import org.key_project.util.collection.ImmutableSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.StringReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import static de.uka.ilkd.key.util.mergerule.MergeRuleUtils.sequentToSETriple;


/**
 * This class is responsible for generating a KeY proof from an intermediate
 * representation generated by {@link IntermediatePresentationProofFileParser}.
 * <p>
 *
 * Replay is started using {@link #replay()}. In the course of replaying, new
 * nodes are added to the supplied proof object. The last goal touched during
 * replay can be obtained by {@link #getLastSelectedGoal()}.
 *
 * TODO: Check if joining with more than one partner works out of the box.
 * Potential problem: Different order may result in syntactically different
 * nodes.
 *
 * @see IntermediatePresentationProofFileParser
 *
 * @author Dominic Scheurer
 */
public class IntermediateProofReplayer {
    public static final String SMT_NOT_RUN = "Your proof has been loaded, but SMT solvers have not been run";


    private static final String ERROR_LOADING_PROOF_LINE = "Error loading proof.\n";
    private static final String NOT_APPLICABLE = " not available or not applicable in this context.";
    private static final Logger LOGGER = LoggerFactory.getLogger(IntermediateProofReplayer.class);


    /** The problem loader, for reporting errors */
    private final AbstractProblemLoader loader;
    /** The proof object into which to load the replayed proof */
    private Proof proof = null;

    /** Encountered errors */
    private List<Throwable> errors = new LinkedList<Throwable>();
    /** Error status */
    private String status = "";

    /** Stores open branches */
    private LinkedList<Pair<Node, NodeIntermediate>> queue = new LinkedList<Pair<Node, NodeIntermediate>>();

    /** Maps join node IDs to previously seen join partners */
    private HashMap<Integer, HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>>> joinPartnerNodes = new HashMap<Integer, HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>>>();

    /** The current open goal */
    private Goal currGoal = null;

    /**
     * Constructs a new {@link IntermediateProofReplayer}.
     *
     * @param loader
     *            The problem loader, for reporting errors.
     * @param proof
     *            The proof object into which to load the replayed proof.
     */
    public IntermediateProofReplayer(AbstractProblemLoader loader, Proof proof,
            IntermediatePresentationProofFileParser.Result parserResult) {
        this.proof = proof;
        this.loader = loader;

        queue.addFirst(new Pair<Node, NodeIntermediate>(proof.root(),
            parserResult.getParsedResult()));
    }

    /**
     * @return the lastSelectedGoal
     */
    public Goal getLastSelectedGoal() {
        return currGoal;
    }

    /**
     * Starts the actual replay process. Results are stored in the supplied
     * proof object; the last selected goal may be obtained by
     * {@link #getLastSelectedGoal()}.
     */
    public Result replay(ProblemInitializer.ProblemInitializerListener listener, ProgressMonitor progressMonitor) {
        long startTime = System.currentTimeMillis();
        int stepIndex = 0;
        int lastLineNr = 0;
        int reportInterval = 1;
        if (listener != null && progressMonitor != null) {
            int max = !queue.isEmpty() && queue.peekFirst().second != null ? queue.peekFirst().second.subtreeSize() : 1;
            listener.reportStatus(this, "Replaying proof", max);
            reportInterval = Math.max(1, Integer.highestOneBit(max / 256));
        }
        var mapping = new HashMap<Integer, NodeIntermediate>();
        if (GeneralSettings.slicing && !queue.isEmpty()) {
            final int[] i = {0};
            if (queue.peekFirst().second != null) {
                queue.peekFirst().second.depthFirstVisit(node -> {
                    if (node instanceof AppNodeIntermediate) {
                        //LOGGER.info("Node {} idx {}", ((AppNodeIntermediate) node).getIntermediateRuleApp().getRuleName(), i[0]);
                        mapping.put(i[0], node);
                        i[0]++;
                        if (node.subtreeSize() == 1 && !((AppNodeIntermediate) node).getIntermediateRuleApp().getRuleName().equals("SMTRule")) {
                            i[0]++;
                        }
                    }
                });
            }
        }
        var stepIdxOverrides = new ArrayDeque<Integer>();
        Goal overrideGoal = null;
        var appliedIdxes = new HashSet<>();
        while (!queue.isEmpty()) {
            if (listener != null && progressMonitor != null && stepIndex % reportInterval == 0) {
                progressMonitor.setProgress(stepIndex);
            }
            var overridenStep = !stepIdxOverrides.isEmpty();
            int finalStepIndex = stepIdxOverrides.isEmpty() ? stepIndex : stepIdxOverrides.pollFirst();
            if (GeneralSettings.slicing && GeneralSettings.branchStacks.containsKey(finalStepIndex)) {
                var list = GeneralSettings.branchStacks.get(finalStepIndex);
                LOGGER.trace("found branch stack @ {} with {} nodes", currGoal.node().serialNr(), list.size());
                for (int i = list.size() - 1; i >= 0; i--) {
                    queue.addFirst(new Pair<>(queue.peekFirst().first, mapping.get(list.get(i))));
                    stepIdxOverrides.addFirst(list.get(i));
                }
                GeneralSettings.branchStacks.remove(finalStepIndex);
                continue;
            }
            final Pair<Node, NodeIntermediate> currentP = queue.pollFirst();
            Node currNode = overrideGoal != null ? overrideGoal.node() : currentP.first;
            final NodeIntermediate currNodeInterm = currentP.second;
            int currNodeIntermChildrenCount = currNodeInterm != null ? currNodeInterm.getChildren().size() : -1;
            currGoal = overrideGoal != null ? overrideGoal : proof.getGoal(currNode);
            overrideGoal = null;
            boolean apply = !GeneralSettings.slicing || ((GeneralSettings.usefulSteps.contains(finalStepIndex) || overridenStep) && !appliedIdxes.contains(finalStepIndex));
            currNode.stepIndex = finalStepIndex;
            boolean wasSMT = false;

            try {
                if (currNodeInterm instanceof BranchNodeIntermediate) {
                    assert currNodeInterm.getChildren()
                            .size() <= 1 : "Branch node should have exactly one child.";
                    if (currNodeInterm.getChildren().size() == 1) {
                        currNode.getNodeInfo().setBranchLabel(
                                ((BranchNodeIntermediate) currNodeInterm)
                                        .getBranchTitle());
                        queue.addFirst(new Pair<Node, NodeIntermediate>(
                            currNode, currNodeInterm.getChildren().get(0)));
                    }
                    continue;
                } else if (currNodeInterm instanceof AppNodeIntermediate) {
                    if (apply) {
                        appliedIdxes.add(finalStepIndex);
                    }
                    AppNodeIntermediate currInterm = (AppNodeIntermediate) currNodeInterm;
                    if (GeneralSettings.slicing) {
                        var name = currInterm.getIntermediateRuleApp().getRuleName();
                        wasSMT = name.equals("SMTRule");
                        LOGGER.debug("slicing @ {} [{}] {} (apply = {}, line = {}, original app = {})",
                                finalStepIndex, currNode.serialNr(), name,
                                apply, currInterm.getIntermediateRuleApp().getLineNr(), GeneralSettings.stepIdxToName.get(finalStepIndex));
                        if (!name.equals(GeneralSettings.stepIdxToName.get(finalStepIndex))) {
                            LOGGER.error("names do not match");
                        }
                    }
                    int newLineNr = Integer.parseInt(currInterm.getIntermediateRuleApp().getLineNr());
                    if (newLineNr < lastLineNr) {
                        LOGGER.warn("didn't follow line number order!");
                        if (!overridenStep) {
                            throw new IllegalStateException("Proof Slicer didn't follow line number order!");
                        }
                    }
                    if (currGoal == null && apply) {
                        LOGGER.error("currGoal == null @ step index {} node serialNr {}", finalStepIndex, currNode.serialNr());
                        break;
                    }
                    if (!overridenStep) {
                        lastLineNr = newLineNr;
                    }
                    currNode.getNodeInfo().setInteractiveRuleApplication(
                        currInterm.isInteractiveRuleApplication());
                    currNode.getNodeInfo().setScriptRuleApplication(
                        currInterm.isScriptRuleApplication());
                    currNode.getNodeInfo().setNotes(currInterm.getNotes());

                    if (apply) {
                        // Register name proposals
                        proof.getServices().getNameRecorder().setProposals(
                                currInterm.getIntermediateRuleApp().getNewNames());
                    }

                    if (currInterm
                            .getIntermediateRuleApp() instanceof TacletAppIntermediate) {
                        TacletAppIntermediate appInterm = (TacletAppIntermediate) currInterm
                                .getIntermediateRuleApp();

                        try {
                            Goal newGoal = null;
                            if (apply) {
                                newGoal = currGoal.apply(
                                        constructTacletApp(appInterm, currGoal, finalStepIndex)).head();
                            }

                            final Iterator<Node> children = currNode
                                    .childrenIterator();
                            final LinkedList<NodeIntermediate> intermChildren = currInterm
                                    .getChildren();

                            if (!overridenStep) {
                                addChildren(currNode, !apply, children, intermChildren);
                            } else {
                                overrideGoal = newGoal;
                            }

                            // Children are no longer needed, set them to null
                             // to free memory.
                            if (!overridenStep) {
                                currInterm.setChildren(null);
                            }
                        } catch (Exception | AssertionError e) {
                            e.printStackTrace();
                            reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                    + appInterm.getLineNr() + ", goal "
                                    + currGoal.node().serialNr() + ", rule "
                                    + appInterm.getRuleName() + NOT_APPLICABLE,
                                e);
                        }

                    } else if (currInterm
                            .getIntermediateRuleApp() instanceof BuiltInAppIntermediate) {
                        BuiltInAppIntermediate appInterm = (BuiltInAppIntermediate) currInterm
                                .getIntermediateRuleApp();

                        if (appInterm instanceof MergeAppIntermediate) {
                            MergeAppIntermediate joinAppInterm = (MergeAppIntermediate) appInterm;
                            HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>> partnerNodesInfo = joinPartnerNodes
                                    .get(((MergeAppIntermediate) appInterm)
                                            .getId());

                            if (partnerNodesInfo == null || partnerNodesInfo
                                    .size() < joinAppInterm.getNrPartners()) {
                                // In case of an exception happening during the
                                 // replay process, it can happen that the queue
                                 // is
                                // empty when reaching this point. Then, we may
                                // not
                                // add the join node to the end of the queue
                                // since
                                // this will result in non-termination.

                                if (queue.isEmpty()) {
                                    continue;
                                }

                                // Wait until all partners are found: Add node
                                 // at the end of the queue. NOTE: DO NOT CHANGE
                                 // THIS to adding the node to the front! This
                                 // will
                                // result in non-termination!
                                queue.addLast(new Pair<Node, NodeIntermediate>(
                                    currNode, currNodeInterm));
                            } else {
                                try {
                                    final Services services = proof
                                            .getServices();

                                    MergeRuleBuiltInRuleApp joinApp = instantiateJoinApp(
                                        joinAppInterm, currNode,
                                        partnerNodesInfo, services);

                                    assert joinApp
                                            .complete() : "Join app should be automatically completed in replay";

                                    currGoal.apply(joinApp);

                                    final Iterator<Node> childrenIterator = currNode
                                            .childrenIterator();
                                    for (NodeIntermediate child : currInterm
                                            .getChildren()) {
                                        queue.addFirst(
                                            new Pair<Node, NodeIntermediate>(
                                                childrenIterator.next(),
                                                child));
                                    }

                                    // Now add children of partner nodes
                                    for (Triple<Node, PosInOccurrence, NodeIntermediate> partnerNodeInfo : partnerNodesInfo) {
                                        Iterator<Node> children = partnerNodeInfo.first
                                                .childrenIterator();
                                        LinkedList<NodeIntermediate> intermChildren = partnerNodeInfo.third
                                                .getChildren();

                                        addChildren(currNode, false, children, intermChildren);
                                    }
                                } catch (SkipSMTRuleException | BuiltInConstructionException e) {
                                    reportError(ERROR_LOADING_PROOF_LINE
                                            + "Line " + appInterm.getLineNr()
                                            + ", goal "
                                            + currGoal.node().serialNr()
                                            + ", rule "
                                            + appInterm.getRuleName()
                                            + NOT_APPLICABLE,
                                        e);
                                }
                            }
                        } else if (appInterm instanceof MergePartnerAppIntermediate) {
                            // Register this partner node
                            MergePartnerAppIntermediate joinPartnerApp = (MergePartnerAppIntermediate) appInterm;
                            HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>> partnerNodeInfo = joinPartnerNodes
                                    .get(joinPartnerApp.getMergeNodeId());

                            if (partnerNodeInfo == null) {
                                partnerNodeInfo = new HashSet<Triple<Node, PosInOccurrence, NodeIntermediate>>();
                                joinPartnerNodes.put(
                                    joinPartnerApp.getMergeNodeId(),
                                    partnerNodeInfo);
                            }

                            partnerNodeInfo.add(
                                new Triple<Node, PosInOccurrence, NodeIntermediate>(
                                    currNode,
                                    PosInOccurrence.findInSequent(
                                        currGoal.sequent(),
                                        appInterm.getPosInfo().first,
                                        appInterm.getPosInfo().second),
                                    currNodeInterm));
                        } else {
                            try {
                                if (apply) {
                                    IBuiltInRuleApp app = constructBuiltinApp(
                                            appInterm, currGoal, finalStepIndex);
                                    if (!app.complete()) {
                                        app = app.tryToInstantiate(currGoal);
                                    }
                                    currGoal.apply(app);
                                }

                                final Iterator<Node> children = currNode
                                        .childrenIterator();
                                LinkedList<NodeIntermediate> intermChildren = currInterm
                                        .getChildren();

                                if (!overridenStep) {
                                    addChildren(currNode, !apply, children, intermChildren);
                                }
                            } catch (SkipSMTRuleException e) {
                                // silently continue; status will be reported
                                // via
                                // polling
                                if (GeneralSettings.slicing) {
                                    LOGGER.trace("slicing: skipping SMT");
                                    // TODO(slicing): remove this
                                    currGoal.apply(new RuleAppSMT(RuleAppSMT.rule, PosInOccurrence.findInSequent(currGoal.sequent(), 1, PosInTerm.getTopLevel())));
                                }
                            } catch (BuiltInConstructionException | RuntimeException | AssertionError e) {
                                reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                        + appInterm.getLineNr() + ", goal "
                                        + currGoal.node().serialNr() + ", rule "
                                        + appInterm.getRuleName()
                                        + NOT_APPLICABLE,
                                    e);
                            }
                        }
                    }
                }
            } catch (Throwable throwable) {
                // Default exception catcher -- proof should not stop loading
                // if anything goes wrong, but instead continue with the next
                // node in the queue.
                reportError(ERROR_LOADING_PROOF_LINE, throwable);
            }
            if (!overridenStep) {
                if (currNodeIntermChildrenCount == 0 && !wasSMT) {
                    stepIndex++;
                }
                stepIndex++;
            }
        }
        GeneralSettings.slicing = false;
        GeneralSettings.branchStacks = null;
        GeneralSettings.stepIdxToIfInsts = null;
        GeneralSettings.stepIdxToPos = null;
        GeneralSettings.stepIdxToName = null;
        GeneralSettings.stepIndexToDynamicRule = null;
        LOGGER.info("replay time: {} ms", System.currentTimeMillis() - startTime);
        return new Result(status, errors, currGoal);
    }

    /**
     * Adds the pairs of proof node children and intermediate children to the
     * queue. At the moment, they are added in the order they were parsed. For
     * the future, it may be sensible to choose a different procedure, for
     * instance one that minimizes the number of open goals per time interval to
     * save memory. Note that in this case, some test cases might be adapted
     * which depend on fixed node serial numbers.
     *
     * @param ignoreChildren instead of the proof node children iterator, always use currNode
     * @param children Iterator of proof node children.
     * @param intermChildren List of corresponding intermediate children.
     */
    private void addChildren(Node currNode, boolean ignoreChildren, Iterator<Node> children,
                             LinkedList<NodeIntermediate> intermChildren) {
        if (GeneralSettings.slicing) {
            LOGGER.trace("addChildren node: {} ignore: {}, children.len: {}, intermChildren.len: {}", currNode.serialNr(), ignoreChildren, 42, intermChildren.size());
        }
        int i = 0;
        while (ignoreChildren || (!currGoal.node().isClosed() && children.hasNext()
                && intermChildren.size() > 0)) {
            if (ignoreChildren && i >= intermChildren.size()) {
                break;
            }

            // NOTE: In the case of an unfinished proof, there
            // is another node after the last application which
            // is not represented by an intermediate
            // application. Therefore, we have to add the last
            // check in the above conjunction.

            Node child = ignoreChildren ? currNode : children.next();
            if (ignoreChildren || !proof.getGoal(child).isLinked()) {
                if (GeneralSettings.slicing) {
                    LOGGER.trace("queue insert @ {}: {}", i, intermChildren.get(i).getClass());
                }
                queue.add(i, new Pair<Node, NodeIntermediate>(child,
                    intermChildren.get(i++)));
            }
        }
    }

    /**
     * Communicates a non-fatal condition to the caller. Empty string means
     * everything is OK. The message will be displayed to the user in the GUI
     * after the proof has been parsed.
     */
    public String getStatus() {
        return status;
    }

    /**
     * @return errors encountered during replay.
     */
    public Collection<Throwable> getErrors() {
        return errors;
    }

    /**
     * Constructs a taclet application from an intermediate one.
     *
     * @param currInterm
     *            The intermediate taclet application to create a "real"
     *            application for.
     * @param currGoal
     *            The goal on which to apply the taclet app.
     * @return The taclet application corresponding to the supplied intermediate
     *         representation.
     * @throws TacletAppConstructionException
     *             In case of an error during construction.
     */
    private TacletApp constructTacletApp(TacletAppIntermediate currInterm,
            Goal currGoal, int stepIndex) throws TacletAppConstructionException {

        final String tacletName = currInterm.getRuleName();
        final int currFormula = currInterm.getPosInfo().first;
        final PosInTerm currPosInTerm = currInterm.getPosInfo().second;
        final Sequent seq = currGoal.sequent();

        TacletApp ourApp = null;
        PosInOccurrence pos = null;

        Taclet t = proof.getInitConfig()
                .lookupActiveTaclet(new Name(tacletName));
        if (t == null) {
            LOGGER.trace("using taclet index @ {}", tacletName);
            if (GeneralSettings.slicing && GeneralSettings.stepIndexToDynamicRule.containsKey(stepIndex)) {
                var idx = GeneralSettings.stepIndexToDynamicRule.get(stepIndex);
                // find the correct rule app
                boolean done = false;
                for (var partialApp : currGoal.indexOfTaclets().getPartialInstantiatedApps()) {
                    if (partialApp.taclet().getAddedBy().stepIndex == idx) {
                        ourApp = partialApp;
                        done = true;
                        break;
                    }
                }
                if (!done) {
                    LOGGER.error("failed to find dynamically added taclet");
                }
            } else {
                LOGGER.trace("using index of new proof");
                ourApp = currGoal.indexOfTaclets().lookup(tacletName);
            }
        } else {
            ourApp = NoPosTacletApp.createNoPosTacletApp(t);
        }
        Services services = proof.getServices();

        if (currFormula != 0) { // otherwise we have no pos
            try {
                if (!GeneralSettings.slicing) {
                    pos = PosInOccurrence.findInSequent(currGoal.sequent(),
                            currFormula, currPosInTerm);
                } else {
                    var oldPos = GeneralSettings.stepIdxToPos.get(stepIndex);
                    var oldFormula = oldPos.sequentFormula();
                    var semiSeq = oldPos.isInAntec() ? currGoal.sequent().antecedent() : currGoal.sequent().succedent();
                    var done = false;
                    for (var newFormula : semiSeq.asList()) {
                        if (newFormula.realEquals(oldFormula)) {
                            pos = oldPos.replaceConstrainedFormula(newFormula);
                            done = true;
                            break;
                        }
                    }
                    if (!done) {
                        LOGGER.error("failed to find new formula @ rule name {}, step idx {}, added by {}, required formula {}", tacletName, stepIndex, GeneralSettings.stepIndexToDynamicRule.getOrDefault(stepIndex, -1), oldFormula);
                    }
                }
                /* part of the fix for #1716: ensure that position of find term
                 * (antecedent/succedent) matches the kind of the taclet.
                 */
                Taclet taclet = ourApp.taclet();
                if (taclet instanceof AntecTaclet && !pos.isInAntec()) {
                    throw new TacletAppConstructionException("The taclet " + taclet.name()
                            + " can not be applied to a formula/term in succedent.");
                } else if (taclet instanceof SuccTaclet && pos.isInAntec()) {
                    throw new TacletAppConstructionException("The taclet " + taclet.name()
                            + " can not be applied to a formula/term in antecedent.");
                }
                ourApp = ((NoPosTacletApp) ourApp).matchFind(pos, services);
                    ourApp = ourApp.setPosInOccurrence(pos, services);
            } catch (Exception e) {
                throw (TacletAppConstructionException)new TacletAppConstructionException(
                    "Wrong position information: " + pos).initCause(e);
            }
        }

        ourApp = constructInsts(ourApp, currGoal, currInterm.getInsts(),
            services);

        ImmutableList<IfFormulaInstantiation> ifFormulaList = ImmutableSLList
                .<IfFormulaInstantiation> nil();
        if (!GeneralSettings.slicing) {
            for (String ifFormulaStr : currInterm.getIfSeqFormulaList()) {
                ifFormulaList = ifFormulaList.append(
                        new IfFormulaInstSeq(seq, Integer.parseInt(ifFormulaStr)));
            }
        } else {
            for (var oldFormulaPio : GeneralSettings.stepIdxToIfInsts.get(stepIndex)) {
                var semiSeq = oldFormulaPio.isInAntec() ? currGoal.sequent().antecedent() : currGoal.sequent().succedent();
                var done = false;
                SequentFormula oldFormula = oldFormulaPio.sequentFormula();
                for (SequentFormula newFormula : semiSeq) {
                    if (newFormula.realEquals(oldFormula)) {
                        ifFormulaList = ifFormulaList.append(
                                new IfFormulaInstSeq(currGoal.sequent(), oldFormulaPio.isInAntec(), newFormula)
                        );
                        done = true;
                        break;
                    }
                }
                if (!done) {
                    LOGGER.error("did not locate ifInst during slicing @ rule name {}, serial nr {}", tacletName, stepIndex);
                }
            }

        }
        for (String ifFormulaStr : currInterm.getIfDirectFormulaList()) {
            // MU 2019: #1487. We have to use the right namespaces to not
            // ignore branch-local functions
            NamespaceSet nss = currGoal.getLocalNamespaces();
            Term term = parseTerm(ifFormulaStr, proof, nss.variables(),
                    nss.programVariables(), nss.functions());
            ifFormulaList = ifFormulaList.append(new IfFormulaInstDirect(
                new SequentFormula(term)));
        }

        if (!ourApp.ifInstsCorrectSize(ifFormulaList)) {
            LOGGER.warn("Proof contains wrong number of \\assumes instatiations for {}",
                    tacletName);
            // try to find instantiations automatically
            ImmutableList<TacletApp> instApps = ourApp
                    .findIfFormulaInstantiations(seq, services);
            if (instApps.size() != 1) {
                // none or not a unique result
                throw new TacletAppConstructionException(
                        "\nCould not apply " + tacletName +
                        "\nUnknown instantiations for \\assumes. " +
                        instApps.size()  + " candidates.\n" +
                        "Perhaps the rule's definition has been changed in KeY.");
            }

            TacletApp newApp = instApps.head();
            ifFormulaList = newApp.ifFormulaInstantiations();
        }

        // TODO: In certain cases, the below method call returns null and
        // induces follow-up NullPointerExceptions. This was encountered
        // in a proof of the TimSort method binarySort with several joins.
        // TODO: when replaying certain rule apps (e.g. narrowSelectArrayType)
        // the order of the ifFormulaList matters?!
        ourApp = ourApp.setIfFormulaInstantiations(ifFormulaList, services);
        if (ourApp == null) {
            LOGGER.error("encountered null rule app of {} after instantiating ifInsts", tacletName);
        }

        if (!ourApp.complete()) {
            ourApp = ourApp.tryToInstantiate(proof.getServices());
        }

        return ourApp;
    }

    /**
     * Constructs a built-in rule application from an intermediate one.
     *
     * @param currInterm
     *            The intermediate built-in application to create a "real"
     *            application for.
     * @param currGoal
     *            The goal on which to apply the built-in app.
     * @return The built-in application corresponding to the supplied
     *         intermediate representation.
     * @throws SkipSMTRuleException
     *             If the proof has been loaded, but the SMT solvers have not
     *             been run.
     * @throws BuiltInConstructionException
     *             In case of an error during construction.
     */
    private IBuiltInRuleApp constructBuiltinApp(
            BuiltInAppIntermediate currInterm, Goal currGoal, int stepIndex)
            throws SkipSMTRuleException, BuiltInConstructionException {

        final String ruleName = currInterm.getRuleName();
        final int currFormula = currInterm.getPosInfo().first;
        final PosInTerm currPosInTerm = currInterm.getPosInfo().second;

        Contract currContract = null;
        ImmutableList<PosInOccurrence> builtinIfInsts = null;

        // Load contracts, if applicable
        if (currInterm.getContract() != null) {
            currContract = proof.getServices().getSpecificationRepository()
                    .getContractByName(currInterm.getContract());
            if (currContract == null) {
                final ProblemLoaderException e = new ProblemLoaderException(
                    loader, "Error loading proof: contract \""
                            + currInterm.getContract() + "\" not found.");
                reportError(ERROR_LOADING_PROOF_LINE + ", goal "
                        + currGoal.node().serialNr() + ", rule " + ruleName
                        + NOT_APPLICABLE,
                    e);
            }
        }

        // Load ifInsts, if applicable
        if (currInterm.getBuiltInIfInsts() != null) {
            builtinIfInsts = ImmutableSLList.nil();
            if (!GeneralSettings.slicing) {
                for (final Pair<Integer, PosInTerm> ifInstP : currInterm
                        .getBuiltInIfInsts()) {
                    final int currIfInstFormula = ifInstP.first;
                    final PosInTerm currIfInstPosInTerm = ifInstP.second;

                    try {
                        final PosInOccurrence ifInst = PosInOccurrence
                                .findInSequent(currGoal.sequent(),
                                        currIfInstFormula, currIfInstPosInTerm);
                        builtinIfInsts = builtinIfInsts.append(ifInst);
                    } catch (RuntimeException | AssertionError e) {
                        reportError(ERROR_LOADING_PROOF_LINE + "Line "
                                        + currInterm.getLineNr() + ", goal "
                                        + currGoal.node().serialNr() + ", rule " + ruleName
                                        + NOT_APPLICABLE,
                                e);
                    }
                }
            } else {
                for (var oldFormulaPio : GeneralSettings.stepIdxToIfInsts.get(stepIndex)) {
                    var semiSeq = oldFormulaPio.isInAntec() ? currGoal.sequent().antecedent() : currGoal.sequent().succedent();
                    var done = false;
                    SequentFormula oldFormula = oldFormulaPio.sequentFormula();
                    for (SequentFormula newFormula : semiSeq) {
                        if (newFormula.realEquals(oldFormula)) {
                            builtinIfInsts = builtinIfInsts.append(new PosInOccurrence(newFormula, oldFormulaPio.posInTerm(), oldFormulaPio.isInAntec()));
                            done = true;
                            break;
                        }
                    }
                    if (!done) {
                        LOGGER.error("did not locate built-in ifInst during slicing @ rule name {}, step index {}", ruleName, stepIndex);
                    }
                }
            }
        }

        if (RuleAppSMT.rule.name().toString().equals(ruleName)) {
            boolean error = false;
            final SMTProblem smtProblem = new SMTProblem(currGoal);
            try {
                DefaultSMTSettings settings = new DefaultSMTSettings(
                    proof.getSettings().getSMTSettings(),
                    ProofIndependentSettings.DEFAULT_INSTANCE.getSMTSettings(),
                    proof.getSettings().getNewSMTSettings(),
                    proof);
                SolverLauncher launcher = new SolverLauncher(settings);
                // launcher.addListener(new SolverListener(settings, proof));
                SolverTypeCollection active = ProofIndependentSettings.DEFAULT_INSTANCE
                        .getSMTSettings().computeActiveSolverUnion();
                ArrayList<SMTProblem> problems = new ArrayList<SMTProblem>();
                problems.add(smtProblem);
                launcher.launch(active.getTypes(), problems,
                    proof.getServices());
            } catch (Exception e) {
                error = true;
            }
            if (error || smtProblem.getFinalResult()
                    .isValid() != ThreeValuedTruth.VALID) {
                status = SMT_NOT_RUN;
                // TODO(slicing): remove this
                return RuleAppSMT.rule.createApp(null, proof.getServices());
                //throw new SkipSMTRuleException();
            } else {
                return RuleAppSMT.rule.createApp(null, proof.getServices());
            }
        }

        IBuiltInRuleApp ourApp = null;
        PosInOccurrence pos = null;

        if (currFormula != 0) { // otherwise we have no pos
            if (!GeneralSettings.slicing) {
                try {
                    pos = PosInOccurrence.findInSequent(currGoal.sequent(),
                            currFormula, currPosInTerm);
                } catch (RuntimeException e) {
                    throw new BuiltInConstructionException(
                            "Wrong position information.", e);
                }
            } else {
                var oldPos = GeneralSettings.stepIdxToPos.get(stepIndex);
                var oldFormula = oldPos.sequentFormula();
                var semiSeq = oldPos.isInAntec() ? currGoal.sequent().antecedent() : currGoal.sequent().succedent();
                var done = false;
                for (var newFormula : semiSeq.asList()) {
                    if (newFormula.realEquals(oldFormula)) {
                        pos = oldPos.replaceConstrainedFormula(newFormula);
                        done = true;
                        break;
                    }
                }
                if (!done) {
                    LOGGER.error("failed to find new formula @ built-in rule name {}, serial nr {}", ruleName, stepIndex);
                }
            }
        }

        if (currContract != null) {
            AbstractContractRuleApp contractApp = null;

            BuiltInRule useContractRule;
            if (currContract instanceof OperationContract) {
                useContractRule = UseOperationContractRule.INSTANCE;
                contractApp = (((UseOperationContractRule) useContractRule)
                        .createApp(pos)).setContract(currContract);
            } else {
                useContractRule = UseDependencyContractRule.INSTANCE;
                contractApp = (((UseDependencyContractRule) useContractRule)
                        .createApp(pos)).setContract(currContract);
            }

            if (contractApp.check(currGoal.proof().getServices()) == null) {
                throw new BuiltInConstructionException(
                    "Cannot apply contract: " + currContract);
            } else {
                ourApp = contractApp;
            }

            currContract = null;
            if (builtinIfInsts != null) {
                ourApp = ourApp.setIfInsts(builtinIfInsts);
                builtinIfInsts = null;
            }
            return ourApp;
        }

        final ImmutableSet<IBuiltInRuleApp> ruleApps = collectAppsForRule(
            ruleName, currGoal, pos);
        if (ruleApps.size() != 1) {
            if (ruleApps.size() < 1) {
                throw new BuiltInConstructionException(
                    ruleName + " is missing. Most probably the binary "
                            + "for this built-in rule is not in your path or "
                            + "you do not have the permission to execute it.");
            } else {
                throw new BuiltInConstructionException(
                    ruleName + ": found " + ruleApps.size()
                            + " applications. Don't know what to do !\n" + "@ "
                            + pos);
            }
        }
        ourApp = ruleApps.iterator().next();
        if (ourApp instanceof OneStepSimplifierRuleApp) {
            ourApp.setIfInsts(builtinIfInsts);
            ((OneStepSimplifierRuleApp) ourApp).restrictedIfInsts = true;
        }
        builtinIfInsts = null;
        return ourApp;
    }

    /**
     * Instantiates a Join Rule application.
     *
     * @param joinAppInterm
     *            Intermediate join app.
     * @param services
     *            The services object.
     * @param currNode
     *            The current proof node.
     * @param partnerNodesInfo
     *            Information about join partner nodes.
     * @param currNode
     * @param partnerNodesInfo
     * @return The instantiated Join Rule application.
     * @throws SkipSMTRuleException
     *             If the proof has been loaded, but the SMT solvers have not
     *             been run.
     * @throws BuiltInConstructionException
     *             In case of an error during construction of the builtin rule
     *             app.
     */
    private MergeRuleBuiltInRuleApp instantiateJoinApp(
            final MergeAppIntermediate joinAppInterm, final Node currNode,
            final Set<Triple<Node, PosInOccurrence, NodeIntermediate>> partnerNodesInfo,
            final Services services)
            throws SkipSMTRuleException, BuiltInConstructionException {
        final MergeRuleBuiltInRuleApp joinApp = (MergeRuleBuiltInRuleApp) constructBuiltinApp(
            joinAppInterm, currGoal, 0);
        joinApp.setConcreteRule(
            MergeProcedure.getProcedureByName(joinAppInterm.getJoinProc()));
        joinApp.setDistinguishingFormula(MergeRuleUtils.translateToFormula(
            services, joinAppInterm.getDistinguishingFormula()));

        // Predicate abstraction join rule
        if (joinApp
                .getConcreteRule() instanceof MergeWithPredicateAbstractionFactory) {
            List<AbstractionPredicate> predicates = new ArrayList<AbstractionPredicate>();

            // It may happen that the abstraction predicates are null -- in this
            // case, it is the expected behavior to create a default lattice
            // with top and bottom elements only, which is accomplished by just
            // supplying an empty list of predicates to the join procedure.
            if (joinAppInterm.getAbstractionPredicates() != null) {
                try {
                    predicates = AbstractionPredicate.fromString(
                        joinAppInterm.getAbstractionPredicates(), services,
                        services.getProof().getGoal(currNode)
                                .getLocalNamespaces());
                } catch (ParserException e) {
                    errors.add(e);
                }
            }

            final Class<? extends AbstractPredicateAbstractionLattice> latticeType = joinAppInterm
                    .getPredAbstrLatticeType();

            LinkedHashMap<ProgramVariable, AbstractDomainElement> userChoices = new LinkedHashMap<ProgramVariable, AbstractDomainElement>();

            if (joinAppInterm.getUserChoices() != null) {
                final Pattern p = Pattern.compile("\\('(.+?)', `(.+?)`\\)");
                final Matcher m = p.matcher(joinAppInterm.getUserChoices());

                boolean matched = false;
                while (m.find()) {
                    matched = true;

                    for (int i = 1; i < m.groupCount(); i += 2) {
                        assert i + 1 <= m
                                .groupCount() : "Wrong format of join user choices: "
                                        + "There should always be pairs of program variables "
                                        + "and abstract domain elements.";

                        final String progVarStr = m.group(i);
                        final String abstrElemStr = m.group(i + 1);

                        // Parse the program variable
                        final Pair<Sort, Name> ph = MergeRuleUtils
                                .parsePlaceholder(progVarStr, false, services);

                        final List<AbstractionPredicate> applicablePredicates = StreamSupport
                                .stream(predicates.spliterator(), false)
                                .filter(
                                    pred -> pred.getArgSort().equals(ph.first))
                                .collect(Collectors.toList());

                        // Parse the abstract domain element
                        final AbstractDomainElement elem = MergeWithPredicateAbstraction
                                .instantiateAbstractDomain(ph.first,
                                    applicablePredicates, latticeType, services)
                                .fromString(abstrElemStr, services);
                        final Named pv = services.getNamespaces()
                                .programVariables().lookup(ph.second);

                        assert pv != null && pv instanceof ProgramVariable
                                && ((ProgramVariable) pv).sort().equals(ph.first) :
                                    "Program variable involved in join is not known to the system";

                        userChoices.put((ProgramVariable) pv, elem);
                    }
                }

                if (!matched) {
                    errors.add(new ParserException(
                        "Wrong format of join user choices.", null));
                }
            }

            // Instantiate the join procedure
            joinApp.setConcreteRule(
                ((MergeWithPredicateAbstractionFactory) joinApp
                        .getConcreteRule()).instantiate(
                            predicates,
                            latticeType == null
                                    ? SimplePredicateAbstractionLattice.class
                                    : latticeType,
                            userChoices));

        }

        ImmutableList<MergePartner> joinPartners = ImmutableSLList.nil();
        for (Triple<Node, PosInOccurrence, NodeIntermediate> partnerNodeInfo : partnerNodesInfo) {

            final Triple<Term, Term, Term> ownSEState = sequentToSETriple(
                currNode, joinApp.posInOccurrence(), services);
            final Triple<Term, Term, Term> partnerSEState = sequentToSETriple(
                partnerNodeInfo.first, partnerNodeInfo.second, services);

            assert ownSEState.third.equals(
                partnerSEState.third) : "Cannot merge incompatible program counters";

            joinPartners = joinPartners.append(new MergePartner(
                proof.getGoal(partnerNodeInfo.first), partnerNodeInfo.second));
        }

        joinApp.setMergeNode(currNode);
        joinApp.setMergePartners(joinPartners);

        return joinApp;
    }

    // ######## Below: Methods previously listed in DefaultProofFileParser

    /**
     * Stores an error in the list.
     *
     * @param string
     *            Description text.
     * @param e
     *            Error encountered.
     */
    private void reportError(String string, Throwable e) {
        status = "Errors while reading the proof. Not all branches could be load successfully.";
        errors.add(new ProblemLoaderException(loader, string, e));
    }

    /**
     * Retrieves all registered applications at the given goal and position for
     * the rule corresponding to the given ruleName.
     *
     * @param ruleName
     *            Name of the rule to find applications for.
     * @param g
     *            Goal to search.
     * @param pos
     *            Position of interest in the given goal.
     * @return All matching rule applications at pos in g.
     */
    private static ImmutableSet<IBuiltInRuleApp> collectAppsForRule(
            String ruleName, Goal g, PosInOccurrence pos) {

        ImmutableSet<IBuiltInRuleApp> result = DefaultImmutableSet
                .<IBuiltInRuleApp> nil();

        for (final IBuiltInRuleApp app : g.ruleAppIndex().getBuiltInRules(g,
            pos)) {
            if (app.rule().name().toString().equals(ruleName)) {
                result = result.add(app);
            }
        }

        return result;
    }

    /**
     * Instantiates schema variables in the given taclet application.
     *
     * @param app
     *            The taclet application to instantiate.
     * @param currGoal
     *            The corresponding goal.
     * @param loadedInsts
     *            Loaded schema variable instantiations.
     * @param services
     *            The services object.
     * @return The instantiated taclet.
     */
    private static TacletApp constructInsts(TacletApp app, Goal currGoal,
            LinkedList<String> loadedInsts, Services services) {
        if (loadedInsts == null)
            return app;
        ImmutableSet<SchemaVariable> uninsts = app.uninstantiatedVars();

        // first pass: add variables
        for (final String s : loadedInsts) {
            int eq = s.indexOf('=');
            final String varname = s.substring(0, eq);

            SchemaVariable sv = lookupName(uninsts, varname);
            if (sv == null) {
                // throw new IllegalStateException(
                // varname+" from \n"+loadedInsts+"\n is not in\n"+uninsts);
                LOGGER.error("{} from {} is not in uninsts", varname, app.rule().name());
                continue;
            }
            final String value = s.substring(eq + 1, s.length());
            if (sv instanceof VariableSV) {
                app = parseSV1(app, sv, value, services);
            }
        }

        // second pass: add everything else
        uninsts = app.uninstantiatedVars();
        for (final String s : loadedInsts) {
            int eq = s.indexOf('=');
            final String varname = s.substring(0, eq);
            final SchemaVariable sv = lookupName(uninsts, varname);
            if (sv == null) {
                continue;
            }

            String value = s.substring(eq + 1, s.length());
            app = parseSV2(app, sv, value, currGoal);
        }

        return app;
    }

    /**
     * Finds a schema variable in the given set.
     *
     * @param set
     *            The set to search.
     * @param name
     *            The name to search for.
     * @return The found schema variable, or null if it is not present in the
     *         set.
     */
    private static SchemaVariable lookupName(ImmutableSet<SchemaVariable> set,
            String name) {
        for (SchemaVariable v : set) {
            if (v.name().toString().equals(name))
                return v;
        }
        return null; // handle this better!
    }

    /**
     * Parses a given term in String representation.
     *
     * @param value
     *            String to parse.
     * @param proof
     *            Proof object (for namespaces and Services object).
     * @param varNS
     *            Variable namespace.
     * @param progVarNS
     *            Program variable namespace.
     * @return The parsed term.
     * @throws ParserException
     *             In case of an error.
     */
    public static Term parseTerm(String value, Proof proof,
            Namespace<QuantifiableVariable> varNS,
            Namespace<IProgramVariable> progVarNS,
            Namespace<Function> functNS) {
        try {
            return new DefaultTermParser().parse(new StringReader(value), null,
                proof.getServices(), varNS, functNS,
                proof.getNamespaces().sorts(), progVarNS, new AbbrevMap());
        } catch (ParserException e) {
            throw new RuntimeException("Error while parsing value " + value
                    + "\nVar namespace is: " + varNS + "\n",
                e);
        }
    }

    /**
     * Parses a given term in String representation.
     *
     * @param value
     *            String to parse.
     * @param proof
     *            Proof object (for namespaces and Services object).
     * @return The parsed term.
     */
    public static Term parseTerm(String value, Proof proof) {
        NamespaceSet nss = proof.getNamespaces();
        return parseTerm(value, proof, nss.variables(), nss.programVariables(),
            nss.functions());
    }

    /**
     * Instantiates a schema variable in the given taclet application. 1st pass:
     * only VariableSV.
     *
     * @param app
     *            Application to instantiate.
     * @param sv
     *            Schema variable (VariableSV) to instantiate.
     * @param value
     *            Name for the instantiated logic variable.
     * @param services
     *            The services object.
     * @return An instantiated taclet application, where the schema variable has
     *         been instantiated by a logic variable of the given name.
     */
    public static TacletApp parseSV1(TacletApp app, SchemaVariable sv,
            String value, Services services) {
        LogicVariable lv = new LogicVariable(new Name(value),
            app.getRealSort(sv, services));
        Term instance = services.getTermFactory().createTerm(lv);
        return app.addCheckedInstantiation(sv, instance, services, true);
    }

    /**
     * Instantiates a schema variable in the given taclet application. 2nd pass:
     * All other schema variables.
     *
     * @param app
     *            Application to instantiate.
     * @param sv
     *            Schema variable to instantiate.
     * @param value
     *            Name for the instantiated Skolem constant, program element or
     *            term..
     * @param targetGoal
     *            The goal corresponding to the given application.
     * @return An instantiated taclet application, where the schema variable has
     *         been instantiated, depending on its type, by a Skolem constant,
     *         program element, or term of the given name.
     * @see #parseSV1(TacletApp, SchemaVariable, String, Services)
     */
    public static TacletApp parseSV2(TacletApp app, SchemaVariable sv,
            String value, Goal targetGoal) {
        final Proof p = targetGoal.proof();
        final Services services = p.getServices();
        TacletApp result;
        if (sv instanceof VariableSV) {
            // ignore -- already done
            result = app;
        } else if (sv instanceof ProgramSV) {
            final ProgramElement pe = app.getProgramElement(value, sv,
                services);
            result = app.addCheckedInstantiation(sv, pe, services, true);
        } else if (sv instanceof SkolemTermSV) {
            result = app.createSkolemConstant(value, sv, true, services);
        } else {
            Namespace<QuantifiableVariable> varNS = p.getNamespaces()
                    .variables();
            Namespace<IProgramVariable> prgVarNS = targetGoal
                    .getLocalNamespaces().programVariables();
            Namespace<Function> funcNS = targetGoal.getLocalNamespaces()
                    .functions();
            varNS = app.extendVarNamespaceForSV(varNS, sv);
            Term instance = parseTerm(value, p, varNS, prgVarNS, funcNS);
            result = app.addCheckedInstantiation(sv, instance, services, true);
        }
        return result;
    }

    /**
     * Signals an error during construction of a taclet app.
     */
    static class TacletAppConstructionException extends Exception {
        private static final long serialVersionUID = 7859543482157633999L;

        TacletAppConstructionException(String s) {
            super(s);
        }

        TacletAppConstructionException(Throwable cause) {
            super(cause);
        }
    }

    /**
     * Signals an error during construction of a built-in rule app.
     */
    static class BuiltInConstructionException extends Exception {
        private static final long serialVersionUID = -735474220502290816L;

        BuiltInConstructionException(String s) {
            super(s);
        }

        BuiltInConstructionException(Throwable cause) {
            super(cause);
        }

        public BuiltInConstructionException(String s, Throwable cause) {
            super(s, cause);
        }
    }

    /**
     * Signals that the execution of an SMT solver, that has been used before
     * the now loaded proof was saved, has been skipped.
     */
    static class SkipSMTRuleException extends Exception {
        private static final long serialVersionUID = -2932282883810135168L;
    }

    /**
     * Simple structure containing the results of the replay procedure.
     *
     * @author Dominic Scheurer
     */
    static class Result {
        private String status;
        private List<Throwable> errors;
        private Goal lastSelectedGoal = null;

        public Result(String status, List<Throwable> errors,
                Goal lastSelectedGoal) {
            this.status = status;
            this.errors = errors;
            this.lastSelectedGoal = lastSelectedGoal;
        }

        public String getStatus() {
            return status;
        }

        public List<Throwable> getErrors() {
            return errors;
        }

        public Goal getLastSelectedGoal() {
            return lastSelectedGoal;
        }
    }
}
