// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2014 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//


\schemaVariables {
  \term float left, right;
}


\rules(programRules:Java){

  //primary
  //If the argument is NaN or an infinity, then the result is NaN.
  sinIsNaN {
      \schemaVar \term double arg;
      \find( sinDouble(arg) )
      \add( doubleIsNaN(arg) | doubleIsInfinite(arg) -> doubleIsNaN(sinDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  sineIsZero {
      \schemaVar \term double arg;
      \find( sinDouble(arg) )
      \add( arg = 0.0 -> sinDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  sineRange {
    \schemaVar \term double arg;
    \find( sinDouble(arg) )
    \add( sinDouble(arg) >= -1.0 & sinDouble(arg) <= 1.0 | doubleIsNaN(sinDouble(arg)) ==> )
    \heuristics(userTaclets1)
  };

  sineIsNaNAlt {
    \schemaVar \term double arg;
    \find( doubleIsNaN(sinDouble(arg)) )
    \replacewith( doubleIsNaN(arg) | doubleIsInfinite(arg) )
    \heuristics(simplify)
  };

  sineRangeAlt {
    \schemaVar \term double arg;
    \find( ==> doubleIsNaN(sinDouble(arg)) )
    \add( sinDouble(arg) >= -1.0 & sinDouble(arg) <= 1.0 ==> )
    \heuristics(userTaclets1)
  };

  //lemma
  sinIsNotNaN {
      \schemaVar \term double arg;
      \find( sinDouble(arg) )
      \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) -> !doubleIsNaN(sinDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  sinRange2 {
    \schemaVar \term double arg;
    \find( sinDouble(arg) )
    \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) -> sinDouble(arg) >= -1.0 & sinDouble(arg) <= 1.0 ==>)
    \heuristics(userTaclets1)
  };

  //lemma
  sinRange3 {
    \schemaVar \term double arg;
    \find( sinDouble(arg) )
    \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) -> mulDoubleIEEE (RNE , sinDouble(arg),sinDouble(arg)) >= 0.0 &
     mulDoubleIEEE (RNE , sinDouble(arg),sinDouble(arg)) <= 1.0 ==>)
     \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN or an infinity, then the result is NaN.
  cosIsNaN {
      \schemaVar \term double arg;
      \find( cosDouble(arg) )
      \add( doubleIsNaN(arg) | doubleIsInfinite(arg) -> doubleIsNaN(cosDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  cosRange {
     \schemaVar \term double arg;
     \find( cosDouble(arg) )
     \add( cosDouble(arg) >= 0.0 & cosDouble(arg) <= 1.0 | doubleIsNaN(cosDouble(arg)) ==> )
     \heuristics(userTaclets1)
  };

  cosIsNaNAlt {
    \schemaVar \term double arg;
    \find( doubleIsNaN(cosDouble(arg)) )
    \replacewith( doubleIsNaN(arg) | doubleIsInfinite(arg) )
    \heuristics(simplify)
  };

  cosRangeAlt {
    \schemaVar \term double arg;
    \find( ==> doubleIsNaN(cosDouble(arg)) )
    \add( cosDouble(arg) >= 0.0 & cosDouble(arg) <= 1.0 ==> )
    \heuristics(userTaclets1)
  };

  //lemma
  cosIsNotNaN {
    \schemaVar \term double arg;
    \find( cosDouble(arg) )
    \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) -> !doubleIsNaN(cosDouble(arg)) ==>)
    \heuristics(userTaclets1)
  };

  //lemma
  cosRange2 {
    \schemaVar \term double arg;
    \find( cosDouble(arg) )
    \add(!doubleIsNaN(arg) & !doubleIsInfinite(arg) -> cosDouble(arg) >= 0.0 & cosDouble(arg) <= 1.0 ==> )
    \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN or its absolute value is greater than 1, then the result is NaN.
  asinIsNaN {
      \schemaVar \term double arg;
      \find( asinDouble(arg) )
      \add( doubleIsNaN(arg) | arg <-1.0 | arg > 1.0  -> doubleIsNaN(asinDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  asineIsZero {
      \schemaVar \term double arg;
      \find( asinDouble(arg) )
      \add( arg = 0.0 -> asinDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is between -1 and 1 then the returned angle is in the range -pi/2 through pi/2
  asineRange {
      \schemaVar \term double arg;
      \find( asinDouble(arg) )
      \add(arg >=-1.0 & arg <= 1.0 -> asinDouble(arg) >= (-1.5707963267948966)& asinDouble(arg) <= (1.5707963267948966)==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN or its absolute value is greater than 1, then the result is NaN
  acosIsNaN {
      \schemaVar \term double arg;
      \find( acosDouble(arg) )
      \add( doubleIsNaN(arg) | arg <-1.0 | arg > 1.0  -> doubleIsNaN(acosDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is between -1 and 1 then the returned angle is in the range 0.0 through pi
  acosRange {
      \schemaVar \term double arg;
      \find( acosDouble(arg) )
      \add(arg >=-1.0 & arg <= 1.0 -> acosDouble(arg) >= 0.0 & acosDouble(arg) <= 3.14159265358979323846 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN or an infinity, then the result is NaN
  tanIsNaN {
      \schemaVar \term double arg;
      \find( tanDouble(arg) )
      \add( doubleIsNaN(arg) | doubleIsInfinite(arg) -> doubleIsNaN(tanDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  tanIsZero {
      \schemaVar \term double arg;
      \find( tanDouble(arg) )
      \add( arg = 0.0 -> tanDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If either argument is NaN, then the result is NaN
  atan2IsNaN{
      \schemaVar \term double arg1, arg2;
      \find( atan2Double(arg1 , arg2) )
      \add( doubleIsNaN(arg1) | doubleIsNaN(arg2) -> doubleIsNaN(atan2Double(arg1, arg2)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If neither argument is NaN, then the returned angle is in the range of -pi through pi
  atan2Range {
      \schemaVar \term double arg1, arg2;
      \find( atan2Double(arg1, arg2) )
      \add(!doubleIsNaN(arg1) & !doubleIsNaN(arg2)->  atan2Double(arg1 , arg2) >= -3.14159265358979323846 & atan2Double(arg1 , arg2) <= 3.14159265358979323846 ==>)
  };

  //primary
  //If the argument is NaN or less than zero, then the result is NaN
  sqrtIsNaN {
      \schemaVar \term double arg;
      \find( sqrtDouble(arg) )
      \add( doubleIsNaN(arg) | arg < 0.0 -> doubleIsNaN(sqrtDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive infinity, then the result is positive infinity.
  sqrtIsInfinite {
      \schemaVar \term double arg;
      \find( sqrtDouble(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0 -> doubleIsInfinite(sqrtDouble(arg)) & sqrtDouble(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive zero or negative zero, then the result is the same as the argument.
  sqrtIsZero {
      \schemaVar \term double arg;
      \find( sqrtDouble(arg) )
      \add( arg = 0.0 -> sqrtDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //proved by SMT solver
  //If the argument is not NaN and greater or equal to zero, then the result is not NaN
  sqrtIsNotNaN {
      \schemaVar \term double arg;
      \find( sqrtDouble(arg) )
      \add( !doubleIsNaN(arg) & arg >= 0.0 -> !doubleIsNaN(sqrtDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  sqrtIsSmaller {
      \schemaVar \term double arg;
      \find( sqrtDouble(arg) )
      \add( !doubleIsInfinite(arg) & arg > 1.0 -> sqrtDouble(arg) < arg ==>)
      \heuristics(userTaclets1)
    };

  //primary
  //If the second argument is positive or negative zero, then the result is 1.0.
  powIsOne {
      \schemaVar \term double arg1 , arg2;
      \find( powDouble(arg1 , arg2) )
      \add( arg2 = 0.0 -> powDouble(arg1, arg2) = 1.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the second argument is 1.0 and the first argument is not a NaN, then the result is the same as the first argument.
  powIsNotNaN {
      \schemaVar \term double arg1, arg2;
      \find( powDouble(arg1, arg2) )
      \add(!doubleIsNaN(arg1) & arg2 = 1.0 -> powDouble(arg1, arg2) = arg1  ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the second argument is NaN, then the result is NaN.
  powIsNaN1 {
      \schemaVar \term double arg1, arg2;
      \find( powDouble(arg1, arg2) )
      \add(doubleIsNaN(arg2) -> doubleIsNaN (powDouble(arg1, arg2)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the first argument is NaN and the second argument is nonzero, then the result is NaN.
  powIsNaN2 {
      \schemaVar \term double arg1, arg2;
      \find( powDouble(arg1, arg2) )
      \add(doubleIsNaN(arg1) & arg2 != 0.0 -> doubleIsNaN (powDouble(arg1, arg2)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the absolute value of the first argument is greater than 1 and the second argument is positive infinity, or
  //the absolute value of the first argument is less than 1 and the second argument is negative infinity,
  //then the result is positive infinity.
  powIsInfinite1 {
      \schemaVar \term double arg1, arg2;
      \find( powDouble(arg1, arg2) )
      \add(((arg1 >= 1.0 | arg1 <= -1.0) & doubleIsInfinite(arg2) & arg2 > 0.0) |
            (arg1 < 1.0 & arg1 > -1.0 & doubleIsInfinite(arg2) & arg2 < 0.0)
           -> doubleIsInfinite (powDouble(arg1, arg2)) & powDouble(arg1, arg2) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the absolute value of the first argument is greater than 1 and the second argument is negative infinity, or
  //the absolute value of the first argument is less than 1 and the second argument is positive infinity,
  //then the result is positive zero.
  powIsZero1 {
      \schemaVar \term double arg1, arg2;
      \find( powDouble(arg1, arg2) )
      \add(((arg1 >= 1.0 | arg1 <= -1.0) & doubleIsInfinite(arg2) & arg2 < 0.0) |
            (arg1 < 1.0 & arg1 > -1.0 & doubleIsInfinite(arg2) & arg2 > 0.0)
           -> powDouble(arg1, arg2) = 0.0 ==>)
      \heuristics(userTaclets1)           
  };

  //primary
  //If the absolute value of the first argument equals 1 and the second argument is infinite, then the result is NaN.
  powIsNaN3 {
      \schemaVar \term double arg1, arg2;
      \find( powDouble(arg1, arg2) )
      \add((arg1 >= 1.0 | arg1 <= -1.0) & doubleIsInfinite(arg2) -> doubleIsNaN (powDouble(arg1, arg2)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //the first argument is positive zero and the second argument is greater than zero, or
  //the first argument is positive infinity and the second argument is less than zero,
  //then the result is positive zero.
  powIsZero2 {
      \schemaVar \term double arg1, arg2;
      \find( powDouble(arg1, arg2) )
      \add((javaEqDouble(arg1 , 0.0) & arg2 > 0.0) | (doubleIsInfinite(arg1) & arg1 > 0.0 & arg2 < 0.0)
           -> powDouble(arg1, arg2) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //the first argument is positive zero and the second argument is less than zero, or
  //the first argument is positive infinity and the second argument is greater than zero,
  //then the result is positive infinity.
  powIsInfinite2 {
      \schemaVar \term double arg1, arg2;
      \find( powDouble(arg1, arg2) )
      \add((javaEqDouble(arg1 , 0.0) & arg2 < 0.0) | (doubleIsInfinite(arg1) & arg1 > 0.0 & arg2 > 0.0)
           -> doubleIsInfinite(powDouble(arg1, arg2)) & powDouble(arg1, arg2) > 0.0  ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN, the result is NaN.
  expIsNaN {
      \schemaVar \term double arg;
      \find( expDouble(arg) )
      \add( doubleIsNaN(arg)  -> doubleIsNaN(expDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive infinity, then the result is positive infinity.
  expIsInfinite {
      \schemaVar \term double arg;
      \find( expDouble(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0 -> doubleIsInfinite(expDouble(arg)) & expDouble(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is negative infinity, then the result is positive zero.
  expIsZero {
      \schemaVar \term double arg;
      \find( expDouble(arg) )
      \add( doubleIsInfinite(arg) & arg < 0.0 ->  expDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN, the result is NaN.
  atanIsNaN {
      \schemaVar \term double arg;
      \find( atanDouble(arg) )
      \add( doubleIsNaN(arg)  -> doubleIsNaN(atanDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  atanIsZero {
      \schemaVar \term double arg;
      \find( atanDouble(arg) )
      \add( arg = 0.0 -> atanDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is not NaN,  the returned angle is in the range -pi/2 through pi/2
  atanRange {
      \schemaVar \term double arg;
      \find( atanDouble(arg) )
      \add(!doubleIsNaN(arg) ->  atanDouble(arg) >= (-1.5707963267948966) & atanDouble(arg) <= 1.5707963267948966 ==>)
      \heuristics(userTaclets1)
  };

  //rules for "niceness" syntactic sugar
  niceFloat {
      \schemaVar \term float arg;
      \find(floatIsNice(arg))
      \replacewith( !floatIsNaN(arg) & !floatIsInfinite(arg) )
      \heuristics ( simplify )
  };

  niceDouble {
      \schemaVar \term double arg;
      \find(doubleIsNice(arg))
      \replacewith( !doubleIsNaN(arg) & !doubleIsInfinite(arg) )
      \heuristics ( simplify )
  };

  //primary
  //If the argument is NaN, the result is NaN.
  cbrtIsNaN {
      \schemaVar \term double arg;
      \find( cbrtDouble(arg) )
      \add( doubleIsNaN(arg)  -> doubleIsNaN(cbrtDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is infinite, then the result is an infinity with the same sign as the argument.
  cbrtIsPosInfinite {
      \schemaVar \term double arg;
      \find( cbrtDouble(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0 -> doubleIsInfinite(cbrtDouble(arg)) & cbrtDouble(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is infinite, then the result is an infinity with the same sign as the argument.
  cbrtIsNegInfinite {
      \schemaVar \term double arg;
      \find( cbrtDouble(arg) )
      \add( doubleIsInfinite(arg) & arg < 0.0 -> doubleIsInfinite(cbrtDouble(arg)) & cbrtDouble(arg) < 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  cbrtIsZero {
      \schemaVar \term double arg;
      \find( cbrtDouble(arg) )
      \add( arg = 0.0 -> cbrtDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  cbrtIsNotNaN {
      \schemaVar \term double arg;
      \find( cbrtDouble(arg) )
      \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) -> !doubleIsNaN(cbrtDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN, the result is NaN.
  coshIsNaN {
      \schemaVar \term double arg;
      \find( coshDouble(arg) )
      \add( doubleIsNaN(arg)  -> doubleIsNaN(coshDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is infinite, then the result is positive infinity.
  coshIsInfinite {
      \schemaVar \term double arg;
      \find( coshDouble(arg) )
      \add( doubleIsInfinite(arg)  -> doubleIsInfinite(coshDouble(arg)) & coshDouble(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is 1.0.
  coshIsOne {
        \schemaVar \term double arg;
        \find( coshDouble(arg) )
        \add( arg = 0.0 -> coshDouble(arg) = 1.0 ==>)
        \heuristics(userTaclets1)
  };

  //lemma
  coshIsNotNaN {
      \schemaVar \term double arg;
      \find( coshDouble(arg) )
      \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) -> !doubleIsNaN(coshDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN, the result is NaN.
  expm1IsNaN {
      \schemaVar \term double arg;
      \find( expm1Double(arg) )
      \add( doubleIsNaN(arg)  -> doubleIsNaN(expm1Double(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive infinity, then the result is positive infinity.
  expm1IsPosInfinite {
      \schemaVar \term double arg;
      \find( expm1Double(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0 -> doubleIsInfinite(expm1Double(arg)) & expm1Double(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is negative infinity, then the result is -1.0.
  expm1IsMinusOne {
      \schemaVar \term double arg;
      \find( expm1Double(arg) )
      \add( doubleIsInfinite(arg) & arg < 0.0 -> expm1Double(arg) = -1.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  expm1IsZero {
      \schemaVar \term double arg;
      \find( expm1Double(arg) )
      \add( arg = 0.0 -> expm1Double(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  expm1IsNotNaN {
      \schemaVar \term double arg;
      \find( expm1Double(arg) )
      \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) -> !doubleIsNaN(expm1Double(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If either argument is infinite, then the result is positive infinity.
  hypotIsInfinite{
      \schemaVar \term double arg1, arg2;
      \find( hypotDouble(arg1 , arg2) )
      \add( doubleIsInfinite(arg1) | doubleIsInfinite(arg2) -> doubleIsInfinite(hypotDouble(arg1, arg2)) & hypotDouble(arg1, arg2) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

   //primary
   //If either argument is NaN and neither argument is infinite, then the result is NaN.
   hypotIsNaN{
       \schemaVar \term double arg1, arg2;
       \find( hypotDouble(arg1 , arg2) )
       \add( (doubleIsNaN(arg1) | doubleIsNaN(arg2)) &  (!doubleIsInfinite(arg1) & !doubleIsInfinite(arg2)) -> doubleIsNaN(hypotDouble(arg1, arg2)) ==>)
       \heuristics(userTaclets1)
   };

  //lemma
  hypotIsNotNaN {
      \schemaVar \term double arg1, arg2;
      \find( hypotDouble(arg1 , arg2) )
      \add( !doubleIsNaN(arg1) & !doubleIsInfinite(arg1) & !doubleIsNaN(arg2) & !doubleIsInfinite(arg2) -> !doubleIsNaN(hypotDouble(arg1, arg2)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN or less than zero, then the result is NaN.
  logIsNaN {
      \schemaVar \term double arg;
      \find( logDouble(arg) )
      \add( doubleIsNaN(arg) | arg < 0.0  -> doubleIsNaN(logDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive infinity, then the result is positive infinity.
  logIsPosInfinite {
      \schemaVar \term double arg;
      \find( logDouble(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0 -> doubleIsInfinite(logDouble(arg)) & logDouble(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive zero or negative zero, then the result is negative infinity.
  logIsNegInfinite {
      \schemaVar \term double arg;
      \find( logDouble(arg) )
      \add( arg = 0.0 -> doubleIsInfinite(logDouble(arg)) & logDouble(arg) < 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  logIsNotNaN {
      \schemaVar \term double arg;
      \find( logDouble(arg) )
      \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) & arg > 0.0 -> !doubleIsNaN(logDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN or less than zero, then the result is NaN.
  log10IsNaN {
      \schemaVar \term double arg;
      \find( log10Double(arg) )
      \add( doubleIsNaN(arg) | arg < 0.0  -> doubleIsNaN(log10Double(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive infinity, then the result is positive infinity.
  log10IsPosInfinite {
      \schemaVar \term double arg;
      \find( log10Double(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0 -> doubleIsInfinite(log10Double(arg)) & log10Double(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive zero or negative zero, then the result is negative infinity.
  log10IsNegInfinite {
      \schemaVar \term double arg;
      \find( log10Double(arg) )
      \add( arg = 0.0 -> doubleIsInfinite(log10Double(arg)) & log10Double(arg) < 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  log10IsNotNaN {
      \schemaVar \term double arg;
      \find( log10Double(arg) )
      \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) & arg > 0.0 -> !doubleIsNaN(log10Double(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN or less than -1, then the result is NaN.
  log1pIsNaN {
      \schemaVar \term double arg;
      \find( log1pDouble(arg) )
      \add( doubleIsNaN(arg) | arg < -1.0  -> doubleIsNaN(log1pDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive infinity, then the result is positive infinity.
  log1pIsPosInfinite {
      \schemaVar \term double arg;
      \find( log1pDouble(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0 -> doubleIsInfinite(log1pDouble(arg)) & log1pDouble(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is negative one, then the result is negative infinity.
  log1pIsNegInfinite {
      \schemaVar \term double arg;
      \find( log1pDouble(arg) )
      \add( arg = -1.0 -> doubleIsInfinite(log1pDouble(arg)) & log1pDouble(arg) < 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  log1pIsZero {
      \schemaVar \term double arg;
      \find( log1pDouble(arg) )
      \add( arg = 0.0 -> log1pDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  log1pIsNotNaN {
      \schemaVar \term double arg;
      \find( log1pDouble(arg) )
      \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) & arg > -1.0 -> !doubleIsNaN(log1pDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN, then the result is NaN.
  sinhIsNaN {
      \schemaVar \term double arg;
      \find( sinhDouble(arg) )
      \add( doubleIsNaN(arg)  -> doubleIsNaN(sinhDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is infinite, then the result is an infinity with the same sign as the argument.
  sinhIsPosInfinite {
      \schemaVar \term double arg;
      \find( sinhDouble(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0  -> doubleIsInfinite(sinhDouble(arg)) & sinhDouble(arg) > 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is infinite, then the result is an infinity with the same sign as the argument.
  sinhIsNegInfinite {
      \schemaVar \term double arg;
      \find( sinhDouble(arg) )
      \add( doubleIsInfinite(arg) & arg < 0.0  -> doubleIsInfinite(sinhDouble(arg)) & sinhDouble(arg) < 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  sinhIsZero {
      \schemaVar \term double arg;
      \find( sinhDouble(arg) )
      \add( arg = 0.0 -> sinhDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  sinhIsNotNaN {
      \schemaVar \term double arg;
      \find( sinhDouble(arg) )
      \add( !doubleIsNaN(arg) & !doubleIsInfinite(arg) -> !doubleIsNaN(sinhDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is NaN, then the result is NaN.
  tanhIsNaN {
      \schemaVar \term double arg;
      \find( tanhDouble(arg) )
      \add( doubleIsNaN(arg)  -> doubleIsNaN(tanhDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is zero, then the result is a zero with the same sign as the argument.
  tanhIsZero {
      \schemaVar \term double arg;
      \find( tanhDouble(arg) )
      \add( arg = 0.0 -> tanhDouble(arg) = 0.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is positive infinity, then the result is +1.0.
  tanhIsPosOne {
      \schemaVar \term double arg;
      \find( tanhDouble(arg) )
      \add( doubleIsInfinite(arg) & arg > 0.0  ->  tanhDouble(arg) = 1.0 ==>)
      \heuristics(userTaclets1)
  };

  //primary
  //If the argument is negative infinity, then the result is -1.0.
  tanhIsNegOne {
      \schemaVar \term double arg;
      \find( tanhDouble(arg) )
      \add( doubleIsInfinite(arg) & arg < 0.0  -> tanhDouble(arg) = -1.0 ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  tanhIsNotNaN {
      \schemaVar \term double arg;
      \find( tanhDouble(arg) )
      \add( !doubleIsNaN(arg) -> !doubleIsNaN(tanhDouble(arg)) ==>)
      \heuristics(userTaclets1)
  };

  //lemma
  tanhRange {
    \schemaVar \term double arg;
    \find( tanhDouble(arg) )
    \add( tanhDouble(arg) >= -1.0 & tanhDouble(arg) <= 1.0 | doubleIsNaN(tanhDouble(arg)) ==> )
    \heuristics(userTaclets1)
  };
}
