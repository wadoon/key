

\sorts {
  dual;
  real;
  float;
}

\functions {
  dual dual_add(dual, dual);
  dual dual_fromFloat(float);
  dual dual_from(real, float);
  float dual_float(dual);
  real dual_real(dual);
  real dual_error(dual);
}

\predicates {
  dual_lessThan(dual, dual);
  dual_lessEqual(dual, dual);
  dual_incomparable(dual, dual);
  dual_point(dual);
}



\axioms {

  generated {
     \forall dual d; \exists real r; \exists float f;
       d = dual_from(r, f)
  }

  destrFloat {
     \forall float f; \forall real r; dual_float(dual_from(r, f)) = f
  };

  destrReal {
     \forall float f; \forall real r; dual_real(dual_from(r, f)) = r
  };

  extensionality {
     \forall dual d1, d2; ( dual_float(d1)=dual_float(d2) & dual_real(d1)=dual_real(d2) -> d1=d2 )
  };




  // def ext.
  fromFloatDef {
     \forall float f; dual_fromFloat(f) = dual_from((real)f, f)
  };

  // def ext.
  pointDef {
     \forall dual d; ( dual_point(d) <->  d = dual_fromFloat(dual_float(d)) )
  };

  // def ext.
  lessThanDef {
     \forall dual d1, d2; ( dual_lessThan(d1, d2) <-> rlt(dual_real(d1), dual_real(d2)) & FLOAT_LT(dual_float(d1), dual_float(d2)) )
  };

  // def ext.
  comparison {
     \forall dual d1, d2;
        ( dual_incomparable(d1, d2)
        <-> !( dual_lessThan(d1, d2)
             | dual_lessEqual(d1, d2)
             | d1 = d2
             )
        )
  };

  // def ext.
  errorDef {
     \forall dual d; ( dual_error(d) = rabs(rminus((real)dual_float(d), dual_real(d))) )
  };

  \lemma fromFloatDefFloat {
     \forall float f; dual_float(dual_fromFloat(f)) = f
  };

  \lemma fromFloatDefReal {
     \forall float f; dual_real(dual_fromFloat(f)) = (real)f
  };

  addDef {
     \forall dual d1, d2; dual_add(d1, d2) = dual_from(radd(dual_real(d1), dual_real(d2)), FLOATADD(dual_float(d1), dual_float(d2)))
  };

  // etc. for other ops

  \lemma errorPoint {
     \forall dual d; ( dual_point(d) <-> dual_error(d) = 0r )
  };

  \lemma castPoint {
     \forall dual d; ( dual_point(d) <-> (real)dual_float(d) = dual_real(d) )
  };

  // Casting float to real is injective
  castingFloatReal {
     \forall float f; NICE(f) -> (float)(real)f = f
  };




G |-  [ if a < b then x else y ] phi


G, dual_lt(a,b) |- [x]phi
G, dual_le(b,a) |- [y]phi
G, incomparable(a,b) |- false


G, dual_lt(a,b) |- [x]phi
G, dual_le(b,a) |- [y]phi
G, incomparable(a,b) |- false


local program: no heap writing. only local variables are written.




  G |- {U}<pi_r><pi_f>(conv & {J}post)
------------------------------------
  G |- <pi>_D post



Say pi writes to variables i:int and  d:dual

Duplicate all written variables in pi. Split the dual type, keep other types
   i_f : int
   d_f : float
   i_r : int
   d_r : real

U is the demultiplexing:

   { i_f := i || d_f := dual_float(d) || i_r := i || d_r := dual_real(d) }


conv makes sure that all written variables besides the duals are identical, no divergence here!

   i_f = i_r


J undoes the assignments of U (multiplexer)

   i := i_f || d := dual_from(d_f, d_r)




States are heap and variable assigments.

States are pairs of states R and F.

joins(R,F) --> make dual, choose one for other types

consistent(R,F) --> obvious.


s |= < pi >phi   <=> There is a consistent state pair s' with s' |= phi and s--pi-->s'





y <F 5, y >=R 5, error(y) < epsilon |- < x_f = x_f >< x_r = 5-x_r > {J} error(x) < epsilon