\sorts {
   java.lang.Enum \extends java.lang.Object;
   \generic E \extends java.lang.Enum;
   \generic G;
}

\functions {
   \unique E E::enumConst(int);
}

\schemaVariables {
   \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
   \program Type #ty ;
   \program SimpleExpression #se ;
   \program NonSimpleExpression #nse ;
   \program Expression #e ;
   \program Variable #v0 ;
   \program Variable #id ;
   \program Variable #a ;
   \program Statement #stm ;
 
   \variables int I ;
   \skolemTerm G ar ;
   
   \formula anon1,anon2 ;

   \formula post,inv ;

   \term E e;
   \term Heap h;
   \term int i;
}

/***
 *** Enhanced for
 ***/
\rules(programRules:Java) {

  /*enhancedfor_array {
       \find( \modality{#allmodal}{ .. for (#ty #id : #e) #stm ... }\endmodality(post) )
       \varcond(\new(#v0, int), \new(#a, \typeof(#e)), \isArray(#e))
       \replacewith( \modality{#allmodal}{ .. 
           {
              #typeof(#a) #a = #e;
              for(int #v0 = 0; #v0 < #length-reference(#a); #v0 ++) 
              { 
                 #ty #id = #a[#v0]; 
                 #stm 
              }
           } ... }\endmodality(post) )
       \displayname "enhancedfor_array"
       \heuristics(loop_expand,obsolete)
  };*/

   enhancedfor_iterable {
       \find( \modality{#allmodal}{ .. for (#ty #id : #e) #stm ... }\endmodality(post) )
       \replacewith( \modality{#allmodal}{ .. #enhancedfor-elim(for (#ty #id : #e) #stm); ... }\endmodality(post) )
       \displayname "enhancedfor"
       \heuristics(simplify_prog)
  };

 /*
  * Make the iterated expression in an enhanced for loop simple.
  */
 /*
  enhancedfor_not_simple {
	\find( \modality{#allmodal}{ .. for (#ty #id: #nse) #stm ... }\endmodality(post) )
	\varcond(\new(#v0, \typeof(#nse)))
	\replacewith( \modality{#allmodal}{ .. #typeof(#nse) #v0 = #nse; for (#ty #id: #v0) #stm ... }\endmodality(post) )
       \heuristics(simplify_prog)
  };*/
}


/***
 *** Enumerations
 ***/
\rules(programRules:Java,initialisation:disableStaticInitialisation) {

  enumConstantByIndex {
       \assumes(wellFormed(heap) ==>)
       \find( e )
       \sameUpdateLevel
       \varcond(\enumConstant(e))
       \add( e = E::enumConst(#enumconstantvalue(e)) ==> )
       \heuristics(inReachableStateImplication)
  };


/* TODO Address the connection to the ordinal field once final fields are
        treated final.
        
  enumOrdinalToIndex {
       \find( #fieldref(e, "ordinal") )
       \varcond(\isEnumType(E))
       \add(e = E::<get>(#fieldref(e, "ordinal")) ==> )
  };
*/

  enumConstantInRange {
       \assumes( wellFormed(h) ==> )
       \find( boolean::select(h, e, java.lang.Object::<created>) = TRUE ==> )
       \varcond( \isEnumType(E), \notFreeIn(I, e) )
       \add( \exists I; (e = E::enumConst(I) & 0 <= I & I < #enumcountconstants(e)) ==>)
       // TODO: heuristics
  };

  enumConstantCreated {
       \assumes( wellFormed(h) ==> )
       \find( boolean::select(h, E::enumConst(i), java.lang.Object::<created>) = TRUE )
       // \varcond( \isEnumType(E) )  // no longer needed since "E \extends Enum"
       \replacewith( 0 <= i & i < #enumcountconstants(e) )
       \heuristics(simplify)
  };

  enumConstantNull {
       \find( E::enumConst(i) = null )
       // \varcond( \isEnumType(E) )  // no longer needed since "E \extends Enum"
       \replacewith( false )
       \heuristics(simplify)
  };
  
}