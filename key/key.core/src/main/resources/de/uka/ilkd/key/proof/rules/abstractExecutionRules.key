\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
    \generic G;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    \modalOperator { diamond, diamond_transaction } #dia;
    \modalOperator { box, box_transaction } #box;
    
    \formula fml, post;
    \update upd;
    
    \variables Field f;
    \variables Object o;
    
    \program AbstractStatement #absProg;
    \program AbstractExpression #aexp;
    \program[list] Statement #slist, #slist1, #slist2;
    \program Statement #s;
    \program Expression #e, #e1, #e2;
    \program Variable #normal, #throwsExc, #exc, #returns, #result, #breaks, #continues;
    \program Variable #v, #v1;
    \program[list] Variable #vars, #vars1;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label, #label1;
    \program[list] Label #labels, #labels1;
    \program Variable #h; 

    \program SimpleExpression #se;
    \program LeftHandSide #lhs;
    \program Statement #body;
    \program Variable #x;
}

\heuristicsDecl {
    abstractExecution;
    abstrUpdPriorityRules;
    abstrUpdLowPrioRules;
    abstrUpdLowestPrioRules;
    abstr_upd_commute;
}

/* TODO (DS, 2019-11-07):
 * - we also have to consider the labeled break specification (and continue
 *   for the rules within loop scope)
 */
\rules(programRules:Java) {
    abstractExpression {
        \schemaVar \update U;
    
        \find (\modality{#allmodal}{ .. #v = #aexp; ... }\endmodality(post))
        
        \varcond(\new(#normal, boolean))
        \varcond(\new(#throwsExc, boolean))
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returns, boolean))
        \varcond(\new(#result, \typeof(#v)))
        \varcond(\new(#h, Heap))
        
        \varcond(\initializeParametricSkolemUpdate(U, #aexp))
        
        \replacewith ( 
             {   #normal:=#abstrPrecond(#aexp, "normal")
              || #throwsExc:=#abstrPrecond(#aexp, "throwsExc")
              || #h:=heap}
              (
                (  (#normal = TRUE <-> !#throwsExc = TRUE)
                 & (#excPrecondition(#aexp, #throwsExc)) 
                 & (#throwsExc = TRUE -> !#exc = null)
                 & (\forall f; \forall o;
                     (  elementOf(o,f,#getFrame(#aexp))
                      | !o=null & !boolean::select(#h,o,java.lang.Object::<created>)=TRUE
                      | any::select(heap,o,f) = any::select(#h,o,f)))) ->
                {U}{#exc:=#abstrPrecond(#aexp, "exceptionObject") ||
                    #result:=#addCast(#abstrPrecond(#aexp, "resultObject"), #v)}
                  (
                    (( #throwsExc = TRUE -> !#exc = null & #postCondAE(#aexp, "throwsExc", #returns, #result, #exc)) &
                     (!#throwsExc = TRUE -> #postCondAE(#aexp, "normal", #returns, #result, #exc)) &
                     (\forall f; \forall o;
                       (  elementOf(o,f,#getFrame(#aexp))
                        | !o=null & !boolean::select(#h,o,java.lang.Object::<created>)=TRUE
                        | any::select(heap,o,f) = any::select(#h,o,f)))) ->
                       \modality{#allmodal}{
                         ..
                         if (#throwsExc) {
                             throw #exc;
                         }

                         #v = #result;
                         ...
                       }\endmodality(post)
                  )
              )
        )
        
        \heuristics(abstractExecution, simplify_prog)
    };

    abstractExecutionNonVoid {
        // All Skolem symbols are "fresh for" the abstract program, such that
        // the same program occurring twice directly encodes the same behavior.
        \schemaVar \update U;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        // Check that we're outside a loop scope 
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        // Check that we're inside a method frame (otherwise returning makes no sense)
        \varcond(\prefixContainsElement("MethodFrame"))
        
        // Check that we're in a non-void method, extract result variable
        \varcond(\storeResultVarIn(#v))
        \varcond(\isDefined(#v))
        
        // Surrounding block labels 
        \varcond(\storeContextLabelsIn(#labels))
        // Booleans modeling breaks to those labels. Fresh for the abstract program.
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean))
        
        // Program variables for modeling irregular termination
        \varcond(\new(#normal, boolean))
        \varcond(\new(#throwsExc, boolean))
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returns, boolean))
        \varcond(\new(#result, \typeof(#v)))
        \varcond(\new(#h, Heap))

        // Parametric Skolem update initialization.
        //
        // The update receives two location sets as parameters; the first one for its
        // assignable, and the second one for its accessible locations (similar to a
        // normal update, just with sets).
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith (
             {   #normal:=#abstrPrecond(#absProg, "normal")
              || #throwsExc:=#abstrPrecond(#absProg, "throwsExc")
              || #returns:=#abstrPrecond(#absProg, "returns")
              || #h:=heap}
              (
                (  #mutualExclusionFormula3(#returns, #throwsExc, #vars)
                 & (#normal = TRUE <-> !#returns = TRUE & !#throwsExc = TRUE)
                 & #returnPrecondition(#absProg, #returns)
                 & #excPrecondition(#absProg, #throwsExc)) ->
                {U}{#exc:=#abstrPrecond(#absProg, "exceptionObject") ||
                    #result:=#addCast(#abstrPrecond(#absProg, "resultObject"), #result)}
                  (
                    ((#returns = TRUE   -> #postCondAE(#absProg, "returns", #returns, #result, #exc)) &
                     (#throwsExc = TRUE -> !#exc = null & #postCondAE(#absProg, "throwsExc", #returns, #result, #exc)) &
                     (#normal = TRUE -> #postCondAE(#absProg, "normal", #returns, #result, #exc)) &
                     (\forall f; \forall o;
                       (  elementOf(o,f,#getFrame(#absProg))
                        | !o=null & !boolean::select(#h,o,java.lang.Object::<created>)=TRUE
                        | any::select(heap,o,f) = any::select(#h,o,f)))) ->
                       \modality{#allmodal}{
                         ..
                         if (#returns) {
                             return #result;
                         }
                         if (#throwsExc) {
                             throw #exc;
                         }
                         #foreach (#v1, #label in #vars, #labels) { 
                             if (#v1) {
                                 break #label;
                             }
                         }
                         ...
                       }\endmodality(post)
                  )
              )
        )
        
        \heuristics(abstractExecution, simplify_prog)
    };
    
    abstractExecutionVoid {
        \schemaVar \update U;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        \varcond(\prefixContainsElement("MethodFrame"))
        
        \varcond(\storeResultVarIn(#v))
        \varcond(\not\isDefined(#v))
        
        \varcond(\storeContextLabelsIn(#labels))
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean))
        
        \varcond(\new(#normal, boolean))
        \varcond(\new(#throwsExc, boolean))
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returns, boolean))
        \varcond(\new(#h, Heap))
        
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {   #normal:=#abstrPrecond(#absProg, "normal")
              || #throwsExc:=#abstrPrecond(#absProg, "throwsExc")
              || #returns:=#abstrPrecond(#absProg, "returns")
              || #h:=heap
             }
              (
                (  #mutualExclusionFormula3(#returns, #throwsExc, #vars) 
                 & (#normal = TRUE <-> !#returns = TRUE & #throwsExc)
                 & #returnPrecondition(#absProg, #returns)
                 & #excPrecondition(#absProg, #throwsExc)
                ) ->
                {U}{#exc:=#abstrPrecond(#absProg, "exceptionObject")}
                  (
                    ((#returns = TRUE   -> #postCondAE(#absProg, "returns", #returns, #result, #exc)) &
                     (#throwsExc = TRUE -> !#exc = null & #postCondAE(#absProg, "throwsExc", #returns, #result, #exc)) &
                     (#normal = TRUE -> #postCondAE(#absProg, "normal", #returns, #result, #exc)) &
                     (\forall f; \forall o;
                       (  elementOf(o,f,#getFrame(#absProg))
                        | !o=null & !boolean::select(#h,o,java.lang.Object::<created>)=TRUE
                        | any::select(heap,o,f) = any::select(#h,o,f)))) ->
                       \modality{#allmodal}{
                         ..
                         if (#returns) {
                             return;
                         }
                         if (#throwsExc) {
                             throw #exc;
                         }
                         #foreach (#v1, #label in #vars, #labels) { 
                             if (#v1) {
                                 break #label;
                             }
                         }
                         ...
                       }\endmodality(post)
                  )
              )
        )

        \heuristics(abstractExecution, simplify_prog)
    };
    
    //TODO: This misses, like also the other rules, conditions for labeled breaks...
    abstractExecutionNonVoidLoopScope {
        \schemaVar \update U;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))

        \varcond(\prefixContainsElement("LoopScopeBlock"))
        \varcond(\prefixContainsElement("MethodFrame"))
        
        \varcond(\storeResultVarIn(#v))
        \varcond(\isDefined(#v))
        
        \varcond(\storeContextLabelsIn(#labels))
        \varcond(\storeContextLoopLabelsIn(#labels1))
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean \freshFor(#absProg)))
        \varcond(\instantiateVarsFresh(#vars1, #labels1, "continues", boolean \freshFor(#absProg)))
        
        \varcond(\new(#normal, boolean))
        \varcond(\new(#throwsExc, boolean))
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#returns, boolean))
        \varcond(\new(#result, \typeof(#v)))
        \varcond(\new(#breaks, boolean))
        \varcond(\new(#continues, boolean))
        \varcond(\new(#h, Heap))
        
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
 
        // Index variables for foreach loop 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {   #normal:=#abstrPrecond(#absProg, "normal")
              || #throwsExc:=#abstrPrecond(#absProg, "throwsExc")
              || #returns:=#abstrPrecond(#absProg, "returns")
              || #breaks:=#abstrPrecond(#absProg, "breaks")
              || #continues:=#abstrPrecond(#absProg, "continues")
              || #h:=heap
             }
              (
                (  #mutualExclusionFormula5(#returns, #throwsExc, #breaks, #continues, #vars) 
                 & (#normal = TRUE <-> !#returns = TRUE & !#throwsExc = TRUE & !#breaks = TRUE & !#continues = TRUE)
                 & #returnPrecondition(#absProg, #returns)
                 & #excPrecondition(#absProg, #throwsExc)
                 & #breaksPrecondition(#absProg, #breaks)
                 & #continuesPrecondition(#absProg, #continues)
                ) ->
                {U}{#exc:=#abstrPrecond(#absProg, "exceptionObject") ||
                    #result:=#addCast(#abstrPrecond(#absProg, "resultObject"), #result)}
                  (
                    ((#returns = TRUE   -> #postCondAE(#absProg, "returns", #returns, #result, #exc)) &
                     (#throwsExc = TRUE -> !#exc = null & #postCondAE(#absProg, "throwsExc", #returns, #result, #exc)) &
                     (#normal = TRUE -> #postCondAE(#absProg, "normal", #returns, #result, #exc)) &
                     (\forall f; \forall o;
                       (  elementOf(o,f,#getFrame(#absProg))
                        | !o=null & !boolean::select(#h,o,java.lang.Object::<created>)=TRUE
                        | any::select(heap,o,f) = any::select(#h,o,f)))) ->
                       \modality{#allmodal}{
                         ..
                         if (#returns) {
                             return #result;
                         }
                         if (#throwsExc) {
                             throw #exc;
                         }
                         if (#continues) {
                         continue;
                         }
                         if (#breaks) {
                         break;
                         }
                         #foreach (#v1, #label in #vars, #labels) { 
                             if (#v1) {
                                 break #label;
                             }
                         }
                         #foreach (#v1, #label1 in #vars1, #labels1) { 
                             if (#v1) {
                                 continue #label1;
                             }
                         }
                         ...
                       }\endmodality(post)
                  )
              )
        )
        
        \heuristics(abstractExecution, simplify_prog)
    };
    

    abstractExecutionNoMethod {
        \schemaVar \update U;
    
        \find (\modality{#allmodal}{ .. #absProg ... }\endmodality(post))
                
        \varcond(\not\prefixContainsElement("LoopScopeBlock"))
        \varcond(\not\prefixContainsElement("MethodFrame"))
        
        \varcond(\storeContextLabelsIn(#labels))
        \varcond(\instantiateVarsFresh(#vars, #labels, "breaks", boolean))
        
        \varcond(\new(#normal, boolean))
        \varcond(\new(#throwsExc, boolean))
        \varcond(\new(#exc, java.lang.Throwable))
        \varcond(\new(#h, Heap))
        
        \varcond(\initializeParametricSkolemUpdate(U, #absProg))
 
        \varcond(\new(#v1, boolean))
        \varcond(\newLabel(#label))
        
        \replacewith ( 
             {   #normal:=#abstrPrecond(#absProg, "normal")
              || #throwsExc:=#abstrPrecond(#absProg, "throwsExc")
              || #h:=heap
             }
              (
                (  #mutualExclusionFormula2(#throwsExc, #vars)
                 & (#normal = TRUE <-> !#throwsExc = TRUE)
                 & #excPrecondition(#absProg, #throwsExc)) ->
                {U}{#exc:=#abstrPrecond(#absProg, "exceptionObject")}
                  (
                    ((#throwsExc = TRUE -> !#exc = null & #postCondAE(#absProg, "throwsExc", #returns, #result, #exc)) &
                     (#normal = TRUE -> #postCondAE(#absProg, "normal", #returns, #result, #exc)) &
                     (\forall f; \forall o;
                       (  elementOf(o,f,#getFrame(#absProg))
                        | !o=null & !boolean::select(#h,o,java.lang.Object::<created>)=TRUE
                        | any::select(heap,o,f) = any::select(#h,o,f)))) ->
                       \modality{#allmodal}{
                         ..
                         if (#throwsExc) {
                             throw #exc;
                         }
                         #foreach (#v1, #label in #vars, #labels) { 
                             if (#v1) {
                                 break #label;
                             }
                         }
                         ...
                       }\endmodality(post)
                  )
              )
        )

        \heuristics(abstractExecution, simplify_prog)
    };
}
