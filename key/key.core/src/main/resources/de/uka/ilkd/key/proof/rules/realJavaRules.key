// This file is part of KeY - Integrated Deductive Software Design
//
// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
// Copyright (C) 2011-2014 Karlsruhe Institute of Technology, Germany
//                         Technical University Darmstadt, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General
// Public License. See LICENSE.TXT for details.
//

//
// A collection of symbolice execution rules for the \real JML datatype
// Rules for implicit casts are currently not implemented.
//
// Author: Mattias Ulbrich 2022
//

\schemaVariables {
  \modalOperator { diamond, box, diamond_transaction, box_transaction } #normalassign;
  \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;

  \program JavaRealExpression #seReal, #seReal0, #seReal1 ;

  \program SimpleExpression #se;

  \program Variable #loc ;
  \program LeftHandSide #lhs;

  \program Variable #v;

  \program NonSimpleExpression #nse;

  \formula post;

  \term real r1, r2;
}



\rules(programRules:Java) {

  less_than_comparison_real {
    \find ( \modality{#allmodal}{.. #lhs = #seReal0 < #seReal1; ...}\endmodality(post))
    \replacewith( {#lhs := \if(rlt(#seReal0,#seReal1)) \then (TRUE) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
  };

  less_equal_than_comparison_real {
    \find ( \modality{#allmodal}{.. #lhs = #seReal0 <= #seReal1; ...}\endmodality(post))
    \replacewith( {#lhs := \if (rle(#seReal0,#seReal1)) \then (TRUE) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
  };

  greater_than_comparison_real {
    \find ( \modality{#allmodal}{.. #lhs = #seReal0 > #seReal1; ...}\endmodality(post))
    \replacewith ( {#lhs := \if (rgt(#seReal0,#seReal1)) \then (TRUE) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
  };

  greater_equal_than_comparison_real {
    \find ( \modality{#allmodal}{.. #lhs = #seReal0 >= #seReal1; ...}\endmodality(post))
    \replacewith ({#lhs := \if(rge(#seReal0,#seReal1)) \then (TRUE) \else (FALSE)}
		\modality{#allmodal}{.. ...}\endmodality(post))
    \heuristics(simplify_prog)
  };

  //------------- unary minus for reals

  unary_minus_real {
     \find (\modality{#normalassign}{.. #loc = - #seReal; ...}\endmodality(post))
     \replacewith({ #loc := rneg(#seReal) }
                      \modality{#normalassign}{..  ...}\endmodality(post))
    \heuristics(simplify_prog)
  };


  //------------- Arithmetic operations with strictfp

  add_real_java  {
     \find(\modality{#normalassign}{.. #loc = #seReal0 + #seReal1; ...}\endmodality(post))
     \replacewith(
         {#loc := radd(#seReal0, #seReal1)}
             \modality{#normalassign}{.. ...}\endmodality(post))
     \heuristics(simplify_prog)
  };

  sub_real_java  {
     \find(\modality{#normalassign}{.. #loc = #seReal0 - #seReal1; ...}\endmodality(post))
     \replacewith(
         {#loc := rsub(#seReal0, #seReal1)}
             \modality{#normalassign}{.. ...}\endmodality(post))
     \heuristics(simplify_prog)
  };

  mul_real_java  {
     \find(\modality{#normalassign}{.. #loc = #seReal0 * #seReal1; ...}\endmodality(post))
     \replacewith(
         {#loc := rmul(#seReal0, #seReal1)}
             \modality{#normalassign}{.. ...}\endmodality(post))
  };

  div_real_java  {
     \find(\modality{#normalassign}{.. #loc = #seReal0 / #seReal1; ...}\endmodality(post))
     \replacewith(
         {#loc := rdiv(#seReal0, #seReal1)}
             \modality{#normalassign}{.. ...}\endmodality(post))
     \heuristics(simplify_prog)
  };

  // ... There are for now no rules that would require an implicit casts.
  // ... Just make these casts explicit in the specifications for the moment.


  // Typecasts

  cast_to_real {
     \find (\modality{#normalassign}{.. #loc = (\real) #se; ...}\endmodality(post))
     \replacewith ( { #loc := (real)#se }
          \modality{#normalassign}{..  ...}\endmodality(post))
     \heuristics(simplify_prog)
  };

  // Non-simple casts

  compound_real_cast_expression {
     \find (\modality{#normalassign}{.. #loc = (\real) #nse; ...}\endmodality(post))
     \varcond (\newTypeOf(#v, #nse))
     \replacewith (\modality{#normalassign}{.. #typeof(#nse) #v = #nse; #loc = (\real) #v;  ...}\endmodality(post))
     \heuristics (simplify_prog)
  };

}
