<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>

    <comment>These are the preamble snippets needed for handling floating point numbers</comment>

    <entry key="float.axioms">
        (assert (forall ((f Float32)) (= (u2f (f2u f)) f)))
        (assert (forall ((x U)) (=> (= (typeof x) sort_float) (= (f2u (u2f x)) x))))
        (assert (forall ((x U)) (=> (instanceof x sort_float) (= (typeof x ) sort_float))))
        (assert (forall ((f Float32)) (= (typeof (f2u f)) sort_float)))

        (assert (forall ((d Float64)) (= (u2d (d2u d)) d)))
        (assert (forall ((x U)) (=> (= (typeof x) sort_double) (= (d2u (u2d x)) x))))
        (assert (forall ((x U)) (=> (instanceof x sort_double) (= (typeof x ) sort_double))))
        (assert (forall ((d Float64)) (= (typeof (d2u d)) sort_double)))
    </entry>

    <entry key="float.decls">
        (declare-fun u2f (U) Float32)
        (declare-fun f2u (Float32) U)
        (declare-const sort_float T)

        (declare-fun u2d (U) Float64)
        (declare-fun d2u (Float64) U)
        (declare-const sort_double T)
    </entry>

    <entry key="sinDouble.axioms">
        <!-- TODO this is not mentioned in the documentation.-->
<!--        (assert (forall ((a Float64)) (=> (and (not (fp.isNaN a)) (not (fp.isInfinite a))) (and (fp.leq (sinDouble a) (fp #b0 #b01111111111-->
<!--        #b0000000000000000000000000000000000000000000000000000))(fp.geq (sinDouble a) (fp #b1 #b01111111111-->
<!--        #b0000000000000000000000000000000000000000000000000000))))))-->

        <!-- If the argument is NaN or an infinity, then the result is NaN.-->
        (assert (forall ((a Float64)) (=> (or (fp.isNaN a)(fp.isInfinite a)) (fp.isNaN (sinDouble a)))))

        <!-- If the argument is zero, then the result is a zero with the same sign as the argument.-->
        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (sinDouble a) (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))
        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (sinDouble a) (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))

    </entry>

    <entry key="sinDouble.decls">
        (declare-fun sinDouble (Float64) Float64)
    </entry>

    <entry key="cosDouble.axioms">
        <!-- TODO this is not mentioned in the documentation.-->
<!--        (assert (forall ((a Float64)) (=> (and (not (fp.isNaN a)) (not (fp.isInfinite a))) (and (fp.leq (cosDouble a) (fp #b0 #b01111111111-->
<!--        #b0000000000000000000000000000000000000000000000000000))(fp.geq (cosDouble a) (fp #b1 #b01111111111-->
<!--        #b0000000000000000000000000000000000000000000000000000))))))-->

        <!-- If the argument is NaN or an infinity, then the result is NaN -->
        (assert (forall ((a Float64)) (=> (or (fp.isNaN a)(fp.isInfinite a)) (fp.isNaN (cosDouble a)))))

        <!-- TODO this is not mentioned in the documentation. -->
<!--        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b0 #b00000000000-->
<!--        #b0000000000000000000000000000000000000000000000000000))(fp.eq (cosDouble a) (fp #b0 #b01111111111-->
<!--        #b0000000000000000000000000000000000000000000000000000)))))-->
    </entry>

    <entry key="cosDouble.decls">
        (declare-fun cosDouble (Float64) Float64)
    </entry>

    <entry key="asinDouble.axioms">
        <!--  If the argument is NaN or its absolute value is greater than 1, then the result is NaN-->
        (assert (forall ((a Float64)) (=> (or (fp.isNaN a)(fp.gt a (fp #b0 #b01111111111
        #b0000000000000000000000000000000000000000000000000000)) (fp.lt a (fp #b1 #b01111111111
        #b0000000000000000000000000000000000000000000000000000))) (fp.isNaN (asinDouble a)))))

        <!-- If the argument is zero, then the result is a zero with the same sign as the argument-->
        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (asinDouble a) (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))
        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (asinDouble a) (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))

        <!-- The returned angle is in the range -pi/2 through pi/2-->
        (assert (forall ((a Float64)) (=> (and (not (fp.isNaN a)) (fp.geq a (fp #b1 #b01111111111
        #b0000000000000000000000000000000000000000000000000000)) (fp.leq a (fp #b0 #b01111111111
        #b0000000000000000000000000000000000000000000000000000)))(and (fp.geq (asinDouble a) (fp #b1 #b01111111111
        #b1001001000011111101101010100010001000010110100011000))(fp.leq (asinDouble a) (fp #b0 #b01111111111
        #b1001001000011111101101010100010001000010110100011000))))))
    </entry>

    <entry key="asinDouble.decls">
        (declare-fun asinDouble (Float64) Float64)
    </entry>

    <entry key="acosDouble.axioms">
        <!-- If the argument is NaN or its absolute value is greater than 1, then the result is NaN-->
        (assert (forall ((a Float64)) (=> (or (fp.isNaN a)(fp.gt a (fp #b0 #b01111111111
        #b0000000000000000000000000000000000000000000000000000)) (fp.lt a (fp #b1 #b01111111111
        #b0000000000000000000000000000000000000000000000000000))) (fp.isNaN (acosDouble a)))))

        <!-- The returned angle is in the range 0.0 through pi-->
        (assert (forall ((a Float64)) (=> (and (not (fp.isNaN a)) (fp.geq a (fp #b1 #b01111111111
        #b0000000000000000000000000000000000000000000000000000)) (fp.leq a (fp #b0 #b01111111111
        #b0000000000000000000000000000000000000000000000000000)))(and (fp.geq (acosDouble a) (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.leq (acosDouble a) (fp #b0 #b10000000000
        #b1001001000011111101101010100010001000010110100011000))))))
    </entry>

    <entry key="acosDouble.decls">
        (declare-fun acosDouble (Float64) Float64)
    </entry>

    <entry key="tanDouble.axioms">
        <!-- If the argument is NaN or an infinity, then the result is NaN-->
        (assert (forall ((a Float64)) (=> (or (fp.isNaN a) (fp.isInfinite a)) (fp.isNaN (tanDouble a)))))

        <!-- If the argument is zero, then the result is a zero with the same sign as the argument-->
        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (tanDouble a) (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))
        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (tanDouble a) (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))
    </entry>
    <entry key="tanDouble.decls">
        (declare-fun tanDouble (Float64) Float64)
    </entry>

    <!--TODO implemented the rest if needed-->
    <entry key="atan2Double.axioms">
        <!-- If either argument is NaN, then the result is NaN-->
        (assert (forall ((a Float64)(b Float64)) (=> (or (fp.isNaN a) (fp.isNaN b)) (fp.isNaN (atan2Double a b)))))

        <!-- This method computes the phase theta by computing an arc tangent of y/x in the range of -pi to pi-->
        (assert (forall ((a Float64)(b Float64)) (=> (and (not(fp.isNaN a))(not(fp.isNaN b))) (and (fp.gt (atan2Double a
        b) (fp #b1 #b10000000000
        #b1001001000011111101101010100010001000010110100011000))(fp.leq (atan2Double a b) (fp #b0 #b10000000000
        #b1001001000011111101101010100010001000010110100011000))))))
    </entry>

    <entry key="atan2Double.decls">
        (declare-fun atan2Double (Float64 Float64) Float64)
    </entry>

    <entry key="sqrtDouble.axioms">
        <!-- If the argument is NaN or less than zero, then the result is NaN-->
        (assert (forall ((a Float64)) (=> (or (fp.isNaN a) (fp.lt a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))(fp.isNaN (sqrtDouble a)))))

        <!-- If the argument is positive infinity, then the result is positive infinity-->
        (assert (forall ((a Float64)) (=> (and (fp.isInfinite a) (fp.gt a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))(and (fp.isInfinite (sqrtDouble a))(fp.gt (sqrtDouble
        a) (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))))))

        <!-- If the argument is positive zero or negative zero, then the result is the same as the argument-->
        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (sqrtDouble a) (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))
        (assert (forall ((a Float64)) (=> (fp.eq a (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (sqrtDouble a) (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))

        <!-- (! isInfinite(a)) ==> ! isInfinite(sqrt(a))-> proved by a smt solver -->
        (assert (forall ((a Float64)) (=> (not (fp.isInfinite a)) (not (fp.isInfinite (sqrtDouble a))))))

        <!-- (a != oo) && ( a > 1) ==> sqrt(a) < a -> proved by a smt solver -->
        (assert (forall ((a Float64)) (=> (and (not (fp.isInfinite a)) (fp.gt a (fp #b0 #b01111111111
        #b0000000000000000000000000000000000000000000000000000)))(fp.lt (sqrtDouble a) a))))

        <!-- (! isNaN(a) && a >= 0 ) ==> ! isNaN(sqrt(a)) -> proved by a smt solver -->
        (assert (forall ((a Float64)) (=> (and (not (fp.isNaN a)) (fp.geq a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))(not (fp.isNaN (sqrtDouble a))))))

    </entry>

    <entry key="sqrtDouble.decls">
        (declare-fun sqrtDouble (Float64) Float64)
    </entry>

    <!--TODO implemented the rest if needed-->
    <entry key="powDouble.axioms">
        <!-- If the second argument is positive or negative zero, then the result is 1.0.-->
        (assert (forall ((a Float64)(b Float64)) (=> (or (fp.eq b (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)) (fp.eq b (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))) (fp.eq (powDouble a b) (fp #b0 #b01111111111
        #b0000000000000000000000000000000000000000000000000000)))))

        <!-- If the second argument is 1.0, then the result is the same as the first argument. TODO: this is always false! why?-->
<!--        (assert (forall ((a Float64)(b Float64)) (=> (fp.eq b (fp #b0 #b01111111111
        #b0000000000000000000000000000000000000000000000000000))(fp.eq (powDouble a b) a))))-->

        <!-- If the second argument is NaN, then the result is NaN.-->
        (assert (forall ((a Float64)(b Float64)) (=> (fp.isNaN b) (fp.isNaN (powDouble a b)))))

        <!-- If the first argument is NaN and the second argument is nonzero, then the result is NaN.-->
        (assert (forall ((a Float64)(b Float64)) (=> (and (fp.isNaN a) (not (or (fp.eq b (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)) (fp.eq b (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))))) (fp.isNaN (powDouble a b)))))

        <!-- If the first argument is positive zero and the second argument is greater than zero, or
         the first argument is positive infinity and the second argument is less than zero,
         then the result is positive zero.-->
        (assert (forall ((a Float64)(b Float64)) (=> (or (and (fp.eq a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)) (fp.gt b (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))(and (and (fp.isInfinite a)(fp.gt a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))) (fp.lt b (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))) (fp.eq (powDouble a b) (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))

        <!-- If the first argument is positive zero and the second argument is less than zero, or
         the first argument is positive infinity and the second argument is greater than zero,
         then the result is positive infinity.-->
        (assert (forall ((a Float64)(b Float64)) (=> (or (and (fp.eq a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)) (fp.lt b (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))(and (and (fp.isInfinite a)(fp.gt a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))) (fp.gt b (fp #b1 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))) (and (fp.isInfinite (powDouble a b))(fp.gt (powDouble a b)(fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))))))

    </entry>

    <entry key="powDouble.decls">
        (declare-fun powDouble (Float64 Float64) Float64)
    </entry>

    <!--TODO implement the ones for -0.0 if needed-->
    <entry key="expDouble.axioms">
        <!-- If the argument is NaN, the result is NaN.-->
        (assert (forall ((a Float64)) (=> (fp.isNaN a) (fp.isNaN (expDouble a)))))

        <!-- If the argument is positive infinity, then the result is positive infinity-->
        (assert (forall ((a Float64)) (=> (and (fp.isInfinite a) (fp.gt a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))) (and (fp.isInfinite (expDouble a)(gt (expDouble a) (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000) ))))))

        <!-- If the argument is negative infinity, then the result is positive zero.-->
        (assert (forall ((a Float64)) (=> (and (fp.isInfinite a) (fp.lt a (fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000))) (fp.eq (expDouble a)(fp #b0 #b00000000000
        #b0000000000000000000000000000000000000000000000000000)))))

        <!-- TODO prove and add again -->
        <!-- (assert (forall ((a Float64)) (=> (not (fp.isNaN a)) (not(fp.isNaN (expDouble a)))))) -->
    </entry>
    <entry key="expDouble.decls">
        (declare-fun expDouble (Float64) Float64)
    </entry>

</properties>

