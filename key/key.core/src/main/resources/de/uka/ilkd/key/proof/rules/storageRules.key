\sorts{
	\generic G;
	\generic H;

	\generic alpha \extends any;
	\generic beta \extends any;
}

\rules(programRules:Solidity) {
	///////////////////// Sequences //////////////////////
	removeSingletonSeq {
		\schemaVar \term Field f;
		\find( seqRemove(seqSingleton(f), 0) )
		\replacewith( seqEmpty )
		\displayname "remove singleton seq"
		\heuristics(simplify)
	};
	
	removeFirstElementSeq {
		\schemaVar \term Field f;
		\schemaVar \term Seq seq1, seq2;
		\find( seqRemove(seqConcat(seq1, seq2), 0) )
		\replacewith( seq2 )
		\displayname "remove first element seq"
		\heuristics(simplify)
	};
	
	///////////////////// Writes /////////////////////////
	writeStructEmptyPath {
		\schemaVar \term any x, x0;
		\find( write(x, seqEmpty, x0) )
		\replacewith( x0 )
		\displayname "write struct empty path"
		\heuristics(simplify)
	};
	
	writeArray {
		\schemaVar \term int i;
		\schemaVar \term Seq array, rest;
		\schemaVar \term any x;
		\find( write(array, seqConcat(seqSingleton(arr(i)), rest), x) )
		\replacewith ( seqReplace(array, i, write(any::seqGet(array, i), rest, x)) )
		\displayname "write array"
		\heuristics(simplify)
	};
	
	writeArraySingletonPath {
		\schemaVar \term int i;
		\schemaVar \term Seq array;
		\schemaVar \term any x;
		\find( write(array, seqSingleton(arr(i)), x) )
		\replacewith( seqReplace(array, i, x) )
		\displayname "write array"
		\heuristics(simplify)
	};
	
	//////////////////////// Reads /////////////////////////
	
	readStructEmptyPath1 {
		\schemaVar \term beta x;
		\find ( alpha::read(x, seqEmpty) )
		\varcond ( \not \same(beta, Struct) )
		\replacewith ( (alpha)x )
		\displayname "read struct empty path"
		\heuristics(simplify)
	};
	
	readStructEmptyPath2 {
		// If 'x' is a struct, 'alpha' will be a concrete program struct type.
		// However, in SolidiKeY, all program structs are modelled as type "Struct"
		\schemaVar \term Struct x;
		\find ( alpha::read(x, seqEmpty) )
		\replacewith ( (Struct)x )
		\displayname "read struct empty path"
		\heuristics(simplify)
	};
	
	readOfWriteStruct {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field head, head0;
		\schemaVar \term Seq rest, rest0;
		\find( beta::read(write(s, seqConcat(seqSingleton(head), rest), x), seqConcat(seqSingleton(head0), rest0)) )
		\replacewith( \if (head = head0)
		              \then ( beta::read(write(s, rest, x), rest0) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head0), rest0))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructCast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field head, head0;
		\schemaVar \term Seq rest, rest0;
		\find( beta::read((Struct)(write(s, seqConcat(seqSingleton(head), rest), x)), seqConcat(seqSingleton(head0), rest0)) )
		\replacewith( \if (head = head0)
		              \then ( beta::read(write(s, rest, x), rest0) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head0), rest0))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath1 {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read(write(s, seqSingleton(f), x), seqConcat(seqSingleton(head), rest)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, seqEmpty, x), rest) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head), rest))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath1Cast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read((Struct)(write(s, seqSingleton(f), x)), seqConcat(seqSingleton(head), rest)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, seqEmpty, x), rest) )
					  \else ( beta::read(s, seqConcat(seqSingleton(head), rest))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath2 {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read(write(s, seqConcat(seqSingleton(head), rest), x), seqSingleton(f)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, rest, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPath2Cast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, head;
		\schemaVar \term Seq rest;
		\find( beta::read((Struct)(write(s, seqConcat(seqSingleton(head), rest), x)), seqSingleton(f)) )
		\replacewith( \if (f = head)
		              \then ( beta::read(write(s, rest, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f))) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPaths {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, f0;
		\find( beta::read(write(s, seqSingleton(f), x), seqSingleton(f0)) )
		\replacewith( \if (f = f0)
		              \then ( beta::read(write(s, seqEmpty, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f0)) ) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readOfWriteStructSingletonPathsCast {
		\schemaVar \term Struct s;
		\schemaVar \term alpha x;
		\schemaVar \term Field f, f0;
		\find( beta::read((Struct)(write(s, seqSingleton(f), x)), seqSingleton(f0)) )
		\replacewith( \if (f = f0)
		              \then ( beta::read(write(s, seqEmpty, x), seqEmpty) )
					  \else ( beta::read(s, seqSingleton(f0)) ) )
		\displayname "read of write struct"
		\heuristics(simplify)
	};
	
	readArray {
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field head;
		\schemaVar \term Seq array, rest;
		\find( beta::read(array, seqConcat(seqSingleton(arr(i)), rest)) )
		\replacewith ( beta::read(any::seqGet(array, i), rest) )
		\displayname "read array"
		\heuristics(simplify)
	};
	
	readArraySingletonPath {
		\schemaVar \term Struct s;
		\schemaVar \term int i;
		\schemaVar \term alpha x;
		\schemaVar \term Field head;
		\schemaVar \term Seq array;
		\find( beta::read(array, seqSingleton(arr(i))) )
		\replacewith ( beta::read(any::seqGet(array, i), seqEmpty) )
		\displayname "read array"
		\heuristics(simplify)
	};
	
	////////////////////// Storage <=> self rules ///////////////////////
	/*
	// Uncomment it, it says "self not defined"
	selfToStorage {
		\schemaVar \term Heap h;
		\schemaVar \term Field f;
		\find( beta::select(h, self, f) ) // comes from a term like "self.f"
		\replacewith( beta::read(storage, seqSingleton(f)) )
		\displayname "self to storage"
		\heuristics(simplify)
	};
	*/
	//////////////////////// Assignments ///////////////////////////
	
	assignField {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #a, #v;
		\schemaVar \program Expression #e;
		\find ( ==> \modality{#allmodal}{ .. this.#a = #e; ... }\endmodality(post))
		\varcond ( \new(#v, \seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v; #v += this.#a; #v = #e; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign field"
	};
	
	unfoldFieldAssignment {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #a, #v;
		\schemaVar \program Expression #e;
		\schemaVar \program NonSimpleExpression #nse;
		\find ( ==> \modality{#allmodal}{ .. #nse.#a = #e; ... }\endmodality(post))
		\varcond ( \isStorage(#nse), \new(#v, \seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v; #v += #nse.#a; #v = #e; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	unfoldArrayAssignment {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v;
		\schemaVar \program Expression #e, #e0;
		\schemaVar \program NonSimpleExpression #nse;
		\find ( ==> \modality{#allmodal}{ .. #nse[#e] = #e0; ... }\endmodality(post))
		\varcond ( \new(#v, \seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v; #v += #nse[#e]; #v = #e0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	appendSeq1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #a, #v;

		\find ( ==> \modality{#allmodal}{ .. #v += this.#a; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq))
		\replacewith ( ==> { #v := seqConcat(seqSingleton(#memberPVToField(#a)), #v) } 
		                     \modality{#allmodal}{ .. ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "append seq"
	};
	
	appendSeq2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #a, #v;
		\schemaVar \program NonSimpleExpression #nse;

		\find ( ==> \modality{#allmodal}{ .. #v += #nse.#a; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq), \isStorage(#nse) )
		\replacewith ( ==> { #v := seqConcat(seqSingleton(#memberPVToField(#a)), #v) } 
		                     \modality{#allmodal}{ .. #v += #nse; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "append seq"
	};
	
	appendSeq3 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program JavaIntExpression #seInt;

		\find ( ==> \modality{#allmodal}{ .. #v += #nse[#seInt]; ... }\endmodality(post))
		\varcond(\same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq), \isStorage(#nse) )
		\replacewith ( ==> { #v := seqConcat(seqSingleton(arr(#seInt)), #v) } 
		                     \modality{#allmodal}{ .. #v += #nse; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "append seq"
	};
	
	appendSeq4 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;
		\find ( ==> \modality{#allmodal}{ .. #v += #nse[#v0]; ... }\endmodality(post))
		\varcond( \same(\typeof(#v), Seq), \same(\typeof(#v0), Seq), \not \same(\typeof(#nse), Seq), \isStorage(#nse) )
		\replacewith ( ==> { #v := seqConcat(seqSingleton(arr(int::read(storage, #v0))), #v) } 
		                     \modality{#allmodal}{ .. #v += #nse; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "append seq"
	};
	
	appendSeq5 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program NonSimpleExpression #nse, #nse0;

		\find ( ==> \modality{#allmodal}{ .. #v += #nse[#nse0]; ... }\endmodality(post))
		\varcond( \new(#v0, \typeof(#nse0)), \same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq), \isStorage(#nse), \not \same(\typeof(#nse0), Seq), \not \isStorage(#nse0) )
		\replacewith ( ==> \modality{#allmodal}{ .. #typeof(#nse0) #v0 = #nse0; #v += #nse[#v0]; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	appendSeq6 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0, #a;
		\schemaVar \program NonSimpleExpression #nse, #nse0;
		\find ( ==> \modality{#allmodal}{ .. #v += #nse[this.#a]; ... }\endmodality(post))
		\varcond( \new(#v0, \seq), \same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq), \isStorage(#nse) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0; #v0 += this.#a; #v += #nse[#v0]; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	appendSeq7 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0, #a;
		\schemaVar \program NonSimpleExpression #nse, #nse0;
		\find ( ==> \modality{#allmodal}{ .. #v += #nse[#nse0.#a]; ... }\endmodality(post))
		\varcond( \new(#v0, \seq), \same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq), \isStorage(#nse), \not \same(\typeof(#nse0), Seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0; #v0 += #nse0.#a; #v += #nse[#v0]; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	appendSeq8 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0, #a;
		\schemaVar \program NonSimpleExpression #nse, #nse0;
		\schemaVar \program Expression #e;
		\find ( ==> \modality{#allmodal}{ .. #v += #nse[#nse0[#e]]; ... }\endmodality(post))
		\varcond( \new(#v0, \seq), \same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq), \isStorage(#nse), \not \same(\typeof(#nse0), Seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0; #v0 += #nse0[#e]; #v += #nse[#v0]; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	assignSeq1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v;
		\schemaVar \program SimpleExpression #se;
		\find ( ==> \modality{#allmodal}{ .. #v = #se; ... }\endmodality(post))
		\varcond ( \same(\typeof(#v), Seq), \not \same(\typeof(#se), Seq), \not \isStorage(#se) )
		\replacewith ( ==> { storage := (Struct)write(storage, #v, #se) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;
		\find ( ==> \modality{#allmodal}{ .. #v = #nse; ... }\endmodality(post))
		\varcond ( \same(\typeof(#v), Seq), \not \same(\typeof(#nse), Seq), \not \isStorage(#nse) )
		\replacewith ( ==> \modality{#allmodal}{ .. #typeof(#nse) #v0 = #nse; #v = #v0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold"
	};
	
	assignSeq3 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #a;
		\find ( ==> \modality{#allmodal}{ .. #v = this.#a; ... }\endmodality(post))
		\varcond ( \same(\typeof(#v), Seq), \hasSort(#a, G) )
		\replacewith ( ==> { storage := (Struct)write(storage, #v, G::read(storage, seqSingleton(#memberPVToField(#a)))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq4 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0, #a;
		\schemaVar \program NonSimpleExpression #nse;
		\find ( ==> \modality{#allmodal}{ .. #v = #nse.#a; ... }\endmodality(post))
		\varcond ( \same(\typeof(#v), Seq), \isStorage(#nse), \new(#v0, \seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0; #v0 += #nse.#a; #v = (#typeof(#a))#v0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq5 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e;
		\find ( ==> \modality{#allmodal}{ .. #v = #nse[#e]; ... }\endmodality(post))
		\varcond ( \same(\typeof(#v), Seq), \isStorage(#nse), \new(#v0, \seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0; #v0 += #nse[#e]; #v = (#typeof(#nse[#e]))#v0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignSeq6 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program Type #t;
		\find ( ==> \modality{#allmodal}{ .. #v = (#t)#v0; ... }\endmodality(post))
		\varcond ( \same(\typeof(#v), Seq), \same(\typeof(#v0), Seq), \hasSort(#t, G) )
		\replacewith ( ==> { storage := (Struct)write(storage, #v, G::read(storage, #v0)) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign seq"
	};
	
	assignLocalVarFromStorage1 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #a;
		\find ( ==> \modality{#allmodal}{ .. #v = this.#a; ... }\endmodality(post))
		\varcond ( \not \same(\typeof(#v), Seq), \not \isStorage(#v), \hasSort(#a, G) )
		\replacewith ( ==> { #v := G::read(storage, seqSingleton(#memberPVToField(#a))) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign"
	};
	
	assignLocalVarFromStorage2 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0, #a;
		\schemaVar \program NonSimpleExpression #nse;
		\find ( ==> \modality{#allmodal}{ .. #v = #nse.#a; ... }\endmodality(post))
		\varcond ( \not \same(\typeof(#v), Seq), \not \isStorage(#v), \new(#v0, \seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0; #v0 += #nse.#a; #v = (#typeof(#a))#v0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign"
	};
	
	assignLocalVarFromStorage3 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e;
		\find ( ==> \modality{#allmodal}{ .. #v = #nse[#e]; ... }\endmodality(post))
		\varcond ( \not \same(\typeof(#v), Seq), \not \isStorage(#v), \new(#v0, \seq) )
		\replacewith ( ==> \modality{#allmodal}{ .. \seq #v0; #v0 += #nse[#e]; #v = (#typeof(#nse[#e]))#v0; ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign"
	};
	
	assignLocalVarFromStorage4 {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;
		\schemaVar \program Variable #v, #v0;
		\schemaVar \program Type #t;
		\find ( ==> \modality{#allmodal}{ .. #v = (#t)#v0; ... }\endmodality(post))
		\varcond ( \not \same(\typeof(#v), Seq), \not \isStorage(#v), \same(\typeof(#v0), Seq), \hasSort(#t, G) )
		\replacewith ( ==> { #v := G::read(storage, #v0) }
							\modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assign"
	};
	
	unfoldStorageDeclaration {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program VariableInitializer #vi;

		\schemaVar \program Type #tr;
		\schemaVar \program SimpleExpression #se;

		\find ( ==> \modality{#allmodal}{ .. final #tr #v = #vi; ... }\endmodality(post))
		\varcond( \isStorage(#vi) )
		\replacewith ( ==> \modality{#allmodal}{ .. final #tr #v; #v = #vi; ... }\endmodality(post) )
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "unfold storage declaration"
	};

	eliminateVarStorageDeclaration {
		\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
		\schemaVar \formula post;

		\schemaVar \program Variable #v;
		\schemaVar \program Type #tr;

		\find ( ==> \modality{#allmodal}{ .. final #tr #v; ... }\endmodality(post))

		\replacewith ( ==> \modality{#allmodal}{ ..  ... }\endmodality(post) )
		\addprogvars(#v)
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "storage var declaration"
	};
}