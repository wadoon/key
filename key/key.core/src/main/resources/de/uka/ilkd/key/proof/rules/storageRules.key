\sorts{
	\generic alpha \extends any;
}

\schemaVariables {
	\formula post;
	
	\modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
	
	\program JavaIntExpression #i;
	\program SimpleExpression #se, #se0;
	\program Variable #v, #v0, #a, #a0, #this, #f, #f0;
	
	\term alpha x;
	\term Field f, f0;
	\term Heap heap;
	\term Object o, o0;
	\term Path path;
	\program Variable stg;
	\term Struct struct;
}

\rules(programRules:Solidity) {
	readEmptyStruct {
		\find(alpha::readStruct(emptyStruct, f))
		\replacewith ( alpha::defaultValue )
	};
	
	readOfWriteStruct {
		\find(alpha::readStruct(writeStruct(struct, f, x), f0))
		\replacewith( \if (f = f0) \then (x) \else (alpha::readStruct(struct, f0)) )
	};
	
	readEmptyStorage {
		\find(alpha::readField(emptyStg, f))
		\replacewith ( alpha::defaultValue )
	};
	
	readOfWriteStorage {
		\find(alpha::readField(writeField(stg, f, x), f0))
		\replacewith( \if (f = f0) \then (x) \else (alpha::readField(stg, f0)) )
	};
	
	selectStructToMem {
		\find(alpha::select(struct2Mem(heap, o, struct), o0, f))
		\replacewith( \if (o = o0) \then (alpha::readStruct(struct, f)) \else (alpha::select(heap, o0, f)))
	};



	/*
	readStoragePrimitive {
		\find(alpha::readField(stg, f))
		\varcond(\not \isReference(\typeof(f)))
		\replacewith(f)
	};
	
	writeStoragePrimitive {
		\find(writeField(stg, f, x))
		\varcond(\not \isReference(\typeof(f)))
		\replacewith({f := x})
	};
	*/
	
	/*
	writePathHead {
		\find(writePath(stg, headStoragePath(f), x))
		\replacewith(writeFÃ­eld(stg, f, x));
	};
	
	writePathRecursive {
		\find(writePath(stg, consStoragePath(struct, path), x))
		\replacewith(writePath(stg, path, writeS(alpha::readPath(stg, path), struct, x))
	};
	
	readPathHead {
		\find(alpha::readPath(stg, headStoragePath(f)))
		\replacewith(alpha::readField(stg, f))
	};
	
	readPathRecursive {
		\find(alpha::readPath(stg, consStoragePath(struct, path))
		\replacewith(alpha::readStruct(alpha::readPath(stg, consStoragePath(struct, path)), struct))
	};
	*/
	
	/////////////////////////// Read/writes storage => storage //////////////////////////////////////
	
	/*  Hopefully, rules in javaRules.key takes care of compound versions of the below?
		P = primitive, R = reference
		#v = #v0		#v = R; #v0 = R		#v = P; #v0 = R		#v = R; #v0 = P
		#v = #v0.#f		#v = R; #v0 = R		#v = P; #v0 = R
		#v = #v0[#a]	#v = R; #v0 = R		#v = P; #v0 = R
		#v.#f = #v0		#v = R; #v0 = R							#v = R; #v0 = P
		#v[#a] = #v0	#v = R; #v0 = R							#v = R; #v0 = P
	*/
	
	assignmentStorageLocalFrom {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \not \isReference(\typeof(#v0)) )
		\replacewith ( ==> { storage := writeField(storage, #v, #v0) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentStorageLocalTo {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \not \isReference(\typeof(#v)), \isStorage(#v0) )
		\replacewith ( ==> { #v := alpha::readField(stg, #v0) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentStorage {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { stg := writeField(stg, #v, alpha::readField(stg, #v0)) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentWriteStructFieldStorage {
		\find ( ==> \modality{#allmodal}{ .. #v.#f = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { stg := writeField(stg, #v, writeStruct(#v, #memberPVToPath(#f), alpha::readField(stg, #v0))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
	assignmentWriteArrayStorage {
		\find ( ==> \modality{#allmodal}{ .. #v[#i] = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { stg := writeField(stg, #v, writeStruct(alpha::readField(stg, #v), arr(#i), alpha::readField(stg, #v0))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentReadStructFieldStorage {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0.#f; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { stg := writeField(stg, #v, alpha::readField(stg, alpha::readStruct(#v0, #memberPVToPath(#f)))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
	assignmentReadArrayStorage {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0[#i]; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { stg := writeField(stg, #v, alpha::readField(stg, alpha::readStruct(#v0, arr(#i)))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	/////////////////////////// Read/writes storage => memory //////////////////////////////////////
	assignmentStorageToMemory {
		\schemaVar \skolemTerm java.lang.Object ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \isMemory(#v), \isStorage(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { #v := ctrct || 
		                     heap := struct2Mem(heap, ctrct, alpha::readField(stg, #v0)) } 
							 \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentWriteStructFieldStorageToMemory {
		\schemaVar \skolemTerm java.lang.Object ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v.#f = #v0; ... }\endmodality(post))
		\varcond( \isMemory(#v), \isStorage(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { heap := store(heap, #v, #memberPVToPath(#f), ctrct) || 
		                     heap := struct2Mem(heap, ctrct, alpha::readField(stg, #v0)) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
	assignmentWriteArrayStorageToMemory {
		\schemaVar \skolemTerm java.lang.Object ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v[#i] = #v0; ... }\endmodality(post))
		\varcond( \isMemory(#v), \isStorage(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { heap := store(heap, #v, arr(#i), ctrct) || 
		                     heap := struct2Mem(heap, ctrct, alpha::readField(stg, #v0)) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentReadStructFieldStorageToMemory {
		\schemaVar \skolemTerm java.lang.Object ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v = #v0.#f; ... }\endmodality(post))
		\varcond( \isMemory(#v), \isStorage(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { #v := ctrct ||
		                     heap := struct2Mem(heap, ctrct, alpha::readField(stg, alpha::readStruct(#v0, #memberPVToPath(#f)))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
	assignmentReadArrayStorageToMemory {
		\schemaVar \skolemTerm java.lang.Object ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v = #v0[#i]; ... }\endmodality(post))
		\varcond( \isMemory(#v), \isStorage(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { #v := ctrct ||
		                     heap := struct2Mem(heap, ctrct, alpha::readField(stg, alpha::readStruct(#v0, arr(#i)))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	/////////////////////////// Read/writes memory => storage //////////////////////////////////////
	assignmentMemoryToStorage {
		\schemaVar \skolemTerm Struct ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isMemory(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { #v := ctrct || 
		                     stg := object2Stg(stg, heap, #v0, alpha::readField(stg, #v)) } 
							 \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentWriteStructFieldMemoryToStorage {
		\schemaVar \skolemTerm Struct ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v.#f = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isMemory(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { stg := writeField(stg, #v, writeStruct(#v, #memberPVToPath(#f), ctrct)) || 
		                     stg := object2Stg(stg, #v0, alpha::readField(stg, alpha::readStruct(#v, #memberPVToPath(#f)))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
	assignmentWriteArrayMemoryToStorage {
		\schemaVar \skolemTerm Struct ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v[#i] = #v0; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isMemory(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { stg := writeField(stg, #v, writeStruct(#v, arr(#i), ctrct)) || 
		                     stg := object2Stg(stg, #v0, alpha::readField(stg, alpha::readStruct(#v, arr(#i)))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentReadStructFieldMemoryToStorage {
		\schemaVar \skolemTerm Struct ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v = #v0.#f; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isMemory(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { #v := ctrct ||
		                     stg := object2Stg(stg, select(heap, #v0, #memberPVToPath(#f)), alpha::readField(stg, #v)) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
	assignmentReadArrayMemoryToStorage {
		\schemaVar \skolemTerm Struct ctrct;
		\find ( ==> \modality{#allmodal}{ .. #v = #v0[#i]; ... }\endmodality(post))
		\varcond( \isStorage(#v), \isMemory(#v0), \new(ctrct, \dependingOn(post)) )
		\replacewith ( ==> { #v := ctrct ||
		                     stg := object2Stg(stg, select(heap, #v0, arr(#i)), alpha::readField(stg, #v)) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	/////////////////////////// Read/writes local storage variables //////////////////////////////////////
	/*
	assignmentStorage {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \localstorage(#v), \localstorage(#v0) )
		\replacewith ( ==> { #v := #v0 } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentStorage {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \localstorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { #v := headStoragePath(#v0) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentReadStructFieldStorageToMemory {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0.#f; ... }\endmodality(post))
		\varcond( \localstorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { #v := consStoragePath(#v0, headStoragePath(#memberPVToPath(#f))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
		\find ( ==> \modality{#allmodal}{ .. #v = #v0[#i]; ... }\endmodality(post))
		\varcond( \localstorage(#v), \isStorage(#v0) )
		\replacewith ( ==> { #v := consStoragePath(#v0, headStoragePath(arr(#i))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	*/
}