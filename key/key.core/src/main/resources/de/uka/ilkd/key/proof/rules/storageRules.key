\sorts{
	\generic G;
}

\schemaVariables {
	\term Heap heap, heap0;
	\term Storage stg, stg0;
	\term Struct struct, struct0;
	\term Path path, path0;
	\term Field f, f0;
	\term Object o, o0;
	\term alpha x;
	
	\schemaVar \formula post;
	\schemaVar \program Variable #v, #v0, #a, #a0, #this;
	\schemaVar \program SimpleExpression #se, #se0;
	\schemaVar \modalOperator {box_transaction, diamond_transaction, box, diamond} #allmodal;
};

\rules(programRules:Solidity) {
	
	readEmptyStruct {
		\find(alpha::readStruct(emptyStruct(), f))
		\replacewith ( (#typeof(f))::defaultValue )
	};
	
	readOfWriteStruct {
		\find(alpha::readStruct(writeStruct(struct, f, x), f0))
		\replacewith( \if (f = f') \then (x) \else (alpha::readStruct(struct, f0)) )
	};
	
	readEmptyStorage {
		\find(alpha::readField(emptyStg(), f))
		\replacewith ( (#typeof(f))::defaultValue )
	};
	
	readOfWriteStorage {
		\find(alpha::readField(writeField(stg, f, x), f0))
		\replacewith( \if (f = f') \then (x) \else (alpha::readField(stg, f0)) )
	};
	
	selectStructToMem {
		\find(alpha::select(struct2Mem(heap, o, struct), o0, f))
		\replacewith( \if (o = o0) \then (alpha::readStruct(struct, f)) \else (alpha::select(heap, o0, f)))
	};
	
	writePathHead {
		\find(writePath(stg, loneStoragePath(f), x))
		\replacewith(writeFÃ­eld(stg, f, x));
	};
	
	writePathRecursive {
		\find(writePath(stg, consStoragePath(struct, path), x))
		\replacewith(writePath(stg, path, writeS(alpha::readPath(stg, path), struct, x))
	};
	
	readPathHead {
		\find(alpha::readPath(stg, loneStoragePath(f)))
		\replacewith(alpha::readField(stg, f))
	};
	
	readPathRecursive {
		\find(alpha::readPath(stg, consStoragePath(struct, path))
		\replacewith(alpha::readStruct(alpha::readPath(stg, consStoragePath(struct, path)), struct))
	}:
	
	/////////////////////////// Read/writes storage => storage //////////////////////////////////////
	
	/*  Hopefully, rules in javaRules.key takes care of compound versions of the below?
		#v = #v0
		#v = #v0.#f
		#v = #v0[#a]
		#v.#f = #v0
		#v[#a] = #v0
	*/
	test {
		\find ( ==>  \modality(#allmodal){ .. #lhs =  }\endmodality(post))
	};
	
	assignmentReadField1 {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \storage(#v), \localPrimitiveVar(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #v, #v0) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentWriteField1 {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \storage(#v), \localPrimitiveVar(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #v, #v0) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentWriteField2 {
		\find ( ==> \modality{#allmodal}{ .. #v = #v0; ... }\endmodality(post))
		\varcond( \storage(#v), \storage(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #v, readField(storage, #v0)) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentWriteStructField1 {
		\find ( ==> \modality{#allmodal}{ .. #v.#f = #v0; ... }\endmodality(post))
		\varcond( \storage(#v), \localPrimitiveVar(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #v, writeStruct(#v, #f, #v0)) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
	assignmentWriteStructField2 {
		\find ( ==> \modality{#allmodal}{ .. #v.#f = #v0; ... }\endmodality(post))
		\varcond( \storage(#v), \storage(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #v, writeStruct(#v, #f, readField(storage, #v0))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	}:
	
	assignmentWriteArray1 {
		\find ( ==> \modality{#allmodal}{ .. #v[#i] = #v0; ... }\endmodality(post))
		\varcond( \storage(#v), \localPrimitiveVar(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #v, writeStruct(readField(stg, #v), arr(#i), #v0)) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentWriteArray2 {
		\find ( ==> \modality{#allmodal}{ .. #v[#i] = #v0; ... }\endmodality(post))
		\varcond( \storage(#v), \storage(#v0) )
		\replacewith ( ==> { storage := writeField(storage, #v, writeStruct(readField(stg, #v), arr(#i), readField(storage, #v0))) } \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	/////////////////////////// Read/writes storage => memory //////////////////////////////////////
	
	
	
	
	
	assignmentWriteAttribute {
		\find ( ==> \modality{#allmodal}{ .. #v.#a = #se; ... }\endmodality(post))
		\varcond ( \not \isThisReference(#this) )
		\replacewith ( ==> {storage:=writePath(storage, #memberPVToPath(#a), #se)} \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentWriteAttributeThis {
		\find ( ==> \modality{#allmodal}{ .. #this.#a = #se; ... }\endmodality(post))
		\varcond ( \isThisReference(#this) )
		\replacewith ( ==> {storage:=writeF(storage, #memberPVToField(#a), #se)} \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
	
	assignmentReadAttribute {
		\find ( ==> \modality{#allmodal}{ .. #v.#a = #v0.#a0; ... }\endmodality(post))
		\varcond ( \not \isThisReference(#this) )
		\replacewith ( ==> {#v0:=G::readF(storage, #memberPVToField(#a))} \modality{#allmodal}{ ..  ... }\endmodality(post))
		\heuristics ( simplify_prog_subset, simplify_prog )
		\displayname "assignment"
	};
}