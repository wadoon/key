 \sorts {
    \generic G \extends any;
	Storage;
	java.lang.Address \extends java.lang.Object;
 }


 \schemaVariables {
  \modalOperator { diamond, box } #allmodal;
  \modalOperator { diamond } #diamond;
  \modalOperator { box } #box;

  \program Variable #v, #this, #a;
  \program SimpleExpression #se;
  \formula post;
 }
 
 \functions{
   int solidityUintAddition(int, int);
   int solidityUintSubtraction(int, int);
   \unique int UINT_MAX;
   \unique Field address(java.lang.Address);
 }
 
 \predicates {
   inUint(int);
   
   CInv(Heap, java.lang.Address);
 }
 
 \programVariables {
   Object net;
 }

 \rules(intRules:solidity) {

    uintMaxDef {
    	\find(UINT_MAX) 
    	\replacewith(115792089237316195423570985008687907853269984665640564039457584007913129639936)
    	\heuristics(simplify)
    
    };

 	inUintDef {
 		\schemaVar \term int val;
 		\find(inUint(val))
 		\replacewith(val>=0 & val<=UINT_MAX)
 		\heuristics(simplify) 		
 	};

 	translateSolidityUintAddition {
 		\schemaVar \term int left, right;
 		\find(solidityUintAddition(left,right))
 		\replacewith(jmod(left+right,UINT_MAX))
 		\heuristics(simplify)
 	};

 	translateSolidityUintSubtraction {
 		\schemaVar \term int left, right;
 		\find(solidityUintSubtraction(left,right))
 		\replacewith(\if (left-right < 0) \then (UINT_MAX+(left-right+1)) \else (left-right))
 		\heuristics(simplify)
 	};
 
 }
 
 \rules(programRules:Solidity) {
 
    variableDeclarationAssign  {
     \schemaVar \program Type #t;
     \schemaVar \program VariableInitializer #vi ;
     
     \find (\modality{#allmodal}{.. #t #v = #vi; ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{.. #t #v; #v = #vi; ...}\endmodality(post))
     \heuristics(simplify_prog, simplify_prog_subset)
     \displayname "variableDeclaration"
  }; 
  
    variableDeclaration { 
     \schemaVar \program Type #t;

      \find (\modality{#allmodal}{.. #t #v; ...}\endmodality(post)) 
	  \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
      \addprogvars(#v) 
      \heuristics(simplify_prog, simplify_prog_subset)
      \displayname "variableDeclaration"
    };


    assignAttributeNonThis {
		\find(\modality{#allmodal}{.. #v.#a = #se; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		\replacewith({heap:=store(heap, #v, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};

    assignLocalVariableReadAttributeNonThis {
		\find(\modality{#allmodal}{.. #v = #this.#a; ...}\endmodality(post))
		\varcond(\hasSort(#a, G), \not\isThisReference(#this))
        \replacewith({#v := G::select(heap, #this, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
    assignAttribute {
		\find(\modality{#allmodal}{.. #this.#a = #se; ...}\endmodality(post))
		\varcond(\isThisReference(#this))
		\replacewith({heap:=store(heap, #this, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};

    unfoldRightAssignAttribute {
        \schemaVar \program NonSimpleExpression #nse;
    
		\find(\modality{#allmodal}{.. #this.#a = #nse; ...}\endmodality(post))
		\varcond(\isThisReference(#this), \new(#v, \typeof(#nse)))
		\replacewith(\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #this.#a = #v; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"
	};
	
	

	assignLocalVariable {
		\find(\modality{#allmodal}{.. #v = #se; ...}\endmodality(post))
		\replacewith({#v:=#se}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
	assignLocalVariableReadAttribute {
		\find(\modality{#allmodal}{.. #v = #this.#a; ...}\endmodality(post))
		\varcond(\hasSort(#a, G), \isThisReference(#this))
        \replacewith({#v := G::select(heap, #this, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
	assignLocalVariableIntAddition {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left + #right; ...}\endmodality(post))
		\replacewith({#v:=solidityUintAddition(#left,#right)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
    assignLocalVariableIntSubtraction {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left - #right; ...}\endmodality(post))
		\replacewith({#v:=solidityUintSubtraction(#left,#right)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
    assignLocalVariableLessThan {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left < #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left<#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};

    assignLocalVariableLessOrEqual {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left <= #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left<=#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
	 assignLocalVariableGreaterThan {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left > #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left>#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};

    assignLocalVariableGreaterOrEqual {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left <= #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left>=#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	

	evalLocalVariableLessThanLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #right;
		\schemaVar \program Variable #leftVar;
	
		\find(\modality{#allmodal}{.. #v = #left < #right; ...}\endmodality(post))
		\varcond(\new(#leftVar,\typeof(#left)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#left) #leftVar = #left; 
		          #v = #leftVar < #right;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableLessThanRight {
		\schemaVar \program SimpleExpression #left;
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #rightVar;
	
		\find(\modality{#allmodal}{.. #v = #left < #right; ...}\endmodality(post))
		\varcond(\new(#rightVar,\typeof(#right)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#right) #rightVar = #right; 
		          #v = #left < #rightVar;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableLessOrEqualLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #right;
		\schemaVar \program Variable #leftVar;
	
		\find(\modality{#allmodal}{.. #v = #left <= #right; ...}\endmodality(post))
		\varcond(\new(#leftVar,\typeof(#left)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#left) #leftVar = #left; 
		          #v = #leftVar <= #right;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableLessOrEqualRight {
		\schemaVar \program SimpleExpression #left;
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #rightVar;
	
		\find(\modality{#allmodal}{.. #v = #left <= #right; ...}\endmodality(post))
		\varcond(\new(#rightVar,\typeof(#right)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#right) #rightVar = #right; 
		          #v = #left <= #rightVar;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};

	evalLocalVariableGreaterOrEqualLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #right;
		\schemaVar \program Variable #leftVar;
	
		\find(\modality{#allmodal}{.. #v = #left >= #right; ...}\endmodality(post))
		\varcond(\new(#leftVar,\typeof(#left)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#left) #leftVar = #left; 
		          #v = #leftVar >= #right;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableGreaterOrEqualRight {
		\schemaVar \program SimpleExpression #left;
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #rightVar;
	
		\find(\modality{#allmodal}{.. #v = #left >= #right; ...}\endmodality(post))
		\varcond(\new(#rightVar,\typeof(#right)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#right) #rightVar = #right; 
		          #v = #left >= #rightVar;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableGreaterLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #right;
		\schemaVar \program Variable #leftVar;
	
		\find(\modality{#allmodal}{.. #v = #left > #right; ...}\endmodality(post))
		\varcond(\new(#leftVar,\typeof(#left)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#left) #leftVar = #left; 
		          #v = #leftVar > #right;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableGreaterRight {
		\schemaVar \program SimpleExpression #left;
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #rightVar;
	
		\find(\modality{#allmodal}{.. #v = #left > #right; ...}\endmodality(post))
		\varcond(\new(#rightVar,\typeof(#right)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#right) #rightVar = #right; 
		          #v = #left > #rightVar;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
   
	 evalEqualityLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #e;
		\schemaVar \program Variable #b;
		
	
		\find(\modality{#allmodal}{.. #v = #left==#e; ...}\endmodality(post))
		\varcond(\new(#b,\typeof(#left)))
		\replacewith(\modality{#allmodal}{.. #typeof(#left) #b = #left; #v=#b==#e; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "evalEquality"		
	};
	
    evalEqualityRight {
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #b;
		
	
		\find(\modality{#allmodal}{.. #v = #se==#right; ...}\endmodality(post))
		\varcond(\new(#b,\typeof(#right)))
		\replacewith(\modality{#allmodal}{.. #typeof(#right) #b = #right; #v=#se==#b; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "evalEquality"		
	};
	
	assignLocalVariableEqual {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left == #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left=#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};

	assignLocalVariableNotEqual {
	    \schemaVar \program Expression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left != #right; ...}\endmodality(post))
		\replacewith(\modality{#allmodal}{.. #v = !(#left == #right); ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
	removeParenthesis {
	    \schemaVar \program Expression #e;
	
		\find(\modality{#allmodal}{.. #v = (#e); ...}\endmodality(post))
		\replacewith(\modality{#allmodal}{.. #v = #e; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
	evalNegation {
	    \schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Variable #b;
		
	
		\find(\modality{#allmodal}{.. #v = !#nse; ...}\endmodality(post))
		\varcond(\new(#b,boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; #v=!#b; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "evalNegation"		
	};

   


	assignLocalVariableNegation {
		\schemaVar \program Variable #b;
		
	
		\find(\modality{#allmodal}{.. #v = !#se; ...}\endmodality(post))
		\replacewith({#v:=\if (#se=TRUE)\then(FALSE)\else(TRUE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};


	ifThenEvalGuard {
	    \schemaVar \program NonSimpleExpression #nse;
	    \schemaVar \program Variable #b;
	    \schemaVar \program Statement #s;

		\find (\modality{#allmodal}{.. if (#nse) #s ...}\endmodality(post))
		\varcond(\new(#b, boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; if (#b) #s ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
	};

	ifThenElseEvalGuard {
	    \schemaVar \program NonSimpleExpression #nse;
	    \schemaVar \program Variable #b;
	    \schemaVar \program Statement #s1,#s2;

		\find (\modality{#allmodal}{.. if (#nse) #s1 else #s2 ...}\endmodality(post))
		\varcond(\new(#b, boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; if (#b) #s1 else #s2 ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
	};
	
	ifThenElseSplit {
	    \schemaVar \program SimpleExpression #guard;
	    \schemaVar \program Statement #s1,#s2;

		\find (\modality{#allmodal}{.. if (#guard) #s1 else #s2 ...}\endmodality(post))
		\replacewith(\if (#guard=TRUE) \then 
		    (\modality{#allmodal}{.. #s1 ...}\endmodality(post))
		   \else
		    (\modality{#allmodal}{.. #s2 ...}\endmodality(post))
		)
		\heuristics(simplify_prog_subset,simplify)
	};	
	
	ifThenSplit {
	    \schemaVar \program SimpleExpression #guard;
	    \schemaVar \program Statement #s;

		\find (\modality{#allmodal}{.. if (#guard) #s ...}\endmodality(post))
		\replacewith(\if (#guard=TRUE) \then 
		    (\modality{#allmodal}{.. #s ...}\endmodality(post))
		   \else
		    (\modality{#allmodal}{.. ...}\endmodality(post))
		)
		\heuristics(simplify_prog_subset,simplify)
	};	
	
    assertEval {
        \schemaVar \program NonSimpleExpression #nse;
	    \schemaVar \program Variable #b;
        
        \find (\modality{#allmodal}{.. assert #nse; ...}\endmodality(post))
		\varcond(\new(#b, boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; assert #b; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)	
    };

    assertSucc {        
        \find (==> \modality{#allmodal}{.. assert #se; ...}\endmodality(post))        
		\replacewith(==> \modality{#allmodal}{.. ...}\endmodality(post))
		\add(#se=TRUE ==>);
		\replacewith(==> #se=TRUE)
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assert"	
    };
    
    requireEval {
        \schemaVar \program MethodName[name=require] #require;
    
        \schemaVar \program NonSimpleExpression #nse;
	    \schemaVar \program Variable #b;
        
        \find (\modality{#allmodal}{.. #require(#nse); ...}\endmodality(post))
		\varcond(\new(#b, boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; #require(#b); ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)	
    };

    requireSucc {        
        \schemaVar \program MethodName[name=require] #require;
        \find (==> \modality{#allmodal}{.. #require(#se); ...}\endmodality(post))        
		\replacewith(==> \modality{#allmodal}{.. ...}\endmodality(post))
		\add(#se=TRUE ==>);
		\replacewith(==> \modality{#allmodal}{.. throw null; ...}\endmodality(post))
		\add(#se=FALSE ==>)
		\heuristics(simplify_prog_subset,simplify)
		\displayname "require"	
    };


    transferEvalArgument {
        \schemaVar \program MethodName[name=transfer] #transfer;
    
        \schemaVar \program NonSimpleExpression #nse;
	    \schemaVar \program Variable #money;
        
        \find (\modality{#allmodal}{.. #v.#transfer(#nse); ...}\endmodality(post))
		\varcond(\new(#money, int))
		\replacewith(\modality{#allmodal}{.. int #money = #nse; #v.#transfer(#money); ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)	
    };
    
    transferEvalCallee {
        \schemaVar \program MethodName[name=transfer] #transfer;
    
	    \schemaVar \program Variable #callee;
        \schemaVar \program Expression #e;
        
        \find (\modality{#allmodal}{.. #e.#transfer(#se); ...}\endmodality(post))
		\varcond(\new(#callee, \typeof(#e)))
		\replacewith(\modality{#allmodal}{.. #typeof(#e) #callee = #e; #callee.#transfer(#se); ...}\endmodality(post))
		\heuristics(simplify_ENLARGING)	
    };

    transferSucc {        
        \schemaVar \program MethodName[name=transfer] #transfer;
        \schemaVar \skolemTerm Heap anonStorage;
        \schemaVar \program ProgramMethod #pm ; 
        \schemaVar \program Type #t;
        \schemaVar \program Variable #v1;
        \schemaVar \program SimpleExpression #callee;
        

        \find (==> \modality{#allmodal}{.#pm@#t(#v1).. #callee.#transfer(#se); ...}\endmodality(post)) 
        \varcond ( \new(anonStorage, \dependingOn(post)) )       
		"Guarantee Invariant":\replacewith(==> {heap:=store(heap, net, address(#callee), int::select(heap, net, address(#callee)) - #se)}CInv(heap,#v1));
		"Assume Invariant"   :\replacewith(==> {heap:=anon(heap, allLocs, anonStorage)}(CInv(heap,#v1) -> \modality{#allmodal}{.. ...}\endmodality(post)))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "transfer"	
    };

   functionCallEmpty {
   	\schemaVar \program ExecutionContext #ex;
    \find (\modality{#allmodal}{.. method-frame(#ex):{} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
   };
  
  
  emptyBlock {
    \find (\modality{#allmodal}{.. {} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
  };
  
  emptyProgram {
    \find (\modality{#allmodal}{ }\endmodality(post)) 
    \replacewith (post) 
    \heuristics(simplify_prog) 
  };
  
  propagateThrowBlock {
     \schemaVar \program[list] Statement #slist;
  
     \find (\modality{#allmodal}{.. { throw #se; #slist } ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post)) 
     \heuristics(simplify_prog) 
      
  };
  
  propagateThrowMF {
     \schemaVar \program[list] Statement #s;
     \schemaVar \program ExecutionContext #ex;
  
     \find(\modality{#allmodal}{.. method-frame(#ex):{ throw #se; #s } ...}\endmodality(post))
     \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality(post)) 
     \heuristics(simplify_prog) 
  };
  
  
  revert {
     \schemaVar \program Statement #s;
     \schemaVar \program ExecutionContext #ex;
  
     \find(\modality{#allmodal}{throw #se;}\endmodality(post))
     \replacewith({heap:=savedHeap}\modality{#allmodal}{}\endmodality(post)) 
     \heuristics(simplify_prog) 
  };
  
}
