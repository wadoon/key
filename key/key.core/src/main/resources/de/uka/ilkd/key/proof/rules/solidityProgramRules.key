 \sorts {
    \generic G \extends any;
    \generic H \extends java.lang.Address;
    
	Storage;
 }


 \schemaVariables {
  \modalOperator { diamond, box } #allmodal;
  \modalOperator { diamond } #diamond;
  \modalOperator { box } #box;

  \program Variable #v, #v0, #this, #a;
  \program SimpleExpression #se, #msg;
  \formula post;
  \term H addr1, addr2;
  
 }
 
 \functions{
   int solidityUintAddition(int, int);
   int solidityUintSubtraction(int, int);
   \unique int UINT_MAX;
   \unique Field arr_length;
 }
 
 \predicates {
   inUint(int);
   
   CInv(Heap, java.lang.Address);
   DInv(Heap, java.lang.Address);
 }
 
 \programVariables {
   Object net;
 }

 \rules(intRules:solidity) {

    uintMaxDef {
    	\find(UINT_MAX) 
    	\replacewith(115792089237316195423570985008687907853269984665640564039457584007913129639936)
    	\heuristics(simplify)
    
    };

 	inUintDef {
 		\schemaVar \term int val;
 		\find(inUint(val))
 		\replacewith(val>=0 & val<=UINT_MAX)
 		\heuristics(simplify) 		
 	};

 	/*translateSolidityUintAddition {
 		\schemaVar \term int left, right;
 		\find(solidityUintAddition(left,right))
 		\replacewith(jmod(left+right,UINT_MAX))
 		\heuristics(simplify)
 	};

 	translateSolidityUintSubtraction {
 		\schemaVar \term int left, right;
 		\find(solidityUintSubtraction(left,right))
 		\replacewith(\if (left-right < 0) \then (UINT_MAX+(left-right+1)) \else (left-right))
 		\heuristics(simplify)
 	};*/
 	
 	translateSolidityUintAddition {
        \schemaVar \term int left, right;
        \find(solidityUintAddition(left,right))
        \replacewith(left+right)
        \heuristics(simplify)
    };

    translateSolidityUintSubtraction {
        \schemaVar \term int left, right;
        \find(solidityUintSubtraction(left,right))
        \replacewith(left-right)
        \heuristics(simplify)
    };
 	
 	intCastEqual { 
        \find( (int) addr1 = (int) addr2 )
        \replacewith( addr1 = addr2 )
        \heuristics(simplify) 	
 	};
 
 }
 
 \rules(programRules:Solidity) {
 
 	enumConstantsNotEqual {
 		\schemaVar \term Field ec1;
 		\schemaVar \term Field ec2;
 		\schemaVar \term Heap h1, h2;
 	 	
 		\find(G::select(h1, null, ec1) = G::select(h2, null, ec2))
 		\varcond(\enumConstant(ec1), \enumConstant(ec2), \different(ec1,ec2))
 		\replacewith(false)
 		\heuristics(concrete)
 	};
 
 
    variableDeclarationAssign  {
     \schemaVar \program Type #t;
     \schemaVar \program VariableInitializer #vi ;
     
     \find (\modality{#allmodal}{.. #t #v = #vi; ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{.. #t #v; #v = #vi; ...}\endmodality(post))
     \heuristics(simplify_prog, simplify_prog_subset)
     \displayname "variableDeclaration"
    }; 
  
    variableDeclaration { 
     \schemaVar \program Type #t;

      \find (\modality{#allmodal}{.. #t #v; ...}\endmodality(post)) 
	  \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
      \addprogvars(#v) 
      \heuristics(simplify_prog, simplify_prog_subset)
      \displayname "variableDeclaration"
    };

  assignment_read_length {
    \schemaVar \program ArrayLength #length;
		\find (\modality{#allmodal}{.. #v0 = #v.#length; ...}\endmodality(post)) \sameUpdateLevel
		\varcond(\not\isThisReference(#v))
            \replacewith({#v0 := length(#v)}\modality{#allmodal}{.. ...}\endmodality(post))
	//	      \add (==>(#v=null))
		      \heuristics(simplify_prog, simplify_prog_subset)
      \displayname "assignmen_read_length"
  };  

    assignAttributeNonThis {
		\find(\modality{#allmodal}{.. #v.#a = #se; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v))
		\replacewith({heap:=store(heap, #v, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
	 assignAttributeEnumValue {
	 	\schemaVar \program StaticVariable #sv;
	 	
		\find(\modality{#allmodal}{.. #v.#a = #sv; ...}\endmodality(post))
		\varcond(\not\isThisReference(#v),\hasSort(#sv,G))
		\replacewith({heap:=store(heap, #v, #memberPVToField(#a), G::select(heap, null, #memberPVToField(#sv)))}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};

    assignLocalVariableReadAttributeNonThis {
    	\schemaVar \program Variable #v2;
		\find(\modality{#allmodal}{.. #v2 = #v.#a; ...}\endmodality(post))
		\varcond(\hasSort(#a, G), \not\isThisReference(#v))
        \replacewith({#v2 := G::select(heap, #v, #memberPVToField(#a))}
        				\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
	 assignLocalVariableEnumValue {
	 	\schemaVar \program StaticVariable #sv;
		\find(\modality{#allmodal}{.. #v = #sv; ...}\endmodality(post))
		\varcond(\hasSort(#sv,G))
		\replacewith({#v:=G::select(heap, null, #memberPVToField(#sv))}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
	unfoldAttributeAccessLeft {
		\schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Expression #e;

		\find(\modality{#allmodal}{.. #nse.#a = #e; ...}\endmodality(post))
		\varcond(\new(#v,\typeof(#nse)))
		\replacewith(
			\modality{#allmodal}{.. 
			   #typeof(#nse) #v = #nse;
			   #v.#a = #e;
			   ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"	
	};

	unfoldAttributeRight {
	 	\schemaVar \program NonSimpleExpression #nse;
	 
		\find(\modality{#allmodal}{.. #v0.#a = #nse; ...}\endmodality(post))
		\varcond(\new(#v,\typeof(#nse)))
		\replacewith(\modality{#allmodal}{.. 
		                 #typeof(#nse) #v = #nse;
			   			 #v0.#a = #v;
		                ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"
	};
	
    assignAttribute {
		\find(\modality{#allmodal}{.. #this.#a = #se; ...}\endmodality(post))
		\varcond(\isThisReference(#this))
		\replacewith({heap:=store(heap, #this, #memberPVToField(#a), #se)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
	assignArray {
		\schemaVar \program Variable #array;
		\schemaVar \program SimpleExpression #idx;
		
		\find(\modality{#allmodal}{.. #array[#idx] = #se; ...}\endmodality(post))
		\replacewith({heap:=store(heap, #array, arr((int)#idx), #se)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};

	unfoldAssignArray1 {
        \schemaVar \program NonSimpleExpression #arrNSE;
        \schemaVar \program Expression #idx;
        \schemaVar \program Expression #e;
        \schemaVar \program Variable #arr; 
    
		\find(\modality{#allmodal}{.. #arrNSE[#idx] = #e; ...}\endmodality(post))
		\varcond(\new(#arr, \typeof(#arrNSE)))
		\replacewith(\modality{#allmodal}{.. 
			#typeof(#arrNSE) #arr = #arrNSE;
		    #arr[#idx] = #e; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"
	};
	
	unfoldAssignArray2 {
        \schemaVar \program SimpleExpression #arr;
        \schemaVar \program NonSimpleExpression #idx;
        \schemaVar \program Variable #idxV; 
        \schemaVar \program Expression #e;
    
		\find(\modality{#allmodal}{.. #arr[#idx] = #e; ...}\endmodality(post))
		\varcond(\new(#idxV, \typeof(#idx)))
		\replacewith(\modality{#allmodal}{.. 
			#typeof(#idx) #idxV = #idx;
		    #arr[#idxV] = #e; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"
	};

	unfoldAssignArray3 {
        \schemaVar \program SimpleExpression #arr;
        \schemaVar \program SimpleExpression #idx;
        \schemaVar \program NonSimpleExpression #nse;
        \schemaVar \program Variable #value; 
    
		\find(\modality{#allmodal}{.. #arr[#idx] = #nse; ...}\endmodality(post))
		\varcond(\isThisReference(#this), 
		         \new(#value, \typeof(#nse)))
		\replacewith(\modality{#allmodal}{.. 
			#typeof(#nse) #value = #nse;
		    #arr[#idx] = #value; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"
	};

	
	assignLocalVariable {
		\find(\modality{#allmodal}{.. #v = #se; ...}\endmodality(post))
		\replacewith({#v:=#se}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
	assignLocalVariableReadAttribute {
		\find(\modality{#allmodal}{.. #v = #this.#a; ...}\endmodality(post))
		\varcond(\hasSort(#a, G), \isThisReference(#this))
        \replacewith({#v := G::select(heap, #this, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};
	
	unfoldLocalVariableRight {
		\schemaVar \program Variable #t;	
	    \schemaVar \program NonSimpleExpression #nse;
	
		\find(\modality{#allmodal}{.. #v = #nse.#a; ...}\endmodality(post))
		\varcond(\new(#t,\typeof(#nse)))
        \replacewith(\modality{#allmodal}{.. 
        		#typeof(#nse) #t = #nse;
        		#v = #t.#a;
        		...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"
	};


	unfoldReadArray1 {
        \schemaVar \program NonSimpleExpression #arrayExp;
        \schemaVar \program Expression #idx;        
        \schemaVar \program Variable #arr; 
    
		\find(\modality{#allmodal}{.. #v = #arrayExp[#idx]; ...}\endmodality(post))
		\varcond(\isThisReference(#this), \new(#arr, \typeof(#arrayExp)))
		\replacewith(\modality{#allmodal}{.. 
			#typeof(#arrayExp) #arr = #arrayExp;
		    #v = #arr[#idx]; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"
	};

	unfoldReadArray2 {
        \schemaVar \program NonSimpleExpression #idx;        
        \schemaVar \program Variable #arr, #idxV; 
    
		\find(\modality{#allmodal}{.. #v = #arr[#idx]; ...}\endmodality(post))
		\varcond(\new(#idxV, \typeof(#idx)))
		\replacewith(\modality{#allmodal}{.. 
			#typeof(#idx) #idxV = #idx;
		    #v = #arr[#idxV]; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "unfold"
	};
	
	assignLocalVariableReadArray {
		\schemaVar \program SimpleExpression #idx;
		\schemaVar \program Variable #array;
		\find(\modality{#allmodal}{.. #v = #array[#idx]; ...}\endmodality(post))
		\varcond(\hasSort(\elemSort(#array),G))
        \replacewith({#v := G::select(heap, #array, arr((int)#idx))}
                         \modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"
	};

    eval_order_IntAddition_left {
        \schemaVar \program NonSimpleExpression #left;
        \schemaVar \program Expression #right;
    
        \find(\modality{#allmodal}{.. #v = #left + #right; ...}\endmodality(post))
        \varcond(\new(#v0, \typeof(#left)))
        \replacewith(\modality{#allmodal}{.. #typeof(#left) #v0 = #left; #v = #v0 + #right; ...}\endmodality(post))
        \heuristics(simplify_prog_subset,simplify)
        \displayname "eval_order"       
    };

    eval_order_IntAddition_right {
        \schemaVar \program SimpleExpression #left;
        \schemaVar \program NonSimpleExpression #right;
    
        \find(\modality{#allmodal}{.. #v = #left + #right; ...}\endmodality(post))
        \varcond(\new(#v0, \typeof(#right)))
        \replacewith(\modality{#allmodal}{.. #typeof(#right) #v0 = #right; #v = #left + #v0; ...}\endmodality(post))
        \heuristics(simplify_prog_subset,simplify)
        \displayname "eval_order"       
    };
	
	assignLocalVariableIntAddition {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left + #right; ...}\endmodality(post))
		\replacewith({#v:=solidityUintAddition(#left,#right)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
	 eval_order_IntSubstraction_left {
        \schemaVar \program NonSimpleExpression #left;
        \schemaVar \program Expression #right;
    
        \find(\modality{#allmodal}{.. #v = #left - #right; ...}\endmodality(post))
        \varcond(\new(#v0, \typeof(#left)))
        \replacewith(\modality{#allmodal}{.. #typeof(#left) #v0 = #left; #v = #v0 - #right; ...}\endmodality(post))
        \heuristics(simplify_prog_subset,simplify)
        \displayname "eval_order"       
    };

    eval_order_IntSubstraction_right {
        \schemaVar \program SimpleExpression #left;
        \schemaVar \program NonSimpleExpression #right;
    
        \find(\modality{#allmodal}{.. #v = #left - #right; ...}\endmodality(post))
        \varcond(\new(#v0, \typeof(#right)))
        \replacewith(\modality{#allmodal}{.. #typeof(#right) #v0 = #right; #v = #left - #v0; ...}\endmodality(post))
        \heuristics(simplify_prog_subset,simplify)
        \displayname "eval_order"       
    };
	
    assignLocalVariableIntSubtraction {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left - #right; ...}\endmodality(post))
		\replacewith({#v:=solidityUintSubtraction(#left,#right)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};

	orEval {
        \schemaVar \program Expression #left;
        \schemaVar \program Expression #right;
    
        \find(\modality{#allmodal}{.. #v = #left || #right; ...}\endmodality(post))
        \replacewith(\modality{#allmodal}{.. if (#left) { #v = true; } 
                                             else { 
                                               if (#right) { #v = true; } 
                                               else { #v = false; }
                                              }  ...}\endmodality(post))
        \heuristics(simplify_prog_subset,simplify)
        \displayname "eval_order"       
    };
    
    andEval {
        \schemaVar \program Expression #left;
        \schemaVar \program Expression #right;
    
        \find(\modality{#allmodal}{.. #v = #left && #right; ...}\endmodality(post))
        \replacewith(\modality{#allmodal}{.. if (#left) { 
                                               if (#right) { #v = false; }
                                               else { #v = true; }
                                             } else { #v = false; }
                                          ...}\endmodality(post))
        \heuristics(simplify_prog_subset,simplify)
        \displayname "eval_order"       
    };
	
    assignLocalVariableLessThan {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left < #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left<#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};

    assignLocalVariableLessOrEqual {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left <= #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left<=#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
	 assignLocalVariableGreaterThan {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left > #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left>#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};

    assignLocalVariableGreaterOrEqual {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left >= #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left>=#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
	evalCastAddressToInt {
		\find(\modality{#allmodal}{.. #v = (int)#se; ...}\endmodality(post))
		\replacewith({#v:=(int)#se}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify)		
	};
	
	evalCastAddressToInt2 {
        \find(\modality{#allmodal}{.. #v = (int)#v0.#a; ...}\endmodality(post))
        \varcond(\hasSort(#a, G))
        \replacewith({#v:=(int)G::select(heap, #v0, #memberPVToField(#a))}\modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify)       
    };
	

	evalLocalVariableLessThanLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #right;
		\schemaVar \program Variable #leftVar;
	
		\find(\modality{#allmodal}{.. #v = #left < #right; ...}\endmodality(post))
		\varcond(\new(#leftVar,\typeof(#left)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#left) #leftVar = #left; 
		          #v = #leftVar < #right;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableLessThanRight {
		\schemaVar \program SimpleExpression #left;
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #rightVar;
	
		\find(\modality{#allmodal}{.. #v = #left < #right; ...}\endmodality(post))
		\varcond(\new(#rightVar,\typeof(#right)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#right) #rightVar = #right; 
		          #v = #left < #rightVar;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableLessOrEqualLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #right;
		\schemaVar \program Variable #leftVar;
	
		\find(\modality{#allmodal}{.. #v = #left <= #right; ...}\endmodality(post))
		\varcond(\new(#leftVar,\typeof(#left)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#left) #leftVar = #left; 
		          #v = #leftVar <= #right;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableLessOrEqualRight {
		\schemaVar \program SimpleExpression #left;
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #rightVar;
	
		\find(\modality{#allmodal}{.. #v = #left <= #right; ...}\endmodality(post))
		\varcond(\new(#rightVar,\typeof(#right)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#right) #rightVar = #right; 
		          #v = #left <= #rightVar;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};

	evalLocalVariableGreaterOrEqualLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #right;
		\schemaVar \program Variable #leftVar;
	
		\find(\modality{#allmodal}{.. #v = #left >= #right; ...}\endmodality(post))
		\varcond(\new(#leftVar,\typeof(#left)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#left) #leftVar = #left; 
		          #v = #leftVar >= #right;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableGreaterOrEqualRight {
		\schemaVar \program SimpleExpression #left;
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #rightVar;
	
		\find(\modality{#allmodal}{.. #v = #left >= #right; ...}\endmodality(post))
		\varcond(\new(#rightVar,\typeof(#right)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#right) #rightVar = #right; 
		          #v = #left >= #rightVar;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableGreaterLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #right;
		\schemaVar \program Variable #leftVar;
	
		\find(\modality{#allmodal}{.. #v = #left > #right; ...}\endmodality(post))
		\varcond(\new(#leftVar,\typeof(#left)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#left) #leftVar = #left; 
		          #v = #leftVar > #right;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
	
	evalLocalVariableGreaterRight {
		\schemaVar \program SimpleExpression #left;
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #rightVar;
	
		\find(\modality{#allmodal}{.. #v = #left > #right; ...}\endmodality(post))
		\varcond(\new(#rightVar,\typeof(#right)))
		
		\replacewith(\modality{#allmodal}{.. 
		          #typeof(#right) #rightVar = #right; 
		          #v = #left > #rightVar;
		        ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "eval"		
	};
   
	 evalEqualityLeft {
	    \schemaVar \program NonSimpleExpression #left;
	    \schemaVar \program Expression #e;
		\schemaVar \program Variable #b;
		
	
		\find(\modality{#allmodal}{.. #v = #left==#e; ...}\endmodality(post))
		\varcond(\new(#b,\typeof(#left)))
		\replacewith(\modality{#allmodal}{.. #typeof(#left) #b = #left; #v=#b==#e; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "evalEquality"		
	};
	
    evalEqualityRight {
	    \schemaVar \program NonSimpleExpression #right;
		\schemaVar \program Variable #b;
		
	
		\find(\modality{#allmodal}{.. #v = #se==#right; ...}\endmodality(post))
		\varcond(\new(#b,\typeof(#right)))
		\replacewith(\modality{#allmodal}{.. #typeof(#right) #b = #right; #v=#se==#b; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "evalEquality"		
	};
	
	assignLocalVariableEqual {
	    \schemaVar \program SimpleExpression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left == #right; ...}\endmodality(post))
		\replacewith({#v:=\if (#left=#right) \then (TRUE) \else (FALSE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};

	assignLocalVariableNotEqual {
	    \schemaVar \program Expression #left, #right;
	
		\find(\modality{#allmodal}{.. #v = #left != #right; ...}\endmodality(post))
		\replacewith(\modality{#allmodal}{.. #v = !(#left == #right); ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
	removeParenthesis {
	    \schemaVar \program Expression #e;
	
		\find(\modality{#allmodal}{.. #v = (#e); ...}\endmodality(post))
		\replacewith(\modality{#allmodal}{.. #v = #e; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};
	
	evalNegation {
	    \schemaVar \program NonSimpleExpression #nse;
		\schemaVar \program Variable #b;
		
	
		\find(\modality{#allmodal}{.. #v = !#nse; ...}\endmodality(post))
		\varcond(\new(#b,boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; #v=!#b; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "evalNegation"		
	};

   


	assignLocalVariableNegation {
		\schemaVar \program Variable #b;
		
	
		\find(\modality{#allmodal}{.. #v = !#se; ...}\endmodality(post))
		\replacewith({#v:=\if (#se=TRUE)\then(FALSE)\else(TRUE)}\modality{#allmodal}{.. ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assign"		
	};


	ifThenEvalGuard {
	    \schemaVar \program NonSimpleExpression #nse;
	    \schemaVar \program Variable #b;
	    \schemaVar \program Statement #s;

		\find (\modality{#allmodal}{.. if (#nse) #s ...}\endmodality(post))
		\varcond(\new(#b, boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; if (#b) #s ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
	};

	ifThenElseEvalGuard {
	    \schemaVar \program NonSimpleExpression #nse;
	    \schemaVar \program Variable #b;
	    \schemaVar \program Statement #s1,#s2;

		\find (\modality{#allmodal}{.. if (#nse) #s1 else #s2 ...}\endmodality(post))
		\varcond(\new(#b, boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; if (#b) #s1 else #s2 ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)
	};
	
	ifThenElseSplit {
	    \schemaVar \program SimpleExpression #guard;
	    \schemaVar \program Statement #s1,#s2;

		\find (\modality{#allmodal}{.. if (#guard) #s1 else #s2 ...}\endmodality(post))
		\replacewith(\if (#guard=TRUE) \then 
		    (\modality{#allmodal}{.. #s1 ...}\endmodality(post))
		   \else
		    (\modality{#allmodal}{.. #s2 ...}\endmodality(post))
		)
		\heuristics(simplify_prog_subset,simplify)
	};	
	
	ifThenSplit {
	    \schemaVar \program SimpleExpression #guard;
	    \schemaVar \program Statement #s;

		\find (\modality{#allmodal}{.. if (#guard) #s ...}\endmodality(post))
		\replacewith(\if (#guard=TRUE) \then 
		    (\modality{#allmodal}{.. #s ...}\endmodality(post))
		   \else
		    (\modality{#allmodal}{.. ...}\endmodality(post))
		)
		\heuristics(simplify_prog_subset,simplify)
	};	
	
    assertEval {
        \schemaVar \program NonSimpleExpression #nse;
	    \schemaVar \program Variable #b;
        
        \find (\modality{#allmodal}{.. assert #nse; ...}\endmodality(post))
		\varcond(\new(#b, boolean))
		\replacewith(\modality{#allmodal}{.. boolean #b = #nse; assert #b; ...}\endmodality(post))
		\heuristics(simplify_prog_subset,simplify)	
    };

    assertSucc {        
        \find (==> \modality{#allmodal}{.. assert #se; ...}\endmodality(post))        
		\replacewith(==> \modality{#allmodal}{.. ...}\endmodality(post))
		\add(#se=TRUE ==>);
		\replacewith(==> #se=TRUE)
		\heuristics(simplify_prog_subset,simplify)
		\displayname "assert"	
    };
    
    requireSucc {        
        \schemaVar \program MethodName[name=require] #require;
        \find (==> \modality{#allmodal}{.. #require(#se); ...}\endmodality(post))        
		\replacewith(==> \modality{#allmodal}{.. ...}\endmodality(post))
		\add(#se=TRUE ==>)/*;
		\replacewith(==> \modality{#allmodal}{.. throw null; ...}\endmodality(post))
		\add(#se=FALSE ==>)*/
		\heuristics(simplify_prog_subset,simplify)
		\displayname "require"	
    };


   functionCallEmpty {
   	\schemaVar \program ExecutionContext #ex;
    \find (\modality{#allmodal}{.. method-frame(#ex):{} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
   };
  
  
  emptyBlock {
    \find (\modality{#allmodal}{.. {} ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. ...}\endmodality(post)) 
    \heuristics(simplify_prog) 
  };
  
  emptyProgram {
    \find (\modality{#allmodal}{ }\endmodality(post)) 
    \replacewith (post) 
    \heuristics(simplify_prog) 
  };
  
  propagateThrowBlock {
     \schemaVar \program[list] Statement #slist;
  
     \find (\modality{#allmodal}{.. { throw #se; #slist } ...}\endmodality(post))
     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post)) 
     \heuristics(simplify_prog) 
      
  };
  
  propagateThrowMF {
     \schemaVar \program[list] Statement #s;
     \schemaVar \program ExecutionContext #ex;
  
     \find(\modality{#allmodal}{.. method-frame(#ex):{ throw #se; #s } ...}\endmodality(post))
     \replacewith(\modality{#allmodal}{.. throw #se; ...}\endmodality(post)) 
     \heuristics(simplify_prog) 
  };
  
  
  revert {
     \schemaVar \program Statement #s;
     \schemaVar \program ExecutionContext #ex;
  
     \find(\modality{#allmodal}{throw #se;}\endmodality(post))
     \replacewith({heap:=savedHeap}\modality{#allmodal}{}\endmodality(post)) 
     \heuristics(simplify_prog) 
  };
  
  
  methodCallUnfoldArguments { 
    \schemaVar \program NonSimpleMethodReference #nsmr;

    \find (\modality{#allmodal}{.. #nsmr ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#nsmr); ...}\endmodality(post))
    \heuristics(simplify_autoname)
  };

  methodCallUnfoldTarget { 
    \schemaVar \program[list] Expression #elist ;
   	\schemaVar \program MethodName #mn;
   	\schemaVar \program NonSimpleExpression #nse;
   	
  
    \find (\modality{#allmodal}{.. #nse.#mn(#elist); ...}\endmodality(post)) 
    \varcond(\new(#v0, \typeof(#nse)))
    \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v0; 
                               #v0 = #nse; #v0.#mn(#elist); ...}\endmodality(post))
    \heuristics(simplify_autoname)
  };
  
  
/*  methodCall { 
    \schemaVar \program[list] SimpleExpression #selist ;
   	\schemaVar \program MethodName #mn;

    \find (\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 			    
		 					#method-call(#se.#mn(#selist));
				...}\endmodality(post))
    \heuristics(method_expand)
    \displayname "methodCall"
  };*/
  
  methodCall { 
    \schemaVar \program[list] SimpleExpression #selist ;
   	\schemaVar \program MethodName #mn;

    \find (\modality{#allmodal}{.. #mn(#selist); ...}\endmodality(post)) 
    \replacewith (\modality{#allmodal}{.. 			    
		 					#method-call(this.#mn(#selist));
				...}\endmodality(post))
    \heuristics(method_expand)
    \displayname "methodCall"
  };
  
  
   methodBodyExpand { 	
    \schemaVar \program NonModelMethodBody #mb; 
    \find (\modality{#allmodal}{.. #mb ...}\endmodality(post))
    \replacewith (#introAtPreDefs(\modality{#allmodal}{.. #expand-method-body(#mb); ...}\endmodality(post)))
    \heuristics(simplify_prog) 
  };
  
    array_push {        
        \schemaVar \program MethodName[name=push] #push;
        \find (==> \modality{#allmodal}{.. #v.#push(#se); ...}\endmodality(post))        
      \replacewith(==>
        {heap:=store(
          store(heap,#v,arr(int::select(heap,#v,arr_length)),#se),
          #v,
          arr_length,
          int::select(heap,#v,arr_length)+1
        )}\modality{#allmodal}{.. ...}\endmodality(post)
      )
      \heuristics(simplify_prog_subset,simplify)
      \displayname "array_push"	
    };
}

\rules(transfer:callBackPossible) {
    transferSucc {        
        \schemaVar \program MethodName[name=transfer] #transfer;
        \schemaVar \skolemTerm Heap anonStorage;
        \schemaVar \program ProgramMethod #pm ; 
        \schemaVar \program Type #t;
        \schemaVar \program Variable #v1;
        \schemaVar \program SimpleExpression #callee;
        

        \find (==> \modality{#allmodal}{.#pm@#t(#v1).. #callee.#transfer(#msg,#se); ...}\endmodality(post)) 
        \varcond ( \new(anonStorage, \dependingOn(post)) )       
        "Guarantee Invariant":\replacewith(==> {heap:=\if (#callee != #v1) \then (store(heap, net, address(#callee), int::select(heap, net, address(#callee)) - #se)) \else (heap)}CInv(heap,#v1));
        "Assume Invariant"   :\replacewith(==> {heap:=anon(heap, allLocs, anonStorage)}(CInv(heap,#v1) -> \modality{#allmodal}{.. ...}\endmodality(post)))
        \heuristics(simplify_prog_subset,simplify)
        \displayname "transfer" 
    };
}

\rules(transfer:noCallBack) {
    transferSucc {        
        \schemaVar \program MethodName[name=transfer] #transfer;
        \schemaVar \skolemTerm Heap anonStorage;
        \schemaVar \program ProgramMethod #pm ; 
        \schemaVar \program Type #t;
        \schemaVar \program Variable #v1;
        \schemaVar \program SimpleExpression #callee;
        

        \find (==> \modality{#allmodal}{.#pm@#t(#v1).. #callee.#transfer(#msg,#se); ...}\endmodality(post)) 
        \varcond ( \new(anonStorage, \dependingOn(post)) )       
        \replacewith(==> {heap:=\if (#callee != #v1) \then (store(heap, net, address(#callee), int::select(heap, net, address(#callee)) - #se)) \else (heap)}\modality{#allmodal}{.. ...}\endmodality(post))
        \heuristics(simplify_prog_subset,simplify)
        \displayname "transfer" 
    };
}
