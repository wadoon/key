\schemaVariables {
  \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
  \modalOperator { diamond, diamond_transaction } #dia;
  \modalOperator { box, box_transaction } #box;
  \formula post;

  \program SimpleExpression #se;
  \program LeftHandSide #lhs;
  \program Statement #body;
  \program[list] Statement #slist;
  \program Expression #nse;
  \program Label #lb, #lb1;

  \program Variable #x;
}

 /////////////////////////////////////////////////////
 // Rules transforming loops: Invariant & Unwinding //
 /////////////////////////////////////////////////////

\rules(programRules:Java, javaLoopTreatment:efficient) {
  loopScopeInvDia {
    \schemaVar \formula inv;
    \schemaVar \formula freeInv;
    \schemaVar \term any variantTerm;
    \schemaVar \formula loopFormula;
    \schemaVar \program Statement #loopStmt;
    \schemaVar \program Variable #variant;
    
    \schemaVar \skolemTerm Heap anon_heap_LOOP; 
    \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
    \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
     
    \schemaVar \program Variable #heapBefore_LOOP; 
    \schemaVar \program Variable #savedHeapBefore_LOOP; 
    \schemaVar \program Variable #permissionsBefore_LOOP; 
     
    \find ( (\modality{#dia} {.. while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#variant, any))
    \varcond(\new(#heapBefore_LOOP, Heap))
    \varcond(\new(#savedHeapBefore_LOOP, Heap))
    \varcond(\new(#permissionsBefore_LOOP, Heap))
   
    \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    // Implementation Note (DS, 2019-04-11): We have to separately store the active statement
    //   in a ProgramSV (and cannot just use the loopFormula already stored above) for the
    //   varconds below since otherwise, we get an error because KeY cannot compute the Taclet
    //   Prefix for loopFormula. It's obviously not possible (at least not without a change to
    //   something deep inside the KeY core which I don't dare to do now) to instantiate an
    //   unmatched TermSV in a varcond and use it in subsequent varconds. We could of course also
    //   just always pass the whole input formula, but that is also not really nice and handy.
    \varcond(\storeStmtIn(#loopStmt, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\not\hasLoopLabel(#loopStmt)) 
    \varcond(\hasInvariant(#loopStmt, #dia)) 
    \varcond(\getInvariant(#loopStmt, #dia, inv))
    \varcond(\getFreeInvariant(#loopStmt, #dia, freeInv))
    \varcond(\getVariant(#loopStmt, variantTerm))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Invariant Preserved and Used":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          {#variant:=variantTerm}
            (inv & freeInv ->
               (\modality{#dia}{
                  ..
                  boolean #x;
                  loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  (#x<<loopScopeIndex>> = TRUE -> post) & 
                  (#x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                    & prec(variantTerm, #variant))
                 )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  loopScopeInvDiaLabel {
    \schemaVar \formula inv;
    \schemaVar \formula freeInv;
    \schemaVar \term any variantTerm;
    \schemaVar \formula loopFormula;
    \schemaVar \program Statement #loopStmt;
    \schemaVar \program Variable #variant;
    
    \schemaVar \skolemTerm Heap anon_heap_LOOP; 
    \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
    \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
     
    \schemaVar \program Variable #heapBefore_LOOP; 
    \schemaVar \program Variable #savedHeapBefore_LOOP; 
    \schemaVar \program Variable #permissionsBefore_LOOP; 
     
    \find ( (\modality{#dia} {.. #lb: while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#variant, any))
    \varcond(\new(#heapBefore_LOOP, Heap))
    \varcond(\new(#savedHeapBefore_LOOP, Heap))
    \varcond(\new(#permissionsBefore_LOOP, Heap))
   
    \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\storeStmtIn(#loopStmt, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\hasInvariant(#loopStmt, #dia)) 
    \varcond(\getInvariant(#loopStmt, #dia, inv))
    \varcond(\getFreeInvariant(#loopStmt, #dia, freeInv))
    \varcond(\getVariant(#loopStmt, variantTerm))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Invariant Preserved and Used":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          {#variant:=variantTerm}
            (inv & freeInv ->
               (\modality{#dia}{
                  ..
                  boolean #x;
                  #lb: loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  (#x<<loopScopeIndex>> = TRUE -> post) & 
                  (#x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                    & prec(variantTerm, #variant))
                 )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  loopScopeInvBox {
    \schemaVar \formula inv;
    \schemaVar \formula freeInv;
    \schemaVar \formula loopFormula;
    \schemaVar \program Statement #loopStmt;
    
    \schemaVar \skolemTerm Heap anon_heap_LOOP; 
    \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
    \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
     
    \schemaVar \program Variable #heapBefore_LOOP; 
    \schemaVar \program Variable #savedHeapBefore_LOOP; 
    \schemaVar \program Variable #permissionsBefore_LOOP; 
     
    \find ( (\modality{#box} {.. while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#heapBefore_LOOP, Heap))
    \varcond(\new(#savedHeapBefore_LOOP, Heap))
    \varcond(\new(#permissionsBefore_LOOP, Heap))
    
    \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\storeStmtIn(#loopStmt, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\not\hasLoopLabel(#loopStmt)) 
    \varcond(\hasInvariant(#loopStmt, #box)) 
    \varcond(\getInvariant(#loopStmt, #box, inv))
    \varcond(\getFreeInvariant(#loopStmt, #box, freeInv))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Invariant Preserved and Used":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          (inv & freeInv ->
             (\modality{#box}{
                ..
                boolean #x;
                loop-scope(#x) {
                  if (#nse) { 
                    #body
                    continue;
                  } else {
                    break;
                  }
                }
                ...
              }\endmodality(
                (#x<<loopScopeIndex>> = TRUE -> post) & 
                (#x<<loopScopeIndex>> = FALSE -> 
                    inv & freeInv
                  & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP))
               )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  loopScopeInvBoxLabel {
    \schemaVar \formula inv;
    \schemaVar \formula freeInv;
    \schemaVar \formula loopFormula;
    \schemaVar \program Statement #loopStmt;
    
    \schemaVar \skolemTerm Heap anon_heap_LOOP; 
    \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
    \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
     
    \schemaVar \program Variable #heapBefore_LOOP; 
    \schemaVar \program Variable #savedHeapBefore_LOOP; 
    \schemaVar \program Variable #permissionsBefore_LOOP; 
     
    \find ( (\modality{#box} {.. #lb: while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#heapBefore_LOOP, Heap))
    \varcond(\new(#savedHeapBefore_LOOP, Heap))
    \varcond(\new(#permissionsBefore_LOOP, Heap))
    
    \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\storeStmtIn(#loopStmt, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\hasInvariant(#loopStmt, #box)) 
    \varcond(\getInvariant(#loopStmt, #box, inv))
    \varcond(\getFreeInvariant(#loopStmt, #box, freeInv))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Invariant Preserved and Used":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            (inv & freeInv ->
               (\modality{#box}{
                  ..
                  boolean #x;
                  #lb: loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  (#x<<loopScopeIndex>> = TRUE -> post) & 
                  (#x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP))
                 )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
    \heuristics(loop_scope_inv_taclet)
  };
}

// NOTE/TODO (DS, 2019-07-22): Update these unwinding rules!!! They don't work
// that way, since the assumed semantics of continues is different (had in the
// meantime been changed due to the attempt to use loop scopes for for loops).
// Safest to revert to the state of Nathan's thesis. Commenting out for now (unsound!!!). 
/*
\rules(programRules:Java) {
  unwindLoopScope { 
    \schemaVar \program Variable #cont;
    \schemaVar \program Statement #loopStmt;
    
    \find ( (\modality{#allmodal} {.. while (#nse) #body ... }\endmodality(post)) )

    \varcond(\storeStmtIn(#loopStmt, \modality{#allmodal}{ while (#nse) #body }\endmodality(post)))
    \varcond(\not\hasLoopLabel(#loopStmt))

    \varcond(\new(#x, boolean))
    \varcond(\new(#cont, boolean))

    \replacewith (
       (\modality{#allmodal}{
          ..
          boolean #x; boolean #cont;
          #x = true; #cont = false;
          loop-scope(#x) {
            if (#nse) {
              #body
              #x = false;
            }
            if (!#x) {
              #x = true;
              #cont = true;
            }
          }
          if (#cont) {
            #reattachLoopInvariant(
              while (#nse) {
                #body
              }
            );
          }
          ...
        }\endmodality(post))
    )
  
    \heuristics(loop_inv_taclets)
  };

  unwindLoopScopeLabel { 
    \schemaVar \program Variable #cont;
    
    \find ( (\modality{#allmodal} {.. #lb: while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#cont, boolean))

    \replacewith (
      {#x:=TRUE || #cont:=FALSE}
         (\modality{#allmodal}{
            ..
            loop-scope(#x) {
              if (#nse) #lb: {
                #body
                #x = false;
              }
              if (!#x) {
                #x = true;
                #cont = true;
              }
            }
            if (#cont) {
              #lb: #reattachLoopInvariant(
                while (#nse) {
                  #body
                }
              );
            }
            ...
          }\endmodality(post))
    )
  
    \heuristics(loop_scope_expand)
  };
}
*/

///////////////////////////////////////////////////
// Loop-Scope Based Three-Branch Invariant Rules //
///////////////////////////////////////////////////

\rules(programRules:Java, javaLoopTreatment:teaching) {
  threeBranchLoopScopeInvRuleDia {
    \schemaVar \formula inv;
    \schemaVar \formula freeInv;
    \schemaVar \term any variantTerm;
    \schemaVar \formula loopFormula;
    \schemaVar \program Statement #loopStmt;
    \schemaVar \program Variable #variant;
    
    \schemaVar \skolemTerm Heap anon_heap_LOOP; 
    \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
    \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
     
    \schemaVar \program Variable #heapBefore_LOOP; 
    \schemaVar \program Variable #savedHeapBefore_LOOP; 
    \schemaVar \program Variable #permissionsBefore_LOOP; 
     
    \find ( (\modality{#dia} {.. while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#variant, any))
    \varcond(\new(#heapBefore_LOOP, Heap))
    \varcond(\new(#savedHeapBefore_LOOP, Heap))
    \varcond(\new(#permissionsBefore_LOOP, Heap))
   
    \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\storeStmtIn(#loopStmt, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\not\hasLoopLabel(#loopStmt)) 
    \varcond(\hasInvariant(#loopStmt, #dia)) 
    \varcond(\getInvariant(#loopStmt, #dia, inv))
    \varcond(\getFreeInvariant(#loopStmt, #dia, freeInv))
    \varcond(\getVariant(#loopStmt, variantTerm))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Body Preserves Invariant":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          {#variant:=variantTerm}
            (inv & freeInv ->
               (\modality{#dia}{
                  ..
                  boolean #x;
                  loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  #x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                    & prec(variantTerm, #variant)
                 )))
      )

      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>);
      
    "Use Case":
      \replacewith (
        {   #createAbstractAnonUpdate(loopFormula) 
         || #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          {#variant:=variantTerm}
            (inv & freeInv ->
               (\modality{#dia}{
                  ..
                  boolean #x;
                  loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  #x<<loopScopeIndex>> = TRUE -> post
                 )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
    \heuristics(loop_scope_inv_taclet)
  };

  threeBranchLoopScopeInvRuleDiaLabel {
    \schemaVar \formula inv;
    \schemaVar \formula freeInv;
    \schemaVar \term any variantTerm;
    \schemaVar \formula loopFormula;
    \schemaVar \program Statement #loopStmt;
    \schemaVar \program Variable #variant;
    
    \schemaVar \skolemTerm Heap anon_heap_LOOP; 
    \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
    \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
     
    \schemaVar \program Variable #heapBefore_LOOP; 
    \schemaVar \program Variable #savedHeapBefore_LOOP; 
    \schemaVar \program Variable #permissionsBefore_LOOP; 
     
    \find ( (\modality{#dia} {.. #lb: while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#variant, any))
    \varcond(\new(#heapBefore_LOOP, Heap))
    \varcond(\new(#savedHeapBefore_LOOP, Heap))
    \varcond(\new(#permissionsBefore_LOOP, Heap))
   
    \varcond(\storeTermIn(loopFormula, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\storeStmtIn(#loopStmt, \modality{#dia}{ while (#nse) #body }\endmodality(post)))
    \varcond(\hasInvariant(#loopStmt, #dia)) 
    \varcond(\getInvariant(#loopStmt, #dia, inv))
    \varcond(\getFreeInvariant(#loopStmt, #dia, freeInv))
    \varcond(\getVariant(#loopStmt, variantTerm))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Body Preserves Invariant":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          {#variant:=variantTerm}
            (inv & freeInv ->
               (\modality{#dia}{
                  ..
                  boolean #x;
                  #lb: loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  #x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                    & prec(variantTerm, #variant)
                 )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>);
      
    "Use Case":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          {#variant:=variantTerm}
            (inv & freeInv ->
               (\modality{#dia}{
                  ..
                  boolean #x;
                  #lb: loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  #x<<loopScopeIndex>> = TRUE -> post
                 )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  threeBranchLoopScopeInvRuleBox {
    \schemaVar \formula inv;
    \schemaVar \formula freeInv;
    \schemaVar \formula loopFormula;
    \schemaVar \program Statement #loopStmt;
    
    \schemaVar \skolemTerm Heap anon_heap_LOOP; 
    \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
    \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
     
    \schemaVar \program Variable #heapBefore_LOOP; 
    \schemaVar \program Variable #savedHeapBefore_LOOP; 
    \schemaVar \program Variable #permissionsBefore_LOOP; 
     
    \find ( (\modality{#box} {.. while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#heapBefore_LOOP, Heap))
    \varcond(\new(#savedHeapBefore_LOOP, Heap))
    \varcond(\new(#permissionsBefore_LOOP, Heap))
    
    \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\storeStmtIn(#loopStmt, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\not\hasLoopLabel(#loopStmt)) 
    \varcond(\hasInvariant(#loopStmt, #box)) 
    \varcond(\getInvariant(#loopStmt, #box, inv))
    \varcond(\getFreeInvariant(#loopStmt, #box, freeInv))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Body Preserves Invariant":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          (inv & freeInv ->
             (\modality{#box}{
                ..
                boolean #x;
                loop-scope(#x) {
                  if (#nse) { 
                    #body
                    continue;
                  } else {
                    break;
                  }
                }
                ...
              }\endmodality(
                #x<<loopScopeIndex>> = FALSE -> 
                    inv & freeInv
                  & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
               )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>);
  
    "Use Case":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
          (inv & freeInv ->
             (\modality{#box}{
                ..
                boolean #x;
                loop-scope(#x) {
                  if (#nse) { 
                    #body
                    continue;
                  } else {
                    break;
                  }
                }
                ...
              }\endmodality(
                #x<<loopScopeIndex>> = TRUE -> post
               )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
    \heuristics(loop_scope_inv_taclet)
  };
  
  threeBranchLoopScopeInvRuleBoxLabel {
    \schemaVar \formula inv;
    \schemaVar \formula freeInv;
    \schemaVar \formula loopFormula;
    \schemaVar \program Statement #loopStmt;
    
    \schemaVar \skolemTerm Heap anon_heap_LOOP; 
    \schemaVar \skolemTerm Heap anon_savedHeap_LOOP; 
    \schemaVar \skolemTerm Heap anon_permissions_LOOP; 
     
    \schemaVar \program Variable #heapBefore_LOOP; 
    \schemaVar \program Variable #savedHeapBefore_LOOP; 
    \schemaVar \program Variable #permissionsBefore_LOOP; 
     
    \find ( (\modality{#box} {.. #lb: while (#nse) #body ... }\endmodality(post)) )

    \varcond(\new(#x, boolean))
    \varcond(\new(#heapBefore_LOOP, Heap))
    \varcond(\new(#savedHeapBefore_LOOP, Heap))
    \varcond(\new(#permissionsBefore_LOOP, Heap))
    
    \varcond(\storeTermIn(loopFormula, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\storeStmtIn(#loopStmt, \modality{#box}{ while (#nse) #body }\endmodality(post)))
    \varcond(\hasInvariant(#loopStmt, #box)) 
    \varcond(\getInvariant(#loopStmt, #box, inv))
    \varcond(\getFreeInvariant(#loopStmt, #box, freeInv))

    "Invariant Initially Valid":
      \replacewith(inv);

    "Body Preserves Invariant":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            (inv & freeInv ->
               (\modality{#box}{
                  ..
                  boolean #x;
                  #lb: loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  #x<<loopScopeIndex>> = FALSE -> 
                      inv & freeInv
                    & #createFrameCond(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP)
                 )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>);
  
    "Use Case":
      \replacewith (
        {   #createBeforeLoopUpdate(loopFormula, #heapBefore_LOOP, #savedHeapBefore_LOOP, #permissionsBefore_LOOP) 
         || #createLocalAnonUpdate(loopFormula)
         || #createHeapAnonUpdate(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP)}
            (inv & freeInv ->
               (\modality{#box}{
                  ..
                  boolean #x;
                  #lb: loop-scope(#x) {
                    if (#nse) { 
                      #body
                      continue;
                    } else {
                      break;
                    }
                  }
                  ...
                }\endmodality(
                  #x<<loopScopeIndex>> = TRUE -> post
                 )))
      )
      
      \add (#wellFormedCond(loopFormula, anon_heap_LOOP, anon_savedHeap_LOOP, anon_permissions_LOOP) ==>)
  
    \heuristics(loop_scope_inv_taclet)
  };
}
  
////////////////////////////////
// Rules Handling Loop Scopes //
////////////////////////////////

// TODO (2019-07-22): Update loop scopes rules due to new version in thesis

\rules(programRules:Java) {
  emptyIndexedLoopScope {
      \find (\modality{#allmodal}{.. loop-scope(#lhs) {} ...}\endmodality(post))
      \replacewith (
        \if (#lhs = TRUE) 
        \then (\modality{#allmodal}{.. ...}\endmodality(post))
        \else (\modality{#allmodal}{}\endmodality(post)))
      \heuristics(simplify_prog)
  };// NOTE (DS, 2019-02-15): This works because the loop body is put into
  //   a block by the loop scope invariant rule, and the other rules drop
  //   the rest of the block when encountering a continue. We have to keep
  //   that context since #slist will contain a program added by the loop
  //   scope invariant or unwinding rules, which sets some continue variable
  //   or executes a for loop update. See, for instance, blockContinue as
  //   an example for why this will work (and, of course, the invariant /
  //   unwinding rules).
  unlabeledContinueIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { continue; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. loop-scope(#lhs) { #lhs = false; #slist } ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  blockLoopScopes {
      \find        (\modality{#allmodal}{.. { loop-scope(#lhs) { #slist }  } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. loop-scope(#lhs) { #slist } ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  labeledContinueIndexedLoopScope {
      
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  throwIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { throw #se; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. #lhs = true; throw #se; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  returnIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { return #se; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; return #se; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  emptyReturnIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { return; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; return; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  labeledBreakIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { break #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..  #lhs = true; break #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  unlabeledBreakIndexedLoopScope {
      \find        (\modality{#allmodal}{.. loop-scope(#lhs) { break; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..#lhs = true; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

////////////////////////////////
//// Loop Scope-Related Rules //
////////////////////////////////

  blockContinue {
      \find        (\modality{#allmodal}{.. { continue; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   continue; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockBreak {
      \find        (\modality{#allmodal}{.. { break; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   break; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockContinueLabeled {
      \find        (\modality{#allmodal}{.. { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  
  blockBreakLabeled {
      \find        (\modality{#allmodal}{.. { break #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{..   break #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
  blockContinueNoMatch {
      \find        (\modality{#allmodal}{.. #lb1: { continue #lb; #slist } ...}\endmodality(post))
      \varcond (\different (#lb1, #lb))
      \replacewith (\modality{#allmodal}{.. continue #lb; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };

  blockContinueLabel {
      \find        (\modality{#allmodal}{.. #lb: { continue #lb; #slist } ...}\endmodality(post))
      \replacewith (\modality{#allmodal}{.. continue; ...}\endmodality(post))
      \heuristics(simplify_prog)
  };
}
