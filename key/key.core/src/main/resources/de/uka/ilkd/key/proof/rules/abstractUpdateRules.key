\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
    \generic G;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    \modalOperator { diamond, diamond_transaction } #dia;
    \modalOperator { box, box_transaction } #box;
    
    \formula fml, post;
    \update upd;
    
    \program[list] Statement #slist, #slist1, #slist2;
    \program Statement #s;
    \program Expression #e, #e1, #e2;
    \program Variable #normal, #exc, #returns, #result, #breaks, #continues;
    \program Variable #v, #v1;
    \program[list] Variable #vars, #vars1;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label, #label1;
    \program[list] Label #labels, #labels1;

    \program SimpleExpression #se;
    \program LeftHandSide #lhs;
    \program Statement #body;
    \program Variable #x;
}

\heuristicsDecl {
    abstractExecution;
    abstrUpdPriorityRules;
    abstrUpdLowPrioRules;
    abstrUpdLowestPrioRules;
    abstr_upd_commute;
}

\rules(programRules:Java) {
    // Rules directly treating abstract updates
    
    applyOnAbstractUpdate {
        \schemaVar \update u1, u2, result;    
    
        \find({u1}u2)
        \varcond(\abstractUpdate(u2))
        \varcond(\applyOnAbstractUpdate(u1, u2, result))
    
        \replacewith(result)
        \heuristics(update_apply_on_update)
    };
    
    // Simplifies, e.g., 
    //   U_P(x!,y!,someloc:=accessibles)
    // to
    //   U_P(_,_,someloc:=accessibles)||x:=f_P_1(accessibles)||y:=f_P_2(accessibles)
    abstractUpdateToElementaryUpdates {
        \schemaVar \update u, result;
        
        \find(u)
        \varcond(\abstractUpdate(u))
        \varcond(\abstractUpdateToElementaryUpdates(u, result))
        
        \replacewith(result)
	    \heuristics(update_elim)
    };
    
    applyUpdateOnParametricValueTerm {
        \schemaVar \update u;
        \schemaVar \term LocSet paramSkLs;
        \schemaVar \term any result;
        
        \find ( {u} value(paramSkLs) )
        \varcond (\applyUpdateOnParametricValueTerm(u, paramSkLs, result))
        
        \replacewith (result)
        \heuristics (update_elim)
    };
    
    // NOTE: Converted into a built-in rule, taclets are not flexible enough.
    //       E.g., need a dynamic number of assumes terms, one for every part
    //       of the frame. Also, it's difficult to ensure that the taclet gets
    //       called again if the assumptions changed.
    /*
    // !elementOf(o,f,frame) -> 
    //      G::select({... || U_P(frame:=...) || ...}h, o, f)
    //    = G::select({... || ... }h, o, f)
    dropAbstractUpdateInSelect {
		\schemaVar \term Heap h;
		\schemaVar \term Object o;
		\schemaVar \term Field f;
		\schemaVar \update u, result;
		\schemaVar \term LocSet frame;
        
        \assumes(==> elementOf(o,f,frame))
        
    	\find(G::select({u}h, o, f))
        \varcond(\containsAbstractUpdate(u))
        \varcond(\simplifyAbstractUpdateInSelect(u, o, f, frame, result))
        
    	\replacewith(G::select({result}h, o, f))
    	\heuristics(update_elim)
    };
    */
}
