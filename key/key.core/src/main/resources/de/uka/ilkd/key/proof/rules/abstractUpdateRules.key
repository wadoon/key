\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
    \generic G;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    \modalOperator { diamond, diamond_transaction } #dia;
    \modalOperator { box, box_transaction } #box;
    
    \formula fml, post;
    \update upd;
    
    \program[list] Statement #slist, #slist1, #slist2;
    \program Statement #s;
    \program Expression #e, #e1, #e2;
    \program Variable #normal, #exc, #returns, #result, #breaks, #continues;
    \program Variable #v, #v1;
    \program[list] Variable #vars, #vars1;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label, #label1;
    \program[list] Label #labels, #labels1;

    \program SimpleExpression #se;
    \program LeftHandSide #lhs;
    \program Statement #body;
    \program Variable #x;
}

\heuristicsDecl {
    abstractExecution;
    abstrUpdPriorityRules;
    abstrUpdLowPrioRules;
    abstrUpdLowestPrioRules;
}

\rules(programRules:Java) {
    applyOnAbstractUpdate {
        \schemaVar \update u1, u2, result;    
    
        \find({u1}u2)
        \varcond(\abstractUpdate(u2))
        \varcond(\applyOnAbstractUpdate(u1, u2, result))
    
        \replacewith(result)
        \heuristics(update_apply_on_update)
    };
    
    // Simplifies, e.g., 
    //   U_P(x!,y!,someloc:=accessibles)
    // to
    //   U_P(_,_,someloc:=accessibles)||x:=f_P_1(accessibles)||y:=f_P_2(accessibles)
    abstractUpdateToElementaryUpdates {
        \schemaVar \update u, result;
        
        \find(u)
        \varcond(\abstractUpdate(u))
        \varcond(\abstractUpdateToElementaryUpdates(u, result))
        
        \replacewith(result)
	    \heuristics(update_elim)
    };
    
    applyUpdateOnParametricValueTerm {
        \schemaVar \update u;
        \schemaVar \term LocSet paramSkLs;
        \schemaVar \term any result;
        
        \find ( {u} value(paramSkLs) )
        \varcond (\applyUpdateOnParametricValueTerm(u, paramSkLs, result))
        
        \replacewith (result)
        \heuristics (update_elim)
    };
    
    dropStoreToDisjointAbstractLocSet1 {
		\schemaVar \term Heap h;
		\schemaVar \term Object o;
		\schemaVar \term Field f;
		\schemaVar \term any t;
		\schemaVar \term LocSet frame;
        
        \assumes(==> elementOf(o,f,frame))
    	\find({heap:=store(h, o, f, t)} value(frame))
    	        
    	\replacewith({heap:=h} value(frame))
    	
    	\heuristics(update_elim)
        \displayname "dropStoreToDisjointAbstractLocSet"
    };
    
    dropStoreToDisjointAbstractLocSet2 {
        \schemaVar \update u;
		\schemaVar \term Heap h;
		\schemaVar \term Object o;
		\schemaVar \term Field f;
		\schemaVar \term any t;
		\schemaVar \term LocSet frame;
        
        \assumes(==> elementOf(o,f,frame))
    	\find({u || heap:=store(h, o, f, t)} value(frame))
    	        
    	\replacewith({u || heap:=h} value(frame))
    	
    	\heuristics(update_elim)
        \displayname "dropStoreToDisjointAbstractLocSet"
    };
    
    // Motivation for the following rule:
    // Either, u2 does not assign the heap, then it can be dropped anyway.
    // If it, however, assigns the heap, it overrides the first update.
    // Therefore, we can flatten the abstract heap update.
    flattenAbstractHeapUpdate {
        \schemaVar \update u1, u2;
        
        \find({heap:={u1}heap || u2} heap)
        \varcond(\abstractUpdate(u1))
        
        \replacewith({u1 || u2} heap)
        
	    \heuristics(update_elim)
    };
    
    // The following rule is needed for relational proofs,
    // where the target of the update is an abstract location
    // set on which the concrete update cannot be concretely
    // applied. The rule establishes a normal form. It is needed,
    // e.g., in the extract method refactoring proof.
    pushHeapUpdateToEnd1 {
        \schemaVar \term Heap t1;
        \schemaVar \term any t2;
        
        \find(heap := t1 || #v := t2)
        \varcond(\not \same (\typeof(#v), Heap))
        
        \replacewith(#v := t2 || heap := t1)
        
	    \heuristics(update_elim)
        \displayname "pushHeapUpdateToEnd"
    };
    
    pushHeapUpdateToEnd2 {
        \schemaVar \update u;
        \schemaVar \term Heap t1;
        \schemaVar \term any t2;
        
        \find(u || heap := t1 || #v := t2)
        \varcond(\not \same (\typeof(#v), Heap))
        
        \replacewith(u || #v := t2 || heap := t1)
        
	    \heuristics(update_elim)
        \displayname "pushHeapUpdateToEnd"
    };

    abstractUpdateDoesNotDestroyObjects {
        \schemaVar \update u;
        \schemaVar \term Object o;

        \assumes(boolean::select(heap, o, java.lang.Object::<created>) = TRUE ==>)
        \find(boolean::select({u}heap, o, java.lang.Object::<created>) = TRUE)
        \sameUpdateLevel

        \varcond(\abstractUpdate(u))

        \replacewith(true)
        \heuristics(update_elim)
    };
    
    // NOTE: Converted into a built-in rule, taclets are not flexible enough.
    //       E.g., need a dynamic number of assumes terms, one for every part
    //       of the frame. Also, it's difficult to ensure that the taclet gets
    //       called again if the assumptions changed.
    /*
    // !elementOf(o,f,frame) -> 
    //      G::select({... || U_P(frame:=...) || ...}h, o, f)
    //    = G::select({... || ... }h, o, f)
    dropAbstractUpdateInSelect {
		\schemaVar \term Heap h;
		\schemaVar \term Object o;
		\schemaVar \term Field f;
		\schemaVar \update u, result;
		\schemaVar \term LocSet frame;
        
        \assumes(==> elementOf(o,f,frame))
        
    	\find(G::select({u}h, o, f))
        \varcond(\containsAbstractUpdate(u))
        \varcond(\simplifyAbstractUpdateInSelect(u, o, f, frame, result))
        
    	\replacewith(G::select({result}h, o, f))
    	\heuristics(update_elim)
    };
    */
}
