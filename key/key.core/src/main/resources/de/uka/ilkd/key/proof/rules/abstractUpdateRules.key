\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
    \generic G;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    \modalOperator { diamond, diamond_transaction } #dia;
    \modalOperator { box, box_transaction } #box;
    
    \formula fml, post;
    \update upd;
    
    \program[list] Statement #slist, #slist1, #slist2;
    \program Statement #s;
    \program Expression #e, #e1, #e2;
    \program Variable #normal, #exc, #returns, #result, #breaks, #continues;
    \program Variable #v, #v1;
    \program[list] Variable #vars, #vars1;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label, #label1;
    \program[list] Label #labels, #labels1;

    \program SimpleExpression #se;
    \program LeftHandSide #lhs;
    \program Statement #body;
    \program Variable #x;
}

\heuristicsDecl {
    abstractExecution;
    abstrUpdPriorityRules;
    abstrUpdLowPrioRules;
    abstrUpdLowestPrioRules;
}

\rules(programRules:Java) {
    applyOnAbstractUpdate {
        \schemaVar \update u1, u2, result;    
    
        \find({u1}u2)
        \varcond(\abstractUpdate(u2))
        \varcond(\applyOnAbstractUpdate(u1, u2, result))
    
        \replacewith(result)
        \heuristics(update_apply_on_update)
    };
    
    // Simplifies, e.g., 
    //   U_P(x!,y!,someloc:=accessibles)
    // to
    //   U_P(_,_,someloc:=accessibles)||x:=f_P_1(accessibles)||y:=f_P_2(accessibles)
    abstractUpdateToElementaryUpdates {
        \schemaVar \update u, result;
        
        \find(u)
        \varcond(\abstractUpdate(u))
        \varcond(\abstractUpdateToElementaryUpdates(u, result))
        
        \replacewith(result)
	    \heuristics(update_elim)
    };
    
    applyUpdateOnParametricValueTerm {
        \schemaVar \update u;
        \schemaVar \term LocSet paramSkLs;
        \schemaVar \term any result;
        
        \find ( {u} value(paramSkLs) )
        \varcond (\applyUpdateOnParametricValueTerm(u, paramSkLs, result))
        
        \replacewith (result)
        \heuristics (update_elim)
    };
    
    dropStoreToDisjointAbstractLocSet1 {
		\schemaVar \term Heap h;
		\schemaVar \term Object o;
		\schemaVar \term Field f;
		\schemaVar \term any t;
		\schemaVar \term LocSet frame;
        
        \assumes(==> elementOf(o,f,frame))
    	\find({heap:=store(h, o, f, t)} value(frame))
    	        
    	\replacewith({heap:=h} value(frame))
    	
    	\heuristics(update_elim)
        \displayname "dropStoreToDisjointAbstractLocSet"
    };
    
    dropStoreToDisjointAbstractLocSet2 {
        \schemaVar \update u;
		\schemaVar \term Heap h;
		\schemaVar \term Object o;
		\schemaVar \term Field f;
		\schemaVar \term any t;
		\schemaVar \term LocSet frame;
        
        \assumes(==> elementOf(o,f,frame))
    	\find({u || heap:=store(h, o, f, t)} value(frame))
    	        
    	\replacewith({u || heap:=h} value(frame))
    	
    	\heuristics(update_elim)
        \displayname "dropStoreToDisjointAbstractLocSet"
    };
    
    // Motivation for the following rule:
    // Either, u2 does not assign the heap, then it can be dropped anyway.
    // If it, however, assigns the heap, it overrides the first update.
    // Therefore, we can flatten the abstract heap update.
    flattenAbstractHeapUpdate {
        \schemaVar \update u1, u2;
        
        \find({heap:={u1}heap || u2} heap)
        \varcond(\abstractUpdate(u1))
        
        \replacewith({u1 || u2} heap)
        
	    \heuristics(update_elim)
    };
    
    // The following rule is needed for relational proofs,
    // where the target of the update is an abstract location
    // set on which the concrete update cannot be concretely
    // applied. The rule establishes a normal form. It is needed,
    // e.g., in the extract method refactoring proof.
    pushHeapUpdateToEnd1 {
        \schemaVar \term Heap t1;
        \schemaVar \term any t2;
        
        \find(heap := t1 || #v := t2)
        \varcond(\not \same (\typeof(#v), Heap))
        
        \replacewith(#v := t2 || heap := t1)
        
	    \heuristics(update_elim)
        \displayname "pushHeapUpdateToEnd"
    };
    
    pushHeapUpdateToEnd2 {
        \schemaVar \update u;
        \schemaVar \term Heap t1;
        \schemaVar \term any t2;
        
        \find(u || heap := t1 || #v := t2)
        \varcond(\not \same (\typeof(#v), Heap))
        
        \replacewith(u || #v := t2 || heap := t1)
        
	    \heuristics(update_elim)
        \displayname "pushHeapUpdateToEnd"
    };

    abstractHeapUpdate {
        \schemaVar \update u;
        \schemaVar \term LocSet frame;
        \schemaVar \term Heap h;
        \schemaVar \term Heap heapTransf;

        \find({u}h)

        \varcond(\abstractUpdate(u))
        \varcond(\storeAbstractUpdateFrame(u, frame))
        \varcond(\getAbstractUpdateHeapTransformer(u, heapTransf))

        \replacewith(anon(h, frame, heapTransf))
        \add(wellFormed(heapTransf) ==>)

        \heuristics(update_elim)
    };

    reorderAbstractAnon1 {
      \schemaVar \term LocSet frameP;
      \schemaVar \term LocSet frameQ;
      \schemaVar \term Heap h;
      \schemaVar \term Heap anonP;
      \schemaVar \term Heap anonQ;

      \assumes(intersect(frameP, frameQ) = empty ==>)
      \find(anon(anon(heap, frameP, anonP), frameQ, anonQ))

      \varcond(\syntacticallySmaller(frameP, frameQ))

      \replacewith(anon(anon(heap, frameQ, anonQ), frameP, anonP))

      \heuristics(simplify)
    };

    reorderAbstractAnon2 {
      \schemaVar \term LocSet frameP;
      \schemaVar \term LocSet frameQ;
      \schemaVar \term Heap h;
      \schemaVar \term Heap anonP;
      \schemaVar \term Heap anonQ;

      \assumes(intersect(frameQ, frameP) = empty ==>)
      \find(anon(anon(heap, frameP, anonP), frameQ, anonQ))

      \varcond(\syntacticallySmaller(frameP, frameQ))

      \replacewith(anon(anon(heap, frameQ, anonQ), frameP, anonP))

      \heuristics(simplify)
    };
}
