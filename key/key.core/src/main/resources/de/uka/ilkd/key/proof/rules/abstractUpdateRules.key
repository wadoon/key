\sorts {
    \abstract java.lang.Throwable \extends java.lang.Object;
    \generic G;
}

\schemaVariables {
    \modalOperator { diamond, box, diamond_transaction, box_transaction } #allmodal;
    \modalOperator { diamond, diamond_transaction } #dia;
    \modalOperator { box, box_transaction } #box;
    
    \formula fml, post;
    \update upd;
    
    \program AbstractProgram #absProg;
    \program[list] Statement #slist, #slist1, #slist2;
    \program Statement #s;
    \program Expression #e, #e1, #e2;
    \program Variable #normal, #exc, #returns, #result, #breaks, #continues;
    \program Variable #v, #v1;
    \program[list] Variable #vars, #vars1;
    \program ExecutionContext #ctx, #ctx1;
    \program Label #label, #label1;
    \program[list] Label #labels, #labels1;

    \program SimpleExpression #se;
    \program LeftHandSide #lhs;
    \program Statement #body;
    \program Variable #x;
}

\heuristicsDecl {
    abstractExecution;
    abstrUpdPriorityRules;
    abstrUpdLowPrioRules;
    abstrUpdLowestPrioRules;
    abstr_upd_commute;
}

\rules(programRules:Java) {
    applyOnAbstractUpdate {
        \schemaVar \update u1, u2, result;    
    
        \find({u1}u2)
        \varcond(\abstractUpdate(u2))
        \varcond(\applyOnAbstractUpdate(u1, u2, result))
    
        \replacewith(result)
        \heuristics(update_apply_on_update)
    };
    
    /*
    dropEffectlessAbstractUpdate1 {
        \schemaVar \update u, result;
        \schemaVar \term [nonrigid] any t;
       
        \find({u}t) 
        
        \varcond(\abstractUpdate(u))
        \varcond(\dropEffectlessAbstractUpdate(u, t, result))
        
        \replacewith({result}t)
        \heuristics(abstrUpdPriorityRules)
    };

    dropEffectlessAbstractUpdate2 {
        \schemaVar \update u, result;
        \schemaVar \formula [nonrigid] phi;
       
        \find({u}phi) 
        
        \varcond(\abstractUpdate(u))
        \varcond(\dropEffectlessAbstractUpdate(u, phi, result))
        
        \replacewith({result}phi)
        \heuristics(abstrUpdPriorityRules)
    };
    
    sequentialToConcatenatedAbs {
        \schemaVar \update u, u2;
        \schemaVar \formula phi;    
    
        \find({u}{u2} phi)
        \varcond(\abstractUpdate(u))
        \varcond(\abstractUpdate(u2))
    
        \replacewith({u ++ u2} phi)
    
        \heuristics(abstrUpdLowestPrioRules)
    };
   
    sequentialToConcatenatedAbsTerm {
        \schemaVar \update u, u2;
        \schemaVar \term any t;    
    
        \find({u}{u2} t)
        \varcond(\abstractUpdate(u))
        \varcond(\abstractUpdate(u2))
    
        \replacewith({u ++ u2} t)
    
        \heuristics(abstrUpdLowestPrioRules)
    };
   
    sequentialToConcatenated {
        \schemaVar \update u, u2;
        \schemaVar \formula phi;    
    
        \find({u}{u2} phi)
    
        \replacewith({u ++ u2} phi)
    };
   
    applyAbstrOnConcrUpd {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result;
       
        \find({u1}{u2}phi) 
        
        \varcond(\abstractUpdate(u1))
        \varcond(\not\abstractUpdate(u2))
        
        \varcond(\applyAbstrOnConcrUpdate(u1, u2, phi, result))
        
        \replacewith(result)
        \heuristics(abstrUpdPriorityRules)
    };

    applyConcrOnAbstrUpd {
        \schemaVar \update u1, u2;
        \schemaVar \formula phi, result;
       
        \find({u1}{u2}phi)
        
        \varcond(\not\abstractUpdate(u1))
        \varcond(\abstractUpdate(u2))
        
        \varcond(\applyConcrOnAbstrUpdate(u1, u2, phi, result))
        
        \replacewith(result)
        \heuristics(abstrUpdLowestPrioRules)
    };

    applyConcrOnAbstrUpdTerm {
        \schemaVar \update u1, u2;
        \schemaVar \term any t, result;
       
        \find({u1}{u2}t)
        
        \varcond(\not\abstractUpdate(u1))
        \varcond(\abstractUpdate(u2))
        
        \varcond(\applyConcrOnAbstrUpdate(u1, u2, t, result))
        
        \replacewith(result)
        \heuristics(abstrUpdLowestPrioRules)
    };
    
    // Simplifies formulas like
    //
    //   {U_P(a, x, c := rhs)}t(x) = {U_P(a, y, c := rhs)}t(y)
    //
    // to "true". The "x" has to be at the exact position of the 
    // "y". Situations like that arise for renamings, the terms
    // should evaluate to the same result. 
    abstractUpdateTermsUnification {
    	\schemaVar \update u1, u2;
    	\schemaVar \term any t1, t2;
    	
    	\find({u1}t1 = {u2}t2)
    	
    	\varcond(\canUnifyAbstrUpdLHSForTargets(u1, t1, u2, t2))
    	
    	\replacewith(true)
    	
        \heuristics(abstrUpdPriorityRules)
    };
    
    simplifyAbstractUpdate1 {
        \schemaVar \update u, result;
        \schemaVar \term [nonrigid] any t;
       
        \find({u}t) 
        
        \varcond(\abstractUpdate(u))
        \varcond(\dropEffectlessAbstractUpdateAssignments(u, t, result))
        
        \replacewith({result}t)
        \heuristics(abstrUpdPriorityRules)
    };

    simplifyAbstractUpdate2 {
        \schemaVar \update u, result;
        \schemaVar \formula [nonrigid] phi;
       
        \find({u}phi) 
        
        \varcond(\abstractUpdate(u))
        \varcond(\dropEffectlessAbstractUpdateAssignments(u, phi, result))
        
        \replacewith({result}phi)
        \heuristics(abstrUpdPriorityRules)
    };

    commuteConcatenatedAbstractUpdates1 {
        \schemaVar \update uleft, uright;
        
        \find(uleft ++ uright)
        
        \varcond(\abstractUpdate(uleft))
        \varcond(\abstractUpdate(uright))
        \varcond(\abstrUpdatesIndependent(uleft, uright))
        
        \replacewith(uright ++ uleft)
        
        \heuristics(abstr_upd_commute)
    };
    
    commuteConcatenatedAbstractUpdates2 {
        \schemaVar \update uleft, uright, r;
        
        \find((r ++ uleft) ++ uright)
        
        \varcond(\abstractUpdate(uleft))
        \varcond(\abstractUpdate(uright))
        \varcond(\abstrUpdatesIndependent(uleft, uright))
        
        \replacewith((r ++ uright) ++ uleft)
        
        \heuristics(abstr_upd_commute)
    };
    
    updateConcatAssoc {
        \schemaVar \update uleft, uright, r;
        
        \find(uleft ++ (uright ++ r))
        
        \replacewith(uleft ++ uright ++ r)
        
        \heuristics(abstrUpdPriorityRules)
    };
    */
    
    // The following are heap rules which are only allowed in abstract
    // update scope. Normally, we have to perform a pull out before, but
    // this does not work with abstract updates because generally, we can
    // never substitute the simplified value back and therefore won't be
    // able to close the proofs.
    
    selectOfStoreAbstrUpdScope {
	  \schemaVar \term Heap h;
	  \schemaVar \term Object o, o2;
	  \schemaVar \term Field f, f2;
	  \schemaVar \term alpha x;

	  \find(beta::select(store(h, o, f, x), o2, f2))
	  \inAbstractUpdateScope

	  \replacewith(\if(o = o2 & f = f2 & f != java.lang.Object::<created>)
                   \then((beta)x)
                   \else(beta::select(h, o2, f2)))
	  \heuristics(simplify)
    };

   
    // The following quantifier rules allow quantifier treatment
    // below multiple updates, which we need for abstract execution
    // where updates cannot be always be merged to one. This is,
    // however, no nice solution: It would be better to have generic
    // "update context" SVs (and corresponding notations) in which
    // preceding updates can explicitly be stored. 
    
    allLeftUpdLevel1 {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find ({u1} (\forall v; phi) ==>)
  	  \add  ({u1} ({\subst v; t}(phi)) ==>)
  	  \heuristics(gamma)
    };
    
    allLeftUpdLevel2 {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1, u2;
      
  	  \find ({u1}{u2} (\forall v; phi) ==>)
  	  \add  ({u1}{u2} ({\subst v; t}(phi)) ==>)
    };
    
    allLeftUpdLevel2a {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find ({u1} (\modality{#allmodal}{ #slist }\endmodality(\forall v; phi)) ==>)
  	  \add  ({u1} (\modality{#allmodal}{ #slist }\endmodality({\subst v; t}(phi))) ==>)
    };
    
    allLeftHideUpdLevel2a {
      \schemaVar \variables G v;
      \schemaVar \term G t;
      \schemaVar \formula phi;
      \schemaVar \update u1;
      
  	  \find         ({u1} (\modality{#allmodal}{ #slist }\endmodality(\forall v; phi)) ==>)
  	  \replacewith  ({u1} (\modality{#allmodal}{ #slist }\endmodality({\subst v; t}(phi))) ==>)
      \addrules (insert_hidden { \add ({u1} (\modality{#allmodal}{ #slist }\endmodality(\forall v; phi)) ==>) })
    };
    
    // The following are rules preprocessing formulas such that they are
    // processable by succedent/antecedent taclets that normally only apply
    // to formulas under at most one update. We need this because with
    // abstract updates, we cannot / do not always simplify them to one
    // update, such that we often have nested update applications at the end.
    
    splitImp {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi -> psi))
        \replacewith({u}phi -> {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitAnd {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi & psi))
        \replacewith({u}phi & {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitOr {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi | psi))
        \replacewith({u}phi | {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 

    splitBiimp {
        \schemaVar \update u;
        \schemaVar \formula phi, psi;
        
        \find({u}(phi <-> psi))
        \replacewith({u}phi <-> {u}psi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
    
    splitNot {
        \schemaVar \update u;
        \schemaVar \formula phi;
        
        \find({u}(!phi))
        \replacewith(!{u}phi)

        \heuristics(abstrUpdLowestPrioRules)
    }; 
}
