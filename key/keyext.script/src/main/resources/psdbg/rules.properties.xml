<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
<comment>Generated on: Sat Sep 09 21:55:35 CEST 2017. Use extractDocumentation.groovy</comment>
<entry key="wd_Logical_Op_Or">wd_Logical_Op_Or {
\find(WD(or(a,b)))
\replacewith(or(or(and(WD(a),a),and(WD(b),b)),and(WD(a),WD(b)))) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="wd_Type_Cast">wd_Type_Cast {
\find(wd(alpha::cast(t)))
\replacewith(and(wd(t),equals(alpha::instance(t),TRUE))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="assignmentThis">assignment_write_attribute_this {
\find(==&gt;#allmodal ( (modal operator))\[{ .. #v.#a=#se; ... }\] (post))
\varcond( \not \static(#a (program Variable)), \isThisReference (#v (program Variable)), )
\replacewith([]==&gt;[writePermission(Permission::select(permissions,#v,#memberPVToField(#a)))]) ;
\replacewith([]==&gt;[update-application(elem-update(heap)(store(heap,#v,#memberPVToField(#a),#se)),#allmodal(post))]) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {runtimeExceptions:ban,programRules:Java}}</entry>
<entry key="expand_subJlong">expand_subJlong {
\find(subJlong(i,i1))
\replacewith(moduloLong(sub(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="wd_LocSet_Singleton_Quant">wd_LocSet_Singleton_Quant {
\find(all{c (variable)}(wd(singleton(o,f))))
\varcond(\isArray(o (java.lang.Object term)), )
\replacewith(all{c (variable)}(and(wd(o),wd(f)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="repeatStarAxiom">repeatStarAxiom {
\find(match(repeatStar(rexp),string))
\varcond(\notFreeIn(nTimes (variable), string (Seq term)), \notFreeIn(nTimes (variable), rexp (RegEx term)))
\replacewith(exists{nTimes (variable)}(and(geq(nTimes,Z(0(#))),match(repeat(rexp,nTimes),string)))) 
\heuristics(simplify)
Choices: {Strings:on}}</entry>
<entry key="createdInHeapWithSetMinusFreshLocsEQ">createdInHeapWithSetMinusFreshLocsEQ {
\assumes ([equals(setMinus(s,freshLocs(h)),EQ)]==&gt;[]) 
\find(createdInHeap(EQ,h))
\sameUpdateLevel\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="setMinusUnfold">setMinusUnfoldRight {
\find(#allmodal ( (modal operator))\[{ .. #v=\set_minus(#seLeft,#nseRight); ... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseRight) #vRightNew = #nseRight;#v=\set_minus(#seLeft,#vRightNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="getOfMapOverride">getOfMapOverride {
\find(mapGet(mapOverride(m0,m1),x))
\sameUpdateLevel\replacewith(if-then-else(inDomain(m1,x),mapGet(m1,x),mapGet(m0,x))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="emptyEqualsSingleton">emptyEqualsSingleton {
\find(equals(empty,singleton(o,f)))
\replacewith(false) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="polySimp_mulComm1">polySimp_mulComm1 {
\find(mul(mul(i0,commLeft),commRight))
\replacewith(mul(mul(i0,commRight),commLeft)) 
\heuristics(polySimp_mulOrder, polySimp_expand)
Choices: {}}</entry>
<entry key="polySimp_mulComm0">polySimp_mulComm0 {
\find(mul(commLeft,commRight))
\replacewith(mul(commRight,commLeft)) 
\heuristics(polySimp_mulOrder, polySimp_expand)
Choices: {}}</entry>
<entry key="greater_or_equal">compound_greater_equal_than_comparison_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e&gt;=#nse0; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse0) #v1 = #nse0;#lhs=#v0&gt;=#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="bprod_shift_index">bprod_shift_index {
\find(bprod{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bprod{uSub1 (variable)}(Z(0(#)),sub(i1,i0),subst{uSub (variable)}(add(uSub1,i0),t))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="add_sub_step">add_sub_step {
\find(add(neg(i),neg(i0)))
\replacewith(neg(add(i,i0))) 

Choices: {}}</entry>
<entry key="wd_T_Logical_Op_ExCond_Form">wd_T_Logical_Op_ExCond_Form {
\find(T(ifExThenElse{j (variable)}(a,b,c)))
\varcond(\notFreeIn(j (variable), jPrime (int skolem term)), \notFreeIn(j (variable), c (formula)))
\replacewith(or(or(exists{j (variable)}(and(and(T(a),T(b)),imp(and(wellOrderLeqInt(jPrime,j),not(equals(jPrime,j))),subst{j (variable)}(jPrime,F(a))))),all{j (variable)}(and(F(a),T(c)))),all{j (variable)}(and(T(b),T(c))))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="elementOfArrayRangeEQ">elementOfArrayRangeEQ {
\assumes ([equals(arrayRange(o2,lower,upper),EQ)]==&gt;[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\varcond(\notFreeIn(iv (variable), upper (int term)), \notFreeIn(iv (variable), lower (int term)), \notFreeIn(iv (variable), f (Field term)))
\replacewith(and(equals(o,o2),exists{iv (variable)}(and(and(equals(f,arr(iv)),leq(lower,iv)),leq(iv,upper))))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="notInDomain">notInDomain {
\find(==&gt;inDomain(m,x))
\add [equals(mapGet(m,x),mapUndef)]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {}}</entry>
<entry key="wd_Heap_Create">wd_Heap_Create {
\find(wd(create(h,o)))
\replacewith(and(and(and(wd(h),wd(o)),wellFormed(h)),not(equals(o,null)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="instanceof disjoint type">instanceof_not_compatible_5 {
\assumes ([equals(H::instance(a),TRUE)]==&gt;[]) 
\find(equals(G::instance(a),TRUE))
\varcond(\sub(Null, G), \disjointModuloNull(G, H), )
\replacewith(equals(a,null)) 
\heuristics(evaluate_instanceof, concrete)
Choices: {}}</entry>
<entry key="expand_unaryMinusJlong">expand_unaryMinusJlong {
\find(unaryMinusJlong(i))
\replacewith(moduloLong(neg(i))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="greater-or-equal than distinction">greater_equal_than_comparison_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#se0&gt;=#se1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(geq(#se0,#se1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="neq_or">neq_or {
\find(or(phi,not(phi)))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="reachDependenciesStoreSimpleEQ">reachDependenciesStoreSimpleEQ {
\assumes ([equals(store(h,o3,f2,x),h2)]==&gt;[]) 
\find(reach(h2,allObjects(f),o,o2,n))
\varcond(\metaDisjoint f (Field term), f2 (Field term), )
\replacewith(reach(h,allObjects(f),o,o2,n)) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="definitionOfNewObjectsIsomorphic">definitionOfNewObjectsIsomorphic {
\find(==&gt;newObjectsIsomorphic(s1,h1,s2,h2))
\replacewith([]==&gt;[objectsIsomorphic(s1,s1,s2,s2)]) ;
\replacewith([]==&gt;[sameTypes(s1,s2)]) ;
\replacewith([]==&gt;[newOnHeap(h2,s2)]) ;
\replacewith([]==&gt;[newOnHeap(h1,s1)]) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="createdInHeapWithArrayRangeEQ">createdInHeapWithArrayRangeEQ {
\assumes ([equals(arrayRange(o,lower,upper),EQ)]==&gt;[]) 
\find(createdInHeap(EQ,h))
\sameUpdateLevel\replacewith(or(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE)),lt(upper,lower))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="castType">castType2 {
\assumes ([]==&gt;[equals(H::instance(C::cast(s)),TRUE)]) 
\find(equals(CSub::instance(s),TRUE)==&gt;)
\replacewith([]==&gt;[equals(H::instance(s),TRUE)]) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="add_sub_elim_right">add_sub_elim_right {
\find(add(i,neg(i)))
\replacewith(Z(0(#))) 

Choices: {}}</entry>
<entry key="leq_to_geq">leq_to_geq {
\find(leq(i,i0))
\replacewith(geq(i0,i)) 

Choices: {}}</entry>
<entry key="bitwiseOr">assignmentBitwiseOrLong3 {
\find(#normalassign ( (modal operator))\[{ .. #loc=#seLong0|#seLong1; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseOrLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: {programRules:Java}}</entry>
<entry key="eqSymm">eqSymm {
\find(equals(commEqLeft,commEqRight))
\replacewith(equals(commEqRight,commEqLeft)) 
\heuristics(order_terms)
Choices: {}}</entry>
<entry key="elim_forall_superOfAll_and_phi">elim_forall_superOfAll_and_phi {
\find(all{locVar (variable)}(and(subset(locVar,locSetTerm),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(and(equals(locSetTerm,allLocs),all{locVar (variable)}(phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="apply_eq_monomials">apply_eq_monomials {
\assumes ([equals(applyEqDivisor,i0)]==&gt;[]) 
\find(applyEqDividend)
\sameUpdateLevel\replacewith(add(mul(#divideMonomials(applyEqDividend,applyEqDivisor),add(i0,mul(applyEqDivisor,Z(neglit(1(#)))))),applyEqDividend)) 
\heuristics(notHumanReadable, apply_equations, polySimp_applyEq)
Choices: {}}</entry>
<entry key="expand_modJint">expand_modJint {
\find(modJint(i,i1))
\replacewith(moduloInt(jmod(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="getOfMapSingleton">getOfMapSingleton {
\find(mapGet(mapSingleton(x,y),z))
\sameUpdateLevel\replacewith(if-then-else(equals(x,z),y,mapUndef)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="writePermissionAfterReturnEQ">writePermissionAfterReturnEQ {
\assumes ([writePermissionObject(o1,p2),equals(returnPermission(o1,o2,p2),p1)]==&gt;[]) 
\find(writePermissionObject(o2,p1))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="abortJavaCardTransactionAPI">abortJavaCardTransactionAPI {
\find(==&gt;#allmodal ( (modal operator))\[{ .. 
  #jcsystemType.#abortTransaction()@#jcsystemType; ... }\] (post))
\replacewith([]==&gt;[#allmodal ( (modal operator))\[{ .. #abortJavaCardTransaction; ... }\] (post)]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="lastIndexOf">lastIndexOf {
\find(clLastIndexOfChar(sourceStr,c,i))
\varcond(\notFreeIn(iv (variable), sourceStr (Seq term)), \notFreeIn(iv (variable), i (int term)), \notFreeIn(iv (variable), c (int term)))
\replacewith(ifExThenElse{iv (variable)}(and(and(and(gt(iv,Z(0(#))),geq(i,iv)),lt(sub(i,iv),seqLen(sourceStr))),equals(int::seqGet(sourceStr,sub(i,iv)),c)),sub(i,iv),Z(neglit(1(#))))) 
\heuristics(stringsExpandDefNormalOp)
Choices: {Strings:on}}</entry>
<entry key="instanceof_known_dynamic_type_2">instanceof_known_dynamic_type_2 {
\assumes ([equals(G::exactInstance(a),TRUE)]==&gt;[]) 
\find(H::instance(a))
\sameUpdateLevel\varcond(\not\sub(G, H), )
\replacewith(FALSE) 
\heuristics(evaluate_instanceof, simplify)
Choices: {}}</entry>
<entry key="replace_int_RANGE">replace_int_RANGE {
\find(int_RANGE)
\replacewith(Z(6(9(2(7(6(9(4(9(2(4(#)))))))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="diamond_split_termination">diamond_split_termination {
\find(\&lt;{ .. #s ... }\&gt; (post))
\replacewith(and(\[{ .. #s ... }\] (post),\&lt;{ .. #s ... }\&gt; (true))) 

Choices: {programRules:Java}}</entry>
<entry key="elementOfAllFields">elementOfAllFields {
\find(elementOf(o,f,allFields(o2)))
\replacewith(equals(o,o2)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="blockReturn">blockReturn {
\find(#allmodal ( (modal operator))\[{ ..  {return #se;#slist} ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. return #se; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="shift">assignmentUnsignedShiftRightLong {
\find(#normalassign ( (modal operator))\[{ .. #loc=#seLong0&gt;&gt;&gt;#se; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaUnsignedShiftRightLong(#seLong0,#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: {programRules:Java}}</entry>
<entry key="writePermissionImpliesReadPermission">writePermissionImpliesReadPermission {
\assumes ([writePermissionObject(o,p)]==&gt;[]) 
\find(readPermissionObject(o,p))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="lenOfRemoveConcrete2">lenOfRemoveConcrete2 {
\assumes ([geq(seqLen(s1),Z(1(#)))]==&gt;[]) 
\find(seqLen(seqRemove(s1,Z(0(#)))))
\replacewith(sub(seqLen(s1),Z(1(#)))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="lenOfRemoveConcrete1">lenOfRemoveConcrete1 {
\assumes ([geq(seqLen(s1),Z(1(#)))]==&gt;[]) 
\find(seqLen(seqRemove(s1,sub(seqLen(s1),Z(1(#))))))
\replacewith(sub(seqLen(s1),Z(1(#)))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="seqDef_one_summand">seqDef_one_summand {
\find(seqDef{uSub (variable)}(from,idx,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), idx (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(if-then-else(equals(add(from,Z(1(#))),idx),seqSingleton(subst{uSub (variable)}(from,t)),seqDef{uSub (variable)}(from,idx,t))) 

Choices: {sequences:on}}</entry>
<entry key="seqNPermRight">seqNPermRight {
\find(==&gt;seqNPerm(s))
\varcond(\notFreeIn(jv (variable), s (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\add []==&gt;[and(and(all{iv (variable)}(all{jv (variable)}(imp(and(and(and(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),leq(Z(0(#)),jv)),lt(jv,seqLen(s))),equals(int::seqGet(s,iv),int::seqGet(s,jv))),equals(iv,jv)))),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),and(leq(Z(0(#)),int::seqGet(s,iv)),lt(int::seqGet(s,iv),seqLen(s)))))),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(int::instance(any::seqGet(s,iv)),TRUE))))] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="less_zero_is_total">less_zero_is_total {
\find(i)
\sameUpdateLevel\add [lt(Z(0(#)),i)]==&gt;[] ;
\add [equals(i,Z(0(#)))]==&gt;[] ;
\add [lt(i,Z(0(#)))]==&gt;[] 

Choices: {}}</entry>
<entry key="transferPermission_slice">transferPermission_slice {
\find(transferPermission(split,from,to,depth,slice(owners,p)))
\replacewith(if-then-else(equals(from,to),slice(owners,p),if-then-else(checkPermissionOwner(from,depth,owners),slice(insertPermissionOwner(from,to,depth,owners),if-then-else(equals(split,TRUE),slice(owners,p),transferPermission(split,from,to,depth,p))),slice(owners,transferPermission(split,from,to,depth,p))))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="assert">assertSafeWithMessage {
\find(==&gt;#allmodal ( (modal operator))\[{ .. assert #e1 : #e2; ... }\] (b))
\varcond(\new(#message (program Variable), \typeof(#e2 (program Expression))), \new(#condition (program Variable), \typeof(#e1 (program Expression))), \not \containsAssignment( #e1 ), \not \containsAssignment( #e2 ), )
\add [equals(oldHeap,heap)]==&gt;[] \replacewith([]==&gt;[\[{method-frame(#ex): {#typeof    (#e1) #condition = #e1;#typeof    (#e2) #message = #e2;
  }
}\] (all{f (variable)}(all{o (variable)}(or(and(not(equals(o,null)),equals(boolean::select(oldHeap,o,java.lang.Object::&lt;created&gt;),FALSE)),equals(any::select(oldHeap,o,f),any::select(heap,o,f))))))]) ;
\replacewith([]==&gt;[\&lt;{method-frame(#ex): {#typeof    (#e1) #condition = #e1;#typeof    (#e2) #message = #e2;
  }
}\&gt; (equals(#condition,TRUE))]) ;
\replacewith([]==&gt;[#allmodal(b)]) 
\heuristics(simplify_prog)
Choices: {assertions:safe,programRules:Java}}</entry>
<entry key="wd_Subst_Formula">wd_Subst_Formula {
\find(WD(subst{v (variable)}(u,f)))
\replacewith(and(wd(u),subst{v (variable)}(u,WD(f)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="shift_paren_or">shift_paren_or {
\find(or(assoc0,or(assoc1,assoc2)))
\replacewith(or(or(assoc0,assoc1),assoc2)) 
\heuristics(cnf_orAssoc, conjNormalForm)
Choices: {}}</entry>
<entry key="disjointInfiniteUnion_2">disjointInfiniteUnion_2 {
\find(equals(intersect(s,infiniteUnion{iv (variable)}(s2)),empty))
\varcond(\notFreeIn(iv (variable), s (LocSet term)))
\replacewith(all{iv (variable)}(equals(intersect(s,s2),empty))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="intersectWithSingleton">intersectWithSingleton {
\find(intersect(singleton(o,f),s))
\replacewith(if-then-else(elementOf(o,f,s),singleton(o,f),empty)) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_leqRight">inEqSimp_leqRight {
\find(==&gt;leq(i,i0))
\replacewith([geq(add(add(Z(neglit(1(#))),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))]==&gt;[]) 
\heuristics(notHumanReadable, inEqSimp_moveLeft, inEqSimp_expand)
Choices: {}}</entry>
<entry key="wd_Numerical_Pred_InChar">wd_Numerical_Pred_InChar {
\find(WD(inChar(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="seqPermTrans">seqPermTrans {
\assumes ([seqPerm(s2,s3)]==&gt;[]) 
\find(seqPerm(s1,s2)==&gt;)
\add [seqPerm(s1,s3)]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="wellFormedCreate">wellFormedCreate {
\find(wellFormed(create(h,o)))
\succedentPolarity\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="tryBreak">tryFinallyBreak {
\find(#allmodal ( (modal operator))\[{ .. try {break ;
    #slist
  }
  #cs               finally {
    #slist2
  }
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..  {#slist2}break ;
 ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Op_Sub">wd_Numerical_Op_SubLongOverFlow {
\find(wd(javaSubLongOverFlow(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="binaryAndZeroLeft">binaryAndZeroLeft {
\find(binaryAnd(Z(0(#)),right))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="ifElseSplit">ifSplit {
\find(==&gt;#allmodal ( (modal operator))\[{ .. if (#se)
    #s0
 ... }\] (post))
\add [equals(#se,FALSE)]==&gt;[] \replacewith([]==&gt;[#allmodal(post)]) ;
\add [equals(#se,TRUE)]==&gt;[] \replacewith([]==&gt;[#allmodal ( (modal operator))\[{ .. #s0 ... }\] (post)]) 
\heuristics(split_if)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Op_ShiftLeft">wd_Numerical_Op_JavaShiftLeftLong {
\find(wd(javaShiftLeftLong(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="assignment_to_reference_array_component">assignment_to_reference_array_component_transaction {
\find(#transaction ( (modal operator))\[{ .. #v[#se]=#se0; ... }\] (post))
\varcond(\isReferenceArray(#v (program Variable)), )
\replacewith(update-application(elem-update(heap)(store(heap,#v,arr(#se),#se0)),update-application(elem-update(savedHeap)(if-then-else(equals(int::select(heap,#v,java.lang.Object::&lt;transient&gt;),Z(0(#))),store(savedHeap,#v,java.lang.Object::&lt;transactionConditionallyUpdated&gt;,TRUE),if-then-else(equals(boolean::select(savedHeap,#v,java.lang.Object::&lt;transactionConditionallyUpdated&gt;),FALSE),store(savedHeap,#v,arr(#se),#se0),savedHeap))),#transaction(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {JavaCard:on,runtimeExceptions:ignore,programRules:Java}}</entry>
<entry key="prod_one">prod_one {
\find(prod{x (variable)}(range,Z(1(#))))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="stringConcatBooleanRight">stringConcatBooleanRight {
\find(#normalassign ( (modal operator))\[{ .. #v=#sstrLeft+#seRight; ... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(strContent(#sstrLeft),if-then-else(equals(#seRight,TRUE),seqConcat(seqSingleton(C(6(1(1(#))))),seqConcat(seqSingleton(C(4(1(1(#))))),seqConcat(seqSingleton(C(7(1(1(#))))),seqSingleton(C(1(0(1(#)))))))),seqConcat(seqSingleton(C(2(0(1(#))))),seqConcat(seqSingleton(C(7(9(#)))),seqConcat(seqSingleton(C(8(0(1(#))))),seqConcat(seqSingleton(C(5(1(1(#))))),seqSingleton(C(1(0(1(#))))))))))))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="array2seqDef">array2seqDef {
\find(array2seq(h,a))
\varcond(\notFreeIn(u (variable), h (Heap term)), \notFreeIn(u (variable), a (java.lang.Object term)))
\replacewith(seqDef{u (variable)}(Z(0(#)),length(a),any::select(h,a,arr(u)))) 
\heuristics(simplify_enlarging)
Choices: {sequences:on}}</entry>
<entry key="cut_direct_r">cut_direct_r {
\find(==&gt;b)
\add [b]==&gt;[] ;
\replacewith([]==&gt;[b]) 

Choices: {}}</entry>
<entry key="lt_diff_1">lt_diff_1 {
\find(lt(i0,add(i0,Z(1(#)))))
\replacewith(true) 
\heuristics(int_arithmetic)
Choices: {}}</entry>
<entry key="wd_Seq_Reverse">wd_Seq_Reverse {
\find(wd(seqReverse(s)))
\replacewith(wd(s)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="methodCallReturn">methodCallReturnIgnoreResult {
\find(#allmodal ( (modal operator))\[{ .. method-frame(#ex): {
    return  #se;
    #slist
  }
 ... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="cut_direct_l">cut_direct_l {
\find(b==&gt;)
\add []==&gt;[b] ;
\replacewith([b]==&gt;[]) 

Choices: {}}</entry>
<entry key="stringConcatObjectRight">stringConcatObjectRight {
\find(#normalassign ( (modal operator))\[{ .. #v=#sstrLeft+#seRight; ... }\] (post))
\sameUpdateLevel\add [equals(#seRight,null),equals(strContent(sk),seqConcat(strContent(#sstrLeft),strContent(null)))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) ;
\add []==&gt;[equals(#seRight,null)] \replacewith(#normalassign ( (modal operator))\[{ .. #v=#sstrLeft+#seRight.toString(); ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="compound_assignment_op_or_attr">compound_assignment_op_or_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute|=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute|#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="instEx">instEx {
\assumes ([]==&gt;[exists{u (variable)}(b)]) 
\find(t)
\add []==&gt;[subst{u (variable)}(t,b)] 

Choices: {}}</entry>
<entry key="for_to_while">for_to_while {
\find(#allmodal ( (modal operator))\[{ .. #forloop ... }\] (post))
\varcond(\newLabel (#innerLabel (program Label)), \newLabel (#outerLabel (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ .. #for-to-while(#forloop) ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="make_insert_eq_nonrigid">make_insert_eq_nonrigid {
\find(equals(s,t)==&gt;)
\addrules [insert_eq_nonrigid {
\find(s)
\sameUpdateLevel\replacewith(t) 

Choices: {}}] 

Choices: {}}</entry>
<entry key="box_or_right">box_or_right {
\find(==&gt;#box ( (modal operator))\[{ .. #s ... }\] (or(post,post1)))
\replacewith([]==&gt;[or(#box ( (modal operator))\[{ .. #s ... }\] (post),#box ( (modal operator))\[{ .. #s ... }\] (post1))]) 

Choices: {programRules:Java}}</entry>
<entry key="simplifySelectOfAnon">simplifySelectOfAnon {
\find(equals(beta::select(anon(h,s,h2),o,f),sk)==&gt;)
\addrules [replaceKnownSelect {
\find(beta::select(anon(h,s,h2),o,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(or(and(elementOf(o,f,s),not(equals(f,java.lang.Object::&lt;created&gt;))),elementOf(o,f,freshLocs(h))),beta::select(h2,o,f),beta::select(h,o,f)),sk)]==&gt;[]) 
\heuristics(simplify_select)
Choices: {programRules:Java}}</entry>
<entry key="subsetWithEmpty">subsetWithEmpty {
\find(subset(empty,s))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="switch">switch {
\find(#allmodal ( (modal operator))\[{ .. #sw ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. switch-to-if(#sw) ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="writePermissionAfterFullTransferEQ">writePermissionAfterFullTransferEQ {
\assumes ([writePermissionObject(o1,p2),equals(transferPermission(FALSE,o1,o2,Z(0(#)),p2),p1)]==&gt;[]) 
\find(writePermissionObject(o2,p1))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="ifthenelse_false">ifthenelse_false_for {
\find(if-then-else(false,b,c))
\replacewith(c) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="predecrement_assignment_attribute">predecrement_assignment_attribute {
\find(#allmodal ( (modal operator))\[{ .. #lhs=--#e.#attribute; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#v.#attribute=(#typeof(#attribute))(#v.#attribute-1);#lhs=#v.#attribute; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="special_constructor_call">special_constructor_call {
\find(#allmodal ( (modal operator))\[{ .. #scr ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. special-constructor-call(#scr) ... }\] (post)) 
\heuristics(method_expand)
Choices: {programRules:Java}}</entry>
<entry key="initialized classes have been prepared">class_being_initialized_is_prepared {
\assumes ([equals(boolean::select(heap,null,alphaObj::&lt;classInitializationInProgress&gt;),TRUE),wellFormed(heap)]==&gt;[]) 
\find(boolean::select(heap,null,alphaObj::&lt;classPrepared&gt;))
\sameUpdateLevel\replacewith(TRUE) 
\heuristics(simplify, confluence_restricted)
Choices: {programRules:Java}}</entry>
<entry key="javaShiftRightLongDef">javaShiftRightLongDef {
\find(shiftrightJlong(left,right))
\replacewith(moduloLong(shiftright(left,mod(right,Z(4(6(#))))))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="reach_does_not_depend_on_fresh_locs">reach_does_not_depend_on_fresh_locs {
\assumes ([]==&gt;[equals(o,null)]) 
\find(reach(anon(h,empty,h2),s,o,o2,n))
\add []==&gt;[and(wellFormed(h),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))] ;
\replacewith(reach(h,s,o,o2,n)) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="wd_Logical_Quant_All">wd_Logical_Quant_All {
\find(WD(all{i (variable)}(a)))
\replacewith(or(exists{i (variable)}(and(WD(a),not(a))),all{i (variable)}(WD(a)))) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="eqClose">eqClose {
\find(equals(s,s))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="mul_assoc">mul_assoc {
\find(mul(mul(i,i0),i1))
\replacewith(mul(i,mul(i0,i1))) 

Choices: {}}</entry>
<entry key="getOfSeqReverse">getOfSeqReverseEQ {
\assumes ([equals(seqReverse(seq),EQ)]==&gt;[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\replacewith(alpha::seqGet(seq,sub(sub(seqLen(seq),Z(1(#))),idx))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: {sequences:on}}</entry>
<entry key="concrete_not_2">concrete_not_2 {
\find(not(false))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="wd_Reach_Pred_Acc">wd_Reach_Pred_Acc {
\find(WD(acc(h,l,o,p)))
\replacewith(and(and(and(and(wd(h),wd(l)),wd(o)),wd(p)),wellFormed(h))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="concrete_not_1">concrete_not_1 {
\find(not(true))
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="isFiniteOfMapRemove">isFiniteOfMapRemove {
\find(isFinite(mapRemove(m,key)))
\sameUpdateLevel\replacewith(isFinite(m)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="bprod_find">bprod_find {
\find(bprod{uSub (variable)}(low,high,t))
\varcond(\notFreeIn(uSub (variable), high (int term)), \notFreeIn(uSub (variable), middle (int term)), \notFreeIn(uSub (variable), low (int term)))
\replacewith(if-then-else(and(leq(low,middle),leq(middle,high)),mul(bprod{uSub (variable)}(low,middle,t),bprod{uSub (variable)}(middle,high,t)),bprod{uSub (variable)}(low,high,t))) 
\heuristics(triggered, comprehension_split)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="subSeqCompleteSeqDef">subSeqCompleteSeqDef {
\find(seqSub(seqDef{i (variable)}(Z(0(#)),u,a),Z(0(#)),u))
\replacewith(seqDef{i (variable)}(Z(0(#)),u,a)) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="secondOfPair">secondOfPair {
\find(second(pair(t,t1)))
\replacewith(t1) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="bsum_induction_upper2_concrete">bsum_induction_upper2_concrete {
\find(bsum{uSub (variable)}(i0,add(Z(neglit(1(#))),i2),t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(sub(bsum{uSub (variable)}(i0,i2,t),if-then-else(lt(i0,i2),subst{uSub (variable)}(sub(i2,Z(1(#))),t),Z(0(#))))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="postincrement_assignment_attribute">postincrement_assignment_attribute {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=#e.#attribute++; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#lhs0 (program LeftHandSide))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#lhs0) #v1 = #v.#attribute;#v.#attribute=(#typeof(#attribute))(#v.#attribute+1);#lhs0=#v1; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="ifExthenelse1_eq_phi">ifExthenelse1_eq_phi {
\find(ifExThenElse{intVar (variable)}(and(phi,equals(intVar,t)),then,else))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(if-then-else(subst{intVar (variable)}(t,phi),subst{intVar (variable)}(t,then),else)) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="mapRemoveUnchanged2">mapRemoveUnchanged2 {
\find(equals(mapRemove(m,key),m))
\replacewith(not(inDomain(m,key))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="bprod_induction_lower_concrete">bprod_induction_lower_concrete {
\find(bprod{uSub (variable)}(add(Z(neglit(1(#))),i0),i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(i0,i2,t),if-then-else(lt(add(Z(neglit(1(#))),i0),i2),subst{uSub (variable)}(add(Z(neglit(1(#))),i0),t),Z(1(#))))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="reachZero">reachZero {
\find(reach(h,s,o,o2,Z(0(#))))
\replacewith(and(not(equals(o,null)),equals(o,o2))) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="singletonAssignment">singletonAssignment {
\find(#allmodal ( (modal operator))\[{ .. #v=\singleton(#seObj.#a); ... }\] (post))
\replacewith(update-application(elem-update(#v (program Variable))(singleton(#seObj,#memberPVToField(#a))),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="translateJavaUnsignedShiftRight">translateJavaUnsignedShiftRightInt {
\find(javaUnsignedShiftRightInt(left,right))
\replacewith(if-then-else(inInt(unsignedshiftrightJint(left,right)),unsignedshiftrightJint(left,right),javaUnsignedShiftRightOverFlow(left,right))) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="wd_LocSet_Pred_Disjoint">wd_LocSet_Pred_Disjoint {
\find(WD(disjoint(l,s)))
\replacewith(and(wd(l),wd(s))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="reachDependenciesStore">reachDependenciesStore {
\find(reach(store(h,o3,f,x),s,o,o2,n))
\sameUpdateLevel\varcond(\notFreeIn(nv (variable), n (int term)), \notFreeIn(nv (variable), o2 (java.lang.Object term)), \notFreeIn(nv (variable), o (java.lang.Object term)), \notFreeIn(nv (variable), s (LocSet term)), \notFreeIn(nv (variable), x (any term)), \notFreeIn(nv (variable), f (Field term)), \notFreeIn(nv (variable), o3 (java.lang.Object term)), \notFreeIn(nv (variable), h (Heap term)))
\add [not(and(exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,o3,nv))),elementOf(o3,f,s)))]==&gt;[] \replacewith(reach(h,s,o,o2,n)) ;
\add []==&gt;[not(and(exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,o3,nv))),elementOf(o3,f,s)))] 

Choices: {reach:on}}</entry>
<entry key="seqPermRefl">seqPermRefl {
\find(seqPerm(s,s))
\replacewith(true) 
\heuristics(concrete)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="getOfRemoveAny">getOfRemoveAny {
\find(alpha::seqGet(seqRemove(s1,i2),i3))
\replacewith(if-then-else(or(lt(i2,Z(0(#))),leq(seqLen(s1),i2)),alpha::seqGet(s1,i3),if-then-else(lt(i3,i2),alpha::seqGet(s1,i3),if-then-else(and(leq(i2,i3),lt(i3,sub(seqLen(s1),Z(1(#))))),alpha::seqGet(s1,add(i3,Z(1(#)))),alpha::cast(seqGetOutside))))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="narrow type">castAdd {
\assumes ([equals(CSub::instance(strictCTerm2),TRUE)]==&gt;[]) 
\find(strictCTerm2)
\sameUpdateLevel\replacewith(CSub::cast(strictCTerm2)) 

Choices: {}}</entry>
<entry key="nonNullZero">nonNullZero {
\find(nonNull(heapSV,o,Z(0(#))))
\replacewith(not(equals(o,null))) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="moduloCharFixpoint">moduloCharFixpoint {
\assumes ([inChar(t)]==&gt;[]) 
\find(moduloChar(t))
\sameUpdateLevel\replacewith(t) 
\heuristics(simplify)
Choices: {intRules:arithmeticSemanticsCheckingOF}}</entry>
<entry key="nullCreated">nullCreated {
\add [or(all{h (variable)}(equals(boolean::select(h,null,java.lang.Object::&lt;created&gt;),TRUE)),all{h (variable)}(equals(boolean::select(h,null,java.lang.Object::&lt;created&gt;),FALSE)))]==&gt;[] 

Choices: {programRules:Java}}</entry>
<entry key="cast">narrowingByteCastBigint {
\find(#allmodal ( (modal operator))\[{ .. #loc=(byte)#seBigint; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaCastByte(#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: {bigint:on,programRules:Java}}</entry>
<entry key="moduloLongFixpoint">moduloLongFixpoint {
\assumes ([inLong(t)]==&gt;[]) 
\find(moduloLong(t))
\sameUpdateLevel\replacewith(t) 
\heuristics(simplify)
Choices: {intRules:arithmeticSemanticsCheckingOF}}</entry>
<entry key="ifExthenelse1_split">ifExthenelse1_split_for {
\find(ifExThenElse{intVar (variable)}(phi,b,c))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), intSk (int skolem term)))
\add []==&gt;[exists{intVar (variable)}(phi)] \replacewith(c) ;
\add [subst{intVar (variable)}(intSk,phi),all{intVar (variable)}(imp(phi,wellOrderLeqInt(intSk,intVar)))]==&gt;[] \replacewith(subst{intVar (variable)}(intSk,b)) 
\heuristics(split_cond)
Choices: {}}</entry>
<entry key="seqNPermDefLeft">seqNPermDefLeft {
\find(seqNPerm(s1)==&gt;)
\varcond(\notFreeIn(jv (variable), s1 (Seq term)), \notFreeIn(iv (variable), s1 (Seq term)))
\add [all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s1))),exists{jv (variable)}(and(and(leq(Z(0(#)),jv),lt(jv,seqLen(s1))),equals(any::seqGet(s1,jv),iv)))))]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="ifElseSplitLeft">ifElseSplitLeft {
\find(#allmodal ( (modal operator))\[{ .. if (#se)
    #s0
  else 
    #s1
 ... }\] (post)==&gt;)
\add [equals(#se,FALSE)]==&gt;[] \replacewith([#allmodal ( (modal operator))\[{ .. #s1 ... }\] (post)]==&gt;[]) ;
\add [equals(#se,TRUE)]==&gt;[] \replacewith([#allmodal ( (modal operator))\[{ .. #s0 ... }\] (post)]==&gt;[]) 
\heuristics(split_if)
Choices: {programRules:Java}}</entry>
<entry key="subsetUnionLeftEQ">subsetUnionLeftEQ {
\assumes ([equals(union(s,s2),EQ)]==&gt;[]) 
\find(subset(EQ,s3))
\sameUpdateLevel\replacewith(and(subset(s,s3),subset(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="instanceof static supertype">instanceof_static_type_2 {
\assumes ([equals(a2,a)]==&gt;[]) 
\find(G::instance(a))
\sameUpdateLevel\varcond(\sub(\typeof(a2 (any term)), G), )
\replacewith(TRUE) 
\heuristics(evaluate_instanceof, concrete)
Choices: {}}</entry>
<entry key="assignment_read_attribute_this">assignment_read_attribute_this {
\find(#allmodal ( (modal operator))\[{ .. #v0=#v.#a; ... }\] (post))
\varcond( \not \static(#a (program Variable)),  \not \isArrayLength(#a (program Variable)), \hasSort(#a (program Variable), G), \isThisReference (#v (program Variable)), )
\replacewith(update-application(elem-update(#v0 (program Variable))(G::select(heap,#v,#memberPVToField(#a))),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {runtimeExceptions:ignore,programRules:Java}}</entry>
<entry key="seqDef_split">seqDef_split {
\find(seqDef{uSub (variable)}(from,to,t))
\varcond(\notFreeIn(uSub1 (variable), t (any term)), \notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), idx (int term)), \notFreeIn(uSub (variable), from (int term)), \notFreeIn(uSub1 (variable), to (int term)), \notFreeIn(uSub1 (variable), idx (int term)), \notFreeIn(uSub1 (variable), from (int term)))
\replacewith(if-then-else(and(leq(from,idx),lt(idx,to)),seqConcat(seqDef{uSub (variable)}(from,idx,t),seqDef{uSub1 (variable)}(idx,to,subst{uSub (variable)}(uSub1,t))),seqDef{uSub (variable)}(from,to,t))) 

Choices: {sequences:on}}</entry>
<entry key="arrayLengthIsAnInt">arrayLengthIsAnInt {
\find(length(o))
\sameUpdateLevel\add [inInt(length(o))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {JavaCard:off,programRules:Java}}</entry>
<entry key="selectOfMemset">selectOfMemset {
\find(beta::select(memset(h,s,x),o,f))
\replacewith(if-then-else(and(elementOf(o,f,s),not(equals(f,java.lang.Object::&lt;created&gt;))),beta::cast(x),beta::select(h,o,f))) 
\heuristics(semantics_blasting)
Choices: {programRules:Java}}</entry>
<entry key="subsetSingletonLeft">subsetSingletonLeft {
\find(subset(singleton(o,f),s))
\replacewith(elementOf(o,f,s)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="less_is_total_heu">less_is_total_heu {
\assumes ([]==&gt;[lt(i,i0),equals(i,i0),lt(i0,i)]) 
\closegoal
Choices: {}}</entry>
<entry key="seqReverseUnfold">seqReverseUnfold {
\find(#allmodal ( (modal operator))\[{ .. #v=\seq_reverse(#nse); ... }\] (post))
\varcond(\new(#vNew (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #vNew = #nse;#v=\seq_reverse(#vNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="transferPermission_empty">transferPermission_empty {
\find(transferPermission(split,from,to,depth,emptyPermission))
\replacewith(emptyPermission) 
\heuristics(concrete)
Choices: {permissions:on}}</entry>
<entry key="infiniteUnionUnused">infiniteUnionUnused {
\find(infiniteUnion{av (variable)}(s))
\varcond(\notFreeIn(av (variable), s (LocSet term)))
\replacewith(s) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="bsum_invert_index_concrete">bsum_invert_index_concrete {
\find(bsum{uSub (variable)}(mul(i0,Z(neglit(1(#)))),mul(i1,Z(neglit(1(#)))),t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(i1,i0,subst{uSub (variable)}(neg(uSub1),t))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="add_zero_left">add_zero_left {
\find(add(Z(0(#)),i))
\replacewith(i) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="translateJavaBitwiseAnd">translateJavaBitwiseAndLong {
\find(javaBitwiseAndLong(left,right))
\replacewith(andJlong(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:javaSemantics,programRules:Java}}</entry>
<entry key="bprod_equal_one_right">bprod_equal_one_right {
\find(==&gt;equals(bprod{uSub (variable)}(i0,i2,t),Z(1(#))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add []==&gt;[all{uSub (variable)}(subst{uSub (variable)}(uSub,imp(and(geq(uSub,i0),lt(uSub,i2)),equals(t,Z(1(#))))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_LocSet_AllObjects">wd_LocSet_AllObjects {
\find(wd(allObjects(f)))
\replacewith(wd(f)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="elim_exists_leq">elim_exists_leq {
\find(exists{INTVar (variable)}(and(leq(INTVar,intTermLeft),geq(INTVar,intTermRight))))
\varcond(\notFreeIn(INTVar (variable), intTermRight (int term)), \notFreeIn(INTVar (variable), intTermLeft (int term)))
\replacewith(leq(intTermRight,intTermLeft)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="defIsFinite">defIsFinite {
\find(isFinite(m))
\varcond(\notFreeIn(s (variable), m (Map term)), \notFreeIn(vx (variable), m (Map term)))
\replacewith(exists{s (variable)}(all{vx (variable)}(equiv(inDomain(m,vx),exists{ix (variable)}(and(and(leq(Z(0(#)),ix),lt(ix,seqLen(s))),equals(any::seqGet(s,ix),vx))))))) 

Choices: {}}</entry>
<entry key="elim_exists_sub_1_and_phi">elim_exists_sub_1_and_phi {
\find(exists{locVar (variable)}(and(and(subset(locVar,locSetTerm),subset(locSetTerm,locVar)),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(exists{locVar (variable)}(and(equals(locVar,locSetTerm),phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="commuteDisjoint">commuteDisjoint {
\find(disjoint(commLeft,commRight))
\replacewith(disjoint(commRight,commLeft)) 
\heuristics(cnf_setComm)
Choices: {programRules:Java}}</entry>
<entry key="getOfMapUpdate">getOfMapUpdate {
\find(mapGet(mapUpdate(m,key,value),x))
\sameUpdateLevel\replacewith(if-then-else(equals(x,key),value,mapGet(m,x))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="only_created_objects_are_reachable">only_created_objects_are_reachable {
\assumes ([wellFormed(h)]==&gt;[equals(o,null)]) 
\find(reach(h,s,o,o2,n)==&gt;)
\add [or(not(equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE)),equals(boolean::select(h,o2,java.lang.Object::&lt;created&gt;),TRUE))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {reach:on}}</entry>
<entry key="defMapEmpty">defMapEmpty {
\find(mapEmpty)
\replacewith(mapForeach{vy (variable)}(FALSE,mapUndef)) 

Choices: {}}</entry>
<entry key="schiffl_thm_1">schiffl_thm_1 {
\varcond(\notFreeIn(idx (variable), t (Seq term)), \notFreeIn(idx (variable), s (Seq term)), \notFreeIn(idx (variable), b (any term)), \notFreeIn(idx (variable), a (any term)), \notFreeIn(idx (variable), y (int term)), \notFreeIn(idx (variable), x (int term)))
\add [imp(and(and(and(and(and(and(seqPerm(s,t),equals(any::seqGet(s,x),any::seqGet(t,x))),equals(any::seqGet(s,y),any::seqGet(t,y))),leq(Z(0(#)),x)),lt(x,seqLen(s))),leq(Z(0(#)),y)),lt(y,seqLen(s))),seqPerm(seqDef{idx (variable)}(Z(0(#)),seqLen(s),if-then-else(equals(idx,y),b,if-then-else(equals(idx,x),a,any::seqGet(s,idx)))),seqDef{idx (variable)}(Z(0(#)),seqLen(s),if-then-else(equals(idx,y),b,if-then-else(equals(idx,x),a,any::seqGet(t,idx))))))]==&gt;[] 

Choices: {}}</entry>
<entry key="intersectionSetMinusItself">intersectionSetMinusItself {
\find(intersect(setMinus(s1,s2),s2))
\replacewith(empty) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="assignment_read_static_attribute">assignment_read_static_attribute {
\find(#allmodal ( (modal operator))\[{ .. #v0=@(#sv); ... }\] (post))
\sameUpdateLevel\varcond(\hasSort(#sv (program StaticVariable), G), )
\add []==&gt;[readPermission(Permission::select(permissions,null,#memberPVToField(#sv)))] \replacewith(#allmodal ( (modal operator))\[{ .. assert false : "Access permission check-point (static read)."; ... }\] (post)) ;
\replacewith(update-application(elem-update(#v0 (program Variable))(G::select(heap,null,#memberPVToField(#sv))),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="concrete_impl_4">concrete_impl_4 {
\find(imp(b,true))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="unionWithEmpty">unionWithEmptyRight {
\find(union(s,empty))
\replacewith(s) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wd_F_Logical_Op_And">wd_F_Logical_Op_And {
\find(F(and(a,b)))
\replacewith(or(F(a),F(b))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="concrete_impl_3">concrete_impl_3 {
\find(imp(b,false))
\replacewith(not(b)) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="polyMod_pullOut">polyMod_pullOut {
\find(mod(divNum,divDenom))
\replacewith(mod(add(divNum,mul(mul(polyDivCoeff,Z(neglit(1(#)))),divDenom)),divDenom)) 
\heuristics(notHumanReadable, defOps_divModPullOut, polyDivision)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="concrete_impl_2">concrete_impl_2 {
\find(imp(false,b))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="concrete_impl_1">concrete_impl_1 {
\find(imp(true,b))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="reachDependenciesAnon">reachDependenciesAnon {
\find(reach(anon(h,s2,h2),s,o,o2,n))
\sameUpdateLevel\varcond(\notFreeIn(nv (variable), n (int term)), \notFreeIn(nv (variable), o2 (java.lang.Object term)), \notFreeIn(nv (variable), o (java.lang.Object term)), \notFreeIn(nv (variable), s (LocSet term)), \notFreeIn(nv (variable), h2 (Heap term)), \notFreeIn(nv (variable), s2 (LocSet term)), \notFreeIn(nv (variable), h (Heap term)), \notFreeIn(fv (variable), n (int term)), \notFreeIn(fv (variable), o2 (java.lang.Object term)), \notFreeIn(fv (variable), o (java.lang.Object term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(fv (variable), h2 (Heap term)), \notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), h (Heap term)), \notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h2 (Heap term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\add [all{ov (variable)}(all{fv (variable)}(not(and(and(elementOf(ov,fv,s2),exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,ov,nv)))),elementOf(ov,fv,s)))))]==&gt;[] \replacewith(reach(h,s,o,o2,n)) ;
\add []==&gt;[all{ov (variable)}(all{fv (variable)}(not(and(and(elementOf(ov,fv,s2),exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,ov,nv)))),elementOf(ov,fv,s)))))] 

Choices: {reach:on}}</entry>
<entry key="wd_Logical_Quant_Exist">wd_Logical_Quant_Exist {
\find(WD(exists{i (variable)}(a)))
\replacewith(or(exists{i (variable)}(and(WD(a),a)),all{i (variable)}(WD(a)))) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="diamond_or_left">diamond_or_left {
\find(#diamond ( (modal operator))\[{ .. #s ... }\] (or(post,post1))==&gt;)
\replacewith([or(#diamond ( (modal operator))\[{ .. #s ... }\] (post),#diamond ( (modal operator))\[{ .. #s ... }\] (post1))]==&gt;[]) 

Choices: {programRules:Java}}</entry>
<entry key="cut_direct">cut_direct {
\find(cutFormula)
\sameUpdateLevel\add []==&gt;[cutFormula] \replacewith(false) ;
\add [cutFormula]==&gt;[] \replacewith(true) 
\heuristics(cut_direct)
Choices: {}}</entry>
<entry key="replaceEmpty">replaceEmpty {
\find(clReplace(seqEmpty,searchChar,replChar))
\replacewith(seqEmpty) 
\heuristics(stringsSimplify)
Choices: {Strings:on}}</entry>
<entry key="applyOnParallel">applyOnParallel {
\find(update-application(u,parallel-upd(u2,u3)))
\replacewith(parallel-upd(update-application(u,u2),update-application(u,u3))) 
\heuristics(update_apply_on_update)
Choices: {}}</entry>
<entry key="ifExthenelse1_unused_var">ifExthenelse1_unused_var_for {
\find(ifExThenElse{intVar (variable)}(phi,b,c))
\varcond(\notFreeIn(intVar (variable), b (formula)))
\replacewith(if-then-else(exists{intVar (variable)}(phi),b,c)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="compound_assignment_op_shiftright">compound_assignment_op_shiftright {
\find(#allmodal ( (modal operator))\[{ .. #v&gt;&gt;=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v&gt;&gt;(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="selectOfAnonEQ">selectOfAnonEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==&gt;[]) 
\find(beta::select(EQ,o,f))
\sameUpdateLevel\replacewith(if-then-else(or(and(elementOf(o,f,s),not(equals(f,java.lang.Object::&lt;created&gt;))),elementOf(o,f,freshLocs(h))),beta::select(h2,o,f),beta::select(h,o,f))) 
\heuristics(simplify_heap_high_costs)
Choices: {programRules:Java}}</entry>
<entry key="readPermissionSlice">readPermissionSlice {
\find(readPermissionObject(o,slice(ol,p)))
\replacewith(or(checkPermissionOwner(o,Z(0(#)),ol),readPermissionObject(o,p))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="eqSeqConcat4EQ">eqSeqConcat4EQ {
\assumes ([equals(seqConcat(s2,seqSingleton(x)),EQ)]==&gt;[]) 
\find(equals(seqConcat(s1,seqSingleton(y)),EQ))
\replacewith(and(equals(s1,s2),equals(x,y))) 
\heuristics(simplify, no_self_application)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="add_zero_right">add_zero_right {
\find(add(i,Z(0(#))))
\replacewith(i) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="eq_and">eq_and {
\find(and(phi,phi))
\replacewith(phi) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="compound_assignment_op_unsigned_shiftright">compound_assignment_op_unsigned_shiftright {
\find(#allmodal ( (modal operator))\[{ .. #v&gt;&gt;&gt;=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v&gt;&gt;&gt;(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="dismissNonSelectedField">dismissNonSelectedField {
\find(alpha::select(store(h,o,f1,x),u,f2))
\varcond(\differentFields (f1 (Field term), f2 (Field term)), )
\replacewith(alpha::select(h,u,f2)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="precOfPair">precOfPair {
\find(prec(pair(a1,b1),pair(a2,b2)))
\replacewith(or(prec(a1,a2),and(equals(a1,a2),prec(b1,b2)))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="elementOfSingleton">elementOfSingleton {
\find(elementOf(o,f,singleton(o2,f2)))
\replacewith(and(equals(o,o2),equals(f,f2))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="allObjectsAssignment">allObjectsAssignment {
\find(#allmodal ( (modal operator))\[{ .. #v=\all_objects(#eObj.#a); ... }\] (post))
\replacewith(update-application(elem-update(#v (program Variable))(allObjects(#memberPVToField(#a))),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Pred_Geq">wd_Numerical_Pred_Geq {
\find(WD(geq(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="bsum_split">bsum_split {
\find(bsum{uSub (variable)}(low,high,t))
\varcond(\notFreeIn(uSub (variable), high (int term)), \notFreeIn(uSub (variable), middle (int term)), \notFreeIn(uSub (variable), low (int term)))
\replacewith(if-then-else(and(leq(low,middle),leq(middle,high)),add(bsum{uSub (variable)}(low,middle,t),bsum{uSub (variable)}(middle,high,t)),bsum{uSub (variable)}(low,high,t))) 
\heuristics(triggered, comprehension_split)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="ifElse">ifElse {
\find(#allmodal ( (modal operator))\[{ .. if (#se)
    #s0
  else 
    #s1
 ... }\] (post))
\replacewith(if-then-else(equals(#se,TRUE),#allmodal ( (modal operator))\[{ .. #s0 ... }\] (post),#allmodal ( (modal operator))\[{ .. #s1 ... }\] (post))) 

Choices: {programRules:Java}}</entry>
<entry key="bsum_lower_equals_upper">bsum_lower_equals_upper {
\find(bsum{uSub (variable)}(i0,i0,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_F_Logical_Op_Or">wd_F_Logical_Op_Or {
\find(F(or(a,b)))
\replacewith(and(F(a),F(b))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="expand_inByte">expand_inByte {
\find(inByte(i))
\replacewith(and(leq(i,byte_MAX),leq(byte_MIN,i))) 
\heuristics(defOps_expandRanges)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="getAnyOfNPermInv">getAnyOfNPermInv {
\find(any::seqGet(seqNPermInv(s1),i3))
\add []==&gt;[and(leq(Z(0(#)),i3),lt(i3,seqLen(s1)))] ;
\replacewith(int::seqGet(seqNPermInv(s1),i3)) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="eqSeqConcat5">eqSeqConcat5 {
\find(equals(seqConcat(seqSingleton(x),s1),seqConcat(seqSingleton(y),s2)))
\replacewith(and(equals(x,y),equals(s1,s2))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="arrayLengthIsAShort">arrayLengthIsAShort {
\find(length(o))
\sameUpdateLevel\add [inShort(length(o))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="eqSeqConcat4">eqSeqConcat4 {
\find(equals(seqConcat(s1,seqSingleton(x)),seqConcat(s2,seqSingleton(y))))
\replacewith(and(equals(s1,s2),equals(x,y))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="replaceSubstring">replaceSubstring {
\assumes ([equals(seqSub(str,startIdx,endIdx),subStr)]==&gt;[]) 
\find(clReplace(subStr,searchChar,replaceChar))
\sameUpdateLevel\replacewith(if-then-else(and(and(geq(startIdx,Z(0(#))),geq(endIdx,startIdx)),leq(endIdx,seqLen(str))),seqSub(clReplace(str,searchChar,replaceChar),startIdx,endIdx),clReplace(subStr,searchChar,replaceChar))) 
\heuristics(stringsMoveReplaceInside)
Choices: {Strings:on}}</entry>
<entry key="eqSeqConcat3">eqSeqConcat3 {
\find(equals(seqConcat(s1,s),seqConcat(s2,s)))
\replacewith(equals(s1,s2)) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="eqSeqConcat2">eqSeqConcat2 {
\find(equals(seqConcat(s,s1),seqConcat(s,s2)))
\replacewith(equals(s1,s2)) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="pullOutbsum2">pullOutbsum2 {
\find(leq(bsum{uSub1 (variable)}(i0,i1,t1),t)==&gt;)
\add [equals(bsum{uSub1 (variable)}(i0,i1,t1),sk)]==&gt;[] \replacewith([leq(sk,t)]==&gt;[]) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="nullString">nullString {
\find(strContent(null))
\replacewith(seqConcat(seqSingleton(C(0(1(1(#))))),seqConcat(seqSingleton(C(7(1(1(#))))),seqConcat(seqSingleton(C(8(0(1(#))))),seqSingleton(C(8(0(1(#))))))))) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="wd_Seq_Singleton">wd_Seq_Singleton {
\find(wd(seqSingleton(t)))
\replacewith(wd(t)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="pullOutbsum1">pullOutbsum1 {
\find(geq(bsum{uSub1 (variable)}(i0,i1,t1),t)==&gt;)
\add [equals(bsum{uSub1 (variable)}(i0,i1,t1),sk)]==&gt;[] \replacewith([geq(sk,t)]==&gt;[]) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="shiftRightDef">shiftRightDef {
\find(shiftright(left,right))
\replacewith(if-then-else(lt(right,Z(0(#))),shiftleft(left,neg(right)),div(left,pow(Z(2(#)),right)))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="erroneous classes have no initialized subclasses">erroneous_class_has_no_initialized_sub_class {
\assumes ([equals(boolean::select(heap,null,alphaObj::&lt;classErroneous&gt;),TRUE),wellFormed(heap)]==&gt;[]) 
\find(boolean::select(heap,null,betaObj::&lt;classInitialized&gt;))
\sameUpdateLevel\varcond(\sub(betaObj, alphaObj), )
\replacewith(FALSE) 
\heuristics(simplify, confluence_restricted)
Choices: {programRules:Java}}</entry>
<entry key="less_base">less_base {
\find(lt(i,i))
\replacewith(false) 

Choices: {}}</entry>
<entry key="wd_Heap_Memset">wd_Heap_Memset {
\find(wd(memset(h,l,a)))
\replacewith(and(and(and(wd(h),wd(l)),wd(a)),wellFormed(h))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="box_and_right">box_and_right {
\find(==&gt;#box ( (modal operator))\[{ .. #s ... }\] (and(post,post1)))
\replacewith([]==&gt;[#box ( (modal operator))\[{ .. #s ... }\] (post1)]) ;
\replacewith([]==&gt;[#box ( (modal operator))\[{ .. #s ... }\] (post)]) 

Choices: {programRules:Java}}</entry>
<entry key="applyEqReverse">applyEqReverse {
\assumes ([equals(s,t1)]==&gt;[]) 
\find(t1)
\sameUpdateLevel\replacewith(s) 
\heuristics(apply_auxiliary_eq)
Choices: {}}</entry>
<entry key="bsum_positive2">bsum_positive2 {
\find(bsum{uSub (variable)}(i0,i1,if-then-else(b,Z(0(#)),Z(1(#)))))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [geq(bsum{uSub (variable)}(i0,i1,if-then-else(b,Z(0(#)),Z(1(#)))),Z(0(#)))]==&gt;[] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_inEq7">divide_inEq7 {
\assumes ([leq(divX,divXBoundNonPos)]==&gt;[]) 
\find(leq(divProd,divProdBoundNeg)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNonPos,Z(0(#))),imp(leq(divProdBoundNeg,Z(neglit(1(#)))),geq(divY,Z(1(#))))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_pos, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="bsum_positive1">bsum_positive1 {
\find(bsum{uSub (variable)}(i0,i1,if-then-else(b,Z(1(#)),Z(0(#)))))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add [geq(bsum{uSub (variable)}(i0,i1,if-then-else(b,Z(1(#)),Z(0(#)))),Z(0(#)))]==&gt;[] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_inEq6">divide_inEq6 {
\assumes ([leq(divX,divXBoundNeg)]==&gt;[]) 
\find(leq(divProd,divProdBoundNonNeg)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNeg,Z(neglit(1(#)))),imp(geq(divProdBoundNonNeg,Z(0(#))),geq(divY,div(divProdBoundNonNeg,divXBoundNeg)))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_inEq5">divide_inEq5 {
\assumes ([leq(divX,divXBoundNonPos)]==&gt;[]) 
\find(geq(divProd,divProdBoundPos)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNonPos,Z(0(#))),imp(geq(divProdBoundPos,Z(1(#))),leq(divY,Z(neglit(1(#)))))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_neg, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_inEq4">divide_inEq4 {
\assumes ([leq(divX,divXBoundNeg)]==&gt;[]) 
\find(geq(divProd,divProdBoundNonPos)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNeg,Z(neglit(1(#)))),imp(leq(divProdBoundNonPos,Z(0(#))),leq(divY,div(divProdBoundNonPos,divXBoundNeg)))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="definitionAllElementsOfArray2">definitionAllElementsOfArray2 {
\find(allElementsOfArray(h,array,allFields(o)))
\varcond(\notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(infiniteUnion{j (variable)}(if-then-else(and(leq(Z(0(#)),j),lt(j,length(array))),allFields(java.lang.Object::select(h,array,arr(j))),empty))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="divide_inEq3">divide_inEq3 {
\assumes ([geq(divX,divXBoundNonNeg)]==&gt;[]) 
\find(geq(divProd,divProdBoundPos)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundNonNeg,Z(0(#))),imp(geq(divProdBoundPos,Z(1(#))),geq(divY,Z(1(#))))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_pos, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="disjointAllFields">disjointAllFields {
\assumes ([equals(intersect(allFields(o),s),empty)]==&gt;[]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\replacewith(false) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wd_F_Logical_Op_Neg">wd_F_Logical_Op_Neg {
\find(F(not(a)))
\replacewith(T(a)) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="impLeft">impLeft {
\find(imp(b,c)==&gt;)
\replacewith([c]==&gt;[]) ;
\replacewith([]==&gt;[b]) 
\heuristics(beta)
Choices: {}}</entry>
<entry key="divide_inEq2">divide_inEq2 {
\assumes ([geq(divX,divXBoundPos)]==&gt;[]) 
\find(geq(divProd,divProdBoundNonPos)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundPos,Z(1(#))),imp(leq(divProdBoundNonPos,Z(0(#))),geq(divY,div(sub(add(divProdBoundNonPos,divXBoundPos),Z(1(#))),divXBoundPos)))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_inEq1">divide_inEq1 {
\assumes ([geq(divX,divXBoundNonNeg)]==&gt;[]) 
\find(leq(divProd,divProdBoundNeg)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundNonNeg,Z(0(#))),imp(leq(divProdBoundNeg,Z(neglit(1(#)))),leq(divY,Z(neglit(1(#)))))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_neg, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="compound_unary_plus_assignment">compound_unary_plus_assignment {
\find(#allmodal ( (modal operator))\[{ .. #lhs=+#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs=#e; ... }\] (post)) 
\heuristics(executeIntegerAssignment)
Choices: {programRules:Java}}</entry>
<entry key="permissionTransferReturnIdentity">permissionTransferReturnIdentity {
\find(returnPermission(o2,o1,transferPermission(FALSE,o1,o2,Z(0(#)),p)))
\replacewith(p) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="divide_inEq0">divide_inEq0 {
\assumes ([geq(divX,divXBoundPos)]==&gt;[]) 
\find(leq(divProd,divProdBoundNonNeg)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundPos,Z(1(#))),imp(geq(divProdBoundNonNeg,Z(0(#))),leq(divY,div(divProdBoundNonNeg,divXBoundPos)))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="null_can_always_be_stored_in_a_reference_type_array">null_can_always_be_stored_in_a_reference_type_array {
\assumes ([]==&gt;[equals(array,null)]) 
\find(arrayStoreValid(array,null))
\sameUpdateLevel\varcond(\isReferenceArray(array (GOS term)), )
\replacewith(true) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="add_two_inequations_2">add_two_inequations_2 {
\assumes ([leq(i,i0)]==&gt;[]) 
\find(leq(j,j0)==&gt;)
\add [leq(add(i,j),add(i0,j0))]==&gt;[] 

Choices: {}}</entry>
<entry key="add_two_inequations_1">add_two_inequations_1 {
\assumes ([lt(i,i0)]==&gt;[]) 
\find(lt(j,j0)==&gt;)
\add [lt(add(i,j),add(i0,j0))]==&gt;[] 

Choices: {}}</entry>
<entry key="exRightHide">exRightHide {
\find(==&gt;exists{u (variable)}(b))
\addrules [insert_hidden {
\add []==&gt;[exists{u (variable)}(b)] 

Choices: {}}] \replacewith([]==&gt;[subst{u (variable)}(t,b)]) 
\heuristics(gamma_destructive)
Choices: {}}</entry>
<entry key="hide_left">hide_left {
\find(b==&gt;)
\addrules [insert_hidden {
\add [b]==&gt;[] 

Choices: {}}] \replacewith([]==&gt;[]) 

Choices: {}}</entry>
<entry key="insert_eqv_rl">insert_eqv_rl {
\find(equiv(br,cr)==&gt;)
\addrules [insert_eqv {
\find(cr)
\replacewith(br) 
\heuristics(simplify)
Choices: {}}] 

Choices: {}}</entry>
<entry key="wd_Numerical_Op_Or">wd_Numerical_Op_BitOrLong {
\find(wd(javaBitwiseOrLong(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_Numerical_Op_Minus">wd_Numerical_Op_MinusLongOverFlow {
\find(wd(javaUnaryMinusLongOverFlow(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="disjointAllFields_2">disjointAllFields_2 {
\find(equals(intersect(allFields(o),allFields(o2)),empty))
\replacewith(not(equals(o,o2))) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wd_String_Hash">wd_String_Hash {
\find(wd(clHashCode(c)))
\replacewith(wd(c)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="local_cut">local_cut {
\find(phi)
\replacewith(and(or(not(psi),phi),or(psi,phi))) 

Choices: {}}</entry>
<entry key="leq_to_gt_alt">leq_to_gt_alt {
\find(leq(i,j))
\replacewith(or(lt(i,j),equals(i,j))) 

Choices: {}}</entry>
<entry key="inEqSimp_strengthen1">inEqSimp_strengthen1 {
\assumes ([]==&gt;[equals(strengthenLeft,strengthenRight)]) 
\find(geq(strengthenLeft,strengthenRight)==&gt;)
\replacewith([geq(strengthenLeft,add(Z(1(#)),strengthenRight))]==&gt;[]) 
\heuristics(notHumanReadable, inEqSimp_strengthen, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="inEqSimp_strengthen0">inEqSimp_strengthen0 {
\assumes ([]==&gt;[equals(strengthenLeft,strengthenRight)]) 
\find(leq(strengthenLeft,strengthenRight)==&gt;)
\replacewith([leq(strengthenLeft,add(Z(neglit(1(#))),strengthenRight))]==&gt;[]) 
\heuristics(notHumanReadable, inEqSimp_strengthen, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="precOfIntPair">precOfIntPair {
\find(prec(a,pair(b,x)))
\replacewith(and(leq(Z(0(#)),a),leq(a,b))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="wd_RegEx_Plus">wd_RegEx_Plus {
\find(wd(repeatPlus(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="commuteIntersection">commuteIntersection {
\find(intersect(commLeft,commRight))
\replacewith(intersect(commRight,commLeft)) 
\heuristics(cnf_setComm)
Choices: {programRules:Java}}</entry>
<entry key="addition">assignmentAdditionBigint2 {
\find(#allmodal ( (modal operator))\[{ .. #loc=#seAny+#seBigint; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(add(#seAny,#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: {bigint:on,programRules:Java}}</entry>
<entry key="disjointDefinition">disjointDefinition {
\find(disjoint(s,s2))
\replacewith(equals(intersect(s,s2),empty)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="wd_T_Logical_Quant_All">wd_T_Logical_Quant_All {
\find(T(all{i (variable)}(a)))
\replacewith(all{i (variable)}(T(a))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="moduloLongIsInLong">moduloLongIsInLong {
\find(inLong(moduloLong(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="jdiv_axiom_inline">jdiv_axiom_inline {
\find(jdiv(divNum,divDenom))
\replacewith(if-then-else(geq(divNum,Z(0(#))),div(divNum,divDenom),mul(div(mul(divNum,Z(neglit(1(#)))),divDenom),Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, defOps_jdiv_inline)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="lenOfSwap">lenOfSwap {
\find(seqLen(seqSwap(s1,iv1,iv2)))
\replacewith(seqLen(s1)) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="divide_leq">divide_leq {
\find(leq(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(and(geq(elimGcd,Z(1(#))),equals(mod(elimGcdLeft,elimGcd),Z(0(#)))),leq(mod(elimGcdRight,elimGcd),add(Z(neglit(1(#))),elimGcd))),leq(div(elimGcdLeft,elimGcd),div(elimGcdRight,elimGcd)),leq(elimGcdLeft,elimGcdRight))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="inEqSimp_and_strengthen3">inEqSimp_and_strengthen3 {
\find(and(and(b,geq(strengthenLeft,strengthenRight)),not(equals(strengthenLeft,strengthenRight))))
\replacewith(and(b,geq(strengthenLeft,add(Z(1(#)),strengthenRight)))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_and_strengthen2">inEqSimp_and_strengthen2 {
\find(and(and(b,leq(strengthenLeft,strengthenRight)),not(equals(strengthenLeft,strengthenRight))))
\replacewith(and(b,leq(strengthenLeft,add(Z(neglit(1(#))),strengthenRight)))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_and_strengthen1">inEqSimp_and_strengthen1 {
\find(and(geq(strengthenLeft,strengthenRight),not(equals(strengthenLeft,strengthenRight))))
\replacewith(geq(strengthenLeft,add(Z(1(#)),strengthenRight))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_and_strengthen0">inEqSimp_and_strengthen0 {
\find(and(leq(strengthenLeft,strengthenRight),not(equals(strengthenLeft,strengthenRight))))
\replacewith(leq(strengthenLeft,add(Z(neglit(1(#))),strengthenRight))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="dismissNonSelectedFieldEQ">dismissNonSelectedFieldEQ {
\assumes ([equals(store(h,o,f1,x),EQ)]==&gt;[]) 
\find(alpha::select(EQ,u,f2))
\sameUpdateLevel\varcond(\differentFields (f1 (Field term), f2 (Field term)), )
\replacewith(alpha::select(h,u,f2)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="wellFormedStoreArray">wellFormedStoreArray {
\find(wellFormed(store(h,o,arr(idx),x)))
\succedentPolarity\varcond(\hasSort(\elemSort(o (java.lang.Object term)), alpha), )
\replacewith(or(and(wellFormed(h),equals(x,null)),and(equals(boolean::select(h,x,java.lang.Object::&lt;created&gt;),TRUE),arrayStoreValid(o,x)))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="UNSOUND_ASSUME">UNSOUND_ASSUME {
\add [b]==&gt;[] 
\heuristics(obsolete)
Choices: {debug:on}}</entry>
<entry key="createdInHeapWithAllFieldsEQ">createdInHeapWithAllFieldsEQ {
\assumes ([equals(allFields(o),EQ)]==&gt;[]) 
\find(createdInHeap(EQ,h))
\sameUpdateLevel\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="same_diamonds_right">same_diamonds_right {
\assumes ([]==&gt;[\&lt;{#s}\&gt; (post)]) 
\find(==&gt;\&lt;{#s}\&gt; (post1))
\add []==&gt;[\&lt;{#s}\&gt; (or(post,post1))] 

Choices: {programRules:Java}}</entry>
<entry key="predecrement_assignment">predecrement_assignment {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=--#lhs1; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs1=(#typeof(#lhs1))(#lhs1-1);#lhs0=#lhs1; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="regExConcatAxiom">regExConcatAxiom {
\find(match(regExConcat(rexp1,rexp2),string))
\varcond(\notFreeIn(endIdx (variable), string (Seq term)), \notFreeIn(endIdx (variable), rexp2 (RegEx term)), \notFreeIn(endIdx (variable), rexp1 (RegEx term)))
\replacewith(exists{endIdx (variable)}(and(and(and(geq(endIdx,Z(0(#))),leq(endIdx,seqLen(string))),match(rexp1,seqSub(string,Z(0(#)),endIdx))),match(rexp2,seqSub(string,endIdx,seqLen(string)))))) 
\heuristics(simplify)
Choices: {Strings:on}}</entry>
<entry key="inEqSimp_subsumption6">inEqSimp_subsumption6 {
\assumes ([geq(subsumLeft,subsumRightBigger)]==&gt;[]) 
\find(geq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller))
\sameUpdateLevel\replacewith(or(and(gt(subsumCoeffSmaller,Z(0(#))),leq(subsumRightSmaller,mul(subsumCoeffSmaller,subsumRightBigger))),geq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="neq_and">neq_and {
\find(and(phi,not(phi)))
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="methodCallUnfoldTarget">methodCallWithAssignmentUnfoldTarget {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#nse.#mn(#elist); ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #v0;#v0=#nse;#lhs=#v0.#mn(#elist); ... }\] (post)) 
\heuristics(simplify_autoname)
Choices: {programRules:Java}}</entry>
<entry key="seqDefOfSeq">seqDefOfSeq {
\find(seqDef{u (variable)}(Z(0(#)),x,any::seqGet(s,u)))
\varcond(\notFreeIn(v (variable), s (Seq term)), \notFreeIn(v (variable), x (int term)), \notFreeIn(u (variable), s (Seq term)), \notFreeIn(u (variable), x (int term)))
\replacewith(if-then-else(equals(seqLen(s),x),s,if-then-else(gt(seqLen(s),x),seqSub(s,Z(0(#)),x),seqConcat(s,seqDef{v (variable)}(seqLen(s),x,seqGetOutside))))) 
\heuristics(simplify_enlarging)
Choices: {sequences:on}}</entry>
<entry key="inEqSimp_subsumption5">inEqSimp_subsumption5 {
\assumes ([geq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger)]==&gt;[]) 
\find(geq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller))
\sameUpdateLevel\replacewith(or(and(and(gt(subsumCoeffSmaller,Z(0(#))),gt(subsumCoeffBigger,Z(0(#)))),leq(mul(subsumCoeffBigger,subsumRightSmaller),mul(subsumCoeffSmaller,subsumRightBigger))),geq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="inEqSimp_subsumption4">inEqSimp_subsumption4 {
\assumes ([leq(subsumLeft,subsumRightSmaller)]==&gt;[]) 
\find(leq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger))
\sameUpdateLevel\replacewith(or(and(gt(subsumCoeffBigger,Z(0(#))),leq(mul(subsumCoeffBigger,subsumRightSmaller),subsumRightBigger)),leq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="indexOf">indexOf {
\find(clIndexOfChar(l,c,i))
\varcond(\notFreeIn(iv (variable), i (int term)), \notFreeIn(iv (variable), c (int term)), \notFreeIn(iv (variable), l (Seq term)))
\replacewith(ifExThenElse{iv (variable)}(and(and(and(geq(i,Z(0(#))),geq(iv,i)),lt(iv,seqLen(l))),equals(int::seqGet(l,iv),c)),iv,Z(neglit(1(#))))) 
\heuristics(stringsExpandDefNormalOp)
Choices: {Strings:on}}</entry>
<entry key="intersectionSetMinusItself_2">intersectionSetMinusItself_2 {
\find(intersect(s2,setMinus(s1,s2)))
\replacewith(empty) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_subsumption2">inEqSimp_subsumption2 {
\assumes ([leq(mul(subsumLeft,subsumCoeffSmaller),subsumRightSmaller)]==&gt;[]) 
\find(leq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger))
\sameUpdateLevel\replacewith(or(and(and(gt(subsumCoeffSmaller,Z(0(#))),gt(subsumCoeffBigger,Z(0(#)))),leq(mul(subsumCoeffBigger,subsumRightSmaller),mul(subsumCoeffSmaller,subsumRightBigger))),leq(mul(subsumLeft,subsumCoeffBigger),subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="inEqSimp_subsumption1">inEqSimp_subsumption1 {
\assumes ([geq(subsumLeft,subsumRightBigger)]==&gt;[]) 
\find(geq(subsumLeft,subsumRightSmaller))
\sameUpdateLevel\replacewith(or(leq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="inEqSimp_subsumption0">inEqSimp_subsumption0 {
\assumes ([leq(subsumLeft,subsumRightSmaller)]==&gt;[]) 
\find(leq(subsumLeft,subsumRightBigger))
\sameUpdateLevel\replacewith(or(leq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_subsumption, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="distr_existsOr">distr_existsOr {
\find(exists{u (variable)}(or(phi,psi)))
\replacewith(or(exists{u (variable)}(phi),exists{u (variable)}(psi))) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: {}}</entry>
<entry key="wd_T_Logical_Op_Cond_Form">wd_T_Logical_Op_Cond_Form {
\find(T(if-then-else(a,b,c)))
\replacewith(or(or(and(T(a),T(b)),and(F(a),T(c))),and(T(b),T(c)))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="inChar">inChar {
\find(inChar(i))
\replacewith(true) 
\heuristics(concrete)
Choices: {intRules:arithmeticSemanticsIgnoringOF,programRules:Java}}</entry>
<entry key="wd_Logical_Op_Imp">wd_Logical_Op_Imp {
\find(WD(imp(a,b)))
\replacewith(or(or(and(WD(a),not(a)),and(WD(b),b)),and(WD(a),WD(b)))) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="nnf_ex2all">nnf_ex2all {
\find(==&gt;exists{u (variable)}(phi))
\replacewith([all{u (variable)}(not(phi))]==&gt;[]) 
\heuristics(notHumanReadable, moveQuantToLeft)
Choices: {}}</entry>
<entry key="translateJavaUnaryMinus">translateJavaUnaryMinusLong {
\find(javaUnaryMinusLong(left))
\replacewith(if-then-else(inLong(neg(left)),neg(left),javaUnaryMinusLongOverFlow(left))) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="elim_forall_superOfAll">elim_forall_superOfAll {
\find(all{locVar (variable)}(subset(locVar,locSetTerm)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(equals(locSetTerm,allLocs)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="lenOfSeqEmpty">lenOfSeqEmptyEQ {
\assumes ([equals(seqEmpty,EQ)]==&gt;[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="readPermissionEmpty">readPermissionEmpty {
\find(readPermissionObject(o,emptyPermission))
\replacewith(false) 
\heuristics(concrete)
Choices: {permissions:on}}</entry>
<entry key="expand_mulJlong">expand_mulJlong {
\find(mulJlong(i,i1))
\replacewith(moduloLong(mul(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="onlyCreatedObjectsAreObservedInLocSetsEQ">onlyCreatedObjectsAreObservedInLocSetsEQ {
\assumes ([equals(obs,EQ)]==&gt;[]) 
\find(elementOf(o,f,EQ)==&gt;)
\varcond(\isObserver (obs (LocSet term), h (Heap term)), )
\add [or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {programRules:Java}}</entry>
<entry key="replace_known_left">replace_known_left {
\assumes ([b]==&gt;[]) 
\find(b)
\sameUpdateLevel\replacewith(true) 
\heuristics(replace_known_left)
Choices: {}}</entry>
<entry key="unionEqualsEmpty">unionEqualsEmpty {
\find(equals(union(s,s2),empty))
\replacewith(and(equals(s,empty),equals(s2,empty))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="gt_to_lt">gt_to_lt {
\find(gt(i,i0))
\replacewith(lt(i0,i)) 

Choices: {}}</entry>
<entry key="wd_Logical_Op_ExCond_Expr">wd_Logical_Op_ExCond_Expr {
\find(wd(ifExThenElse{j (variable)}(a,s,t)))
\varcond(\notFreeIn(j (variable), jPrime (int skolem term)), \notFreeIn(j (variable), t (any term)))
\replacewith(or(or(exists{j (variable)}(and(and(T(a),wd(s)),imp(and(wellOrderLeqInt(jPrime,j),not(equals(jPrime,j))),subst{j (variable)}(jPrime,F(a))))),all{j (variable)}(and(F(a),wd(t)))),all{j (variable)}(and(and(wd(s),wd(t)),equals(s,t))))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="add_equations">add_equations {
\assumes ([equals(i,i0)]==&gt;[]) 
\find(equals(j,j0)==&gt;)
\add [equals(add(i,j),add(i0,j0))]==&gt;[] 

Choices: {}}</entry>
<entry key="doubleImpLeft">doubleImpLeft {
\find(imp(b,imp(c,d))==&gt;)
\replacewith([d]==&gt;[]) ;
\replacewith([]==&gt;[c]) ;
\replacewith([]==&gt;[b]) 
\heuristics(beta)
Choices: {}}</entry>
<entry key="concrete_and_4">concrete_and_4 {
\find(and(b,false))
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="readPermissionAfterTransferWriteEQ">readPermissionAfterTransferWriteEQ {
\assumes ([writePermissionObject(o1,p),equals(transferPermission(split,o1,o2,Z(0(#)),p),p1)]==&gt;[]) 
\find(readPermissionObject(o2,p1))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="disjointAllObjects">disjointAllObjects {
\assumes ([equals(intersect(allObjects(f),s),empty)]==&gt;[]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\replacewith(false) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="concrete_and_3">concrete_and_3 {
\find(and(b,true))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="concrete_and_2">concrete_and_2 {
\find(and(false,b))
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="concrete_and_1">concrete_and_1 {
\find(and(true,b))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="inEqSimp_antiSymm">inEqSimp_antiSymm {
\assumes ([leq(i,i0)]==&gt;[]) 
\find(geq(i,i0)==&gt;)
\add [equals(i,i0)]==&gt;[] 
\heuristics(inEqSimp_antiSymm, inEqSimp_saturate)
Choices: {}}</entry>
<entry key="wellFormedAnonEQ">wellFormedAnonEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==&gt;[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\replacewith(and(wellFormed(h),wellFormed(h2))) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="gt_diff_1">gt_diff_1 {
\find(gt(add(i0,Z(1(#))),i0))
\replacewith(true) 
\heuristics(int_arithmetic)
Choices: {}}</entry>
<entry key="getOfNPermInv">getOfNPermInv {
\find(int::seqGet(seqNPermInv(s1),i3))
\add []==&gt;[and(and(leq(Z(0(#)),i3),lt(i3,seqLen(s1))),seqNPerm(s1))] ;
\add [and(and(equals(int::seqGet(s1,jsk),i3),leq(Z(0(#)),jsk)),lt(jsk,seqLen(s1)))]==&gt;[] \replacewith(jsk) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="evaluate assert condition">evaluateAssertMessage {
\find(#allmodal ( (modal operator))\[{ .. assert #se1 : #nse2; ... }\] (b))
\varcond(\new(#message (program Variable), \typeof(#nse2 (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse2) #message = #nse2;assert #se1 : #message; ... }\] (b)) 
\heuristics(simplify_prog)
Choices: {assertions:on,programRules:Java}}</entry>
<entry key="equal_bsum_same_index">equal_bsum3 {
\assumes ([equals(bsum{uSub1 (variable)}(i0,i1,t1),i),equals(bsum{uSub2 (variable)}(i0,i1,t2),j)]==&gt;[]) 
\find(==&gt;equals(j,i))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==&gt;[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(uSub1,t2))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="cnf_rightDist">cnf_rightDist {
\find(or(distLeft,and(distRight0,distRight1)))
\replacewith(and(or(distLeft,distRight0),or(distRight1,distLeft))) 
\heuristics(cnf_dist, conjNormalForm)
Choices: {}}</entry>
<entry key="definitionSeqdefWorkaround">definitionSeqdefWorkaround {
\find(seq_def_workaround(h,lower,upper,array))
\varcond(\notFreeIn(j (variable), upper (int term)), \notFreeIn(j (variable), lower (int term)), \notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(seqDef{j (variable)}(lower,upper,any::select(h,array,arr(j)))) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="polySimp_elimOne">polySimp_elimOne {
\find(mul(i,Z(1(#))))
\replacewith(i) 
\heuristics(polySimp_elimOneRight, polySimp_expand)
Choices: {}}</entry>
<entry key="less_1_mult">less_1_mult {
\find(and(lt(Z(1(#)),i0),lt(Z(1(#)),i1)))
\replacewith(lt(Z(1(#)),mul(i0,i1))) 

Choices: {}}</entry>
<entry key="finishJavaCardTransaction">finishJavaCardTransactionBox {
\find(==&gt;box_transaction\[{ .. #finishJavaCardTransaction; ... }\] (post))
\replacewith([]==&gt;[box(post)]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="compound_assignment">compound_assignment_xor_nonsimple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#nseBool0^#exBool1; ... }\] (post))
\varcond(\new(#v1 (program Variable), boolean), \new(#v0 (program Variable), boolean))
\replacewith(#allmodal ( (modal operator))\[{ .. boolean #v0 = #nseBool0;boolean #v1 = #exBool1;#lhs=#v0^#v1; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_shiftright_attr">compound_assignment_op_shiftright_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute&gt;&gt;=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute&gt;&gt;#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="simplifySelectOfCreate">simplifySelectOfCreate {
\find(equals(beta::select(create(h,o),o2,f),sk)==&gt;)
\addrules [replaceKnownSelect {
\find(beta::select(create(h,o),o2,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(and(equals(o,o2),not(equals(o,null))),if-then-else(equals(f,java.lang.Object::&lt;created&gt;),beta::cast(TRUE),beta::defaultValue),beta::select(h,o2,f)),sk)]==&gt;[]) ;
\addrules [replaceKnownSelect {
\find(beta::select(create(h,o),o2,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(and(and(equals(o,o2),not(equals(o,null))),equals(f,java.lang.Object::&lt;created&gt;)),beta::cast(TRUE),beta::select(h,o2,f)),sk)]==&gt;[]) 
\heuristics(simplify_select)
Choices: {programRules:Java}}</entry>
<entry key="preincrement_assignment_attribute">preincrement_assignment_attribute {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=++#e.#attribute; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#v.#attribute=(#typeof(#attribute))(#v.#attribute+1);#lhs0=#v.#attribute; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="checkPermissionOwner_nonempty">checkPermissionOwner_nonempty {
\find(checkPermissionOwner(ow,depth,consPermissionOwnerList(o,ol)))
\add []==&gt;[geq(depth,Z(0(#)))] ;
\replacewith(if-then-else(equals(depth,Z(0(#))),equals(ow,o),checkPermissionOwner(ow,sub(depth,Z(1(#))),ol))) 
\heuristics(simplify_expression)
Choices: {permissions:on}}</entry>
<entry key="add_less">add_less {
\find(lt(i,i0))
\replacewith(lt(add(i1,i),add(i1,i0))) 

Choices: {}}</entry>
<entry key="exLeft">exLeft {
\find(exists{u (variable)}(b)==&gt;)
\replacewith([subst{u (variable)}(sk,b)]==&gt;[]) 
\heuristics(delta)
Choices: {}}</entry>
<entry key="hideAuxiliaryEqConcrete2">hideAuxiliaryEqConcrete2 {
\find(==&gt;equals(auxiliarySK,TRUE))
\addrules [replaceKnownAuxiliaryConstant {
\find(auxiliarySK)
\inSequentState\replacewith(FALSE) 
\heuristics(concrete)
Choices: {}}] \replacewith([]==&gt;[]) 
\heuristics(hide_auxiliary_eq_const)
Choices: {programRules:Java}}</entry>
<entry key="defSeq2Map">defSeq2Map {
\find(seq2map(s))
\varcond(\notFreeIn(ix (variable), s (Seq term)))
\replacewith(mapForeach{ix (variable)}(if-then-else(and(leq(Z(0(#)),ix),lt(ix,seqLen(s))),TRUE,FALSE),any::seqGet(s,ix))) 

Choices: {}}</entry>
<entry key="synchronizedBlockEmpty">synchronizedBlockEmpty2 {
\find(#allmodal ( (modal operator))\[{ .. synchronized(#cr) {} ... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="insert_eqv_lr">insert_eqv_lr {
\find(equiv(br,cr)==&gt;)
\addrules [insert_eqv {
\find(br)
\replacewith(cr) 
\heuristics(simplify)
Choices: {}}] 

Choices: {}}</entry>
<entry key="methodCallSuper">methodCallWithAssignmentSuper {
\find(#allmodal ( (modal operator))\[{ .. #lhs=super.#mn(#elist); ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#lhs) #v0;method-call(super.#mn(#elist);)#lhs=#v0; ... }\] (post)) 
\heuristics(simplify_autoname)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Quant_Min">wd_Numerical_Quant_Min {
\find(wd(min{j (variable)}(f,c)))
\replacewith(and(all{j (variable)}(wd(f)),all{j (variable)}(imp(equals(f,TRUE),wd(c))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="eq_add_iff2">eq_add_iff2 {
\find(equals(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(equals(i2,add(mul(sub(i3,i0),i1),i4))) 

Choices: {}}</entry>
<entry key="same_diamonds_left">same_diamonds_left {
\assumes ([\&lt;{ .. #s ... }\&gt; (post)]==&gt;[]) 
\find(\&lt;{ .. #s ... }\&gt; (post1)==&gt;)
\add [\&lt;{ .. #s ... }\&gt; (and(post,post1))]==&gt;[] 

Choices: {programRules:Java}}</entry>
<entry key="eq_add_iff1">eq_add_iff1 {
\find(equals(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(equals(add(mul(sub(i0,i3),i1),i2),i4)) 

Choices: {}}</entry>
<entry key="lenOfRemove">lenOfRemove {
\find(seqLen(seqRemove(s1,iv1)))
\replacewith(if-then-else(and(leq(Z(0(#)),iv1),lt(iv1,seqLen(s1))),sub(seqLen(s1),Z(1(#))),seqLen(s1))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="wd_Numerical_Quant_Sum">wd_Numerical_Quant_Sum {
\find(wd(sum{j (variable)}(f,c)))
\replacewith(and(all{j (variable)}(wd(f)),all{j (variable)}(imp(equals(f,TRUE),wd(c))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="hide_right">hide_right {
\find(==&gt;b)
\addrules [insert_hidden {
\add []==&gt;[b] 

Choices: {}}] \replacewith([]==&gt;[]) 

Choices: {}}</entry>
<entry key="reachEndOfUniquePath2">reachEndOfUniquePath2 {
\assumes ([reach(h,allObjects(f),o,o2,n),equals(alpha::select(h,o2,f),null)]==&gt;[]) 
\find(reach(h,allObjects(f),o,o3,n2)==&gt;)
\varcond(\different (o (java.lang.Object term), o2 (java.lang.Object term)), \different (n (int term), n2 (int term)), )
\add [or(lt(n2,n),and(equals(o2,o3),equals(n,n2)))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {reach:on}}</entry>
<entry key="wd_T_Logical_Op_Imp">wd_T_Logical_Op_Imp {
\find(T(imp(a,b)))
\replacewith(or(F(a),T(b))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="setMinusWithEmpty">setMinusWithEmpty2 {
\find(setMinus(empty,s))
\replacewith(empty) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="definitionAllElementsOfArrayLocsets">definitionAllElementsOfArrayLocsets {
\find(allElementsOfArrayLocsets(h,array,singleton(o,f)))
\varcond(\notFreeIn(j (variable), f (Field term)), \notFreeIn(j (variable), o (java.lang.Object term)), \notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(infiniteUnion{j (variable)}(if-then-else(and(leq(Z(0(#)),j),lt(j,length(array))),LocSet::select(h,java.lang.Object::select(h,array,arr(j)),f),empty))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="subSeqHeadSeqDef">subSeqHeadSeqDef {
\find(seqSub(seqConcat(seqDef{i (variable)}(Z(0(#)),u,a),seq),Z(0(#)),u))
\replacewith(seqDef{i (variable)}(Z(0(#)),u,a)) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="binaryAndSymm">binaryAndSymm {
\find(binaryAnd(left,right))
\replacewith(binaryAnd(right,left)) 

Choices: {}}</entry>
<entry key="splitEquationSucc">splitEquationSucc {
\find(==&gt;equals(splitEqLeft,splitEqRight))
\replacewith([]==&gt;[leq(splitEqLeft,splitEqRight)]) ;
\replacewith([]==&gt;[geq(splitEqLeft,splitEqRight)]) 
\heuristics(notHumanReadable, inEqSimp_split_eq, inEqSimp_nonLin)
Choices: {}}</entry>
<entry key="nnf_notOr">nnf_notOr {
\find(not(or(phi,psi)))
\replacewith(and(not(phi),not(psi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: {}}</entry>
<entry key="wd_String_Pred_StartsWith">wd_String_Pred_StartsWith {
\find(WD(clStartsWith(l,c)))
\replacewith(and(wd(c),wd(l))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="superclasses_of_initialized_classes_are_prepared">superclasses_of_initialized_classes_are_prepared {
\assumes ([equals(boolean::select(heap,null,betaObj::&lt;classInitialized&gt;),TRUE),wellFormed(heap)]==&gt;[]) 
\find(boolean::select(heap,null,alphaObj::&lt;classPrepared&gt;))
\sameUpdateLevel\varcond(\sub(betaObj, alphaObj), )
\replacewith(TRUE) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="divide_equation">divide_equation {
\find(equals(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(and(geq(elimGcd,Z(1(#))),equals(mod(elimGcdLeft,elimGcd),Z(0(#)))),leq(mod(elimGcdRight,elimGcd),add(Z(neglit(1(#))),elimGcd))),and(equals(mod(elimGcdRight,elimGcd),Z(0(#))),equals(div(elimGcdLeft,elimGcd),div(elimGcdRight,elimGcd))),equals(elimGcdLeft,elimGcdRight))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="invertBits">bitwiseNegation {
\find(#normalassign ( (modal operator))\[{ .. #loc=~#se; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseNegation(#se)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: {programRules:Java}}</entry>
<entry key="defOfSeqSwap">defOfSeqSwap {
\find(seqSwap(s,iv,jv))
\varcond(\notFreeIn(uSub (variable), jv (int term)), \notFreeIn(uSub (variable), iv (int term)), \notFreeIn(uSub (variable), s (Seq term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),seqLen(s),if-then-else(not(and(and(and(leq(Z(0(#)),iv),leq(Z(0(#)),jv)),lt(iv,seqLen(s))),lt(jv,seqLen(s)))),any::seqGet(s,uSub),if-then-else(equals(uSub,iv),any::seqGet(s,jv),if-then-else(equals(uSub,jv),any::seqGet(s,iv),any::seqGet(s,uSub)))))) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="tryFinallyThrow">tryFinallyThrow {
\find(#allmodal ( (modal operator))\[{ .. try {throw #se;#slist}finally {
    #slist2
  }
 ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#se (program SimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. if (#se==null) { {
      #slist2
    }
                           throw  new  java.lang.NullPointerException ();
  }  else  {#typeof    (#se) #v0 = #se; {
      #slist2
    }
                           throw  #v0;
  }
 ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="translateJavaBitwiseXOr">translateJavaBitwiseXOrLong {
\find(javaBitwiseXOrLong(left,right))
\replacewith(xorJlong(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:javaSemantics,programRules:Java}}</entry>
<entry key="memsetEmpty">memsetEmpty {
\find(memset(h,empty,x))
\replacewith(h) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="expand_moduloChar">expand_moduloChar {
\find(moduloChar(i))
\replacewith(mod(i,add(char_MAX,Z(1(#))))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="commute_or_2">commute_or_2 {
\find(or(or(commResidue,commLeft),commRight))
\replacewith(or(or(commResidue,commRight),commLeft)) 
\heuristics(cnf_orComm, conjNormalForm)
Choices: {}}</entry>
<entry key="simplifyIfThenElse">simplifyIfThenElseUpdate4 {
\find(if-then-else(phi,t,t))
\varcond(de.uka.ilkd.key.rule.conditions.SimplifyIfThenElseUpdateCondition@146f3d22, )
\replacewith(result) 

Choices: {}}</entry>
<entry key="defOfSeqConcat">defOfSeqConcat {
\find(seqConcat(seq1,seq2))
\varcond(\notFreeIn(uSub (variable), seq2 (Seq term)), \notFreeIn(uSub (variable), seq1 (Seq term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),add(seqLen(seq1),seqLen(seq2)),if-then-else(lt(uSub,seqLen(seq1)),any::seqGet(seq1,uSub),any::seqGet(seq2,sub(uSub,seqLen(seq1)))))) 

Choices: {sequences:on}}</entry>
<entry key="postincrement_array">postincrement_array {
\find(#allmodal ( (modal operator))\[{ .. #e[#e0]++; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#e0) #v0 = #e0;#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="leq_add_iff2">leq_add_iff2 {
\find(leq(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(leq(i2,add(mul(sub(i3,i0),i1),i4))) 

Choices: {}}</entry>
<entry key="leq_add_iff1">leq_add_iff1 {
\find(leq(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(leq(add(mul(sub(i0,i3),i1),i2),i4)) 

Choices: {}}</entry>
<entry key="distributeIntersection">distributeIntersection {
\find(intersect(s1,union(s2,s3)))
\replacewith(union(intersect(s1,s2),intersect(s1,s3))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="square_nonneg">square_nonneg {
\find(leq(Z(0(#)),mul(i0,i0)))
\replacewith(true) 

Choices: {}}</entry>
<entry key="subsetOfEmpty">subsetOfEmpty {
\find(subset(s,empty))
\replacewith(equals(s,empty)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Quant_Bsum">wd_Numerical_Quant_Bsum {
\find(wd(bsum{i (variable)}(a,b,c)))
\varcond(\notFreeIn(i (variable), b (int term)), \notFreeIn(i (variable), a (int term)))
\replacewith(and(and(wd(a),wd(b)),all{i (variable)}(imp(and(leq(a,i),lt(i,b)),wd(c))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="throwLabelBlock">throwLabelBlock {
\find(#allmodal ( (modal operator))\[{ .. #lb: {throw #se;#slist} ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. throw #se; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="geq_diff_1">geq_diff_1 {
\find(geq(add(i0,Z(1(#))),i0))
\replacewith(true) 
\heuristics(int_arithmetic)
Choices: {}}</entry>
<entry key="wd_Heap_Reference">wd_Heap_Reference {
\find(wd(alpha::select(h,o,f)))
\varcond(\isArray(o (java.lang.Object term)), \not\isStaticField(f (Field term)), )
\replacewith(and(and(and(and(and(wd(h),wd(o)),wd(f)),wellFormed(h)),not(equals(o,null))),or(equals(f,java.lang.Object::&lt;created&gt;),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="onlyCreatedObjectsAreInLocSetsEQ">onlyCreatedObjectsAreInLocSetsEQ {
\assumes ([wellFormed(h),equals(LocSet::select(h,o,f),EQ)]==&gt;[]) 
\find(elementOf(o2,f2,EQ)==&gt;)
\add [or(equals(o2,null),equals(boolean::select(h,o2,java.lang.Object::&lt;created&gt;),TRUE))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_minus">compound_assignment_op_minus {
\find(#allmodal ( (modal operator))\[{ .. #v-=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v-(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="writePermissionSlice">writePermissionSlice {
\find(writePermissionObject(o,slice(ol,p)))
\replacewith(and(checkPermissionOwner(o,Z(0(#)),ol),writePermissionObject(o,p))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="mul_comm">mul_comm {
\find(mul(i0,i1))
\replacewith(mul(i1,i0)) 

Choices: {}}</entry>
<entry key="swapQuantifiersEx">swapQuantifiersEx {
\find(exists{u (variable)}(exists{v (variable)}(phi)))
\replacewith(exists{v (variable)}(exists{u (variable)}(phi))) 
\heuristics(swapQuantifiers)
Choices: {}}</entry>
<entry key="polySimp_addComm1">polySimp_addComm1 {
\find(add(add(i0,commLeft),commRight))
\replacewith(add(add(i0,commRight),commLeft)) 
\heuristics(polySimp_addOrder, polySimp_expand)
Choices: {}}</entry>
<entry key="polySimp_addComm0">polySimp_addComm0 {
\find(add(commLeft,commRight))
\replacewith(add(commRight,commLeft)) 
\heuristics(polySimp_addOrder, polySimp_expand)
Choices: {}}</entry>
<entry key="unionEqualsEmptyEQ">unionEqualsEmptyEQ {
\assumes ([equals(union(s,s2),EQ)]==&gt;[]) 
\find(equals(EQ,empty))
\sameUpdateLevel\replacewith(and(equals(s,empty),equals(s2,empty))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="elim_forall9">elim_forall9 {
\find(all{Gvar (variable)}(imp(equals(subGterm,Gvar),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall8">elim_forall8 {
\find(all{Gvar (variable)}(imp(equals(Gvar,subGterm),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall7">elim_forall7 {
\find(all{Gvar (variable)}(or(phi,not(equals(Hterm,Gvar)))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall6">elim_forall6 {
\find(all{Gvar (variable)}(or(phi,not(equals(Gvar,Hterm)))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall5">elim_forall5 {
\find(all{Gvar (variable)}(or(phi,not(equals(subGterm,Gvar)))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="ifthenelse_to_or_right2">ifthenelse_to_or_right2 {
\find(not(equals(t,if-then-else(phi,then,else))))
\replacewith(and(or(not(phi),not(equals(t,then))),or(phi,not(equals(t,else))))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: {}}</entry>
<entry key="expand_moduloShort">expand_moduloShort {
\find(moduloShort(i))
\replacewith(add(short_MIN,mod(add(short_HALFRANGE,i),short_RANGE))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="abortJavaCardTransaction">abortJavaCardTransactionBox {
\find(==&gt;box_transaction\[{ .. #abortJavaCardTransaction; ... }\] (post))
\replacewith([]==&gt;[update-application(elem-update(heap)(anon(savedHeap,allObjects(java.lang.Object::&lt;transactionConditionallyUpdated&gt;),heap)),box(post))]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="elim_forall4">elim_forall4 {
\find(all{Gvar (variable)}(or(phi,not(equals(Gvar,subGterm)))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="noElementOfSupersetImpliesNoElementOfSubset">noElementOfSupersetImpliesNoElementOfSubset {
\assumes ([subset(s,s2)]==&gt;[]) 
\find(==&gt;elementOf(o,f,s2))
\add []==&gt;[elementOf(o,f,s)] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_xor">compound_assignment_op_xor {
\find(#allmodal ( (modal operator))\[{ .. #v^=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v^(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="elim_forall3">elim_forall3 {
\find(all{Gvar (variable)}(not(equals(Hterm,Gvar))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(equals(G::instance(Hterm),FALSE)) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall2">elim_forall2 {
\find(all{Gvar (variable)}(not(equals(Gvar,Hterm))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(equals(G::instance(Hterm),FALSE)) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="defInDomainImpliesCreated">defInDomainImpliesCreated {
\find(inDomainImpliesCreated(m))
\varcond(\notFreeIn(o (variable), m (Map term)))
\replacewith(all{o (variable)}(imp(inDomain(m,o),equals(boolean::select(heap,o,java.lang.Object::&lt;created&gt;),TRUE)))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="accDefinition">accDefinition {
\find(acc(h,s,o,o2))
\varcond(\notFreeIn(fv (variable), o2 (deltaObject term)), \notFreeIn(fv (variable), o (java.lang.Object term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(fv (variable), h (Heap term)))
\replacewith(and(and(not(equals(o,null)),not(equals(o2,null))),exists{fv (variable)}(and(elementOf(o,fv,s),equals(deltaObject::select(h,o,fv),o2))))) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="elim_forall1">elim_forall1 {
\find(all{Gvar (variable)}(not(equals(subGterm,Gvar))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="compound_assignment_op_unsigned_shiftright_array">compound_assignment_op_unsigned_shiftright_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]&gt;&gt;&gt;=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]&gt;&gt;&gt;#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="elim_forall0">elim_forall0 {
\find(all{Gvar (variable)}(not(equals(Gvar,subGterm))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="add_literals">add_literals {
\find(add(Z(iz),Z(jz)))
\replacewith(#add(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="defMapEquality">defMapEquality {
\find(equals(m0,m1))
\varcond(\notFreeIn(vy (variable), m1 (Map term)), \notFreeIn(vy (variable), m0 (Map term)))
\replacewith(all{vy (variable)}(and(equiv(inDomain(m0,vy),inDomain(m1,vy)),imp(inDomain(m0,vy),equals(mapGet(m0,vy),mapGet(m1,vy)))))) 

Choices: {}}</entry>
<entry key="elementOfArrayRange">elementOfArrayRange {
\find(elementOf(o,f,arrayRange(o2,lower,upper)))
\varcond(\notFreeIn(iv (variable), upper (int term)), \notFreeIn(iv (variable), lower (int term)), \notFreeIn(iv (variable), f (Field term)))
\replacewith(and(equals(o,o2),exists{iv (variable)}(and(and(equals(f,arr(iv)),leq(lower,iv)),leq(iv,upper))))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="assignment_xor">compound_assignment_xor_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#seBool0^#seBool1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool0,#seBool1),FALSE,TRUE)),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="bsum_induction_upper_concrete">bsum_induction_upper_concrete {
\find(bsum{uSub (variable)}(i0,add(Z(1(#)),i2),t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(i0,i2,t),if-then-else(leq(i0,i2),subst{uSub (variable)}(i2,t),Z(0(#))))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="getOfMapEmpty">getOfMapEmpty {
\find(mapGet(mapEmpty,x))
\sameUpdateLevel\replacewith(mapUndef) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="mult_neg">mult_neg {
\find(and(lt(i0,Z(0(#))),lt(i1,Z(0(#)))))
\replacewith(lt(Z(0(#)),mul(i0,i1))) 

Choices: {}}</entry>
<entry key="equalityToSeqGetAndSeqLenRight">equalityToSeqGetAndSeqLenRight {
\find(==&gt;equals(s,s2))
\varcond(\notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\replacewith([]==&gt;[and(equals(seqLen(s),seqLen(s2)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(s2,iv)))))]) 
\heuristics(simplify_enlarging)
Choices: {sequences:on}}</entry>
<entry key="defOfSeqNPermInv">defOfSeqNPermInv {
\find(seqNPermInv(s))
\varcond(\notFreeIn(uSub (variable), s (Seq term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),seqLen(s),seqIndexOf(s,uSub))) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="wd_Heap_Pred_WellFormed">wd_Heap_Pred_WellFormed {
\find(WD(wellFormed(h)))
\replacewith(wd(h)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="compound_assignment_op_mul_attr">compound_assignment_op_mul_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute*=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute*#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Pred_InByte">wd_Numerical_Pred_InByte {
\find(WD(inByte(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_Y_Split">wd_Y_Split {
\find(WD(a))
\varcond(\hasSubFormulas (a (formula)), )
\replacewith(or(T(a),F(a))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="wd_Pair">wd_Pair {
\find(wd(pair(s,t)))
\replacewith(and(wd(s),wd(t))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="divide_eq7">divide_eq7 {
\assumes ([leq(divX,divXBoundNonPos)]==&gt;[]) 
\find(equals(divProd,divProdBoundNeg)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNonPos,Z(0(#))),imp(leq(divProdBoundNeg,Z(neglit(1(#)))),geq(divY,Z(1(#))))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_pos, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_eq6">divide_eq6 {
\assumes ([leq(divX,divXBoundNeg)]==&gt;[]) 
\find(equals(divProd,divProdBoundNonNeg)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNeg,Z(neglit(1(#)))),imp(geq(divProdBoundNonNeg,Z(0(#))),geq(divY,div(divProdBoundNonNeg,divXBoundNeg)))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="equalUnique">equalUnique {
\find(equals(f,f2))
\varcond(\equalUnique (f (any term), f2 (any term), result (formula)), )
\replacewith(result) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="divide_eq5">divide_eq5 {
\assumes ([leq(divX,divXBoundNonPos)]==&gt;[]) 
\find(equals(divProd,divProdBoundPos)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNonPos,Z(0(#))),imp(geq(divProdBoundPos,Z(1(#))),leq(divY,Z(neglit(1(#)))))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_neg, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_eq4">divide_eq4 {
\assumes ([leq(divX,divXBoundNeg)]==&gt;[]) 
\find(equals(divProd,divProdBoundNonPos)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(leq(divXBoundNeg,Z(neglit(1(#)))),imp(leq(divProdBoundNonPos,Z(0(#))),leq(divY,div(divProdBoundNonPos,divXBoundNeg)))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_eq3">divide_eq3 {
\assumes ([geq(divX,divXBoundNonNeg)]==&gt;[]) 
\find(equals(divProd,divProdBoundPos)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundNonNeg,Z(0(#))),imp(geq(divProdBoundPos,Z(1(#))),geq(divY,Z(1(#))))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_pos, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_eq2">divide_eq2 {
\assumes ([geq(divX,divXBoundPos)]==&gt;[]) 
\find(equals(divProd,divProdBoundNonPos)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundPos,Z(1(#))),imp(leq(divProdBoundNonPos,Z(0(#))),geq(divY,div(sub(add(divProdBoundNonPos,divXBoundPos),Z(1(#))),divXBoundPos)))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_eq1">divide_eq1 {
\assumes ([geq(divX,divXBoundNonNeg)]==&gt;[]) 
\find(equals(divProd,divProdBoundNeg)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundNonNeg,Z(0(#))),imp(leq(divProdBoundNeg,Z(neglit(1(#)))),leq(divY,Z(neglit(1(#)))))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_neg, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="divide_eq0">divide_eq0 {
\assumes ([geq(divX,divXBoundPos)]==&gt;[]) 
\find(equals(divProd,divProdBoundNonNeg)==&gt;)
\add [imp(equals(divProd,mul(divX,divY)),imp(geq(divXBoundPos,Z(1(#))),imp(geq(divProdBoundNonNeg,Z(0(#))),leq(divY,div(divProdBoundNonNeg,divXBoundPos)))))]==&gt;[] 
\heuristics(inEqSimp_nonLin_divide, inEqSimp_special_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_Seq_Swap">wd_Seq_Swap {
\find(wd(seqSwap(s,m,n)))
\replacewith(and(and(and(and(and(and(wd(s),wd(m)),wd(n)),leq(Z(0(#)),m)),leq(Z(0(#)),n)),lt(m,seqLen(s))),lt(n,seqLen(s)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="repeatMatchEmpty">repeatMatchEmpty {
\find(match(repeat(rexp,nTimes1),seqEmpty))
\replacewith(or(equals(nTimes1,Z(0(#))),and(gt(nTimes1,Z(0(#))),match(rexp,seqEmpty)))) 
\heuristics(simplify)
Choices: {Strings:on}}</entry>
<entry key="twoPermissions">twoPermissions {
\find(twoPermissions(o1,o2,p))
\varcond(\notFreeIn(ol2 (variable), o2 (java.lang.Object term)), \notFreeIn(ol1 (variable), o2 (java.lang.Object term)), \notFreeIn(ol2 (variable), o1 (java.lang.Object term)), \notFreeIn(ol1 (variable), o1 (java.lang.Object term)), \notFreeIn(ol2 (variable), p (Permission term)), \notFreeIn(ol1 (variable), p (Permission term)))
\replacewith(exists{ol1 (variable), ol2 (variable)}(equals(p,slice(consPermissionOwnerList(o1,ol1),slice(consPermissionOwnerList(o2,ol2),emptyPermission))))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="reachDependenciesStoreSimple">reachDependenciesStoreSimple {
\find(reach(store(h,o3,f2,x),allObjects(f),o,o2,n))
\varcond(\metaDisjoint f (Field term), f2 (Field term), )
\replacewith(reach(h,allObjects(f),o,o2,n)) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="distr_forallAnd">distr_forallAnd {
\find(all{u (variable)}(and(phi,psi)))
\replacewith(and(all{u (variable)}(phi),all{u (variable)}(psi))) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: {}}</entry>
<entry key="int_induction">int_induction {
\add [all{nv (variable)}(imp(geq(nv,Z(0(#))),b))]==&gt;[] ;
\add []==&gt;[all{nv (variable)}(imp(and(geq(nv,Z(0(#))),b),subst{nv (variable)}(add(nv,Z(1(#))),b)))] ;
\add []==&gt;[subst{nv (variable)}(Z(0(#)),b)] 

Choices: {}}</entry>
<entry key="inEqSimp_sepNegMonomial1">inEqSimp_sepNegMonomial1 {
\find(geq(add(sepResidue,sepNegMono),Z(0(#))))
\replacewith(leq(mul(sepNegMono,Z(neglit(1(#)))),sepResidue)) 
\heuristics(notHumanReadable, inEqSimp_balance, inEqSimp_directInEquations)
Choices: {}}</entry>
<entry key="ifthenelse_split">ifthenelse_split_for {
\find(if-then-else(phi,b,c))
\sameUpdateLevel\add []==&gt;[phi] \replacewith(c) ;
\add [phi]==&gt;[] \replacewith(b) 
\heuristics(split_cond)
Choices: {}}</entry>
<entry key="inEqSimp_sepNegMonomial0">inEqSimp_sepNegMonomial0 {
\find(leq(add(sepResidue,sepNegMono),Z(0(#))))
\replacewith(geq(mul(sepNegMono,Z(neglit(1(#)))),sepResidue)) 
\heuristics(notHumanReadable, inEqSimp_balance, inEqSimp_directInEquations)
Choices: {}}</entry>
<entry key="allLeftHide">allLeftHide {
\find(all{u (variable)}(b)==&gt;)
\addrules [insert_hidden {
\add [all{u (variable)}(b)]==&gt;[] 

Choices: {}}] \replacewith([subst{u (variable)}(t,b)]==&gt;[]) 
\heuristics(gamma_destructive)
Choices: {}}</entry>
<entry key="readPermissionOwe">readPermissionOwe {
\find(readPermissionOwe(o1,o2,p))
\varcond(\notFreeIn(pp (variable), o2 (java.lang.Object term)), \notFreeIn(ol (variable), o2 (java.lang.Object term)), \notFreeIn(pp (variable), o1 (java.lang.Object term)), \notFreeIn(ol (variable), o1 (java.lang.Object term)), \notFreeIn(pp (variable), p (Permission term)), \notFreeIn(ol (variable), p (Permission term)))
\replacewith(exists{ol (variable)}(exists{pp (variable)}(equals(p,slice(consPermissionOwnerList(o1,consPermissionOwnerList(o2,ol)),pp))))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="interfaces or abstract classes have no exact instances">exact_instance_for_interfaces_or_abstract_classes {
\find(G::exactInstance(obj))
\varcond(\isAbstractOrInterface (G), )
\replacewith(FALSE) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="definitionOfNewOnHeap">definitionOfNewOnHeap {
\find(==&gt;newOnHeap(h,s))
\varcond(\notFreeIn(i (variable), h (Heap term)), \notFreeIn(i (variable), s (Seq term)))
\replacewith([]==&gt;[all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,seqLen(s))),and(imp(equals(java.lang.Object::instance(any::seqGet(s,i)),TRUE),equals(boolean::select(h,java.lang.Object::seqGet(s,i),java.lang.Object::&lt;created&gt;),FALSE)),imp(equals(Seq::instance(any::seqGet(s,i)),TRUE),newOnHeap(h,Seq::seqGet(s,i))))))]) 
\heuristics(comprehensions)
Choices: {}}</entry>
<entry key="wd_Numerical_Quant_Bprod">wd_Numerical_Quant_Bprod {
\find(wd(bprod{i (variable)}(a,b,c)))
\varcond(\notFreeIn(i (variable), b (int term)), \notFreeIn(i (variable), a (int term)))
\replacewith(and(and(wd(a),wd(b)),all{i (variable)}(imp(and(leq(a,i),lt(i,b)),wd(c))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="blockBreakLabel">blockBreakLabel {
\find(#allmodal ( (modal operator))\[{ .. #lb0: {break ;
    #slist
  }
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. do-break(#lb0:break ;  ) ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="associativeLawIntersect">associativeLawIntersect {
\find(intersect(s1,intersect(s2,s3)))
\replacewith(intersect(intersect(s1,s2),s3)) 
\heuristics(conjNormalForm)
Choices: {programRules:Java}}</entry>
<entry key="bsum_induction_upper">bsum_induction_upper {
\find(bsum{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(i0,sub(i2,Z(1(#))),t),if-then-else(lt(i0,i2),subst{uSub (variable)}(sub(i2,Z(1(#))),t),Z(0(#))))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="andRight">andRight {
\find(==&gt;and(b,c))
\replacewith([]==&gt;[c]) ;
\replacewith([]==&gt;[b]) 
\heuristics(beta)
Choices: {}}</entry>
<entry key="bsum_invert_index">bsum_invert_index {
\find(bsum{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(neg(i1),neg(i0),subst{uSub (variable)}(neg(uSub1),t))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="binaryAndZeroRight">binaryAndZeroRight {
\find(binaryAnd(left,Z(0(#))))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="seqNPermDefReplace">seqNPermDefReplace {
\find(seqNPerm(s1))
\varcond(\notFreeIn(jv (variable), s1 (Seq term)), \notFreeIn(iv (variable), s1 (Seq term)))
\replacewith(all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s1))),exists{jv (variable)}(and(and(leq(Z(0(#)),jv),lt(jv,seqLen(s1))),equals(any::seqGet(s1,jv),iv)))))) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="inEqSimp_and_antiSymm1">inEqSimp_and_antiSymm1 {
\find(and(and(b,leq(i,i0)),geq(i,i0)))
\replacewith(and(b,equals(i,i0))) 
\heuristics(inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="sequentialToParallel3">sequentialToParallel3 {
\find(update-application(u,update-application(u2,u3)))
\replacewith(update-application(parallel-upd(u,update-application(u,u2)),u3)) 
\heuristics(update_join)
Choices: {}}</entry>
<entry key="selectCreatedOfAnonAsFormula">selectCreatedOfAnonAsFormula {
\find(equals(boolean::select(anon(h,s,h2),o,java.lang.Object::&lt;created&gt;),TRUE))
\replacewith(or(equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE),equals(boolean::select(h2,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_and_antiSymm0">inEqSimp_and_antiSymm0 {
\find(and(leq(i,i0),geq(i,i0)))
\replacewith(equals(i,i0)) 
\heuristics(inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="sequentialToParallel2">sequentialToParallel2 {
\find(update-application(u,update-application(u2,phi)))
\replacewith(update-application(parallel-upd(u,update-application(u,u2)),phi)) 
\heuristics(update_join)
Choices: {}}</entry>
<entry key="sequentialToParallel1">sequentialToParallel1 {
\find(update-application(u,update-application(u2,t)))
\replacewith(update-application(parallel-upd(u,update-application(u,u2)),t)) 
\heuristics(update_join)
Choices: {}}</entry>
<entry key="moduloLongFixpointInline">moduloLongFixpointInline {
\find(moduloLong(t))
\replacewith(if-then-else(inLong(t),t,moduloLong(t))) 
\heuristics(defOps_expandModulo)
Choices: {intRules:javaSemantics}}</entry>
<entry key="elimGcdLeq">elimGcdLeq {
\find(leq(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(leq(add(add(add(add(sub(Z(1(#)),elimGcd),mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#))),geq(add(add(add(mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#)))),leq(elimGcdLeftDiv,elimGcdRightDiv),leq(elimGcdLeft,elimGcdRight))) 
\heuristics(notHumanReadable, inEqSimp_pullOutGcd_leq, inEqSimp_pullOutGcd)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="lt_to_leq_2">lt_to_leq_2 {
\assumes ([]==&gt;[lt(i,j)]) 
\find(==&gt;equals(i,j))
\replacewith([]==&gt;[leq(i,j)]) 

Choices: {}}</entry>
<entry key="lt_to_leq_1">lt_to_leq_1 {
\find(or(lt(i,j),equals(i,j)))
\replacewith(leq(i,j)) 

Choices: {}}</entry>
<entry key="translateJavaBitwiseOr">translateJavaBitwiseOrInt {
\find(javaBitwiseOrInt(left,right))
\replacewith(if-then-else(and(inInt(left),inInt(right)),orJint(left,right),javaBitwiseOrIntOverFlow(left,right))) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="distr_elim">concrete_or_5 {
\find(or(and(c,b),and(c,not(b))))
\replacewith(c) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="assignmentUnfoldLeft">eval_order_access1 {
\find(#allmodal ( (modal operator))\[{ .. #nv.#attribute=#e; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nv (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nv) #v0 = #nv;#v0.#attribute=#e; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_mul_array">compound_assignment_op_mul_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]*=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]*#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="ifEqualsTRUE">ifEqualsTRUE {
\find(equals(if-then-else(phi,x,y),TRUE))
\replacewith(or(and(phi,equals(x,TRUE)),and(not(phi),equals(y,TRUE)))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="compound_assignment_op_and_array">compound_assignment_op_and_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]&amp;=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]&amp;#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="elementOfIntersect">elementOfIntersect {
\find(elementOf(o,f,intersect(s,s2)))
\replacewith(and(elementOf(o,f,s),elementOf(o,f,s2))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="inDomainOfSeq2Map">inDomainOfSeq2Map {
\find(inDomain(seq2map(s),x))
\replacewith(and(and(equals(int::instance(x),TRUE),leq(Z(0(#)),int::cast(x))),lt(int::cast(x),seqLen(s)))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="reachUniquePathSameSteps">reachUniquePathSameSteps {
\assumes ([reach(h,allObjects(f),o,o2,n)]==&gt;[]) 
\find(reach(h,allObjects(f),o,o3,n)==&gt;)
\varcond(\different (o2 (java.lang.Object term), o3 (java.lang.Object term)), )
\add [equals(o2,o3)]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {reach:on}}</entry>
<entry key="intersectWithEmpty">intersectWithEmptyRight {
\find(intersect(s,empty))
\replacewith(empty) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="unary_minus">unaryMinusLong {
\find(#normalassign ( (modal operator))\[{ .. #loc=-#seLong; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaUnaryMinusLong(#seLong)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: {programRules:Java}}</entry>
<entry key="ifEqualsNull">ifEqualsNull {
\find(equals(if-then-else(phi,x,y),null))
\replacewith(or(and(phi,equals(x,null)),and(not(phi),equals(y,null)))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="writePermissionOtherNoPermissionCurrentRead">writePermissionOtherNoPermissionCurrentRead {
\assumes ([writePermissionObject(o1,p)]==&gt;[equals(o2,o1)]) 
\find(readPermissionObject(o2,p))
\replacewith(false) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="bprod_zero">bprod_zero {
\find(bprod{uSub (variable)}(i0,i1,Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(lt(i0,i1),Z(0(#)),Z(1(#)))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="bsum_induction_lower">bsum_induction_lower {
\find(bsum{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(add(i0,Z(1(#))),i2,t),if-then-else(lt(i0,i2),subst{uSub (variable)}(i0,t),Z(0(#))))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="equalityToElementOfRight">equalityToElementOfRight {
\find(==&gt;equals(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith([]==&gt;[all{ov (variable)}(all{fv (variable)}(equiv(elementOf(ov,fv,s),elementOf(ov,fv,s2))))]) 
\heuristics(setEqualityBlastingRight)
Choices: {programRules:Java}}</entry>
<entry key="intersectWithAllLocs">intersectWithAllLocsRight {
\find(intersect(s,allLocs))
\replacewith(s) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="translateJavaShiftRight">translateJavaShiftRightLong {
\find(javaShiftRightLong(left,right))
\replacewith(shiftrightJlong(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:javaSemantics,programRules:Java}}</entry>
<entry key="commitJavaCardTransactionAPI">commitJavaCardTransactionAPI {
\find(==&gt;#allmodal ( (modal operator))\[{ .. 
  #jcsystemType.#commitTransaction()@#jcsystemType; ... }\] (post))
\replacewith([]==&gt;[#allmodal ( (modal operator))\[{ .. #commitJavaCardTransaction; ... }\] (post)]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="mult_pos_neg">mult_pos_neg {
\find(and(lt(i0,Z(0(#))),lt(Z(0(#)),i1)))
\replacewith(lt(mul(i0,i1),Z(0(#)))) 

Choices: {}}</entry>
<entry key="wd_Logical_Op_ExCond_Form">wd_Logical_Op_ExCond_Form {
\find(WD(ifExThenElse{j (variable)}(a,b,c)))
\varcond(\notFreeIn(j (variable), jPrime (int skolem term)), \notFreeIn(j (variable), c (formula)))
\replacewith(or(or(exists{j (variable)}(and(and(and(WD(a),WD(b)),a),imp(and(wellOrderLeqInt(jPrime,j),not(equals(jPrime,j))),subst{j (variable)}(jPrime,and(WD(a),not(a)))))),all{j (variable)}(and(and(WD(a),WD(c)),not(a)))),all{j (variable)}(and(and(WD(b),WD(c)),equiv(b,c))))) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="wd_Numerical_Quant_Max">wd_Numerical_Quant_Max {
\find(wd(max{j (variable)}(f,c)))
\replacewith(and(all{j (variable)}(wd(f)),all{j (variable)}(imp(equals(f,TRUE),wd(c))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="bsum_induction_lower_concrete">bsum_induction_lower_concrete {
\find(bsum{uSub (variable)}(add(Z(neglit(1(#))),i0),i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(i0,i2,t),if-then-else(lt(add(Z(neglit(1(#))),i0),i2),subst{uSub (variable)}(add(Z(neglit(1(#))),i0),t),Z(0(#))))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="equal_bsum_perm">equal_bsum_perm2 {
\assumes ([equals(bsum{uSub2 (variable)}(i2,i3,t2),t)]==&gt;[]) 
\find(==&gt;equals(bsum{uSub1 (variable)}(i0,i1,t1),t))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==&gt;[seqPerm(seqDef{uSub1 (variable)}(i0,i1,t1),seqDef{uSub2 (variable)}(i2,i3,t2))] 

Choices: {sequences:on,integerSimplificationRules:full}}</entry>
<entry key="writePermissionEmpty">writePermissionEmpty {
\find(writePermissionObject(o,emptyPermission))
\replacewith(true) 
\heuristics(concrete)
Choices: {permissions:on}}</entry>
<entry key="poolKeyIsContentOfValue">poolKeyIsContentOfValue {
\find(strContent(strPool(slit)))
\replacewith(slit) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="switch_brackets">switch_brackets {
\find(add(add(i,i0),i1))
\replacewith(add(i,add(i0,i1))) 

Choices: {}}</entry>
<entry key="superclasses_of_initialized_classes_are_initialized">superclasses_of_initialized_classes_are_initialized {
\assumes ([equals(boolean::select(heap,null,betaObj::&lt;classInitialized&gt;),TRUE),wellFormed(heap)]==&gt;[]) 
\find(boolean::select(heap,null,alphaObj::&lt;classInitialized&gt;))
\sameUpdateLevel\varcond(\isReference[non_null]( betaObj ), \strict\sub(betaObj, alphaObj), )
\replacewith(TRUE) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="typeEq">typeEqDerived2 {
\assumes ([equals(s,t1)]==&gt;[]) 
\find(G::instance(t1))
\sameUpdateLevel\replacewith(TRUE) 
\heuristics(concrete, simplify)
Choices: {}}</entry>
<entry key="mapUpdateUnchanged">mapUpdateUnchanged {
\find(equals(m,mapUpdate(m,key,value)))
\replacewith(and(inDomain(m,key),equals(mapGet(m,key),value))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="measuredByCheckEmpty">measuredByCheckEmpty {
\assumes ([measuredByEmpty]==&gt;[]) 
\find(measuredByCheck(c))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="notRight">notRight {
\find(==&gt;not(b))
\replacewith([b]==&gt;[]) 
\heuristics(alpha)
Choices: {}}</entry>
<entry key="elim_forall_subOfAll_and_phi">elim_forall_subOfAll_and_phi {
\find(all{locVar (variable)}(and(subset(locSetTerm,locVar),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(and(equals(locSetTerm,empty),all{locVar (variable)}(phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="jdiv_axiom">jdiv_axiom {
\find(jdiv(divNum,divDenom))
\sameUpdateLevel\add [equals(jdiv(divNum,divDenom),if-then-else(geq(divNum,Z(0(#))),div(divNum,divDenom),mul(div(mul(divNum,Z(neglit(1(#)))),divDenom),Z(neglit(1(#))))))]==&gt;[] 
\heuristics(notHumanReadable, defOps_jdiv)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_String_Translate">wd_String_Translate {
\find(wd(clTranslateInt(i)))
\replacewith(wd(i)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="arrayInitialisation">arrayInitialisation {
\find(#allmodal ( (modal operator))\[{ .. for ( int #v = #se; #v&lt;this.#length; #v++ )
    this[#v]=#lit;
 ... }\] (post))
\replacewith(update-application(elem-update(heap)(memset(heap,arrayRange(#a,#se,sub(length(#a),Z(1(#)))),#lit)),#allmodal(post))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="zadd_left_cancel0">zadd_left_cancel0 {
\find(equals(i0,add(i0,i1)))
\replacewith(equals(i1,Z(0(#)))) 

Choices: {}}</entry>
<entry key="wellFormedMemsetArrayObject">wellFormedMemsetArrayObject {
\find(wellFormed(memset(h,arrayRange(ar,lo,up),x)))
\succedentPolarity\varcond(\hasSort(\elemSort(ar (java.lang.Object term)), alpha), )
\replacewith(or(and(wellFormed(h),equals(x,null)),and(equals(boolean::select(h,x,java.lang.Object::&lt;created&gt;),TRUE),arrayStoreValid(ar,x)))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="equalRegEx">equalRegEx {
\find(equals(rexp1,rexp2))
\varcond(\notFreeIn(string (variable), rexp2 (RegEx term)), \notFreeIn(string (variable), rexp1 (RegEx term)))
\replacewith(all{string (variable)}(equiv(match(rexp1,string),match(rexp2,string)))) 

Choices: {Strings:on}}</entry>
<entry key="leq_add">leq_add {
\find(==&gt;leq(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==&gt;[exists{j2 (variable)}(leq(add(i0,j2),add(i1,j2)))]) 

Choices: {}}</entry>
<entry key="stringAssignment">stringAssignment {
\find(#normalassign ( (modal operator))\[{ .. #v=#slit; ... }\] (post))
\sameUpdateLevel\add [not(equals(strPool(#slit),null)),equals(boolean::select(heap,strPool(#slit),java.lang.Object::&lt;created&gt;),TRUE)]==&gt;[] \replacewith(update-application(elem-update(#v (program Variable))(strPool(#slit)),#normalassign(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="shiftLeftDef">shiftLeftDef {
\find(shiftleft(left,right))
\replacewith(if-then-else(lt(right,Z(0(#))),shiftright(left,neg(right)),mul(left,pow(Z(2(#)),right)))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="pullOutSelect">pullOutSelect {
\find(beta::select(h,o,f))
\sameUpdateLevel\add [equals(beta::select(h,o,f),selectSK&lt;&lt;selectSK&gt;&gt;)]==&gt;[] \replacewith(selectSK&lt;&lt;selectSK&gt;&gt;) 
\heuristics(pull_out_select)
Choices: {programRules:Java}}</entry>
<entry key="ifthenelse_true">ifthenelse_true_for {
\find(if-then-else(true,b,c))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="division">assignmentDivisionBigint2 {
\find(#allmodal ( (modal operator))\[{ .. #loc=#seAny/#seBigint; ... }\] (post))
\replacewith(if-then-else(not(equals(#seBigint,Z(0(#)))),update-application(elem-update(#loc (program Variable))(div(#seAny,#seBigint)),#allmodal(post)),#allmodal ( (modal operator))\[{ .. throw new java.lang.ArithmeticException (); ... }\] (post))) 
\heuristics(executeIntegerAssignment)
Choices: {runtimeExceptions:allow,bigint:on,programRules:Java}}</entry>
<entry key="inEqSimp_exactShadow3">inEqSimp_exactShadow3 {
\assumes ([leq(esLeft,esRight1)]==&gt;[]) 
\find(geq(esLeft,esRight2)==&gt;)
\add [geq(add(mul(Z(neglit(1(#))),esRight2),esRight1),Z(0(#)))]==&gt;[] 
\heuristics(notHumanReadable, inEqSimp_exactShadow, inEqSimp_saturate)
Choices: {}}</entry>
<entry key="inEqSimp_exactShadow2">inEqSimp_exactShadow2 {
\assumes ([leq(mul(esLeft,esCoeff1),esRight1)]==&gt;[]) 
\find(geq(esLeft,esRight2)==&gt;)
\add [imp(gt(esCoeff1,Z(0(#))),geq(add(mul(Z(neglit(1(#))),mul(esCoeff1,esRight2)),esRight1),Z(0(#))))]==&gt;[] 
\heuristics(notHumanReadable, inEqSimp_exactShadow, inEqSimp_saturate)
Choices: {}}</entry>
<entry key="inDomainOfMapSingleton">inDomainOfMapSingleton {
\find(inDomain(mapSingleton(x,y),z))
\replacewith(equals(x,z)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="inEqSimp_exactShadow1">inEqSimp_exactShadow1 {
\assumes ([leq(esLeft,esRight1)]==&gt;[]) 
\find(geq(mul(esLeft,esCoeff2),esRight2)==&gt;)
\add [imp(gt(esCoeff2,Z(0(#))),geq(add(mul(Z(neglit(1(#))),esRight2),mul(esCoeff2,esRight1)),Z(0(#))))]==&gt;[] 
\heuristics(notHumanReadable, inEqSimp_exactShadow, inEqSimp_saturate)
Choices: {}}</entry>
<entry key="wd_T_Logical_Quant_Exist">wd_T_Logical_Quant_Exist {
\find(T(exists{i (variable)}(a)))
\replacewith(exists{i (variable)}(T(a))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="inEqSimp_exactShadow0">inEqSimp_exactShadow0 {
\assumes ([leq(mul(esLeft,esCoeff1),esRight1)]==&gt;[]) 
\find(geq(mul(esLeft,esCoeff2),esRight2)==&gt;)
\add [imp(and(gt(esCoeff1,Z(0(#))),gt(esCoeff2,Z(0(#)))),geq(add(mul(Z(neglit(1(#))),mul(esCoeff1,esRight2)),mul(esCoeff2,esRight1)),Z(0(#))))]==&gt;[] 
\heuristics(notHumanReadable, inEqSimp_exactShadow, inEqSimp_saturate)
Choices: {}}</entry>
<entry key="boolean commute">boolean_false_commute {
\find(equals(FALSE,bo))
\replacewith(equals(bo,FALSE)) 
\heuristics(simplify_boolean)
Choices: {}}</entry>
<entry key="inEqSimp_or_antiSymm1">inEqSimp_or_antiSymm1 {
\find(or(or(b,leq(antiSymmLeft,antiSymmRightSmaller)),geq(antiSymmLeft,antiSymmRightBigger)))
\replacewith(or(b,if-then-else(equals(add(Z(2(#)),antiSymmRightSmaller),antiSymmRightBigger),not(equals(antiSymmLeft,add(Z(1(#)),antiSymmRightSmaller))),or(leq(antiSymmLeft,antiSymmRightSmaller),geq(antiSymmLeft,antiSymmRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_or_antiSymm, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_antiSymm0">inEqSimp_or_antiSymm0 {
\find(or(leq(antiSymmLeft,antiSymmRightSmaller),geq(antiSymmLeft,antiSymmRightBigger)))
\replacewith(if-then-else(equals(add(Z(2(#)),antiSymmRightSmaller),antiSymmRightBigger),not(equals(antiSymmLeft,add(Z(1(#)),antiSymmRightSmaller))),or(leq(antiSymmLeft,antiSymmRightSmaller),geq(antiSymmLeft,antiSymmRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_or_antiSymm, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="ex_pull_out4">ex_pull_out4 {
\find(or(exists{u (variable)}(b),exists{u2 (variable)}(c)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(or(b,subst{u2 (variable)}(u,c)))) 
\heuristics(pullOutQuantifierUnifying, pullOutQuantifierEx)
Choices: {}}</entry>
<entry key="ex_pull_out3">ex_pull_out3 {
\find(or(c,exists{u (variable)}(b)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(or(c,b))) 
\heuristics(pullOutQuantifierEx)
Choices: {}}</entry>
<entry key="powDef">powDef {
\find(pow(base,exp))
\varcond(\notFreeIn(x (variable), base (int term)), \notFreeIn(x (variable), exp (int term)))
\replacewith(if-then-else(geq(exp,Z(0(#))),bprod{x (variable)}(Z(0(#)),exp,base),undefinedPow(base,exp))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="ex_pull_out2">ex_pull_out2 {
\find(or(exists{u (variable)}(b),c))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(or(b,c))) 
\heuristics(pullOutQuantifierEx)
Choices: {}}</entry>
<entry key="ex_pull_out1">ex_pull_out1 {
\find(and(c,exists{u (variable)}(b)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(and(c,b))) 
\heuristics(pullOutQuantifierEx)
Choices: {}}</entry>
<entry key="ex_pull_out0">ex_pull_out0 {
\find(and(exists{u (variable)}(b),c))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(exists{u (variable)}(and(b,c))) 
\heuristics(pullOutQuantifierEx)
Choices: {}}</entry>
<entry key="wd_Undef_Term">wd_Undef_Term {
\find(wd(t&lt;&lt;l (termLabel)&gt;&gt;))
\varcond(\isConstant (t (any term)), \hasLabel (l (termLabel), undef), )
\replacewith(false) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="bprod_commutative_associative">bprod_commutative_associative {
\find(bprod{uSub (variable)}(i0,i2,mul(t,t2)))
\varcond(\notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(i0,i2,t),bprod{uSub1 (variable)}(i0,i2,subst{uSub (variable)}(uSub1,t2)))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="methodCallUnfoldArguments">methodCallWithAssignmentUnfoldArguments {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#nsmr; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #evaluate-arguments(#lhs=#nsmr;) ... }\] (post)) 
\heuristics(simplify_autoname)
Choices: {programRules:Java}}</entry>
<entry key="distributeIntersection_2">distributeIntersection_2 {
\find(intersect(union(s2,s3),s1))
\replacewith(union(intersect(s2,s1),intersect(s3,s1))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="nnf_notEx">nnf_notEx {
\find(not(exists{u (variable)}(phi)))
\replacewith(all{u (variable)}(not(phi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: {}}</entry>
<entry key="false_right">false_right {
\find(==&gt;false)
\replacewith([]==&gt;[]) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="simplifySelectOfMemset">simplifySelectOfMemset {
\find(equals(beta::select(memset(h,s,x),o,f),sk)==&gt;)
\addrules [replaceKnownSelect {
\find(beta::select(memset(h,s,x),o,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(and(elementOf(o,f,s),not(equals(f,java.lang.Object::&lt;created&gt;))),x,beta::select(h,o,f)),sk)]==&gt;[]) 
\heuristics(simplify_select)
Choices: {programRules:Java}}</entry>
<entry key="sizeOfSeq2Map">sizeOfSeq2Map {
\find(mapSize(seq2map(s)))
\sameUpdateLevel\replacewith(seqLen(s)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="inEqSimp_sepPosMonomial1">inEqSimp_sepPosMonomial1 {
\find(geq(add(sepResidue,sepPosMono),Z(0(#))))
\replacewith(geq(sepPosMono,mul(sepResidue,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, inEqSimp_balance, inEqSimp_directInEquations)
Choices: {}}</entry>
<entry key="inEqSimp_sepPosMonomial0">inEqSimp_sepPosMonomial0 {
\find(leq(add(sepResidue,sepPosMono),Z(0(#))))
\replacewith(leq(sepPosMono,mul(sepResidue,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, inEqSimp_balance, inEqSimp_directInEquations)
Choices: {}}</entry>
<entry key="ineffectiveCast3">ineffectiveCast3 {
\assumes ([equals(H::exactInstance(t),TRUE)]==&gt;[]) 
\find(H::cast(t))
\sameUpdateLevel\add [equals(H::cast(t),t)]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {}}</entry>
<entry key="expand_addJint">expand_addJint {
\find(addJint(i,i1))
\replacewith(moduloInt(add(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="ineffectiveCast2">ineffectiveCast2 {
\assumes ([equals(cs,gt)]==&gt;[]) 
\find(C::cast(gt))
\sameUpdateLevel\add [equals(C::cast(gt),gt)]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {}}</entry>
<entry key="expand_inLong">expand_inLong {
\find(inLong(i))
\replacewith(and(leq(i,long_MAX),leq(long_MIN,i))) 
\heuristics(defOps_expandRanges)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="charLiteral_to_int">charLiteral_to_int {
\find(C(iz))
\replacewith(Z(iz)) 
\heuristics(charLiteral_to_intLiteral)
Choices: {}}</entry>
<entry key="double_not">double_not {
\find(not(not(b)))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="less_add_iff2">less_add_iff2 {
\find(lt(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(lt(i2,add(mul(sub(i3,i0),i1),i4))) 

Choices: {}}</entry>
<entry key="sizeOfMapRemove">sizeOfMapRemove {
\find(mapSize(mapRemove(m,key)))
\add [imp(isFinite(m),equals(mapSize(mapRemove(m,key)),if-then-else(inDomain(m,key),sub(mapSize(m),Z(1(#))),mapSize(m))))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {}}</entry>
<entry key="less_add_iff1">less_add_iff1 {
\find(lt(add(mul(i0,i1),i2),add(mul(i3,i1),i4)))
\replacewith(lt(add(mul(sub(i0,i3),i1),i2),i4)) 

Choices: {}}</entry>
<entry key="lenOfSeqReverse">lenOfSeqReverseEQ {
\assumes ([equals(seqReverse(seq),EQ)]==&gt;[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(seqLen(seq)) 
\heuristics(simplify)
Choices: {sequences:on}}</entry>
<entry key="elementOfSetMinus">elementOfSetMinus {
\find(elementOf(o,f,setMinus(s,s2)))
\replacewith(and(elementOf(o,f,s),not(elementOf(o,f,s2)))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="mult_less_0_iff">mult_less_0_iff {
\find(lt(mul(i0,i1),Z(0(#))))
\replacewith(or(and(lt(i0,Z(0(#))),lt(Z(0(#)),i1)),and(lt(Z(0(#)),i0),lt(i1,Z(0(#)))))) 

Choices: {}}</entry>
<entry key="auto_induction">auto_int_induction_gt_Left2 {
\find(exists{uSub (variable)}(and(gt(uSub,t),b))==&gt;)
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([]==&gt;[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),not(b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),not(b)),true))]) ;
\replacewith([]==&gt;[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),not(b)),true)]) 
\heuristics(induction_var, auto_induction)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_String_Pred_EndsWith">wd_String_Pred_EndsWith {
\find(WD(clEndsWith(l,c)))
\replacewith(and(wd(c),wd(l))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="case_distinction">case_distinction_l {
\find(b==&gt;)
\addrules [to_false {
\find(b==&gt;)
\replacewith([false]==&gt;[]) 
\heuristics(simplify)
Choices: {}}] ;
\addrules [to_true {
\find(b==&gt;)
\replacewith([true]==&gt;[]) 
\heuristics(simplify)
Choices: {}}] 

Choices: {}}</entry>
<entry key="initialisation process has already terminated">class_initialized_excludes_class_init_in_progress {
\assumes ([equals(boolean::select(heap,null,alphaObj::&lt;classInitialized&gt;),TRUE),wellFormed(heap)]==&gt;[]) 
\find(boolean::select(heap,null,alphaObj::&lt;classInitializationInProgress&gt;))
\sameUpdateLevel\replacewith(FALSE) 
\heuristics(simplify, confluence_restricted)
Choices: {programRules:Java}}</entry>
<entry key="simplifySelectOfMemsetEQ">simplifySelectOfMemsetEQ {
\assumes ([equals(memset(h,s,x),EQ)]==&gt;[]) 
\find(equals(beta::select(EQ,o,f),sk)==&gt;)
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(and(elementOf(o,f,s),not(equals(f,java.lang.Object::&lt;created&gt;))),x,beta::select(h,o,f)),sk)]==&gt;[]) 
\heuristics(simplify_select)
Choices: {programRules:Java}}</entry>
<entry key="equalityToSeqGetAndSeqLen">equalityToSeqGetAndSeqLen {
\find(equals(left,right))
\varcond(\notFreeIn(iv (variable), right (Seq term)), \notFreeIn(iv (variable), left (Seq term)))
\replacewith(and(equals(seqLen(left),seqLen(right)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(left))),equals(any::seqGet(left,iv),any::seqGet(right,iv)))))) 
\heuristics(defOpsSeqEquality)
Choices: {sequences:on}}</entry>
<entry key="getOfRemoveAnyConcrete2">getOfRemoveAnyConcrete2 {
\assumes ([geq(seqLen(s1),Z(1(#)))]==&gt;[]) 
\find(alpha::seqGet(seqRemove(s1,Z(0(#))),i3))
\replacewith(if-then-else(and(leq(Z(0(#)),i3),lt(i3,sub(seqLen(s1),Z(1(#))))),alpha::seqGet(s1,add(i3,Z(1(#)))),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="compound_assignment_op_shiftleft">compound_assignment_op_shiftleft {
\find(#allmodal ( (modal operator))\[{ .. #v&lt;&lt;=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v&lt;&lt;(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="getOfRemoveAnyConcrete1">getOfRemoveAnyConcrete1 {
\assumes ([geq(seqLen(s1),Z(1(#)))]==&gt;[]) 
\find(alpha::seqGet(seqRemove(s1,sub(seqLen(s1),Z(1(#)))),i3))
\replacewith(if-then-else(lt(i3,sub(seqLen(s1),Z(1(#)))),alpha::seqGet(s1,i3),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="elementOfUnionEQ">elementOfUnionEQ {
\assumes ([equals(union(s,s2),EQ)]==&gt;[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\replacewith(or(elementOf(o,f,s),elementOf(o,f,s2))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="seqConcatWithEmpty">seqConcatWithSeqEmpty2 {
\find(seqConcat(seqEmpty,seq))
\replacewith(seq) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="stringConcat">stringConcat {
\find(#normalassign ( (modal operator))\[{ .. #v=#sstr1+#sstr2; ... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(strContent(#sstr1),strContent(#sstr2)))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="narrowSelectArrayType">narrowSelectArrayType {
\assumes ([wellFormed(h)]==&gt;[equals(o,null)]) 
\find(beta::select(h,o,arr(idx)))
\sameUpdateLevel\varcond(\hasSort(\elemSort(o (java.lang.Object term)), alpha), \strict\sub(alpha, beta), )
\replacewith(alpha::select(h,o,arr(idx))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_commuteLeq">inEqSimp_commuteLeq {
\find(leq(commLeft,commRight))
\replacewith(geq(commRight,commLeft)) 
\heuristics(inEqSimp_commute, inEqSimp_expand)
Choices: {}}</entry>
<entry key="assignment">assignment_read_static_attribute_with_variable_prefix {
\find(#allmodal ( (modal operator))\[{ .. #loc=@(#v.#sv); ... }\] (post))
\varcond(\hasSort(#sv (program StaticVariable), G), )
\add []==&gt;[readPermission(Permission::select(permissions,#v,#memberPVToField(#sv)))] \replacewith(#allmodal ( (modal operator))\[{ .. assert false : "Access permission check-point (static read)."; ... }\] (post)) ;
\replacewith(update-application(elem-update(#loc (program Variable))(G::select(heap,#v,#memberPVToField(#sv))),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="applyEq_and_int7">applyEq_and_int7 {
\find(and(and(b,equals(applyEqLeft,applyEqRight)),leq(applyEqLeft,applyEqOther)))
\replacewith(and(and(b,equals(applyEqLeft,applyEqRight)),leq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_int6">applyEq_and_int6 {
\find(and(equals(applyEqLeft,applyEqRight),leq(applyEqLeft,applyEqOther)))
\replacewith(and(equals(applyEqLeft,applyEqRight),leq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_int5">applyEq_and_int5 {
\find(and(and(b,equals(applyEqLeft,applyEqRight)),geq(applyEqLeft,applyEqOther)))
\replacewith(and(and(b,equals(applyEqLeft,applyEqRight)),geq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_int4">applyEq_and_int4 {
\find(and(equals(applyEqLeft,applyEqRight),geq(applyEqLeft,applyEqOther)))
\replacewith(and(equals(applyEqLeft,applyEqRight),geq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_int3">applyEq_and_int3 {
\find(and(and(b,leq(applyEqLeft,applyEqOther)),equals(applyEqLeft,applyEqRight)))
\replacewith(and(and(b,leq(applyEqRight,applyEqOther)),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="elementOfUnion">elementOfUnion {
\find(elementOf(o,f,union(s,s2)))
\replacewith(or(elementOf(o,f,s),elementOf(o,f,s2))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="applyEq_and_int2">applyEq_and_int2 {
\find(and(leq(applyEqLeft,applyEqOther),equals(applyEqLeft,applyEqRight)))
\replacewith(and(leq(applyEqRight,applyEqOther),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_int1">applyEq_and_int1 {
\find(and(and(b,geq(applyEqLeft,applyEqOther)),equals(applyEqLeft,applyEqRight)))
\replacewith(and(and(b,geq(applyEqRight,applyEqOther)),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_int0">applyEq_and_int0 {
\find(and(geq(applyEqLeft,applyEqOther),equals(applyEqLeft,applyEqRight)))
\replacewith(and(geq(applyEqRight,applyEqOther),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="simplifySelectOfAnonEQ">simplifySelectOfAnonEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==&gt;[]) 
\find(equals(beta::select(EQ,o,f),sk)==&gt;)
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(or(and(elementOf(o,f,s),not(equals(f,java.lang.Object::&lt;created&gt;))),elementOf(o,f,freshLocs(h))),beta::select(h2,o,f),beta::select(h,o,f)),sk)]==&gt;[]) 
\heuristics(simplify_select)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Pred_WellOrdered">wd_Numerical_Pred_WellOrdered {
\find(WD(wellOrderLeqInt(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="subSeqConcatEQ">subSeqConcatEQ {
\assumes ([equals(seqConcat(s1,s2),EQ)]==&gt;[]) 
\find(seqSub(EQ,l,u))
\replacewith(seqConcat(seqSub(s1,l,if-then-else(lt(seqLen(s1),u),seqLen(s1),u)),seqSub(s2,if-then-else(lt(l,seqLen(s1)),Z(0(#)),sub(l,seqLen(s1))),sub(u,seqLen(s1))))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: {sequences:on}}</entry>
<entry key="orLeft">orLeft {
\find(or(b,c)==&gt;)
\replacewith([c]==&gt;[]) ;
\replacewith([b]==&gt;[]) 
\heuristics(beta)
Choices: {}}</entry>
<entry key="wd_Heap_Reference_Created">wd_Heap_Reference_Created {
\find(wd(alpha::select(h,o,java.lang.Object::&lt;created&gt;)))
\replacewith(and(and(and(wd(h),wd(o)),wellFormed(h)),not(equals(o,null)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="andJIntDef">andJIntDef {
\find(andJint(left,right))
\replacewith(moduloInt(binaryAnd(left,right))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="inDomainOfMapOverride">inDomainOfMapOverride {
\find(inDomain(mapOverride(m0,m1),x))
\replacewith(or(inDomain(m0,x),inDomain(m1,x))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="assignmentSaveLocationThis">eval_order_access4_this {
\find(#allmodal ( (modal operator))\[{ .. #v.#a=#nse; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))),  \not \static(#a (program Variable)), \isThisReference (#v (program Variable)), )
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #v1 = #nse;#v.#a=#v1; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Logical_Op_AndSC">wd_Logical_Op_AndSC {
\find(WD(and(a,b)&lt;&lt;l (termLabel)&gt;&gt;))
\varcond(\hasLabel (l (termLabel), SC), )
\replacewith(and(WD(a),imp(a,WD(b)))) 
\heuristics(simplify)
Choices: {wdOperator:L,wdChecks:on}}</entry>
<entry key="seqReverseOfSeqEmpty">seqReverseOfSeqEmpty {
\find(seqReverse(seqEmpty))
\replacewith(seqEmpty) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="subsetWithAllLocs">subsetWithAllLocs2 {
\find(subset(allLocs,s))
\replacewith(equals(s,allLocs)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="bsum_one_summand_concrete2">bsum_one_summand_concrete2 {
\find(bsum{uSub (variable)}(add(Z(neglit(1(#))),i0),i0,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(subst{uSub (variable)}(add(Z(neglit(1(#))),i0),t)) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="bsum_one_summand_concrete1">bsum_one_summand_concrete1 {
\find(bsum{uSub (variable)}(i0,add(Z(1(#)),i0),t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(subst{uSub (variable)}(i0,t)) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="compound_assignment_op_unsigned_shiftright_attr">compound_assignment_op_unsigned_shiftright_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute&gt;&gt;&gt;=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute&gt;&gt;&gt;#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="tryReturn">tryFinallyReturnNoValue {
\find(#allmodal ( (modal operator))\[{ .. try {return ;#slist}#csfinally {
    #slist2
  }
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..  {#slist2}return ; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="subsetOfItself">subsetOfItself {
\find(subset(s,s))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="assignment_to_primitive_array_component">assignment_to_primitive_array_component_transaction {
\find(#transaction ( (modal operator))\[{ .. #v[#se]=#se0; ... }\] (post))
\varcond( \not \isReferenceArray(#v (program Variable)), )
\replacewith(update-application(elem-update(heap)(store(heap,#v,arr(#se),#se0)),update-application(elem-update(savedHeap)(if-then-else(equals(int::select(heap,#v,java.lang.Object::&lt;transient&gt;),Z(0(#))),store(savedHeap,#v,java.lang.Object::&lt;transactionConditionallyUpdated&gt;,TRUE),if-then-else(equals(boolean::select(savedHeap,#v,java.lang.Object::&lt;transactionConditionallyUpdated&gt;),FALSE),store(savedHeap,#v,arr(#se),#se0),savedHeap))),#transaction(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {JavaCard:on,runtimeExceptions:ignore,programRules:Java}}</entry>
<entry key="contains">contains {
\find(clContains(seqConcat(seqSingleton(fstTextCharacter),textStringTail),searchString))
\sameUpdateLevel\add [equals(seqLen(searchString),newSym)]==&gt;[] \replacewith(and(lt(newSym,seqLen(textStringTail)),or(equals(seqSub(seqConcat(seqSingleton(fstTextCharacter),textStringTail),Z(0(#)),newSym),searchString),clContains(textStringTail,searchString)))) 
\heuristics(stringsIntroduceNewSym, stringsContainsDefInline)
Choices: {Strings:on}}</entry>
<entry key="altAxiom">altAxiom {
\find(match(alt(rexp1,rexp2),string))
\replacewith(or(match(rexp1,string),match(rexp2,string))) 
\heuristics(simplify)
Choices: {Strings:on}}</entry>
<entry key="replace_long_HALFRANGE">replace_long_HALFRANGE {
\find(long_HALFRANGE)
\replacewith(Z(8(0(8(5(7(7(4(5(8(6(3(0(2(7(3(3(2(2(9(#))))))))))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="remove_parentheses_right">remove_parentheses_right {
\find(#allmodal ( (modal operator))\[{ .. #lhs=(#e); ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs=#e; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="javaShiftLeftLongDef">javaShiftLeftLongDef {
\find(shiftleftJlong(left,right))
\replacewith(moduloLong(shiftleft(left,mod(right,Z(4(6(#))))))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="definitionOfObjectIsomorphic">definitionOfObjectIsomorphic {
\find(==&gt;objectIsomorphic(s1,o1,s2,o2))
\varcond(\notFreeIn(i (variable), o2 (java.lang.Object term)), \notFreeIn(i (variable), o1 (java.lang.Object term)), \notFreeIn(i (variable), s2 (Seq term)), \notFreeIn(i (variable), s1 (Seq term)))
\replacewith([]==&gt;[all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,seqLen(s1))),and(imp(equals(java.lang.Object::instance(any::seqGet(s1,i)),TRUE),equiv(equals(java.lang.Object::seqGet(s1,i),o1),equals(java.lang.Object::seqGet(s2,i),o2))),imp(equals(Seq::instance(any::seqGet(s1,i)),TRUE),objectIsomorphic(Seq::seqGet(s1,i),o1,Seq::seqGet(s2,i),o2)))))]) 
\heuristics(comprehensions)
Choices: {}}</entry>
<entry key="postdecrement_attribute">postdecrement_attribute {
\find(#allmodal ( (modal operator))\[{ .. #e.#attribute--; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#v.#attribute=(#typeof(#attribute))(#v.#attribute-1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="insert_constant_value">insert_constant_value {
\find(#cv)
\replacewith(#constantvalue(#cv)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="elementOfEmpty">elementOfEmpty {
\find(elementOf(o,f,empty))
\replacewith(false) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wellFormedStoreLocSetEQ">wellFormedStoreLocSetEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==&gt;[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\replacewith(and(wellFormed(h),createdInHeap(x,h))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_minus_array">compound_assignment_op_minus_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]-=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]-#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="subSeqSingleton">subSeqSingleton {
\find(seqSub(seqSingleton(x),Z(0(#)),Z(1(#))))
\replacewith(seqSingleton(x)) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="regExConcatConcreteStringRight">regExConcatConcreteStringRight {
\find(match(regExConcat(rexp,regEx(pattern)),string))
\replacewith(and(and(leq(seqLen(pattern),seqLen(string)),match(rexp,seqSub(string,Z(0(#)),sub(seqLen(string),seqLen(pattern))))),match(regEx(pattern),seqSub(string,sub(seqLen(string),seqLen(pattern)),seqLen(string))))) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="reference_type_cast">reference_type_cast {
\find(#allmodal ( (modal operator))\[{ .. #lhs=(#npit)#se; ... }\] (post))
\varcond(\hasSort(#npit (program NonPrimitiveType), G), )
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(#addCast(#se,#lhs)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {runtimeExceptions:ignore,programRules:Java}}</entry>
<entry key="hashCodeBase">hashCodeBase {
\find(clHashCode(seqEmpty))
\replacewith(Z(0(#))) 
\heuristics(simplify_literals)
Choices: {Strings:on}}</entry>
<entry key="inByte">inByte {
\find(inByte(i))
\replacewith(true) 
\heuristics(concrete)
Choices: {intRules:arithmeticSemanticsIgnoringOF,programRules:Java}}</entry>
<entry key="nnf_notEqv">nnf_notEqv {
\find(not(equiv(phi,psi)))
\replacewith(equiv(phi,not(psi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: {}}</entry>
<entry key="simplifySelectOfStore">simplifySelectOfStore {
\find(equals(beta::select(store(h,o,f,x),o2,f2),sk)==&gt;)
\addrules [replaceKnownSelect {
\find(beta::select(store(h,o,f,x),o2,f2))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(and(and(equals(o,o2),equals(f,f2)),not(equals(f,java.lang.Object::&lt;created&gt;))),beta::cast(x),beta::select(h,o2,f2)),sk)]==&gt;[]) 
\heuristics(simplify_select)
Choices: {programRules:Java}}</entry>
<entry key="unionWithItself">unionWithItself {
\find(union(s,s))
\replacewith(s) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="bprod_one_factor">bprod_one_factor {
\find(bprod{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(equals(add(i0,Z(1(#))),i1),subst{uSub (variable)}(i0,t),bprod{uSub (variable)}(i0,i1,t))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="lenOfNPermInv">lenOfNPermInv {
\find(seqLen(seqNPermInv(s1)))
\replacewith(seqLen(s1)) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="subSeqSingleton2">subSeqSingleton2 {
\find(seqSub(seqSingleton(x),l,u))
\replacewith(seqConcat(seqSub(seqEmpty,if-then-else(lt(l,Z(0(#))),l,Z(0(#))),if-then-else(lt(u,Z(0(#))),u,Z(0(#)))),seqConcat(if-then-else(and(leq(l,Z(0(#))),geq(u,Z(1(#)))),seqSingleton(x),seqEmpty),seqSub(seqEmpty,if-then-else(gt(l,Z(0(#))),l,Z(1(#))),if-then-else(gt(u,Z(0(#))),u,Z(1(#))))))) 
\heuristics(simplify_enlarging)
Choices: {sequences:on}}</entry>
<entry key="instanceof_eval">instanceof_eval {
\find(#allmodal ( (modal operator))\[{ .. #v=#nse instanceof #t; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #v0 = #nse;#v=#v0 instanceof #t; ... }\] (post)) 
\heuristics(simplify_autoname)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_homoInEq1">inEqSimp_homoInEq1 {
\find(geq(homoLeft,homoRight))
\replacewith(leq(add(homoRight,mul(homoLeft,Z(neglit(1(#))))),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_homo, inEqSimp_expand)
Choices: {}}</entry>
<entry key="bprod_induction_upper">bprod_induction_upper {
\find(bprod{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(i0,sub(i2,Z(1(#))),t),if-then-else(lt(i0,i2),subst{uSub (variable)}(sub(i2,Z(1(#))),t),Z(1(#))))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="collect_same_terms">collect_same_terms_3 {
\find(add(add(neg(mul(i,j)),mul(i0,i1)),add(neg(mul(i,j)),mul(j0,j1))))
\replacewith(add(neg(mul(Z(2(#)),mul(i,j))),add(mul(i0,i1),mul(j0,j1)))) 

Choices: {}}</entry>
<entry key="inEqSimp_homoInEq0">inEqSimp_homoInEq0 {
\find(leq(homoLeft,homoRight))
\replacewith(geq(add(homoRight,mul(homoLeft,Z(neglit(1(#))))),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_homo, inEqSimp_expand)
Choices: {}}</entry>
<entry key="crossInst">crossInst {
\assumes ([]==&gt;[or(or(leq(k,Z(neglit(1(#)))),geq(k,i)),c)]) 
\find(all{v (variable)}(or(or(or(leq(v,Z(neglit(1(#)))),geq(v,j)),b),a))==&gt;)
\add [and(equals(sk,k),subst{v (variable)}(sk,or(or(or(leq(v,Z(neglit(1(#)))),geq(v,j)),b),a)))]==&gt;[] 
\heuristics(loopInvariant)
Choices: {}}</entry>
<entry key="less_or_equal">compound_less_equal_than_comparison_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e&lt;=#nse0; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse0) #v1 = #nse0;#lhs=#v0&lt;=#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="instanceCreation">instanceCreation {
\find(#allmodal ( (modal operator))\[{ .. #n ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#n (program SimpleInstanceCreation))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#v0) #v0 = create-object(#n);constructor-call(#n)post-work(#v0) ... }\] (post)) 
\heuristics(method_expand)
Choices: {programRules:Java}}</entry>
<entry key="geq_add_one">geq_add_one {
\find(geq(i0,i1))
\replacewith(geq(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: {}}</entry>
<entry key="inEqSimp_invertInEq1">inEqSimp_invertInEq1 {
\find(geq(invertLeft,invertRight))
\replacewith(leq(mul(invertLeft,Z(neglit(1(#)))),mul(invertRight,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, inEqSimp_normalise, inEqSimp_directInEquations)
Choices: {}}</entry>
<entry key="inEqSimp_invertInEq0">inEqSimp_invertInEq0 {
\find(leq(invertLeft,invertRight))
\replacewith(geq(mul(invertLeft,Z(neglit(1(#)))),mul(invertRight,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, inEqSimp_normalise, inEqSimp_directInEquations)
Choices: {}}</entry>
<entry key="seqDef_induction_upper_concrete">seqDef_induction_upper_concrete {
\find(seqDef{uSub (variable)}(from,add(Z(1(#)),to),t))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqConcat(seqDef{uSub (variable)}(from,to,t),if-then-else(leq(from,to),seqSingleton(subst{uSub (variable)}(to,t)),seqEmpty))) 
\heuristics(simplify_enlarging)
Choices: {sequences:on}}</entry>
<entry key="eq_sides">eq_sides {
\find(equals(i,j))
\replacewith(equals(sub(i,j),Z(0(#)))) 

Choices: {}}</entry>
<entry key="lt_to_gt">lt_to_gt {
\find(lt(i,i0))
\replacewith(gt(i0,i)) 

Choices: {}}</entry>
<entry key="doWhileUnwind">doWhileUnwind {
\find(#allmodal ( (modal operator))\[{ .. do#swhile ( #e );
 ... }\] (post))
\varcond(\newLabel (#innerLabel (program Label)), \newLabel (#outerLabel (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ .. #unwind-loop(do#swhile ( #e );  ) ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Logical_Op_Eqv">wd_Logical_Op_Eqv {
\find(WD(equiv(a,b)))
\replacewith(and(WD(a),WD(b))) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="defMapSingleton">defMapSingleton {
\find(mapSingleton(xa,y))
\varcond(\notFreeIn(vy (variable), y (any term)), \notFreeIn(vy (variable), xa (alpha term)))
\replacewith(mapForeach{vy (variable)}(if-then-else(equals(vy,any::cast(xa)),TRUE,FALSE),y)) 

Choices: {}}</entry>
<entry key="all_pull_out4">all_pull_out4 {
\find(and(all{u (variable)}(b),all{u2 (variable)}(c)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(and(b,subst{u2 (variable)}(u,c)))) 
\heuristics(pullOutQuantifierUnifying, pullOutQuantifierAll)
Choices: {}}</entry>
<entry key="wd_Logical_Op_Cond_Expr">wd_Logical_Op_Cond_Expr {
\find(wd(if-then-else(a,s,t)))
\replacewith(or(or(and(T(a),wd(s)),and(F(a),wd(t))),and(and(wd(s),wd(t)),equals(s,t)))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="methodCallWithAssignment">methodCallWithAssignment {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#se.#mn(#selist); ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))), \not \staticMethodReference(#se (program SimpleExpression), #mn (program MethodName), #selist (program SimpleExpression)), )
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#lhs) #v0;method-call(#se.#mn(#selist);)#lhs=#v0; ... }\] (post)) 
\heuristics(method_expand)
Choices: {runtimeExceptions:ignore,programRules:Java}}</entry>
<entry key="all_pull_out3">all_pull_out3 {
\find(or(c,all{u (variable)}(b)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(or(c,b))) 
\heuristics(pullOutQuantifierAll)
Choices: {}}</entry>
<entry key="stringConcatBooleanLeft">stringConcatBooleanLeft {
\find(#normalassign ( (modal operator))\[{ .. #v=#seLeft+#sstrRight; ... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(if-then-else(equals(#seLeft,TRUE),seqConcat(seqSingleton(C(6(1(1(#))))),seqConcat(seqSingleton(C(4(1(1(#))))),seqConcat(seqSingleton(C(7(1(1(#))))),seqSingleton(C(1(0(1(#)))))))),seqConcat(seqSingleton(C(2(0(1(#))))),seqConcat(seqSingleton(C(7(9(#)))),seqConcat(seqSingleton(C(8(0(1(#))))),seqConcat(seqSingleton(C(5(1(1(#))))),seqSingleton(C(1(0(1(#)))))))))),strContent(#sstrRight)))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="all_pull_out2">all_pull_out2 {
\find(or(all{u (variable)}(b),c))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(or(b,c))) 
\heuristics(pullOutQuantifierAll)
Choices: {}}</entry>
<entry key="all_pull_out1">all_pull_out1 {
\find(and(c,all{u (variable)}(b)))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(and(c,b))) 
\heuristics(pullOutQuantifierAll)
Choices: {}}</entry>
<entry key="all_pull_out0">all_pull_out0 {
\find(and(all{u (variable)}(b),c))
\varcond(\notFreeIn(u (variable), c (formula)))
\replacewith(all{u (variable)}(and(b,c))) 
\heuristics(pullOutQuantifierAll)
Choices: {}}</entry>
<entry key="beginJavaCardTransaction">beginJavaCardTransactionBox {
\find(==&gt;\[{ .. #beginJavaCardTransaction; ... }\] (post))
\replacewith([]==&gt;[update-application(elem-update(savedHeap)(heap),box_transaction(post))]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="elim_exists_nonSingleton5">elim_exists_nonSingleton5 {
\find(exists{INTVar (variable)}(leq(intTerm,INTVar)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="mapEqualityRight">mapEqualityRight {
\find(==&gt;equals(m0,m1))
\varcond(\notFreeIn(vy (variable), m1 (Map term)), \notFreeIn(vy (variable), m0 (Map term)))
\replacewith([]==&gt;[all{vy (variable)}(and(equiv(inDomain(m0,vy),inDomain(m1,vy)),imp(inDomain(m0,vy),equals(mapGet(m0,vy),mapGet(m1,vy)))))]) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="elim_exists_nonSingleton4">elim_exists_nonSingleton4 {
\find(exists{INTVar (variable)}(geq(intTerm,INTVar)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_exists_nonSingleton3">elim_exists_nonSingleton3 {
\find(exists{INTVar (variable)}(leq(INTVar,intTerm)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_exists_nonSingleton2">elim_exists_nonSingleton2 {
\find(exists{INTVar (variable)}(geq(INTVar,intTerm)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="binaryOrNeutralLeft">binaryOrNeutralLeft {
\find(binaryOr(Z(0(#)),right))
\replacewith(right) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="elim_exists_nonSingleton1">elim_exists_nonSingleton1 {
\find(exists{nonSingleVar (variable)}(not(equals(Hterm,nonSingleVar))))
\varcond(\notFreeIn(nonSingleVar (variable), Hterm (H term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_exists_nonSingleton0">elim_exists_nonSingleton0 {
\find(exists{nonSingleVar (variable)}(not(equals(nonSingleVar,Hterm))))
\varcond(\notFreeIn(nonSingleVar (variable), Hterm (H term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="expand_addJlong">expand_addJlong {
\find(addJlong(i,i1))
\replacewith(moduloLong(add(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="parallelWithSkip2">parallelWithSkip2 {
\find(parallel-upd(u,skip))
\replacewith(u) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="parallelWithSkip1">parallelWithSkip1 {
\find(parallel-upd(skip,u))
\replacewith(u) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="replace_byte_MIN">replace_byte_MIN {
\find(byte_MIN)
\replacewith(Z(neglit(8(2(1(#)))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="bprod_induction_lower">bprod_induction_lower {
\find(bprod{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(add(i0,Z(1(#))),i2,t),if-then-else(lt(i0,i2),subst{uSub (variable)}(i0,t),Z(1(#))))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="make_insert_eq">make_insert_eq {
\find(equals(sr,tr)==&gt;)
\addrules [insert_eq {
\find(sr)
\replacewith(tr) 

Choices: {}}] 

Choices: {}}</entry>
<entry key="wd_Heap_ArrLength">wd_Heap_ArrLength {
\find(wd(length(o)))
\varcond( \not \isArray(o (java.lang.Object term)), )
\replacewith(and(wd(o),not(equals(o,null)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="seqNPermSingletonConrete">seqNPermSingletonConrete {
\find(seqNPerm(seqSingleton(Z(0(#)))))
\replacewith(true) 
\heuristics(concrete)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="translateJavaCast">translateJavaCastChar {
\find(javaCastChar(left))
\replacewith(if-then-else(inChar(left),left,javaCastCharOverFlow(left))) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="wd_Heap_Reference_Static">wd_Heap_Reference_Static {
\find(wd(alpha::select(h,o,f)))
\varcond(\isArray(o (java.lang.Object term)), \isStaticField(f (Field term)), )
\replacewith(and(and(and(and(wd(h),wd(o)),wd(f)),wellFormed(h)),equals(o,null))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="seqPermFromSwap">seqPermFromSwap {
\assumes ([seqPerm(s1,t1)]==&gt;[]) 
\find(==&gt;seqPerm(s2,t2))
\varcond(\notFreeIn(jv (variable), t2 (Seq term)), \notFreeIn(jv (variable), t1 (Seq term)), \notFreeIn(jv (variable), s2 (Seq term)), \notFreeIn(jv (variable), s1 (Seq term)), \notFreeIn(iv (variable), t2 (Seq term)), \notFreeIn(iv (variable), t1 (Seq term)), \notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s1 (Seq term)))
\replacewith([]==&gt;[and(equals(t1,t2),exists{iv (variable)}(exists{jv (variable)}(and(and(and(and(leq(Z(0(#)),iv),leq(Z(0(#)),jv)),lt(iv,seqLen(s2))),lt(jv,seqLen(s2))),equals(s1,seqSwap(s2,iv,jv))))))]) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="equal_add_one">equal_add_one {
\find(equals(i0,i1))
\replacewith(equals(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: {}}</entry>
<entry key="inEqSimp_notGeq">inEqSimp_notGeq {
\find(not(geq(i,i0)))
\replacewith(leq(add(add(Z(1(#)),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="wd_F_Logical_Quant_Exist">wd_F_Logical_Quant_Exist {
\find(F(exists{i (variable)}(a)))
\replacewith(all{i (variable)}(F(a))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="castToBoolean">castToBoolean {
\find(#allmodal ( (modal operator))\[{ .. #lhs=(boolean)#exBool; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs=#exBool; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_div_array">compound_assignment_op_div_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]/=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]/#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="greater_literals">greater_literals {
\find(gt(Z(iz),Z(jz)))
\replacewith(#greater(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="permissionDefaultValue">permissionDefaultValue {
\find(Permission::defaultValue)
\replacewith(initFullPermission) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="equalityToElementOf">equalityToElementOf {
\find(equals(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(equiv(elementOf(ov,fv,s),elementOf(ov,fv,s2))))) 
\heuristics(semantics_blasting)
Choices: {programRules:Java}}</entry>
<entry key="apply_eq_pseudo_geq">apply_eq_pseudo_geq {
\assumes ([equals(mul(aePseudoLeft,aePseudoLeftCoeff),aePseudoRight)]==&gt;[]) 
\find(geq(aePseudoTargetLeft,aePseudoTargetRight))
\sameUpdateLevel\replacewith(if-then-else(and(equals(aePseudoTargetLeft,mul(aePseudoLeft,aePseudoTargetFactor)),gt(aePseudoLeftCoeff,Z(0(#)))),geq(mul(aePseudoRight,aePseudoTargetFactor),mul(aePseudoTargetRight,aePseudoLeftCoeff)),geq(aePseudoTargetLeft,aePseudoTargetRight))) 
\heuristics(notHumanReadable, polySimp_applyEqPseudo, polySimp_leftNonUnit)
Choices: {}}</entry>
<entry key="wellFormedMemsetArrayPrimitive">wellFormedMemsetArrayPrimitive {
\find(wellFormed(memset(h,arrayRange(ar,lo,up),x)))
\succedentPolarity\varcond(\hasSort(\elemSort(ar (java.lang.Object term)), alpha), \not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), \sub(beta, alpha), )
\replacewith(wellFormed(h)) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="permSlice2">permSlice2 {
\find(slice2(pol1,pol2))
\replacewith(slice(pol1,slice(pol2,emptyPermission))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="permSlice1">permSlice1 {
\find(slice1(pol1))
\replacewith(slice(pol1,emptyPermission)) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="disjointNotInOtherLocset2">disjointNotInOtherLocset2 {
\assumes ([equals(intersect(s,s2),empty)]==&gt;[]) 
\find(elementOf(o,f,s2)==&gt;)
\add []==&gt;[elementOf(o,f,s)] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="disjointNotInOtherLocset1">disjointNotInOtherLocset1 {
\assumes ([equals(intersect(s,s2),empty)]==&gt;[]) 
\find(elementOf(o,f,s)==&gt;)
\add []==&gt;[elementOf(o,f,s2)] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="simplifyUpdate3">simplifyUpdate3 {
\find(update-application(u,u2))
\varcond(\dropEffectlessElementaries(u (update), u2 (update), result (update)), )
\replacewith(result) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="array_self_reference_eq">array_self_reference_eq {
\assumes ([wellFormed(heapSV),equals(G::select(heapSV,array,arr(idx)),EQ)]==&gt;[equals(array,null)]) 
\find(arrayStoreValid(array,EQ))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="simplifyUpdate2">simplifyUpdate2 {
\find(update-application(u,phi))
\varcond(\dropEffectlessElementaries(u (update), phi (formula), result (formula)), )
\replacewith(result) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="simplifyUpdate1">simplifyUpdate1 {
\find(update-application(u,t))
\varcond(\dropEffectlessElementaries(u (update), t (any term), result (any term)), )
\replacewith(result) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="compound_assignment_op_shiftleft_array">compound_assignment_op_shiftleft_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]&lt;&lt;=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]&lt;&lt;#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="eqSeqEmpty">eqSeqEmpty {
\find(equals(s,seqEmpty))
\replacewith(equals(seqLen(s),Z(0(#)))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="applyOnRigidTerm">applyOnRigidTerm {
\find(update-application(u,t))
\varcond(\applyUpdateOnRigid(u (update), t (any term), result (any term)), )
\replacewith(result) 
\heuristics(update_apply)
Choices: {}}</entry>
<entry key="array_self_reference">array_self_reference {
\assumes ([wellFormed(heapSV)]==&gt;[equals(array,null)]) 
\find(arrayStoreValid(array,G::select(heapSV,array,arr(idx))))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="bsum_one_summand">bsum_one_summand {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(equals(add(i0,Z(1(#))),i1),subst{uSub (variable)}(i0,t),bsum{uSub (variable)}(i0,i1,t))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="sum_zero">sum_zero {
\find(sum{x (variable)}(range,Z(0(#))))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="stringConcatCharExpLeft">stringConcatCharExpLeft {
\find(#normalassign ( (modal operator))\[{ .. #v=#seLeft+#sstrRight; ... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(seqSingleton(#seLeft),strContent(#sstrRight)))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="expand_moduloByte">expand_moduloByte {
\find(moduloByte(i))
\replacewith(add(byte_MIN,mod(add(byte_HALFRANGE,i),byte_RANGE))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="wd_RegEx_Alt">wd_RegEx_Alt {
\find(wd(alt(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_LocSet_AllElemsArr">wd_LocSet_AllElemsArr {
\find(wd(allElementsOfArray(h,o,l)))
\varcond( \not \isArray(o (java.lang.Object term)), )
\replacewith(and(and(and(and(and(wd(h),wd(o)),wd(l)),wellFormed(h)),not(equals(o,null))),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="geq_to_leq">geq_to_leq {
\find(geq(i,i0))
\replacewith(leq(i0,i)) 

Choices: {}}</entry>
<entry key="selectOfStoreEQ">selectOfStoreEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==&gt;[]) 
\find(beta::select(EQ,o2,f2))
\sameUpdateLevel\replacewith(if-then-else(and(and(equals(o,o2),equals(f,f2)),not(equals(f,java.lang.Object::&lt;created&gt;))),beta::cast(x),beta::select(h,o2,f2))) 
\heuristics(simplify_heap_high_costs)
Choices: {programRules:Java}}</entry>
<entry key="postincrement_assignment">postincrement_assignment {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=#lhs1++; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#lhs0 (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#lhs0) #v = #lhs1;#lhs1=(#typeof(#lhs1))(#lhs1+1);#lhs0=#v; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="reachDependenciesAnonCoarse">reachDependenciesAnonCoarse {
\find(reach(anon(h,s2,h2),s,o,o2,n))
\sameUpdateLevel\varcond(\notFreeIn(nv (variable), n (int term)), \notFreeIn(nv (variable), o2 (java.lang.Object term)), \notFreeIn(nv (variable), o (java.lang.Object term)), \notFreeIn(nv (variable), s (LocSet term)), \notFreeIn(nv (variable), h2 (Heap term)), \notFreeIn(nv (variable), s2 (LocSet term)), \notFreeIn(nv (variable), h (Heap term)), \notFreeIn(fv (variable), n (int term)), \notFreeIn(fv (variable), o2 (java.lang.Object term)), \notFreeIn(fv (variable), o (java.lang.Object term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(fv (variable), h2 (Heap term)), \notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), h (Heap term)), \notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h2 (Heap term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\add [all{ov (variable)}(all{fv (variable)}(not(and(and(elementOf(ov,fv,s2),exists{nv (variable)}(reach(h,s,o,ov,nv))),elementOf(ov,fv,s)))))]==&gt;[] \replacewith(reach(h,s,o,o2,n)) ;
\add []==&gt;[all{ov (variable)}(all{fv (variable)}(not(and(and(elementOf(ov,fv,s2),exists{nv (variable)}(reach(h,s,o,ov,nv))),elementOf(ov,fv,s)))))] 

Choices: {reach:on}}</entry>
<entry key="add_eq">add_eq {
\find(equals(i0,i1))
\replacewith(equals(add(i,i0),add(i,i1))) 

Choices: {}}</entry>
<entry key="ifEqualsInteger">ifEqualsInteger {
\find(equals(if-then-else(phi,x,y),Z(iz)))
\replacewith(or(and(phi,equals(x,Z(iz))),and(not(phi),equals(y,Z(iz))))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="wd_T_Logical_Op_Eqv">wd_T_Logical_Op_Eqv {
\find(T(equiv(a,b)))
\replacewith(or(and(T(a),T(b)),and(F(a),F(b)))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="wd_RegEx_Pred_Match">wd_RegEx_Pred_Match {
\find(WD(match(a,s)))
\replacewith(and(wd(a),wd(s))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="inEqSimp_contradEq7">inEqSimp_contradEq7 {
\assumes ([geq(contradLeft,contradRightBigger)]==&gt;[]) 
\find(equals(contradLeft,contradRightSmaller))
\sameUpdateLevel\replacewith(and(leq(add(contradRightBigger,mul(Z(neglit(1(#))),contradRightSmaller)),Z(0(#))),equals(contradLeft,contradRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_contradEqs, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="bsum_induction_upper2">bsum_induction_upper2 {
\find(bsum{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(sub(bsum{uSub (variable)}(i0,add(i2,Z(1(#))),t),if-then-else(lt(i0,add(i2,Z(1(#)))),subst{uSub (variable)}(i2,t),Z(0(#))))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="inEqSimp_contradEq3">inEqSimp_contradEq3 {
\assumes ([leq(contradLeft,contradRightSmaller)]==&gt;[]) 
\find(equals(contradLeft,contradRightBigger))
\sameUpdateLevel\replacewith(and(geq(add(contradRightSmaller,mul(Z(neglit(1(#))),contradRightBigger)),Z(0(#))),equals(contradLeft,contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_contradEqs, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="eqSeqReverse">eqSeqReverse {
\find(equals(s,seqReverse(s2)))
\varcond(\notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\replacewith(and(equals(seqLen(s),seqLen(seqReverse(s2))),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(seqReverse(s2),iv)))))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="setMinusOfUnionEQ">setMinusOfUnionEQ {
\assumes ([equals(union(s,s2),EQ)]==&gt;[]) 
\find(setMinus(EQ,s3))
\sameUpdateLevel\replacewith(union(setMinus(s,s3),setMinus(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="returnPermission_slice">returnPermission_slice {
\find(returnPermission(from,to,slice(owners,p)))
\replacewith(if-then-else(equals(from,to),slice(owners,p),if-then-else(and(checkPermissionOwner(from,Z(0(#)),owners),checkPermissionOwner(to,Z(1(#)),owners)),slice(returnPermissionOwner(from,owners),returnPermission(from,to,p)),slice(owners,returnPermission(from,to,p))))) 
\heuristics(simplify_expression)
Choices: {permissions:on}}</entry>
<entry key="shift_paren_and">shift_paren_and {
\find(and(assoc0,and(assoc1,assoc2)))
\replacewith(and(and(assoc0,assoc1),assoc2)) 
\heuristics(cnf_andAssoc, conjNormalForm)
Choices: {}}</entry>
<entry key="translateJavaAdd">translateJavaAddLong {
\find(javaAddLong(left,right))
\replacewith(if-then-else(inLong(add(left,right)),add(left,right),javaAddLongOverFlow(left,right))) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="ifFalse">ifFalse {
\assumes ([equals(#se,FALSE)]==&gt;[]) 
\find(==&gt;#allmodal ( (modal operator))\[{ .. if (#se)
    #s0
 ... }\] (post))
\replacewith([]==&gt;[#allmodal(post)]) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="instanceCreationAssignment">instanceCreationAssignment {
\find(#normal ( (modal operator))\[{ .. #lhs=#n; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))))
\replacewith(#normal ( (modal operator))\[{ .. #typeof(#v0) #v0 = create-object(#n);constructor-call(#n)post-work(#v0)#lhs=#v0; ... }\] (post)) 
\heuristics(method_expand)
Choices: {programRules:Java}}</entry>
<entry key="selectOfCreateEQ">selectOfCreateEQ {
\assumes ([equals(create(h,o),EQ)]==&gt;[]) 
\find(beta::select(EQ,o2,f))
\sameUpdateLevel\replacewith(if-then-else(and(equals(o,o2),not(equals(o,null))),if-then-else(equals(f,java.lang.Object::&lt;created&gt;),beta::cast(TRUE),beta::defaultValue),beta::select(h,o2,f))) ;
\replacewith(if-then-else(and(and(equals(o,o2),not(equals(o,null))),equals(f,java.lang.Object::&lt;created&gt;)),beta::cast(TRUE),beta::select(h,o2,f))) 
\heuristics(simplify_heap_high_costs)
Choices: {programRules:Java}}</entry>
<entry key="applySkip3">applySkip3 {
\find(update-application(skip,u))
\replacewith(u) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="onlyCreatedObjectsAreInLocSets">onlyCreatedObjectsAreInLocSets {
\assumes ([wellFormed(h)]==&gt;[]) 
\find(elementOf(o2,f2,LocSet::select(h,o,f))==&gt;)
\add [or(equals(o2,null),equals(boolean::select(h,o2,java.lang.Object::&lt;created&gt;),TRUE))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {programRules:Java}}</entry>
<entry key="applySkip2">applySkip2 {
\find(update-application(skip,phi))
\replacewith(phi) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="getOfSeqConcat">getOfSeqConcatEQ {
\assumes ([equals(seqConcat(seq,seq2),EQ)]==&gt;[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\replacewith(if-then-else(lt(idx,seqLen(seq)),alpha::seqGet(seq,idx),alpha::seqGet(seq2,sub(idx,seqLen(seq))))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: {sequences:on}}</entry>
<entry key="applySkip1">applySkip1 {
\find(update-application(skip,t))
\replacewith(t) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="translateJavaDiv">translateJavaDivLong {
\find(javaDivLong(left,right))
\replacewith(if-then-else(inLong(jdiv(left,right)),jdiv(left,right),javaDivLongOverFlow(left,right))) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="wd_Type_Instance">wd_Type_Instance {
\find(wd(alpha::instance(t)))
\replacewith(wd(t)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_Numerical_Pred_InLong">wd_Numerical_Pred_InLong {
\find(WD(inLong(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="moduloByteIsInByte">moduloByteIsInByte {
\find(inByte(moduloByte(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="readPermissionAfterTransferReadEQ">readPermissionAfterTransferReadEQ {
\assumes ([readPermissionObject(o1,p),equals(transferPermission(split,o1,o2,Z(0(#)),p),p1)]==&gt;[]) 
\find(readPermissionObject(o2,p1))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="optEmpty">optEmpty {
\find(match(opt(rexp),seqEmpty))
\replacewith(true) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="neq_and_4">neq_and_4 {
\find(and(and(psi,not(phi)),phi))
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="moduloByteFixpointInline">moduloByteFixpointInline {
\find(moduloByte(t))
\replacewith(if-then-else(inByte(t),t,moduloByte(t))) 
\heuristics(defOps_expandModulo)
Choices: {intRules:javaSemantics}}</entry>
<entry key="createdInHeapWithAllFields">createdInHeapWithAllFields {
\find(createdInHeap(allFields(o),h))
\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="neq_and_3">neq_and_3 {
\find(and(and(psi,phi),not(phi)))
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="neq_and_2">neq_and_2 {
\find(and(not(phi),phi))
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="wd_Numerical_Pred_InInt">wd_Numerical_Pred_InInt {
\find(WD(inInt(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="nonEmptyPermission">nonEmptyPermission {
\find(nonEmptyPermission(p))
\varcond(\notFreeIn(pp (variable), p (Permission term)), \notFreeIn(ol (variable), p (Permission term)))
\replacewith(exists{ol (variable)}(exists{pp (variable)}(equals(p,slice(ol,pp))))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="throwUnfold">throwUnfoldMore {
\find(#allmodal ( (modal operator))\[{ .. throw #se; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#se (program SimpleExpression))), \isLocalVariable (#se (program SimpleExpression)), )
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#se) #v0 = #se;throw #v0; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="bprod_one">bprod_one {
\find(bprod{uSub (variable)}(i0,i1,Z(1(#))))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="setMinusItself">setMinusItself {
\find(setMinus(s,s))
\replacewith(empty) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="eqSeqConcat3EQ">eqSeqConcat3EQ {
\assumes ([equals(seqConcat(s2,s),EQ)]==&gt;[]) 
\find(equals(seqConcat(s1,s),EQ))
\replacewith(equals(s1,s2)) 
\heuristics(simplify, no_self_application)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="ifExthenelse1_min">ifExthenelse1_min_for {
\find(ifExThenElse{intVar (variable)}(phi,b,c))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), phi (formula)))
\replacewith(if-then-else(phi,subst{intVar (variable)}(Z(0(#)),b),c)) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="box_or_left">box_or_left {
\find(#box ( (modal operator))\[{ .. #s ... }\] (or(post,post1))==&gt;)
\replacewith([or(#box ( (modal operator))\[{ .. #s ... }\] (post),#box ( (modal operator))\[{ .. #s ... }\] (post1))]==&gt;[]) 

Choices: {programRules:Java}}</entry>
<entry key="elementOfSubsetOfUnion2">elementOfSubsetOfUnion2 {
\assumes ([subset(s,union(s2,s3))]==&gt;[elementOf(o,f,s3)]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\add [equiv(elementOf(o,f,s),elementOf(o,f,intersect(s,s2)))]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="elementOfSubsetOfUnion1">elementOfSubsetOfUnion1 {
\assumes ([subset(s,union(s2,s3))]==&gt;[elementOf(o,f,s2)]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\add [equiv(elementOf(o,f,s),elementOf(o,f,intersect(s,s3)))]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="createdInHeapWithSelect">createdInHeapWithSelect {
\find(==&gt;createdInHeap(LocSet::select(h,o,f),h))
\replacewith([]==&gt;[wellFormed(h)]) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wellFormedMemsetPrimitiveEQ">wellFormedMemsetPrimitiveEQ {
\assumes ([equals(memset(h,s,x),EQ)]==&gt;[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), )
\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="definitionOfSameTypes">definitionOfSameTypes {
\find(==&gt;sameTypes(s1,s2))
\varcond(\notFreeIn(i (variable), s2 (Seq term)), \notFreeIn(i (variable), s1 (Seq term)))
\replacewith([]==&gt;[and(equals(seqLen(s1),seqLen(s2)),all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,seqLen(s1))),and(sameType(any::seqGet(s1,i),any::seqGet(s2,i)),imp(equals(Seq::instance(any::seqGet(s1,i)),TRUE),sameTypes(Seq::seqGet(s1,i),Seq::seqGet(s2,i)))))))]) 
\heuristics(comprehensions)
Choices: {}}</entry>
<entry key="postdecrement_array">postdecrement_array {
\find(#allmodal ( (modal operator))\[{ .. #e[#e0]--; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#e0) #v0 = #e0;#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="boolean_not_equal">boolean_not_equal_2 {
\find(equals(FALSE,TRUE))
\replacewith(false) 
\heuristics(concrete, simplify_boolean)
Choices: {}}</entry>
<entry key="elim_exists_sub_1">elim_exists_sub_1 {
\find(exists{locVar (variable)}(and(subset(locVar,locSetTermRight),subset(locSetTermLeft,locVar))))
\varcond(\notFreeIn(locVar (variable), locSetTermRight (LocSet term)), \notFreeIn(locVar (variable), locSetTermLeft (LocSet term)))
\replacewith(subset(locSetTermLeft,locSetTermRight)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="indexOfSeqConcatSecond">indexOfSeqConcatSecond {
\find(seqIndexOf(seqConcat(s1,s2),x))
\sameUpdateLevel\varcond(\notFreeIn(idx (variable), x (any term)), \notFreeIn(idx (variable), s2 (Seq term)), \notFreeIn(idx (variable), s1 (Seq term)))
\add []==&gt;[and(not(exists{idx (variable)}(and(and(leq(Z(0(#)),idx),lt(idx,seqLen(s1))),equals(any::seqGet(s1,idx),x)))),exists{idx (variable)}(and(and(leq(Z(0(#)),idx),lt(idx,seqLen(s2))),equals(any::seqGet(s2,idx),x))))] ;
\replacewith(add(seqIndexOf(s2,x),seqLen(s1))) 

Choices: {sequences:on}}</entry>
<entry key="compound_assignment_op_and">compound_assignment_op_and {
\find(#allmodal ( (modal operator))\[{ .. #v&amp;=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v&amp;(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="ifElseTrue">ifElseTrue {
\assumes ([equals(#se,TRUE)]==&gt;[]) 
\find(==&gt;#allmodal ( (modal operator))\[{ .. if (#se)
    #s0
  else 
    #s1
 ... }\] (post))
\replacewith([]==&gt;[#allmodal ( (modal operator))\[{ .. #s0 ... }\] (post)]) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="getOfSeqDef">getOfSeqDefEQ {
\assumes ([equals(seqDef{uSub (variable)}(from,to,t),EQ)]==&gt;[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(if-then-else(and(leq(Z(0(#)),idx),lt(idx,sub(to,from))),alpha::cast(subst{uSub (variable)}(add(idx,from),t)),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging)
Choices: {sequences:on}}</entry>
<entry key="leq_diff1_eq">leq_diff1_eq {
\find(leq(i0,sub(i1,Z(1(#)))))
\replacewith(lt(i0,i1)) 

Choices: {}}</entry>
<entry key="regExConcatAltRight">regExConcatAltRight {
\find(match(regExConcat(rexp1,alt(rexp2,rexp3)),string))
\replacewith(or(match(regExConcat(rexp1,rexp2),string),match(regExConcat(rexp1,rexp3),string))) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="diamond_and_left">diamond_and_left {
\find(#diamond ( (modal operator))\[{ .. #s ... }\] (and(post,post1))==&gt;)
\replacewith([and(#diamond ( (modal operator))\[{ .. #s ... }\] (post),#diamond ( (modal operator))\[{ .. #s ... }\] (post1))]==&gt;[]) 

Choices: {programRules:Java}}</entry>
<entry key="defMapOverride">defMapOverride {
\find(mapOverride(m0,m1))
\varcond(\notFreeIn(vy (variable), m1 (Map term)), \notFreeIn(vy (variable), m0 (Map term)))
\replacewith(mapForeach{vy (variable)}(if-then-else(or(inDomain(m0,vy),inDomain(m1,vy)),TRUE,FALSE),if-then-else(inDomain(m1,vy),mapGet(m1,vy),mapGet(m0,vy)))) 

Choices: {}}</entry>
<entry key="moduloIntFixpoint">moduloIntFixpoint {
\assumes ([inInt(t)]==&gt;[]) 
\find(moduloInt(t))
\sameUpdateLevel\replacewith(t) 
\heuristics(simplify)
Choices: {intRules:arithmeticSemanticsCheckingOF}}</entry>
<entry key="assignment_and">compound_assignment_4_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#seBool0&amp;#seBool1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool0,TRUE),if-then-else(equals(#seBool1,TRUE),TRUE,FALSE),FALSE)),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="blockBreakNoLabel">blockBreakNoLabel {
\find(#allmodal ( (modal operator))\[{ ..  {break ;
    #slist
  }
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. break ;
 ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="swapQuantifiersAll">swapQuantifiersAll {
\find(all{u (variable)}(all{v (variable)}(phi)))
\replacewith(all{v (variable)}(all{u (variable)}(phi))) 
\heuristics(swapQuantifiers)
Choices: {}}</entry>
<entry key="all_unused">all_unused {
\find(all{u (variable)}(b))
\varcond(\notFreeIn(u (variable), b (formula)))
\replacewith(b) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="wd_F_Subst_Formula">wd_F_Subst_Formula {
\find(F(subst{v (variable)}(u,f)))
\replacewith(and(wd(u),subst{v (variable)}(u,F(f)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="exact_instance_definition_boolean">exact_instance_definition_boolean {
\find(equals(boolean::exactInstance(bool),TRUE))
\varcond(\notFreeIn(bv (variable), bool (boolean term)))
\replacewith(exists{bv (variable)}(equals(bool,bv))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="throwDiamond">throwDiamond {
\find(#diamond ( (modal operator))\[{throw #se;#slist}\] (post))
\replacewith(false) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Undef_Formula">wd_Undef_Formula {
\find(WD(f&lt;&lt;l (termLabel)&gt;&gt;))
\varcond(\isConstant (f (formula)), \hasLabel (l (termLabel), undef), )
\replacewith(false) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="predecrement_assignment_array">predecrement_assignment_array {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=--#e[#e0]; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#e0) #v0 = #e0;#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);#lhs0=#v[#v0]; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="defMapUpdate">defMapUpdate {
\find(mapUpdate(m,key,value))
\varcond(\notFreeIn(vy (variable), value (any term)), \notFreeIn(vy (variable), key (any term)), \notFreeIn(vy (variable), m (Map term)))
\replacewith(mapForeach{vy (variable)}(if-then-else(or(inDomain(m,vy),equals(vy,key)),TRUE,FALSE),if-then-else(equals(vy,key),value,mapGet(m,vy)))) 

Choices: {}}</entry>
<entry key="singletonUnfold">singletonUnfold {
\find(#allmodal ( (modal operator))\[{ .. #v=\singleton(#nseObj.#a); ... }\] (post))
\varcond(\new(#vObjNew (program Variable), \typeof(#nseObj (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseObj) #vObjNew = #nseObj;#v=\singleton(#vObjNew.#a); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="loopUnwind">loopUnwind {
\find(#allmodal ( (modal operator))\[{ .. while ( #e )
    #s
 ... }\] (post))
\varcond(\newLabel (#innerLabel (program Label)), \newLabel (#outerLabel (program Label)), )
\replacewith(#allmodal ( (modal operator))\[{ .. #unwind-loop(while ( #e )
      #s  ) ... }\] (post)) 
\heuristics(loop_expand)
Choices: {programRules:Java}}</entry>
<entry key="createdInHeapWithObserver">createdInHeapWithObserver {
\find(==&gt;createdInHeap(obs,h))
\varcond(\isObserver (obs (LocSet term), h (Heap term)), )
\replacewith([]==&gt;[wellFormed(h)]) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="geq_add">geq_add {
\find(==&gt;geq(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==&gt;[exists{j2 (variable)}(geq(add(i0,j2),add(i1,j2)))]) 

Choices: {}}</entry>
<entry key="wd_Numerical_Const">wd_Numerical_Const_C {
\find(wd(C(n)))
\replacewith(true) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="subsetWithSetMinusLeft">subsetWithSetMinusLeft {
\find(subset(setMinus(s,s2),s3))
\replacewith(subset(s,union(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="replaceCons">replaceCons {
\find(clReplace(seqConcat(seqSingleton(fstChar),str),searchChar,replChar))
\replacewith(if-then-else(equals(searchChar,fstChar),seqConcat(seqSingleton(replChar),clReplace(str,searchChar,replChar)),seqConcat(seqSingleton(fstChar),clReplace(str,searchChar,replChar)))) 
\heuristics(defOpsReplaceInline)
Choices: {Strings:on}}</entry>
<entry key="wellFormedStorePrimitiveEQ">wellFormedStorePrimitiveEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==&gt;[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\varcond(\not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), )
\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="diamond_and_right">diamond_and_right {
\find(==&gt;#diamond ( (modal operator))\[{ .. #s ... }\] (and(post,post1)))
\replacewith([]==&gt;[#diamond ( (modal operator))\[{ .. #s ... }\] (post1)]) ;
\replacewith([]==&gt;[#diamond ( (modal operator))\[{ .. #s ... }\] (post)]) 

Choices: {programRules:Java}}</entry>
<entry key="modulo">assignmentModuloBigint2 {
\find(#allmodal ( (modal operator))\[{ .. #loc=#seAny%#seBigint; ... }\] (post))
\replacewith(if-then-else(not(equals(#seBigint,Z(0(#)))),update-application(elem-update(#loc (program Variable))(mod(#seAny,#seBigint)),#allmodal(post)),#allmodal ( (modal operator))\[{ .. throw new java.lang.ArithmeticException (); ... }\] (post))) 
\heuristics(executeIntegerAssignment)
Choices: {runtimeExceptions:allow,bigint:on,programRules:Java}}</entry>
<entry key="inEqSimp_or_weaken3">inEqSimp_or_weaken3 {
\find(or(or(b,equals(weakenLeft,weakenRightSmaller)),geq(weakenLeft,weakenRightBigger)))
\replacewith(or(b,if-then-else(equals(weakenRightBigger,add(Z(1(#)),weakenRightSmaller)),geq(weakenLeft,weakenRightSmaller),or(equals(weakenLeft,weakenRightSmaller),geq(weakenLeft,weakenRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_or_weaken, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_weaken2">inEqSimp_or_weaken2 {
\find(or(or(b,leq(weakenLeft,weakenRightSmaller)),equals(weakenLeft,weakenRightBigger)))
\replacewith(or(b,if-then-else(equals(weakenRightBigger,add(Z(1(#)),weakenRightSmaller)),leq(weakenLeft,weakenRightBigger),or(leq(weakenLeft,weakenRightSmaller),equals(weakenLeft,weakenRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_or_weaken, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="bsum_split_in_three">bsum_split_in_three {
\find(bsum{uSub (variable)}(i0,i2,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub (variable), i1 (int term)))
\replacewith(add(add(bsum{uSub (variable)}(i0,i1,t),subst{uSub (variable)}(i1,t)),bsum{uSub1 (variable)}(add(i1,Z(1(#))),i2,subst{uSub (variable)}(uSub1,t)))) ;
\add []==&gt;[and(leq(i0,i1),lt(i1,i2))] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="inEqSimp_or_weaken1">inEqSimp_or_weaken1 {
\find(or(equals(weakenLeft,weakenRightSmaller),geq(weakenLeft,weakenRightBigger)))
\replacewith(if-then-else(equals(weakenRightBigger,add(Z(1(#)),weakenRightSmaller)),geq(weakenLeft,weakenRightSmaller),or(equals(weakenLeft,weakenRightSmaller),geq(weakenLeft,weakenRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_or_weaken, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_weaken0">inEqSimp_or_weaken0 {
\find(or(leq(weakenLeft,weakenRightSmaller),equals(weakenLeft,weakenRightBigger)))
\replacewith(if-then-else(equals(weakenRightBigger,add(Z(1(#)),weakenRightSmaller)),leq(weakenLeft,weakenRightBigger),or(leq(weakenLeft,weakenRightSmaller),equals(weakenLeft,weakenRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_or_weaken, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="replace_byte_MAX">replace_byte_MAX {
\find(byte_MAX)
\replacewith(Z(7(2(1(#))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="seqNPermRange">seqNPermRange {
\find(seqNPerm(s)==&gt;)
\varcond(\notFreeIn(iv (variable), s (Seq term)))
\add [all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),and(and(leq(Z(0(#)),int::seqGet(s,iv)),lt(int::seqGet(s,iv),seqLen(s))),equals(int::instance(any::seqGet(s,iv)),TRUE))))]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="returnPermission_empty">returnPermission_empty {
\find(returnPermission(from,to,emptyPermission))
\replacewith(emptyPermission) 
\heuristics(concrete)
Choices: {permissions:on}}</entry>
<entry key="getJavaCardTransient">getJavaCardTransient {
\find(==&gt;#allmodal ( (modal operator))\[{ .. 
  #lhs=#jcsystemType.#getTransient(#se)@#jcsystemType; ... }\] (post))
\replacewith([]==&gt;[not(equals(#se,null))]) ;
\replacewith([]==&gt;[update-application(elem-update(#lhs (program LeftHandSide))(int::select(heap,#se,java.lang.Object::&lt;transient&gt;)),#allmodal(post))]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="assignment_or">compound_assignment_6_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#seBool0|#seBool1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool0,TRUE),TRUE,if-then-else(equals(#seBool1,TRUE),TRUE,FALSE))),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="partition_inequation">partition_inequation {
\assumes ([]==&gt;[lt(i,i0)]) 
\find(lt(i,i1)==&gt;)
\add []==&gt;[lt(i1,i0)] 

Choices: {}}</entry>
<entry key="inEqSimp_gtRight">inEqSimp_gtRight {
\find(==&gt;gt(i,i0))
\replacewith([leq(add(mul(Z(neglit(1(#))),i0),i),Z(0(#)))]==&gt;[]) 
\heuristics(notHumanReadable, inEqSimp_moveLeft, inEqSimp_expand)
Choices: {}}</entry>
<entry key="wd_Constant_Term">wd_Constant_Term {
\find(wd(t&lt;&lt;l (termLabel)&gt;&gt;))
\varcond(\isConstant (t (any term)), \not\hasLabel (l (termLabel), undef), )
\replacewith(true) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="blockEmpty">blockEmpty {
\find(#allmodal ( (modal operator))\[{ ..  {} ... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="inequality">compound_inequality_comparison_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e!=#nse0; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse0) #v1 = #nse0;#lhs=#v0!=#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="createdInHeapWithArrayRange">createdInHeapWithArrayRange {
\find(createdInHeap(arrayRange(o,lower,upper),h))
\replacewith(or(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE)),lt(upper,lower))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="lenOfArray2seq">lenOfArray2seq {
\find(seqLen(array2seq(h,a)))
\replacewith(length(a)) 

Choices: {sequences:on}}</entry>
<entry key="wd_LocSet_FreshLocs">wd_LocSet_FreshLocs {
\find(wd(freshLocs(h)))
\replacewith(and(wd(h),wellFormed(h))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_Logical_Op_Cond_Form">wd_Logical_Op_Cond_Form {
\find(WD(if-then-else(a,b,c)))
\replacewith(or(or(and(and(WD(a),WD(b)),a),and(and(WD(a),WD(c)),not(a))),and(and(WD(b),WD(c)),equiv(b,c)))) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="elim_exists_sub_1_or_phi">elim_exists_sub_1_or_phi {
\find(exists{locVar (variable)}(or(and(subset(locVar,locSetTermRight),subset(locSetTermLeft,locVar)),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTermRight (LocSet term)), \notFreeIn(locVar (variable), locSetTermLeft (LocSet term)))
\replacewith(or(subset(locSetTermLeft,locSetTermRight),exists{locVar (variable)}(phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="onlyCreatedObjectsAreReferenced">onlyCreatedObjectsAreReferenced {
\assumes ([wellFormed(h)]==&gt;[]) 
\find(deltaObject::select(h,o,f))
\sameUpdateLevel\add [or(equals(deltaObject::select(h,o,f),null),equals(boolean::select(h,deltaObject::select(h,o,f),java.lang.Object::&lt;created&gt;),TRUE))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {programRules:Java}}</entry>
<entry key="writePermissionOtherNoPermissionCurrentWrite">writePermissionOtherNoPermissionCurrentWrite {
\assumes ([writePermissionObject(o1,p)]==&gt;[equals(o2,o1)]) 
\find(writePermissionObject(o2,p))
\replacewith(false) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="wd_Constant_Formula">wd_Constant_Formula {
\find(WD(f&lt;&lt;l (termLabel)&gt;&gt;))
\varcond(\isConstant (f (formula)), \not\hasLabel (l (termLabel), undef), )
\replacewith(true) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="arrayCreationWithInitializers">arrayCreationWithInitializers {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#arrayinitializer; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#lhs) #v0;init-array-creation(#arrayinitializer)#lhs=#v0; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="apply_subst">apply_subst_for {
\find(subst{u (variable)}(t,phi))
\replacewith(subst{u (variable)}(t,phi)) 
\heuristics(try_apply_subst)
Choices: {}}</entry>
<entry key="geq_to_lt">geq_to_lt {
\find(geq(i,j))
\replacewith(not(lt(i,j))) 

Choices: {}}</entry>
<entry key="bsum_zero">bsum_zero {
\find(bsum{uSub (variable)}(i0,i1,Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="initialization process has already terminated (or never begun)">class_erroneous_excludes_class_in_init {
\assumes ([equals(boolean::select(heap,null,alphaObj::&lt;classErroneous&gt;),TRUE),wellFormed(heap)]==&gt;[]) 
\find(boolean::select(heap,null,alphaObj::&lt;classInitializationInProgress&gt;))
\sameUpdateLevel\replacewith(FALSE) 
\heuristics(simplify, confluence_restricted)
Choices: {programRules:Java}}</entry>
<entry key="polySimp_critPair">polySimp_critPair {
\assumes ([equals(cpLeft1,cpRight1)]==&gt;[]) 
\find(equals(cpLeft2,cpRight2)==&gt;)
\add [equals(add(mul(#divideLCRMonomials(cpLeft2,cpLeft1),add(mul(Z(neglit(1(#))),cpRight1),cpLeft1)),mul(#divideLCRMonomials(cpLeft1,cpLeft2),add(cpRight2,mul(Z(neglit(1(#))),cpLeft2)))),Z(0(#)))]==&gt;[] 
\heuristics(notHumanReadable, polySimp_critPair, polySimp_saturate)
Choices: {}}</entry>
<entry key="elementOfSubsetImpliesElementOfSuperset">elementOfSubsetImpliesElementOfSuperset {
\assumes ([subset(s,s2)]==&gt;[]) 
\find(elementOf(o,f,s)==&gt;)
\add [elementOf(o,f,s2)]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="bsum_commutative_associative">bsum_commutative_associative {
\find(bsum{uSub (variable)}(i0,i2,add(t,t2)))
\varcond(\notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(i0,i2,t),bsum{uSub1 (variable)}(i0,i2,subst{uSub (variable)}(uSub1,t2)))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="inDomainOfMapRemove">inDomainOfMapRemove {
\find(inDomain(mapRemove(m,key),x))
\replacewith(and(inDomain(m,x),not(equals(x,key)))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="auto_induction_lemma">autoInductGT_Lemma_6 {
\find(==&gt;and(all{uSub (variable)}(or(or(leq(uSub,t),psi),b)),phi))
\varcond(\notFreeIn(uSub (variable), t (int term)))
\replacewith([all{uSub (variable)}(imp(lt(t,uSub),or(psi,b)))]==&gt;[phi]) ;
\replacewith([]==&gt;[imp(and(geq(sk,Z(1(#))),subst{uSub (variable)}(add(t,sk),or(psi,b))),#ExpandQueries(subst{uSub (variable)}(add(t,add(sk,Z(1(#)))),or(psi,b)),true))]) ;
\replacewith([]==&gt;[#ExpandQueries(subst{uSub (variable)}(add(t,Z(1(#))),or(psi,b)),true)]) 
\heuristics(induction_var, auto_induction_lemma)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="polyDiv_pullOut">polyDiv_pullOut {
\find(div(divNum,divDenom))
\replacewith(if-then-else(equals(divDenom,Z(0(#))),div(divNum,Z(0(#))),add(div(add(divNum,mul(mul(polyDivCoeff,Z(neglit(1(#)))),divDenom)),divDenom),polyDivCoeff))) 
\heuristics(notHumanReadable, defOps_divModPullOut, polyDivision)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="seqSelfDefinition">seqSelfDefinitionEQ2 {
\assumes ([equals(seqLen(s),x)]==&gt;[]) 
\find(seqDef{u (variable)}(Z(0(#)),x,any::seqGet(s,u)))
\sameUpdateLevel\varcond(\notFreeIn(u (variable), s (Seq term)), \notFreeIn(u (variable), x (int term)))
\replacewith(s) 
\heuristics(simplify)
Choices: {sequences:on}}</entry>
<entry key="translateJavaMul">translateJavaMulLong {
\find(javaMulLong(left,right))
\replacewith(if-then-else(inLong(mul(left,right)),mul(left,right),javaMulLongOverFlow(left,right))) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="elim_exists7">elim_exists7 {
\find(exists{Gvar (variable)}(and(phi,equals(Hterm,Gvar))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(and(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),TRUE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="enhancedfor">enhancedfor_iterable {
\find(#allmodal ( (modal operator))\[{ .. for (#ty #id : #e)
    #stm
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. enhancedfor-elim(for (#ty #id : #e)
      #stm  ) ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="elim_exists6">elim_exists6 {
\find(exists{Gvar (variable)}(and(phi,equals(Gvar,Hterm))))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(and(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),TRUE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_exists5">elim_exists5 {
\find(exists{Gvar (variable)}(and(phi,equals(subGterm,Gvar))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_exists4">elim_exists4 {
\find(exists{Gvar (variable)}(and(phi,equals(Gvar,subGterm))))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,phi)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="replaceConcat">replaceConcat {
\find(clReplace(seqConcat(leftStr,rightStr),searchChar,replaceChar))
\replacewith(seqConcat(clReplace(leftStr,searchChar,replaceChar),clReplace(rightStr,searchChar,replaceChar))) 
\heuristics(stringsMoveReplaceInside)
Choices: {Strings:on}}</entry>
<entry key="elim_exists3">elim_exists3 {
\find(exists{Gvar (variable)}(equals(Hterm,Gvar)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(equals(G::instance(Hterm),TRUE)) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_exists2">elim_exists2 {
\find(exists{Gvar (variable)}(equals(Gvar,Hterm)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(equals(G::instance(Hterm),TRUE)) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_exists1">elim_exists1 {
\find(exists{Gvar (variable)}(equals(subGterm,Gvar)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="inEqSimp_contradInEq5">inEqSimp_contradInEq5 {
\assumes ([geq(contradLeft,contradRightBigger)]==&gt;[]) 
\find(leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller))
\sameUpdateLevel\replacewith(and(imp(gt(contradCoeffSmaller,Z(0(#))),geq(contradRightSmaller,mul(contradCoeffSmaller,contradRightBigger))),leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="elim_exists0">elim_exists0 {
\find(exists{Gvar (variable)}(equals(Gvar,subGterm)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(true) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="inEqSimp_contradInEq4">inEqSimp_contradInEq4 {
\assumes ([geq(mul(contradLeft,contradCoeffBigger),contradRightBigger)]==&gt;[]) 
\find(leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller))
\sameUpdateLevel\replacewith(and(imp(gt(contradCoeffSmaller,Z(0(#))),imp(gt(contradCoeffBigger,Z(0(#))),geq(mul(contradCoeffBigger,contradRightSmaller),mul(contradCoeffSmaller,contradRightBigger)))),leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="wd_String_LastIndexOfChar">wd_String_LastIndexOfChar {
\find(wd(clLastIndexOfChar(c,i,j)))
\replacewith(and(and(and(and(and(wd(i),wd(j)),wd(c)),leq(Z(0(#)),i)),leq(i,j)),lt(j,seqLen(c)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="inEqSimp_contradInEq3">inEqSimp_contradInEq3 {
\assumes ([leq(contradLeft,contradRightSmaller)]==&gt;[]) 
\find(geq(mul(contradLeft,contradCoeffBigger),contradRightBigger))
\sameUpdateLevel\replacewith(and(imp(gt(contradCoeffBigger,Z(0(#))),geq(mul(contradCoeffBigger,contradRightSmaller),contradRightBigger)),geq(mul(contradLeft,contradCoeffBigger),contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="commitJavaCardTransaction">commitJavaCardTransactionBox {
\find(==&gt;box_transaction\[{ .. #commitJavaCardTransaction; ... }\] (post))
\replacewith([]==&gt;[box(post)]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="inEqSimp_contradInEq2">inEqSimp_contradInEq2 {
\assumes ([leq(mul(contradLeft,contradCoeffSmaller),contradRightSmaller)]==&gt;[]) 
\find(geq(mul(contradLeft,contradCoeffBigger),contradRightBigger))
\sameUpdateLevel\replacewith(and(imp(gt(contradCoeffSmaller,Z(0(#))),imp(gt(contradCoeffBigger,Z(0(#))),geq(mul(contradCoeffBigger,contradRightSmaller),mul(contradCoeffSmaller,contradRightBigger)))),geq(mul(contradLeft,contradCoeffBigger),contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="inEqSimp_contradInEq1">inEqSimp_contradInEq1 {
\assumes ([geq(contradLeft,contradRightBigger)]==&gt;[]) 
\find(leq(contradLeft,contradRightSmaller))
\sameUpdateLevel\replacewith(and(geq(contradRightSmaller,contradRightBigger),leq(contradLeft,contradRightSmaller))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="inEqSimp_contradInEq0">inEqSimp_contradInEq0 {
\assumes ([leq(contradLeft,contradRightSmaller)]==&gt;[]) 
\find(geq(contradLeft,contradRightBigger))
\sameUpdateLevel\replacewith(and(geq(contradRightSmaller,contradRightBigger),geq(contradLeft,contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_contradInEqs, inEqSimp_propagation)
Choices: {}}</entry>
<entry key="firstOfPair">firstOfPair {
\find(first(pair(t,t1)))
\replacewith(t) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="wd_Heap_Reference_Array">wd_Heap_Reference_Array {
\find(wd(alpha::select(h,o,arr(i))))
\varcond( \not \isArray(o (java.lang.Object term)), )
\replacewith(and(and(and(and(and(and(and(wd(h),wd(o)),wd(i)),wellFormed(h)),not(equals(o,null))),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE)),leq(Z(0(#)),i)),lt(i,length(o)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="eqSeqDef2">eqSeqDef2 {
\assumes ([equals(seqDef{i (variable)}(l,u,a),t)]==&gt;[]) 
\find(equals(s,t))
\varcond(\notFreeIn(iv (variable), t (Seq term)), \notFreeIn(iv (variable), a (any term)), \notFreeIn(iv (variable), u (int term)), \notFreeIn(iv (variable), l (int term)), \notFreeIn(iv (variable), s (Seq term)))
\replacewith(and(equals(seqLen(s),seqLen(seqDef{i (variable)}(l,u,a))),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(seqDef{i (variable)}(l,u,a),iv)))))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="eqTermCut">eqTermCut {
\find(t)
\sameUpdateLevel\add [not(equals(t,s))]==&gt;[] ;
\add [equals(t,s)]==&gt;[] 

Choices: {}}</entry>
<entry key="allFieldsAssignment">allFieldsUnfold {
\find(#allmodal ( (modal operator))\[{ .. #v=\all_fields(#nseObj); ... }\] (post))
\varcond(\new(#vObjNew (program Variable), \typeof(#nseObj (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseObj) #vObjNew = #nseObj;#v=\all_fields(#vObjNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="indexOfStr">indexOfStr {
\find(clIndexOfCl(sourceStr,i,searchStr))
\varcond(\notFreeIn(iv (variable), i (int term)), \notFreeIn(iv (variable), sourceStr (Seq term)), \notFreeIn(iv (variable), searchStr (Seq term)))
\replacewith(ifExThenElse{iv (variable)}(and(and(and(geq(iv,i),geq(iv,Z(0(#)))),leq(add(iv,seqLen(searchStr)),seqLen(sourceStr))),equals(seqSub(sourceStr,iv,add(iv,seqLen(searchStr))),searchStr)),iv,Z(neglit(1(#))))) 
\heuristics(stringsExpandDefNormalOp)
Choices: {Strings:on}}</entry>
<entry key="wd_Heap_Anon">wd_Heap_Anon {
\find(wd(anon(h,l,g)))
\replacewith(and(and(and(and(wd(h),wd(l)),wd(g)),wellFormed(h)),wellFormed(g))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="dropEffectlessStores">dropEffectlessStores {
\find(store(h,o,f,x))
\varcond(\dropEffectlessStores(h (Heap term), o (java.lang.Object term), f (Field term), x (any term), result (Heap term)), )
\replacewith(result) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="addition_associative">addition_associative {
\find(add(add(i0,i1),add(j0,j1)))
\replacewith(add(add(j0,i1),add(i0,j1))) 

Choices: {}}</entry>
<entry key="isFiniteOfSeq2Map">isFiniteOfSeq2Map {
\find(isFinite(seq2map(s)))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="defOfSeqSingleton">defOfSeqSingleton {
\find(seqSingleton(x))
\varcond(\notFreeIn(uSub (variable), x (any term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),Z(1(#)),x)) 

Choices: {sequences:on}}</entry>
<entry key="wd_Type_ExactInstance">wd_Type_ExactInstance {
\find(wd(alpha::exactInstance(t)))
\replacewith(wd(t)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="mapSizeNotNegativeForFiniteMaps">mapSizeNotNegativeForFiniteMaps {
\find(mapSize(m))
\add [imp(isFinite(m),geq(mapSize(m),Z(0(#))))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {}}</entry>
<entry key="pull_out_minus">pull_out_neg_2 {
\find(mul(i0,neg(i1)))
\replacewith(neg(mul(i0,i1))) 

Choices: {}}</entry>
<entry key="checkPermissionOwner_empty">checkPermissionOwner_empty {
\find(checkPermissionOwner(ow,depth,emptyPermissionOwnerList))
\add []==&gt;[geq(depth,Z(0(#)))] ;
\replacewith(false) 
\heuristics(concrete)
Choices: {permissions:on}}</entry>
<entry key="wd_LocSet_Pred_ElementOf">wd_LocSet_Pred_ElementOf {
\find(WD(elementOf(o,f,l)))
\varcond(\not\isStaticField(f (Field term)), )
\replacewith(and(and(and(wd(o),wd(f)),wd(l)),not(equals(o,null)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="arrayCreation">arrayCreation {
\find(#normal ( (modal operator))\[{ .. #lhs=#na; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#na (program ArrayCreation))))
\replacewith(#normal ( (modal operator))\[{ .. #typeof(#na) #v0;init-array-creation(#na)#lhs=#v0; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="getOfMapForeach">getOfMapForeach {
\find(mapGet(mapForeach{v (variable)}(b,y),x))
\sameUpdateLevel\replacewith(if-then-else(inDomain(mapForeach{v (variable)}(b,y),x),subst{v (variable)}(alpha::cast(x),y),mapUndef)) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="arrayLengthNotNegative">arrayLengthNotNegative {
\find(length(o))
\sameUpdateLevel\add [geq(length(o),Z(0(#)))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {programRules:Java}}</entry>
<entry key="boolean_equal">boolean_equal_2 {
\find(equiv(equals(b1,TRUE),equals(b2,TRUE)))
\replacewith(equals(b1,b2)) 
\heuristics(concrete, simplify_boolean)
Choices: {}}</entry>
<entry key="elementOfInfiniteUnion2Vars">elementOfInfiniteUnion2Vars {
\find(elementOf(o,f,infiniteUnion{av (variable), bv (variable)}(s)))
\varcond(\notFreeIn(bv (variable), f (Field term)), \notFreeIn(bv (variable), o (java.lang.Object term)), \notFreeIn(av (variable), f (Field term)), \notFreeIn(av (variable), o (java.lang.Object term)))
\replacewith(exists{av (variable)}(exists{bv (variable)}(elementOf(o,f,s)))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="less_than">compound_less_than_comparison_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e&lt;#nse0; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse0) #v1 = #nse0;#lhs=#v0&lt;#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="mult_pos">mult_pos {
\find(and(lt(Z(0(#)),i0),lt(Z(0(#)),i1)))
\replacewith(lt(Z(0(#)),mul(i0,i1))) 

Choices: {}}</entry>
<entry key="equalityToSeqGetAndSeqLenLeft">equalityToSeqGetAndSeqLenLeft {
\find(equals(s,s2)==&gt;)
\varcond(\notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\add [and(equals(seqLen(s),seqLen(s2)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(s2,iv)))))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {sequences:on}}</entry>
<entry key="substringSubstring">substringSubstring {
\find(seqSub(seqSub(str,innerStartIdx,innerEndIdx),outerStartIdx,outerEndIdx))
\sameUpdateLevel\add [imp(and(and(and(and(and(geq(innerStartIdx,Z(0(#))),geq(innerEndIdx,innerStartIdx)),leq(innerEndIdx,seqLen(str))),geq(outerStartIdx,Z(0(#)))),geq(outerEndIdx,outerStartIdx)),leq(outerEndIdx,sub(innerEndIdx,innerStartIdx))),and(equals(seqSub(seqSub(str,innerStartIdx,innerEndIdx),outerStartIdx,outerEndIdx),newSym),equals(seqSub(str,add(outerStartIdx,innerStartIdx),add(innerStartIdx,outerEndIdx)),newSym)))]==&gt;[] 
\heuristics(stringsIntroduceNewSym, stringsReduceSubstring)
Choices: {Strings:on}}</entry>
<entry key="div_literals">div_literals {
\find(div(Z(iz),Z(jz)))
\replacewith(#div(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="seqConcatUnfold">seqConcatUnfoldRight {
\find(#allmodal ( (modal operator))\[{ .. #v=\seq_concat(#seLeft,#nseRight); ... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseRight) #vRightNew = #nseRight;#v=\seq_concat(#seLeft,#vRightNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="expand_inInt">expand_inInt {
\find(inInt(i))
\replacewith(and(leq(i,int_MAX),leq(int_MIN,i))) 
\heuristics(defOps_expandRanges)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="variableDeclaration">variableDeclarationMult {
\find(#allmodal ( (modal operator))\[{ .. #multvardecl ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. multiple-var-decl(#multvardecl) ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="apply_eq_pseudo_eq">apply_eq_pseudo_eq {
\assumes ([equals(mul(aePseudoLeft,aePseudoLeftCoeff),aePseudoRight)]==&gt;[]) 
\find(equals(aePseudoTargetLeft,aePseudoTargetRight))
\sameUpdateLevel\replacewith(if-then-else(and(equals(aePseudoTargetLeft,mul(aePseudoLeft,aePseudoTargetFactor)),not(equals(aePseudoLeftCoeff,Z(0(#))))),equals(mul(aePseudoRight,aePseudoTargetFactor),mul(aePseudoTargetRight,aePseudoLeftCoeff)),equals(aePseudoTargetLeft,aePseudoTargetRight))) 
\heuristics(notHumanReadable, notHumanReadable, polySimp_applyEqPseudo, polySimp_leftNonUnit)
Choices: {}}</entry>
<entry key="selectCreatedOfAnonAsFormulaEQ">selectCreatedOfAnonAsFormulaEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==&gt;[]) 
\find(equals(boolean::select(EQ,o,java.lang.Object::&lt;created&gt;),TRUE))
\sameUpdateLevel\replacewith(or(equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE),equals(boolean::select(h2,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="seqnormalizeDef">seqnormalizeDef {
\find(seqDef{u (variable)}(le,ri,t))
\varcond(\notFreeIn(u (variable), ri (int term)), \notFreeIn(u (variable), le (int term)))
\replacewith(if-then-else(lt(le,ri),seqDef{u (variable)}(Z(0(#)),sub(ri,le),subst{u (variable)}(add(u,le),t)),seqEmpty)) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="createdInHeapWithSingleton">createdInHeapWithSingleton {
\find(createdInHeap(singleton(o,f),h))
\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="setMinusSingleton">setMinusSingleton {
\assumes ([]==&gt;[elementOf(o,f,s)]) 
\find(setMinus(s,singleton(o,f)))
\replacewith(s) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="times_zero">times_zero_2 {
\find(mul(Z(0(#)),i))
\replacewith(Z(0(#))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="theorem_of_archimedes">theorem_of_archimedes {
\assumes ([gt(i0,sub(i1,Z(1(#))))]==&gt;[]) 
\find(lt(i0,i1)==&gt;)
\replacewith([false]==&gt;[]) 

Choices: {}}</entry>
<entry key="ifEnterThen">ifEnterThenConditionInBlock {
\find(#allmodal ( (modal operator))\[{ ..  {#loc=true;}if (#loc)
    #s0
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..  {#loc=true;}#s0 ... }\] (post)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="wd_Seq_Remove">wd_Seq_Remove {
\find(wd(seqRemove(s,n)))
\replacewith(and(and(and(wd(s),wd(n)),leq(Z(0(#)),n)),lt(n,seqLen(s)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="moduloIntIsInInt">moduloIntIsInInt {
\find(inInt(moduloInt(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="instanceCreationUnfoldArguments">instanceCreationUnfoldArguments {
\find(#allmodal ( (modal operator))\[{ .. #nsn ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #evaluate-arguments(#nsn) ... }\] (post)) 
\heuristics(simplify_autoname)
Choices: {programRules:Java}}</entry>
<entry key="mult_leq_0_iff">mult_leq_0_iff {
\find(leq(mul(i0,i1),Z(0(#))))
\replacewith(or(and(leq(i0,Z(0(#))),leq(Z(0(#)),i1)),and(leq(Z(0(#)),i0),leq(i1,Z(0(#)))))) 

Choices: {}}</entry>
<entry key="compound_assignment_op_and_attr">compound_assignment_op_and_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute&amp;=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute&amp;#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="FAKE_CLOSE">FAKE_CLOSE {
\closegoal\heuristics(obsolete)
Choices: {debug:on}}</entry>
<entry key="referencedObjectIsCreatedRight">referencedObjectIsCreatedRight {
\assumes ([]==&gt;[equals(deltaObject::select(h,o,f),null)]) 
\find(==&gt;equals(boolean::select(h,deltaObject::select(h,o,f),java.lang.Object::&lt;created&gt;),TRUE))
\replacewith([]==&gt;[wellFormed(h)]) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="writePermissionAfterReturn">writePermissionAfterReturn {
\assumes ([writePermissionObject(o1,p)]==&gt;[]) 
\find(writePermissionObject(o2,returnPermission(o1,o2,p)))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="greater_add_one">greater_add_one {
\find(gt(i0,i1))
\replacewith(gt(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: {}}</entry>
<entry key="createdInHeapWithObserverEQ">createdInHeapWithObserverEQ {
\assumes ([equals(obs,EQ)]==&gt;[]) 
\find(==&gt;createdInHeap(EQ,h))
\varcond(\isObserver (obs (LocSet term), h (Heap term)), )
\replacewith([]==&gt;[wellFormed(h)]) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="setJavaCardTransient">setJavaCardTransient {
\find(==&gt;#allmodal ( (modal operator))\[{ .. 
  #jcsystemType.#setTransient(#se,#se1)@#jcsystemType; ... }\] (post))
\replacewith([]==&gt;[not(equals(#se,null))]) ;
\replacewith([]==&gt;[update-application(elem-update(heap)(store(heap,#se,java.lang.Object::&lt;transient&gt;,#se1)),#allmodal(post))]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="subsetUnionLeft">subsetUnionLeft {
\find(subset(union(s,s2),s3))
\replacewith(and(subset(s,s3),subset(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="bsum_add_concrete">bsum_add_concrete {
\find(add(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i1,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(i0,i3,subst{uSub2 (variable)}(uSub1,if-then-else(lt(uSub1,i1),t1,t2)))) ;
\add []==&gt;[and(leq(i0,i1),leq(i1,i3))] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="elementOfSetMinusEQ">elementOfSetMinusEQ {
\assumes ([equals(setMinus(s,s2),EQ)]==&gt;[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\replacewith(and(elementOf(o,f,s),not(elementOf(o,f,s2)))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="definitionSeqdefWorkaround2">definitionSeqdefWorkaround2 {
\find(seq_def_workaround2(h,lower,upper,array,singleton(o,f)))
\varcond(\notFreeIn(j (variable), upper (int term)), \notFreeIn(j (variable), lower (int term)), \notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), f (Field term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(seqDef{j (variable)}(lower,upper,any::select(h,java.lang.Object::select(h,array,arr(j)),f))) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="ifthenelse_to_or_for">ifthenelse_to_or_for {
\find(if-then-else(phi,b,c))
\replacewith(and(or(not(phi),b),or(phi,c))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: {}}</entry>
<entry key="classes being initialized have been prepared">initialized_class_is_prepared {
\assumes ([equals(boolean::select(heap,null,alphaObj::&lt;classInitialized&gt;),TRUE),wellFormed(heap)]==&gt;[]) 
\find(boolean::select(heap,null,alphaObj::&lt;classPrepared&gt;))
\sameUpdateLevel\replacewith(TRUE) 
\heuristics(simplify, confluence_restricted)
Choices: {programRules:Java}}</entry>
<entry key="wd_Reach_Pred_Reach">wd_Reach_Pred_Reach {
\find(WD(reach(h,l,o,p,i)))
\replacewith(and(and(and(and(and(wd(h),wd(l)),wd(o)),wd(p)),wd(i)),wellFormed(h))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="assignment_array2">assignment_array2 {
\find(#allmodal ( (modal operator))\[{ .. #v=#v0[#se]; ... }\] (post))
\varcond(\hasSort(\elemSort(#v0 (program Variable)), G), )
\replacewith(update-application(elem-update(#v (program Variable))(G::select(heap,#v0,arr(#se))),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {runtimeExceptions:ignore,programRules:Java}}</entry>
<entry key="selectOfMemsetEQ">selectOfMemsetEQ {
\assumes ([equals(memset(h,s,x),EQ)]==&gt;[]) 
\find(beta::select(EQ,o,f))
\sameUpdateLevel\replacewith(if-then-else(and(elementOf(o,f,s),not(equals(f,java.lang.Object::&lt;created&gt;))),beta::cast(x),beta::select(h,o,f))) 
\heuristics(simplify_heap_high_costs)
Choices: {programRules:Java}}</entry>
<entry key="lengthReplace">lengthReplace {
\find(seqLen(clReplace(str,searchChar,replaceChar)))
\replacewith(seqLen(str)) 
\heuristics(stringsSimplify)
Choices: {Strings:on}}</entry>
<entry key="compound_assignment_op_mod_array">compound_assignment_op_mod_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]%=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]%#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="i_minus_i_is_zero">i_minus_i_is_zero {
\find(sub(i,i))
\replacewith(Z(0(#))) 

Choices: {}}</entry>
<entry key="wellFormedStorePrimitiveArray">wellFormedStorePrimitiveArray {
\find(wellFormed(store(h,o,arr(idx),x)))
\succedentPolarity\varcond(\hasSort(\elemSort(o (java.lang.Object term)), alpha), \not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), \sub(beta, alpha), )
\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="poolIsInjective">poolIsInjective {
\find(equals(strPool(slit1),strPool(slit2)))
\replacewith(equals(slit1,slit2)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="seqSubUnfold">seqSubUnfoldRight {
\find(#allmodal ( (modal operator))\[{ .. #v=\seq_sub(#seLeft,#seMiddle,#nseRight); ... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseRight) #vRightNew = #nseRight;#v=\seq_sub(#seLeft,#seMiddle,#vRightNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="preincrement_array">preincrement_array {
\find(#allmodal ( (modal operator))\[{ .. ++#e[#e0]; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#e0) #v0 = #e0;#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_shiftright_array">compound_assignment_op_shiftright_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]&gt;&gt;=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]&gt;&gt;#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="add_sub_elim_left">add_sub_elim_left {
\find(add(neg(i),i))
\replacewith(Z(0(#))) 

Choices: {}}</entry>
<entry key="ifthenelse_same_branches">ifthenelse_same_branches_for {
\find(if-then-else(phi,b,b))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="compound_assignment_op_shiftleft_attr">compound_assignment_op_shiftleft_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute&lt;&lt;=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute&lt;&lt;#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="seqPermDefLeft">seqPermDefLeft {
\find(seqPerm(s1,s2)==&gt;)
\varcond(\notFreeIn(s (variable), s2 (Seq term)), \notFreeIn(s (variable), s1 (Seq term)), \notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s1 (Seq term)))
\add [and(equals(seqLen(s1),seqLen(s2)),exists{s (variable)}(and(and(equals(seqLen(s),seqLen(s1)),seqNPerm(s)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s1,iv),any::seqGet(s2,int::seqGet(s,iv))))))))]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="neq_or_4">neq_or_4 {
\find(or(or(psi,not(phi)),phi))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="neq_or_3">neq_or_3 {
\find(or(or(psi,phi),not(phi)))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="seqDef_split_in_three">seqDef_split_in_three {
\find(seqDef{uSub (variable)}(from,to,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub1 (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)), \notFreeIn(uSub1 (variable), idx (int term)), \notFreeIn(uSub1 (variable), t (any term)), \notFreeIn(uSub (variable), idx (int term)))
\replacewith(seqConcat(seqDef{uSub (variable)}(from,idx,t),seqConcat(seqSingleton(subst{uSub (variable)}(idx,t)),seqDef{uSub1 (variable)}(add(idx,Z(1(#))),to,subst{uSub (variable)}(uSub1,t))))) ;
\add []==&gt;[and(leq(from,idx),lt(idx,to))] 

Choices: {sequences:on}}</entry>
<entry key="wd_Numerical_Op_Xor">wd_Numerical_Op_BitXOrLong {
\find(wd(javaBitwiseXOrLong(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="regExAxiom">regExAxiom {
\find(match(regEx(stringAsPattern),string))
\replacewith(equals(string,stringAsPattern)) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="neq_or_2">neq_or_2 {
\find(or(not(phi),phi))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="reachNull">reachNull {
\find(reach(h,s,o,null,n))
\replacewith(false) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="orJIntDef">orJIntDef {
\find(orJint(left,right))
\replacewith(moduloInt(binaryOr(left,right))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="wd_LocSet_Pred_InHeap">wd_LocSet_Pred_InHeap {
\find(WD(createdInHeap(l,h)))
\replacewith(and(and(wd(l),wd(h)),wellFormed(h))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="bsum_add">bsum_add {
\find(add(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i2,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(if-then-else(lt(i0,i2),i0,i2),if-then-else(gt(i1,i3),i1,i3),subst{uSub2 (variable)}(uSub1,add(if-then-else(and(leq(i0,uSub1),lt(uSub1,i1)),t1,Z(0(#))),if-then-else(and(leq(i2,uSub1),lt(uSub1,i3)),t2,Z(0(#))))))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="inLong">inLong {
\find(inLong(i))
\replacewith(true) 
\heuristics(concrete)
Choices: {intRules:arithmeticSemanticsIgnoringOF,programRules:Java}}</entry>
<entry key="impRight">impRight {
\find(==&gt;imp(b,c))
\replacewith([b]==&gt;[c]) 
\heuristics(alpha)
Choices: {}}</entry>
<entry key="array_post_declaration">array_post_declaration {
\find(#allmodal ( (modal operator))\[{ .. #arraypost ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. array-post-declaration(#arraypost) ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_div">compound_assignment_op_div {
\find(#allmodal ( (modal operator))\[{ .. #v/=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v/(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="singletonEqualsEmpty">singletonEqualsEmpty {
\find(equals(singleton(o,f),empty))
\replacewith(false) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="seqIndexOfUnfold">seqIndexOfUnfoldRight {
\find(#allmodal ( (modal operator))\[{ .. #v=\indexOf(#seLeft,#nseRight); ... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseRight) #vRightNew = #nseRight;#v=\indexOf(#seLeft,#vRightNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="eval_array_access">eval_array_this_access {
\find(#allmodal ( (modal operator))\[{ .. this[#nse]=#se0; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #v0 = #nse;this[#v0]=#se0; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="defOfSeqReverse">defOfSeqReverse {
\find(seqReverse(seq))
\varcond(\notFreeIn(uSub (variable), seq (Seq term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),seqLen(seq),any::seqGet(seq,sub(sub(seqLen(seq),uSub),Z(1(#)))))) 

Choices: {sequences:on}}</entry>
<entry key="translateJavaMod">translateJavaMod {
\find(javaMod(left,right))
\replacewith(jmod(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="minus_distribute">minus_distribute_2 {
\find(neg(sub(i,i1)))
\replacewith(add(neg(i),i1)) 

Choices: {}}</entry>
<entry key="preincrement_assignment_array">preincrement_assignment_array {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=++#e[#e0]; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#e0) #v0 = #e0;#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);#lhs0=#v[#v0]; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="getOfSeqSingletonConcrete">getOfSeqSingletonConcrete {
\find(alpha::seqGet(seqSingleton(x),Z(0(#))))
\replacewith(alpha::cast(x)) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="expand_moduloInteger">expand_moduloInteger {
\find(moduloInt(i))
\replacewith(add(int_MIN,mod(add(int_HALFRANGE,i),int_RANGE))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="all_bool">all_bool {
\find(all{x (variable)}(c))
\replacewith(and(subst{x (variable)}(FALSE,c),subst{x (variable)}(TRUE,c))) 
\heuristics(boolean_cases)
Choices: {}}</entry>
<entry key="disjointAndSubset2">disjointAndSubset2 {
\assumes ([equals(intersect(s2,s3),empty)]==&gt;[]) 
\find(subset(s,s3)==&gt;)
\add [equals(intersect(s,s2),empty)]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="disjointAndSubset1">disjointAndSubset1 {
\assumes ([equals(intersect(s2,s3),empty)]==&gt;[]) 
\find(subset(s,s2)==&gt;)
\add [equals(intersect(s,s3),empty)]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="invert_bits">compound_invert_bits {
\find(#allmodal ( (modal operator))\[{ .. #lhs=~#nse; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #v1 = #nse;#lhs=~#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="commuteUnion_2">commuteUnion_2 {
\find(union(union(s,commLeft),commRight))
\replacewith(union(union(s,commRight),commLeft)) 
\heuristics(cnf_setComm)
Choices: {programRules:Java}}</entry>
<entry key="blockThrow">blockThrow {
\find(#allmodal ( (modal operator))\[{ ..  {throw #e;#slist} ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. throw #e; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="expand_inShort">expand_inShort {
\find(inShort(i))
\replacewith(and(leq(i,short_MAX),leq(short_MIN,i))) 
\heuristics(defOps_expandRanges)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="unionWithSingletonEqualsUnionWithSingleton">unionWithSingletonEqualsUnionWithSingleton {
\find(equals(union(s1,singleton(o,f)),union(s2,singleton(o,f))))
\replacewith(equals(setMinus(s1,singleton(o,f)),setMinus(s2,singleton(o,f)))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="reachAddOne">reachAddOne {
\find(reach(h,s,o,o2,add(Z(1(#)),n)))
\varcond(\notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\replacewith(and(and(and(geq(n,Z(neglit(1(#)))),not(equals(o,null))),not(equals(o2,null))),or(and(equals(n,Z(neglit(1(#)))),equals(o,o2)),exists{ov (variable)}(and(reach(h,s,o,ov,n),acc(h,s,ov,o2)))))) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="intersectWithItself">intersectWithItself {
\find(intersect(s,s))
\replacewith(s) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Pred_Leq">wd_Numerical_Pred_Leq {
\find(WD(leq(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_F_Logical_Op_ExCond_Form">wd_F_Logical_Op_ExCond_Form {
\find(F(ifExThenElse{j (variable)}(a,b,c)))
\varcond(\notFreeIn(j (variable), jPrime (int skolem term)), \notFreeIn(j (variable), c (formula)))
\replacewith(or(or(exists{j (variable)}(and(and(T(a),F(b)),imp(and(wellOrderLeqInt(jPrime,j),not(equals(jPrime,j))),subst{j (variable)}(jPrime,F(a))))),all{j (variable)}(and(F(a),F(c)))),all{j (variable)}(and(F(b),F(c))))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="blockReturn (remove label)">blockReturnLabel2 {
\find(#allmodal ( (modal operator))\[{ .. #lb: {return #se;#slist} ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. return #se; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="less_is_alternative_2">less_is_alternative_2 {
\assumes ([]==&gt;[lt(i,i0)]) 
\find(==&gt;lt(i0,i))
\add [equals(i,i0)]==&gt;[] 

Choices: {}}</entry>
<entry key="less_is_alternative_1">less_is_alternative_1 {
\assumes ([lt(i,i0),lt(i0,i)]==&gt;[]) 
\closegoal
Choices: {}}</entry>
<entry key="defOfEmpty">defOfEmpty {
\find(seqEmpty)
\varcond(\notFreeIn(uSub (variable), te (any term)))
\replacewith(seqDef{uSub (variable)}(Z(0(#)),Z(0(#)),te)) 

Choices: {sequences:on}}</entry>
<entry key="eqSameSeq">eqSameSeq {
\find(equals(seqSub(seq,from,to),seq))
\sameUpdateLevel\varcond(\notFreeIn(iv (variable), seq (Seq term)), \notFreeIn(iv (variable), from (int term)))
\replacewith(or(or(and(equals(from,Z(0(#))),equals(seqLen(seq),to)),and(leq(to,from),equals(seqLen(seq),Z(0(#))))),and(equals(seqLen(seq),sub(to,from)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(seq))),equals(any::seqGet(seq,iv),any::seqGet(seq,add(iv,from)))))))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="add_non_neg_square">add_non_neg_square {
\add [geq(mul(squareFac,squareFac),Z(0(#)))]==&gt;[] 
\heuristics(inEqSimp_nonNegSquares, inEqSimp_special_nonLin)
Choices: {}}</entry>
<entry key="unionIntersectItself">unionIntersectItself {
\find(union(intersect(s1,s2),s1))
\replacewith(s1) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="equal_bprod">equal_bprod5 {
\find(==&gt;equals(bprod{uSub1 (variable)}(i0,i1,t1),bprod{uSub2 (variable)}(i2,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==&gt;[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(sub(add(uSub1,i2),i0),t2))))] ;
\add []==&gt;[equals(sub(i1,i0),sub(i3,i2))] 
\heuristics(comprehensions_high_costs)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="selectOfAnon">selectOfAnon {
\find(beta::select(anon(h,s,h2),o,f))
\replacewith(if-then-else(or(and(elementOf(o,f,s),not(equals(f,java.lang.Object::&lt;created&gt;))),elementOf(o,f,freshLocs(h))),beta::select(h2,o,f),beta::select(h,o,f))) 
\heuristics(semantics_blasting)
Choices: {programRules:Java}}</entry>
<entry key="disjointWithSingleton">disjointWithSingleton2 {
\find(equals(intersect(singleton(o,f),s),empty))
\replacewith(not(elementOf(o,f,s))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="moduloShortFixpoint">moduloShortFixpoint {
\assumes ([inShort(t)]==&gt;[]) 
\find(moduloShort(t))
\sameUpdateLevel\replacewith(t) 
\heuristics(simplify)
Choices: {intRules:arithmeticSemanticsCheckingOF}}</entry>
<entry key="times_minus_one">times_minus_one_2 {
\find(mul(Z(neglit(1(#))),i))
\replacewith(neg(i)) 

Choices: {}}</entry>
<entry key="isFiniteOfMapUpdate">isFiniteOfMapUpdate {
\find(isFinite(mapUpdate(m,key,value)))
\sameUpdateLevel\replacewith(isFinite(m)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="seqNPermInvNPermLeft">seqNPermInvNPermLeft {
\find(seqNPerm(s1)==&gt;)
\add [seqNPerm(seqNPermInv(s1))]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="leq_diff_1">leq_diff_1 {
\find(leq(i0,add(i0,Z(1(#)))))
\replacewith(true) 
\heuristics(int_arithmetic)
Choices: {}}</entry>
<entry key="compound_assignment_op_or_array">compound_assignment_op_or_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]|=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]|#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="readPermissionAfterTransferWrite">readPermissionAfterTransferWrite {
\assumes ([writePermissionObject(o1,p)]==&gt;[]) 
\find(readPermissionObject(o2,transferPermission(split,o1,o2,Z(0(#)),p)))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="seqGetSInvS">seqGetSInvS {
\find(int::seqGet(s,int::seqGet(seqNPermInv(s),t)))
\add []==&gt;[and(and(seqNPerm(s),leq(Z(0(#)),t)),lt(t,seqLen(s)))] ;
\replacewith(t) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="setUnionUnfold">setUnionUnfoldRight {
\find(#allmodal ( (modal operator))\[{ .. #v=\set_union(#seLeft,#nseRight); ... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseRight) #vRightNew = #nseRight;#v=\set_union(#seLeft,#vRightNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="readPermissionObject">readPermissionObject {
\find(readPermissionObject(o,p))
\replacewith(true) 
\heuristics(concrete)
Choices: {permissions:off}}</entry>
<entry key="replace_char_MIN">replace_char_MIN {
\find(char_MIN)
\replacewith(Z(0(#))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="regExConcatOptLeft">regExConcatOptLeft {
\find(match(regExConcat(opt(rexp1),rexp2),string))
\replacewith(or(match(rexp2,string),match(regExConcat(rexp1,rexp2),string))) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="zero_leq_mult_iff">zero_leq_mult_iff {
\find(leq(Z(0(#)),mul(i0,i1)))
\replacewith(or(and(leq(Z(0(#)),i0),leq(Z(0(#)),i1)),and(leq(i0,Z(0(#))),leq(i1,Z(0(#)))))) 

Choices: {}}</entry>
<entry key="getOfRemoveInt">getOfRemoveInt {
\find(int::seqGet(seqRemove(s1,i2),i3))
\replacewith(if-then-else(or(lt(i2,Z(0(#))),leq(seqLen(s1),i2)),int::seqGet(s1,i3),if-then-else(lt(i3,i2),int::seqGet(s1,i3),if-then-else(and(leq(i2,i3),lt(i3,sub(seqLen(s1),Z(1(#))))),int::seqGet(s1,add(i3,Z(1(#)))),int::cast(seqGetOutside))))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="regExConcatRepeatRight">regExConcatRepeatRight {
\find(match(regExConcat(rexp1,repeat(rexp2,nTimes)),string))
\varcond(\notFreeIn(string2 (variable), nTimes (int term)), \notFreeIn(string2 (variable), rexp2 (RegEx term)), \notFreeIn(string2 (variable), rexp1 (RegEx term)), \notFreeIn(string2 (variable), string (Seq term)), \notFreeIn(string1 (variable), nTimes (int term)), \notFreeIn(string1 (variable), rexp2 (RegEx term)), \notFreeIn(string1 (variable), rexp1 (RegEx term)), \notFreeIn(string1 (variable), string (Seq term)))
\replacewith(if-then-else(equals(nTimes,Z(0(#))),match(rexp1,string),if-then-else(lt(nTimes,Z(0(#))),false,exists{string1 (variable)}(exists{string2 (variable)}(and(and(match(rexp1,string1),match(repeat(rexp2,nTimes),string2)),equals(string,seqConcat(string1,string2)))))))) 
\heuristics(simplify)
Choices: {Strings:on}}</entry>
<entry key="reachDependenciesStoreEQ">reachDependenciesStoreEQ {
\assumes ([equals(store(h,o3,f,x),h2)]==&gt;[]) 
\find(reach(h2,s,o,o2,n))
\sameUpdateLevel\varcond(\notFreeIn(nv (variable), n (int term)), \notFreeIn(nv (variable), o2 (java.lang.Object term)), \notFreeIn(nv (variable), o (java.lang.Object term)), \notFreeIn(nv (variable), s (LocSet term)), \notFreeIn(nv (variable), x (any term)), \notFreeIn(nv (variable), f (Field term)), \notFreeIn(nv (variable), o3 (java.lang.Object term)), \notFreeIn(nv (variable), h (Heap term)))
\add [not(and(exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,o3,nv))),elementOf(o3,f,s)))]==&gt;[] \replacewith(reach(h,s,o,o2,n)) ;
\add []==&gt;[not(and(exists{nv (variable)}(and(lt(nv,n),reach(h,s,o,o3,nv))),elementOf(o3,f,s)))] 

Choices: {reach:on}}</entry>
<entry key="beginJavaCardTransactionAPI">beginJavaCardTransactionAPI {
\find(==&gt;#allmodal ( (modal operator))\[{ .. 
  #jcsystemType.#beginTransaction()@#jcsystemType; ... }\] (post))
\replacewith([]==&gt;[#allmodal ( (modal operator))\[{ .. #beginJavaCardTransaction; ... }\] (post)]) 
\heuristics(simplify_prog)
Choices: {JavaCard:on,programRules:Java}}</entry>
<entry key="elim_forall_leq">elim_forall_leq {
\find(all{INTVar (variable)}(or(leq(INTVar,intTermLeft),geq(INTVar,intTermRight))))
\varcond(\notFreeIn(INTVar (variable), intTermRight (int term)), \notFreeIn(INTVar (variable), intTermLeft (int term)))
\replacewith(leq(intTermRight,add(intTermLeft,Z(1(#))))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="apply_eq_boolean">apply_eq_boolean_rigid_2 {
\assumes ([]==&gt;[equals(br,FALSE)]) 
\find(br)
\replacewith(TRUE) 
\heuristics(apply_equations)
Choices: {}}</entry>
<entry key="prod_empty">prod_empty {
\find(prod{x (variable)}(FALSE,t))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="mult_eq_self_iff">mult_eq_self_iff {
\find(equals(i0,mul(i0,i1)))
\replacewith(or(equals(i0,Z(0(#))),equals(i1,Z(1(#))))) 

Choices: {}}</entry>
<entry key="double_unary_minus">double_unary_minus_literal {
\find(Z(neglit(neglit(iz))))
\replacewith(Z(iz)) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="stringConcatIntExpLeft">stringConcatIntExpLeft {
\find(#normalassign ( (modal operator))\[{ .. #v=#seLeft+#sstrRight; ... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(clTranslateInt(#seLeft),strContent(#sstrRight)))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="orRight">orRight {
\find(==&gt;or(b,c))
\replacewith([]==&gt;[b,c]) 
\heuristics(alpha)
Choices: {}}</entry>
<entry key="ifthenelse_to_or_right">ifthenelse_to_or_right {
\find(equals(t,if-then-else(phi,then,else)))
\replacewith(and(or(not(phi),equals(t,then)),or(phi,equals(t,else)))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: {}}</entry>
<entry key="getOfSeqSub">getOfSeqSubEQ {
\assumes ([equals(seqSub(seq,from,to),EQ)]==&gt;[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\replacewith(if-then-else(and(leq(Z(0(#)),idx),lt(idx,sub(to,from))),alpha::seqGet(seq,add(idx,from)),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: {sequences:on}}</entry>
<entry key="multiply_2_inEq3">multiply_2_inEq3 {
\assumes ([geq(multFacLeft,multFacRight)]==&gt;[]) 
\find(geq(multLeft,multRight)==&gt;)
\add [geq(mul(multLeft,multFacLeft),add(add(mul(neg(multRight),multFacRight),mul(multRight,multFacLeft)),mul(multLeft,multFacRight)))]==&gt;[] 
\heuristics(inEqSimp_nonLin_multiply, inEqSimp_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="geq_to_lt_alt">geq_to_lt_alt {
\find(geq(i,j))
\replacewith(or(gt(i,j),equals(i,j))) 

Choices: {}}</entry>
<entry key="replace_known_right">replace_known_right {
\assumes ([]==&gt;[b]) 
\find(b)
\sameUpdateLevel\replacewith(false) 
\heuristics(replace_known_right)
Choices: {}}</entry>
<entry key="multiply_2_inEq2">multiply_2_inEq2 {
\assumes ([leq(multFacLeft,multFacRight)]==&gt;[]) 
\find(geq(multLeft,multRight)==&gt;)
\add [leq(mul(multLeft,multFacLeft),add(add(mul(neg(multRight),multFacRight),mul(multRight,multFacLeft)),mul(multLeft,multFacRight)))]==&gt;[] 
\heuristics(inEqSimp_nonLin_multiply, inEqSimp_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="multiply_2_inEq1">multiply_2_inEq1 {
\assumes ([geq(multFacLeft,multFacRight)]==&gt;[]) 
\find(leq(multLeft,multRight)==&gt;)
\add [leq(mul(multLeft,multFacLeft),add(add(mul(neg(multRight),multFacRight),mul(multRight,multFacLeft)),mul(multLeft,multFacRight)))]==&gt;[] 
\heuristics(inEqSimp_nonLin_multiply, inEqSimp_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="multiply_2_inEq0">multiply_2_inEq0 {
\assumes ([leq(multFacLeft,multFacRight)]==&gt;[]) 
\find(leq(multLeft,multRight)==&gt;)
\add [geq(mul(multLeft,multFacLeft),add(add(mul(neg(multRight),multFacRight),mul(multRight,multFacLeft)),mul(multLeft,multFacRight)))]==&gt;[] 
\heuristics(inEqSimp_nonLin_multiply, inEqSimp_nonLin)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="expand_moduloLong">expand_moduloLong {
\find(moduloLong(i))
\replacewith(add(long_MIN,mod(add(long_HALFRANGE,i),long_RANGE))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="less_is_total">less_is_total {
\find(i)
\sameUpdateLevel\add [lt(i0,i)]==&gt;[] ;
\add [equals(i,i0)]==&gt;[] ;
\add [lt(i,i0)]==&gt;[] 

Choices: {}}</entry>
<entry key="inEqSimp_and_subsumption7">inEqSimp_and_subsumption7 {
\find(and(and(b,geq(subsumLeft,subsumRightBigger)),not(equals(subsumLeft,subsumRightSmaller))))
\replacewith(and(and(b,geq(subsumLeft,subsumRightBigger)),or(lt(subsumRightSmaller,subsumRightBigger),not(equals(subsumLeft,subsumRightSmaller))))) 
\heuristics(notHumanReadable, inEqSimp_and_subsumptionEq, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_and_subsumption6">inEqSimp_and_subsumption6 {
\find(and(geq(subsumLeft,subsumRightBigger),not(equals(subsumLeft,subsumRightSmaller))))
\replacewith(and(geq(subsumLeft,subsumRightBigger),or(lt(subsumRightSmaller,subsumRightBigger),not(equals(subsumLeft,subsumRightSmaller))))) 
\heuristics(notHumanReadable, inEqSimp_and_subsumptionEq, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="bitwiseAnd">assignmentBitwiseAndLong3 {
\find(#normalassign ( (modal operator))\[{ .. #loc=#seLong0&amp;#seLong1; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseAndLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_and_subsumption5">inEqSimp_and_subsumption5 {
\find(and(and(b,leq(subsumLeft,subsumRightSmaller)),not(equals(subsumLeft,subsumRightBigger))))
\replacewith(and(and(b,leq(subsumLeft,subsumRightSmaller)),or(lt(subsumRightSmaller,subsumRightBigger),not(equals(subsumLeft,subsumRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_and_subsumptionEq, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_and_subsumption4">inEqSimp_and_subsumption4 {
\find(and(leq(subsumLeft,subsumRightSmaller),not(equals(subsumLeft,subsumRightBigger))))
\replacewith(and(leq(subsumLeft,subsumRightSmaller),or(lt(subsumRightSmaller,subsumRightBigger),not(equals(subsumLeft,subsumRightBigger))))) 
\heuristics(notHumanReadable, inEqSimp_and_subsumptionEq, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_and_subsumption3">inEqSimp_and_subsumption3 {
\find(and(and(b,geq(subsumLeft,subsumRightSmaller)),geq(subsumLeft,subsumRightBigger)))
\replacewith(and(and(b,or(leq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightSmaller))),geq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_and_subsumption2">inEqSimp_and_subsumption2 {
\find(and(geq(subsumLeft,subsumRightSmaller),geq(subsumLeft,subsumRightBigger)))
\replacewith(and(or(leq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightSmaller)),geq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="assignment_read_attribute">assignment_read_attribute {
\find(#allmodal ( (modal operator))\[{ .. #v0=#v.#a; ... }\] (post))
\varcond( \not \static(#a (program Variable)),  \not \isArrayLength(#a (program Variable)), \hasSort(#a (program Variable), G), \not\isThisReference (#v (program Variable)), )
\replacewith(update-application(elem-update(#v0 (program Variable))(G::select(heap,#v,#memberPVToField(#a))),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {runtimeExceptions:ignore,programRules:Java}}</entry>
<entry key="inEqSimp_and_subsumption1">inEqSimp_and_subsumption1 {
\find(and(and(b,leq(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger)))
\replacewith(and(and(b,leq(subsumLeft,subsumRightSmaller)),or(leq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_and_subsumption0">inEqSimp_and_subsumption0 {
\find(and(leq(subsumLeft,subsumRightSmaller),leq(subsumLeft,subsumRightBigger)))
\replacewith(and(leq(subsumLeft,subsumRightSmaller),or(leq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="assignmentUnfoldRight">eval_order_access2 {
\find(#allmodal ( (modal operator))\[{ .. #v=#nv.#attribute; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nv (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nv) #v0 = #nv;#v=#v0.#attribute; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Op_ShiftRight">wd_Numerical_Op_JavaUnsignedShiftRightLong {
\find(wd(javaUnsignedShiftRightLong(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="bsum_def">bsum_def {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(lt(i0,i1),add(bsum{uSub (variable)}(i0,sub(i1,Z(1(#))),t),subst{uSub (variable)}(sub(i1,Z(1(#))),t)),Z(0(#)))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="bsum_distributive">bsum_distributive {
\find(bsum{uSub (variable)}(i0,i2,mul(t,t1)))
\varcond(\notFreeIn(uSub (variable), t1 (int term)), \notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bsum{uSub (variable)}(i0,i2,t),t1)) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="polySimp_elimNeg">polySimp_elimNeg {
\find(neg(i))
\replacewith(mul(i,Z(neglit(1(#))))) 
\heuristics(polySimp_elimSubNeg, polySimp_expand)
Choices: {}}</entry>
<entry key="instanceCreationAssignmentUnfoldArguments">instanceCreationAssignmentUnfoldArguments {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#nsn; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #evaluate-arguments(#lhs=#nsn;) ... }\] (post)) 
\heuristics(simplify_autoname)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_or">compound_assignment_op_or {
\find(#allmodal ( (modal operator))\[{ .. #v|=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v|(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="ifthenelse_negated">ifthenelse_negated_for {
\find(if-then-else(not(phi),b,c))
\replacewith(if-then-else(phi,c,b)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="close_by_lt_leq">close_by_lt_leq {
\assumes ([lt(i,j)]==&gt;[]) 
\find(==&gt;leq(add(i,Z(1(#))),j))
\replacewith([]==&gt;[true]) 

Choices: {}}</entry>
<entry key="bprod_lower_equals_upper">bprod_lower_equals_upper {
\find(bprod{uSub (variable)}(i0,i0,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="andLeft">andLeft {
\find(and(b,c)==&gt;)
\replacewith([b,c]==&gt;[]) 
\heuristics(alpha)
Choices: {}}</entry>
<entry key="writePermission">writePermission {
\find(writePermission(p))
\replacewith(writePermissionObject(currentThread,p)) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="replace_long_RANGE">replace_long_RANGE {
\find(long_RANGE)
\replacewith(Z(6(1(6(1(5(5(9(0(7(3(7(0(4(4(7(6(4(4(8(1(#)))))))))))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="less_iff_diff_less_0">less_iff_diff_less_0 {
\find(lt(i0,i1))
\replacewith(lt(sub(i0,i1),Z(0(#)))) 

Choices: {}}</entry>
<entry key="unionIntersectItself_6">unionIntersectItself_6 {
\find(union(union(intersect(s2,s1),s),s1))
\replacewith(union(s,s1)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="unionIntersectItself_5">unionIntersectItself_5 {
\find(union(union(intersect(s1,s2),s),s1))
\replacewith(union(s,s1)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="unionIntersectItself_4">unionIntersectItself_4 {
\find(union(union(s,intersect(s2,s1)),s1))
\replacewith(union(s,s1)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="unionIntersectItself_3">unionIntersectItself_3 {
\find(union(union(s,intersect(s1,s2)),s1))
\replacewith(union(s,s1)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="unionIntersectItself_2">unionIntersectItself_2 {
\find(union(intersect(s2,s1),s1))
\replacewith(s1) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="lenOfSeqDef">lenOfSeqDefEQ {
\assumes ([equals(seqDef{uSub (variable)}(from,to,t),EQ)]==&gt;[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(if-then-else(leq(from,to),sub(to,from),Z(0(#)))) 
\heuristics(simplify)
Choices: {sequences:on}}</entry>
<entry key="wd_LocSet_ArrRange">wd_LocSet_ArrRange {
\find(wd(arrayRange(o,i,j)))
\varcond( \not \isArray(o (java.lang.Object term)), )
\replacewith(and(and(and(and(and(and(wd(o),wd(i)),wd(j)),not(equals(o,null))),leq(Z(0(#)),i)),leq(i,j)),lt(j,length(o)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="reachAddOne2">reachAddOne2 {
\find(reach(h,s,o,o2,add(n,Z(1(#)))))
\varcond(\notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\replacewith(and(and(and(geq(n,Z(neglit(1(#)))),not(equals(o,null))),not(equals(o2,null))),or(and(equals(n,Z(neglit(1(#)))),equals(o,o2)),exists{ov (variable)}(and(reach(h,s,o,ov,n),acc(h,s,ov,o2)))))) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="wd_Numerical_Cast">wd_Numerical_Cast_CharOverFlow {
\find(wd(javaCastCharOverFlow(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="applyEq_and_gen3">applyEq_and_gen3 {
\find(and(and(b,not(equals(applyEqLeft,applyEqOther))),equals(applyEqLeft,applyEqRight)))
\replacewith(and(and(b,not(equals(applyEqRight,applyEqOther))),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_gen2">applyEq_and_gen2 {
\find(and(not(equals(applyEqLeft,applyEqOther)),equals(applyEqLeft,applyEqRight)))
\replacewith(and(not(equals(applyEqRight,applyEqOther)),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_gen1">applyEq_and_gen1 {
\find(and(and(b,equals(applyEqLeft,applyEqOther)),equals(applyEqLeft,applyEqRight)))
\replacewith(and(and(b,equals(applyEqRight,applyEqOther)),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_and_gen0">applyEq_and_gen0 {
\find(and(equals(applyEqLeft,applyEqOther),equals(applyEqLeft,applyEqRight)))
\replacewith(and(equals(applyEqRight,applyEqOther),equals(applyEqLeft,applyEqRight))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="inEqSimp_or_tautInEq3">inEqSimp_or_tautInEq3 {
\find(or(or(b,geq(tautLeft,tautRightSmaller)),leq(tautLeft,tautRightBigger)))
\replacewith(or(or(or(b,geq(tautLeft,tautRightSmaller)),leq(tautLeft,tautRightBigger)),geq(tautRightBigger,add(Z(neglit(1(#))),tautRightSmaller)))) 
\heuristics(notHumanReadable, inEqSimp_or_tautInEqs, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="postdecrement_assignment">postdecrement_assignment {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=#lhs1--; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#lhs0 (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#lhs0) #v = #lhs1;#lhs1=(#typeof(#lhs1))(#lhs1-1);#lhs0=#v; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_or_tautInEq2">inEqSimp_or_tautInEq2 {
\find(or(geq(tautLeft,tautRightSmaller),leq(tautLeft,tautRightBigger)))
\replacewith(or(or(geq(tautLeft,tautRightSmaller),leq(tautLeft,tautRightBigger)),geq(tautRightBigger,add(Z(neglit(1(#))),tautRightSmaller)))) 
\heuristics(notHumanReadable, inEqSimp_or_tautInEqs, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_tautInEq1">inEqSimp_or_tautInEq1 {
\find(or(or(b,leq(tautLeft,tautRightBigger)),geq(tautLeft,tautRightSmaller)))
\replacewith(or(or(or(b,leq(tautLeft,tautRightBigger)),geq(tautLeft,tautRightSmaller)),geq(tautRightBigger,add(Z(neglit(1(#))),tautRightSmaller)))) 
\heuristics(notHumanReadable, inEqSimp_or_tautInEqs, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="translateJavaSub">translateJavaSubLong {
\find(javaSubLong(left,right))
\replacewith(if-then-else(inLong(sub(left,right)),sub(left,right),javaSubLongOverFlow(left,right))) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="getOfMapRemove">getOfMapRemove {
\find(mapGet(mapRemove(m,key),x))
\sameUpdateLevel\replacewith(if-then-else(equals(x,key),mapUndef,mapGet(m,x))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="inEqSimp_or_tautInEq0">inEqSimp_or_tautInEq0 {
\find(or(leq(tautLeft,tautRightBigger),geq(tautLeft,tautRightSmaller)))
\replacewith(or(or(leq(tautLeft,tautRightBigger),geq(tautLeft,tautRightSmaller)),geq(tautRightBigger,add(Z(neglit(1(#))),tautRightSmaller)))) 
\heuristics(notHumanReadable, inEqSimp_or_tautInEqs, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="compound_assignment_op_mul">compound_assignment_op_mul {
\find(#allmodal ( (modal operator))\[{ .. #v*=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v*(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="subsetOfUnionWithItSelfEQ2">subsetOfUnionWithItSelfEQ2 {
\assumes ([equals(union(s2,s),EQ)]==&gt;[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="unionWithSingletonEqualsUnionWithSingleton_2">unionWithSingletonEqualsUnionWithSingleton_2 {
\find(equals(union(singleton(o,f),s1),union(singleton(o,f),s2)))
\replacewith(equals(setMinus(s1,singleton(o,f)),setMinus(s2,singleton(o,f)))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="subsetOfUnionWithItSelfEQ1">subsetOfUnionWithItSelfEQ1 {
\assumes ([equals(union(s,s2),EQ)]==&gt;[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="concrete_or_4">concrete_or_4 {
\find(or(b,false))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="concrete_or_3">concrete_or_3 {
\find(or(b,true))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="concrete_or_2">concrete_or_2 {
\find(or(false,b))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="concrete_or_1">concrete_or_1 {
\find(or(true,b))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="polySimp_mulLiterals">polySimp_mulLiterals {
\find(mul(mul(i,Z(iz)),Z(jz)))
\replacewith(mul(i,#mul(Z(iz),Z(jz)))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="isFiniteOfMapEmpty">isFiniteOfMapEmpty {
\find(isFinite(mapEmpty))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="seqNPermInjective">seqNPermInjective {
\find(seqNPerm(s)==&gt;)
\varcond(\notFreeIn(jv (variable), s (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\add [all{iv (variable)}(all{jv (variable)}(imp(and(and(and(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),leq(Z(0(#)),jv)),lt(jv,seqLen(s))),equals(int::seqGet(s,iv),int::seqGet(s,jv))),equals(iv,jv))))]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="wd_String_LastIndexOfStr">wd_String_LastIndexOfStr {
\find(wd(clLastIndexOfCl(l,i,c)))
\replacewith(and(and(and(and(wd(c),wd(i)),wd(l)),leq(Z(0(#)),i)),lt(add(i,seqLen(c)),seqLen(l)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="hideAuxiliaryEqConcrete">hideAuxiliaryEqConcrete {
\find(equals(auxiliarySK,TRUE)==&gt;)
\addrules [replaceKnownAuxiliaryConstant {
\find(auxiliarySK)
\inSequentState\replacewith(TRUE) 
\heuristics(concrete)
Choices: {}}] \replacewith([]==&gt;[]) 
\heuristics(hide_auxiliary_eq_const)
Choices: {programRules:Java}}</entry>
<entry key="wd_Heap_Pred_ArrStoreValid">wd_Heap_Pred_ArrStoreValid {
\find(WD(arrayStoreValid(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_F_Logical_Op_Imp">wd_F_Logical_Op_Imp {
\find(F(imp(a,b)))
\replacewith(and(T(a),F(b))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="binary_OR">compound_binary_OR_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e|#nse; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse) #v1 = #nse;#lhs=#v0|#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="lenOfSeqSingleton">lenOfSeqSingletonEQ {
\assumes ([equals(seqSingleton(x),EQ)]==&gt;[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(Z(1(#))) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="greater">greater {
\find(gt(i,i0))
\replacewith(lt(i0,i)) 

Choices: {}}</entry>
<entry key="lengthReplaceEQ">lengthReplaceEQ {
\assumes ([equals(clReplace(str,searchChar,replaceChar),newStr)]==&gt;[]) 
\find(seqLen(newStr))
\sameUpdateLevel\replacewith(seqLen(str)) 
\heuristics(stringsSimplify)
Choices: {Strings:on}}</entry>
<entry key="defOfSeqSub">defOfSeqSub {
\find(seqSub(seq,from,to))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)), \notFreeIn(uSub (variable), seq (Seq term)))
\replacewith(seqDef{uSub (variable)}(from,to,any::seqGet(seq,uSub))) 

Choices: {sequences:on}}</entry>
<entry key="wd_T_Logical_Op_Or">wd_T_Logical_Op_Or {
\find(T(or(a,b)))
\replacewith(or(T(a),T(b))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="allRight">allRight {
\find(==&gt;all{u (variable)}(b))
\replacewith([]==&gt;[subst{u (variable)}(sk,b)]) 
\heuristics(delta)
Choices: {}}</entry>
<entry key="castTrueImpliesOriginalTrue">castTrueImpliesOriginalTrue {
\assumes ([equals(boolean::select(h,o,f),TRUE)]==&gt;[]) 
\find(==&gt;equals(any::select(h,o,f),TRUE))
\replacewith([]==&gt;[true]) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="eq_imp">eq_imp {
\find(imp(phi,phi))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="subsetOfUnionWithItSelf2">subsetOfUnionWithItSelf2 {
\find(subset(s,union(s2,s)))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="sub_zero_2">sub_zero_2 {
\find(sub(i,Z(0(#))))
\replacewith(i) 

Choices: {}}</entry>
<entry key="subsetOfUnionWithItSelf1">subsetOfUnionWithItSelf1 {
\find(subset(s,union(s,s2)))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="sub_zero_1">sub_zero_1 {
\find(Z(neglit(0(#))))
\replacewith(Z(0(#))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="break">break {
\find(#allmodal ( (modal operator))\[{ .. #lb0:break ;
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. do-break(#lb0:break ;  ) ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="assignment_read_length">assignment_read_length {
\find(#allmodal ( (modal operator))\[{ .. #v0=#v.#length; ... }\] (post))
\varcond(\not\isThisReference (#v (program Variable)), )
\replacewith(update-application(elem-update(#v0 (program Variable))(length(#v)),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {runtimeExceptions:ignore,programRules:Java}}</entry>
<entry key="initFullPermission">initFullPermission {
\find(initFullPermission)
\replacewith(slice(consPermissionOwnerList(currentThread,emptyPermissionOwnerList),emptyPermission)) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="wellFormedStoreObject">wellFormedStoreObject {
\find(wellFormed(store(h,o,f,x)))
\succedentPolarity\varcond(\fieldType(f (Field term), alpha), )
\replacewith(or(and(wellFormed(h),equals(x,null)),and(equals(boolean::select(h,x,java.lang.Object::&lt;created&gt;),TRUE),equals(alpha::instance(x),TRUE)))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="elementOfInfiniteUnion">elementOfInfiniteUnion {
\find(elementOf(o,f,infiniteUnion{av (variable)}(s)))
\varcond(\notFreeIn(av (variable), f (Field term)), \notFreeIn(av (variable), o (java.lang.Object term)))
\replacewith(exists{av (variable)}(elementOf(o,f,s))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="setMinusOfUnion">setMinusOfUnion {
\find(setMinus(union(s,s2),s3))
\replacewith(union(setMinus(s,s3),setMinus(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="createdInHeapWithSingletonEQ">createdInHeapWithSingletonEQ {
\assumes ([equals(singleton(o,f),EQ)]==&gt;[]) 
\find(createdInHeap(EQ,h))
\sameUpdateLevel\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="ifSplitLeft">ifSplitLeft {
\find(#allmodal ( (modal operator))\[{ .. if (#se)
    #s0
 ... }\] (post)==&gt;)
\add [equals(#se,FALSE)]==&gt;[] \replacewith([#allmodal(post)]==&gt;[]) ;
\add [equals(#se,TRUE)]==&gt;[] \replacewith([#allmodal ( (modal operator))\[{ .. #s0 ... }\] (post)]==&gt;[]) 
\heuristics(split_if)
Choices: {programRules:Java}}</entry>
<entry key="equality">compound_equality_comparison_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e==#nse0; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse0) #v1 = #nse0;#lhs=#v0==#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="reachNull2">reachNull2 {
\find(reach(h,s,null,o2,n))
\replacewith(false) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="readPermissionAfterTransferRead">readPermissionAfterTransferRead {
\assumes ([readPermissionObject(o1,p)]==&gt;[]) 
\find(readPermissionObject(o2,transferPermission(split,o1,o2,Z(0(#)),p)))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="seqGetAlphaCast">seqGetAlphaCast {
\find(alpha::seqGet(seq,at))
\add [equals(alpha::cast(any::seqGet(seq,at)),alpha::seqGet(seq,at))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {sequences:on}}</entry>
<entry key="replace_int_MIN">replace_int_MIN {
\find(int_MIN)
\replacewith(Z(neglit(8(4(6(3(8(4(7(4(1(2(#))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="insert_eqv_once_rl">insert_eqv_once_rl {
\find(equiv(br,cr)==&gt;)
\addrules [insert_eqv {
\find(cr)
\replacewith(br) 

Choices: {}}] 

Choices: {}}</entry>
<entry key="disjointInfiniteUnion">disjointInfiniteUnion {
\find(equals(intersect(infiniteUnion{iv (variable)}(s2),s),empty))
\varcond(\notFreeIn(iv (variable), s (LocSet term)))
\replacewith(all{iv (variable)}(equals(intersect(s2,s),empty))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="regExConcatAltLeft">regExConcatAltLeft {
\find(match(regExConcat(alt(rexp1,rexp2),rexp3),string))
\replacewith(or(match(regExConcat(rexp1,rexp3),string),match(regExConcat(rexp2,rexp3),string))) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="wd_LocSet_Pred_Subset">wd_LocSet_Pred_Subset {
\find(WD(subset(l,s)))
\replacewith(and(wd(l),wd(s))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="seqPermEmpty">seqPermEmpty2 {
\find(seqPerm(s,seqEmpty))
\replacewith(equals(seqEmpty,s)) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="switch_params">switch_params {
\find(add(i0,i1))
\replacewith(add(i1,i0)) 

Choices: {}}</entry>
<entry key="splitEquation">splitEquation {
\find(equals(splitEqLeft,splitEqRight))
\replacewith(and(geq(splitEqLeft,splitEqRight),leq(splitEqLeft,splitEqRight))) 

Choices: {}}</entry>
<entry key="seqOutsideValue">seqOutsideValue {
\find(seqGetOutside)
\add [all{s (variable)}(all{iv (variable)}(imp(or(lt(iv,Z(0(#))),leq(seqLen(s),iv)),equals(any::seqGet(s,iv),seqGetOutside))))]==&gt;[] 

Choices: {sequences:on}}</entry>
<entry key="equal_bprod_perm">equal_bprod_perm2 {
\assumes ([equals(bprod{uSub2 (variable)}(i2,i3,t2),t)]==&gt;[]) 
\find(==&gt;equals(bprod{uSub1 (variable)}(i0,i1,t1),t))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==&gt;[seqPerm(seqDef{uSub1 (variable)}(i0,i1,t1),seqDef{uSub2 (variable)}(i2,i3,t2))] 

Choices: {sequences:on,integerSimplificationRules:full}}</entry>
<entry key="wellFormedStoreObjectEQ">wellFormedStoreObjectEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==&gt;[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\replacewith(or(and(wellFormed(h),equals(x,null)),equals(boolean::select(h,x,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="less_neg">less_neg {
\find(lt(i,i0))
\replacewith(not(lt(i0,add(i,Z(1(#)))))) 

Choices: {}}</entry>
<entry key="methodBodyExpand">methodBodyExpand {
\find(#allmodal ( (modal operator))\[{ .. #mb ... }\] (post))
\replacewith(#introAtPreDefs(#allmodal ( (modal operator))\[{ .. expand-method-body(#mb) ... }\] (post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="associativeLawUnion">associativeLawUnion {
\find(union(s1,union(s2,s3)))
\replacewith(union(union(s1,s2),s3)) 
\heuristics(conjNormalForm)
Choices: {programRules:Java}}</entry>
<entry key="nnf_notAnd">nnf_notAnd {
\find(not(and(phi,psi)))
\replacewith(or(not(phi),not(psi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: {}}</entry>
<entry key="allocateInstance">allocateInstance {
\find(==&gt;#allmodal ( (modal operator))\[{ .. 
  #lhs=#t.#allocate()@#t; ... }\] (post))
\varcond(\hasSort(#t2 (program Type), alphaObj), )
\add [and(and(not(equals(#lhs,null)),imp(wellFormed(heap),equals(boolean::select(heap,#lhs,java.lang.Object::&lt;created&gt;),FALSE))),equals(alphaObj::exactInstance(#lhs),TRUE))]==&gt;[] \replacewith([]==&gt;[update-application(elem-update(heap)(create(heap,#lhs)),#allmodal(post))]) 
\heuristics(method_expand)
Choices: {permissions:off,programRules:Java}}</entry>
<entry key="replace_char_MAX">replace_char_MAX {
\find(char_MAX)
\replacewith(Z(5(3(5(5(6(#))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="allLeft">allLeft {
\find(all{u (variable)}(b)==&gt;)
\add [subst{u (variable)}(t,b)]==&gt;[] 
\heuristics(gamma)
Choices: {}}</entry>
<entry key="wd_LocSet_Diff">wd_LocSet_Diff {
\find(wd(setMinus(l,s)))
\replacewith(and(wd(l),wd(s))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wellFormedAnon">wellFormedAnon {
\find(wellFormed(anon(h,s,h2)))
\succedentPolarity\replacewith(and(wellFormed(h),wellFormed(h2))) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wd_T_Subst_Formula">wd_T_Subst_Formula {
\find(T(subst{v (variable)}(u,f)))
\replacewith(and(wd(u),subst{v (variable)}(u,T(f)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="leq_literals">leq_literals {
\find(leq(Z(iz),Z(jz)))
\replacewith(#leq(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="elementOfIntersectEQ">elementOfIntersectEQ {
\assumes ([equals(intersect(s,s2),EQ)]==&gt;[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\replacewith(and(elementOf(o,f,s),elementOf(o,f,s2))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="le1_add1_eq_le">le1_add1_eq_le {
\find(lt(i0,add(i1,Z(1(#)))))
\replacewith(leq(i0,i1)) 

Choices: {}}</entry>
<entry key="intersectAllFieldsFreshLocs">intersectAllFieldsFreshLocs {
\find(equals(intersect(allFields(o),freshLocs(h)),empty))
\replacewith(or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="containsAxiomSucc">containsAxiomSucc {
\find(==&gt;clContains(textString,searchString))
\varcond(\notFreeIn(iv (variable), textString (Seq term)), \notFreeIn(iv (variable), searchString (Seq term)))
\replacewith([]==&gt;[exists{iv (variable)}(and(and(geq(iv,Z(0(#))),leq(add(iv,seqLen(searchString)),seqLen(textString))),equals(seqSub(textString,iv,add(iv,seqLen(searchString))),searchString)))]) 
\heuristics(stringsExpandDefNormalOp)
Choices: {Strings:on}}</entry>
<entry key="ifExthenelse1_solve">ifExthenelse1_solve_for {
\find(ifExThenElse{intVar (variable)}(phi,b,c))
\sameUpdateLevel\varcond(\notFreeIn(intVar (variable), intValue (int term)))
\add []==&gt;[and(subst{intVar (variable)}(intValue,phi),all{intVar (variable)}(imp(phi,wellOrderLeqInt(intValue,intVar))))] \replacewith(ifExThenElse{intVar (variable)}(phi,b,c)) ;
\replacewith(subst{intVar (variable)}(intValue,b)) 

Choices: {}}</entry>
<entry key="bsum_zero_right">bsum_zero_right {
\find(==&gt;equals(bsum{uSub (variable)}(i0,i2,t),Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add []==&gt;[all{uSub (variable)}(subst{uSub (variable)}(uSub,imp(and(geq(uSub,i0),lt(uSub,i2)),equals(t,Z(0(#))))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="selectCreatedOfAnon">selectCreatedOfAnon {
\find(boolean::select(anon(h,s,h2),o,java.lang.Object::&lt;created&gt;))
\replacewith(if-then-else(equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE),TRUE,boolean::select(h2,o,java.lang.Object::&lt;created&gt;))) 
\heuristics(simplify_heap_high_costs)
Choices: {programRules:Java}}</entry>
<entry key="add_eq_back">add_eq_back_3 {
\find(equals(i1,add(i1,i0)))
\replacewith(equals(Z(0(#)),i0)) 

Choices: {}}</entry>
<entry key="inequality comparison">inequality_comparison_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#se0!=#se1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#se0,#se1),FALSE,TRUE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="bsum_induction_lower2_concrete">bsum_induction_lower2_concrete {
\find(bsum{uSub (variable)}(add(Z(1(#)),i0),i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(sub(bsum{uSub (variable)}(i0,i2,t),if-then-else(lt(i0,i2),subst{uSub (variable)}(i0,t),Z(0(#))))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="elementOfGuardedSet">elementOfGuardedSet {
\find(elementOf(o,f,if-then-else(phi,s,empty)))
\replacewith(and(phi,elementOf(o,f,s))) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="unaryMinus">unaryMinusBigint {
\find(#allmodal ( (modal operator))\[{ .. #loc=-#seBigint; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(neg(#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: {bigint:on,programRules:Java}}</entry>
<entry key="add_equations_right">add_equations_right {
\assumes ([equals(i,i0)]==&gt;[]) 
\find(==&gt;equals(j,j0))
\add []==&gt;[equals(add(i,j),add(i0,j0))] 

Choices: {}}</entry>
<entry key="elimGcdGeq_antec">elimGcdGeq_antec {
\find(geq(elimGcdLeft,elimGcdRight)==&gt;)
\replacewith([or(or(leq(elimGcd,Z(0(#))),leq(add(add(add(add(elimGcd,mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#)))),geq(elimGcdLeftDiv,elimGcdRightDiv))]==&gt;[]) 
\heuristics(notHumanReadable, inEqSimp_pullOutGcd_antec, inEqSimp_pullOutGcd_geq, inEqSimp_pullOutGcd)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="preincrement_assignment">preincrement_assignment {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=++#lhs1; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs1=(#typeof(#lhs1))(#lhs1+1);#lhs0=#lhs1; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="regExConcatConcreteStringLeft">regExConcatConcreteStringLeft {
\find(match(regExConcat(regEx(pattern),rexp),string))
\replacewith(and(and(leq(seqLen(pattern),seqLen(string)),match(regEx(pattern),seqSub(string,Z(0(#)),seqLen(pattern)))),match(rexp,seqSub(string,seqLen(pattern),seqLen(string))))) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="wd_Logical_Op_And">wd_Logical_Op_And {
\find(WD(and(a,b)))
\replacewith(or(or(and(WD(a),not(a)),and(WD(b),not(b))),and(WD(a),WD(b)))) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="nnf_notAll">nnf_notAll {
\find(not(all{u (variable)}(phi)))
\replacewith(exists{u (variable)}(not(phi))) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: {}}</entry>
<entry key="reach_does_not_depend_on_fresh_locs_EQ">reach_does_not_depend_on_fresh_locs_EQ {
\assumes ([equals(anon(h,empty,h2),EQ)]==&gt;[equals(o,null)]) 
\find(reach(EQ,s,o,o2,n))
\add []==&gt;[and(wellFormed(h),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))] ;
\replacewith(reach(h,s,o,o2,n)) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="qeq_literals">qeq_literals {
\find(geq(Z(iz),Z(jz)))
\replacewith(#geq(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="greater_add">greater_add {
\find(==&gt;gt(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==&gt;[exists{j2 (variable)}(gt(add(i0,j2),add(i1,j2)))]) 

Choices: {}}</entry>
<entry key="replaceSingleton">replaceSingleton {
\find(clReplace(seqSingleton(fstChar),searchChar,replChar))
\replacewith(if-then-else(equals(searchChar,fstChar),seqSingleton(replChar),seqSingleton(fstChar))) 
\heuristics(stringsSimplify)
Choices: {Strings:on}}</entry>
<entry key="active_attribute_access">assignment_write_static_attribute_with_variable_prefix {
\find(#allmodal ( (modal operator))\[{ .. @(#v.#sv)=#se; ... }\] (post))
\add []==&gt;[writePermission(Permission::select(permissions,#v,#memberPVToField(#sv)))] \replacewith(#allmodal ( (modal operator))\[{ .. assert false : "Access permission check-point (static write)."; ... }\] (post)) ;
\replacewith(update-application(elem-update(heap)(store(heap,#v,#memberPVToField(#sv),#se)),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="elimGcdEq">elimGcdEq {
\find(equals(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(and(equals(mul(elimGcdLeftDiv,elimGcd),elimGcdLeft),leq(add(elimGcdRight,mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),add(Z(neglit(1(#))),elimGcd))),geq(add(elimGcdRight,mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),Z(0(#)))),and(equals(add(elimGcdRight,mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),Z(0(#))),equals(elimGcdLeftDiv,elimGcdRightDiv)),equals(elimGcdLeft,elimGcdRight))) 
\heuristics(notHumanReadable, polySimp_pullOutGcd)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="equal_bsum_zero_cut">equal_bsum_zero_cut {
\find(==&gt;equals(bsum{uSub1 (variable)}(i0,i1,t1),mul(bsum{uSub2 (variable)}(i2,i3,t2),t)))
\add [equals(bsum{uSub1 (variable)}(i0,i1,t1),Z(0(#)))]==&gt;[] ;
\add []==&gt;[equals(bsum{uSub1 (variable)}(i0,i1,t1),Z(0(#)))] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="compound_assignment_op_mod">compound_assignment_op_mod {
\find(#allmodal ( (modal operator))\[{ .. #v%=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v%(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="postincrement_attribute">postincrement_attribute {
\find(#allmodal ( (modal operator))\[{ .. #e.#attribute++; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#v.#attribute=(#typeof(#attribute))(#v.#attribute+1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="nnf_imp2or">nnf_imp2or {
\find(imp(phi,psi))
\replacewith(or(not(phi),psi)) 
\heuristics(notHumanReadable, negationNormalForm)
Choices: {}}</entry>
<entry key="throwBox">throwBox {
\find(#box ( (modal operator))\[{throw #se;#slist}\] (post))
\replacewith(true) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Heap_Store">wd_Heap_Store {
\find(wd(store(h,o,f,a)))
\replacewith(and(and(and(and(and(and(wd(h),wd(o)),wd(f)),wd(a)),wellFormed(h)),not(equals(o,null))),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="elim_forall_nonSingleton5">elim_forall_nonSingleton5 {
\find(all{INTVar (variable)}(leq(intTerm,INTVar)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="inDomainOfMapForeach">inDomainOfMapForeach {
\find(inDomain(mapForeach{v (variable)}(b,y),x))
\replacewith(and(equals(subst{v (variable)}(alpha::cast(x),b),TRUE),equals(alpha::instance(x),TRUE))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="elim_forall_nonSingleton4">elim_forall_nonSingleton4 {
\find(all{INTVar (variable)}(geq(intTerm,INTVar)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="applyEq_or_int7">applyEq_or_int7 {
\find(or(or(b,not(equals(applyEqLeft,applyEqRight))),leq(applyEqLeft,applyEqOther)))
\replacewith(or(or(b,not(equals(applyEqLeft,applyEqRight))),leq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="elim_forall_nonSingleton3">elim_forall_nonSingleton3 {
\find(all{INTVar (variable)}(leq(INTVar,intTerm)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="applyEq_or_int6">applyEq_or_int6 {
\find(or(not(equals(applyEqLeft,applyEqRight)),leq(applyEqLeft,applyEqOther)))
\replacewith(or(not(equals(applyEqLeft,applyEqRight)),leq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="wd_Seq_Def">wd_Seq_Def {
\find(wd(seqDef{i (variable)}(m,n,t)))
\varcond(\notFreeIn(i (variable), n (int term)), \notFreeIn(i (variable), m (int term)))
\replacewith(and(and(and(wd(m),wd(n)),leq(m,n)),all{i (variable)}(imp(and(leq(m,i),lt(i,n)),wd(t))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="elim_forall_nonSingleton2">elim_forall_nonSingleton2 {
\find(all{INTVar (variable)}(geq(INTVar,intTerm)))
\varcond(\notFreeIn(INTVar (variable), intTerm (int term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="applyEq_or_int5">applyEq_or_int5 {
\find(or(or(b,not(equals(applyEqLeft,applyEqRight))),geq(applyEqLeft,applyEqOther)))
\replacewith(or(or(b,not(equals(applyEqLeft,applyEqRight))),geq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="elim_forall_nonSingleton1">elim_forall_nonSingleton1 {
\find(all{nonSingleVar (variable)}(equals(Hterm,nonSingleVar)))
\varcond(\notFreeIn(nonSingleVar (variable), Hterm (H term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="applyEq_or_int4">applyEq_or_int4 {
\find(or(not(equals(applyEqLeft,applyEqRight)),geq(applyEqLeft,applyEqOther)))
\replacewith(or(not(equals(applyEqLeft,applyEqRight)),geq(applyEqRight,applyEqOther))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="elim_forall_nonSingleton0">elim_forall_nonSingleton0 {
\find(all{nonSingleVar (variable)}(equals(nonSingleVar,Hterm)))
\varcond(\notFreeIn(nonSingleVar (variable), Hterm (H term)))
\replacewith(false) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="applyEq_or_int3">applyEq_or_int3 {
\find(or(or(b,leq(applyEqLeft,applyEqOther)),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(or(b,leq(applyEqRight,applyEqOther)),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_or_int2">applyEq_or_int2 {
\find(or(leq(applyEqLeft,applyEqOther),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(leq(applyEqRight,applyEqOther),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="seqDef_lower_equals_upper">seqDef_lower_equals_upper {
\find(seqDef{uSub (variable)}(idx,idx,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), idx (int term)))
\replacewith(seqEmpty) 
\heuristics(simplify)
Choices: {sequences:on}}</entry>
<entry key="applyEq_or_int1">applyEq_or_int1 {
\find(or(or(b,geq(applyEqLeft,applyEqOther)),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(or(b,geq(applyEqRight,applyEqOther)),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="postincrement">postincrement {
\find(#allmodal ( (modal operator))\[{ .. #lhs1++; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs1=(#typeof(#lhs1))(#lhs1+1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="applyEq_or_int0">applyEq_or_int0 {
\find(or(geq(applyEqLeft,applyEqOther),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(geq(applyEqRight,applyEqOther),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="moduloShortFixpointInline">moduloShortFixpointInline {
\find(moduloShort(t))
\replacewith(if-then-else(inShort(t),t,moduloShort(t))) 
\heuristics(defOps_expandModulo)
Choices: {intRules:javaSemantics}}</entry>
<entry key="xorJIntDef">xorJIntDef {
\find(xorJint(left,right))
\replacewith(moduloInt(binaryXOr(left,right))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="assignment_read_length_this">assignment_read_length_this {
\find(#allmodal ( (modal operator))\[{ .. #v0=#v.#length; ... }\] (post))
\sameUpdateLevel\varcond(\isThisReference (#v (program Variable)), )
\replacewith(update-application(elem-update(#v0 (program Variable))(length(#v)),#allmodal(post))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="seqGetUnfold">seqGetUnfoldRight {
\find(#allmodal ( (modal operator))\[{ .. #v=#seLeft[#nseRight]; ... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseRight) #vRightNew = #nseRight;#v=#seLeft[#vRightNew]; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_xor_attr">compound_assignment_op_xor_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute^=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute^#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="exact_instance_known_dynamic_type">exact_instance_known_dynamic_type {
\assumes ([equals(G::exactInstance(a),TRUE)]==&gt;[]) 
\find(H::exactInstance(a))
\sameUpdateLevel\varcond(\not\same(G, H), )
\replacewith(FALSE) 
\heuristics(evaluate_instanceof, simplify)
Choices: {}}</entry>
<entry key="applyOnPV">applyOnPV {
\find(update-application(elem-update(#pv (program Variable))(t),#pv))
\replacewith(t) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="replace_long_MIN">replace_long_MIN {
\find(long_MIN)
\replacewith(Z(neglit(8(0(8(5(7(7(4(5(8(6(3(0(2(7(3(3(2(2(9(#)))))))))))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="wellFormedMemsetLocSetEQ">wellFormedMemsetLocSetEQ {
\assumes ([equals(memset(h,s,x),EQ)]==&gt;[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\replacewith(and(wellFormed(h),createdInHeap(x,h))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="mapRemoveUnchanged">mapRemoveUnchanged {
\find(equals(m,mapRemove(m,key)))
\replacewith(not(inDomain(m,key))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="ex_unused">ex_unused {
\find(exists{u (variable)}(b))
\varcond(\notFreeIn(u (variable), b (formula)))
\replacewith(b) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="wd_Logical_Op_Neg">wd_Logical_Op_Neg {
\find(WD(not(a)))
\replacewith(WD(a)) 
\heuristics(simplify)
Choices: {wdOperator:D,wdChecks:on}}</entry>
<entry key="replace_byte_HALFRANGE">replace_byte_HALFRANGE {
\find(byte_HALFRANGE)
\replacewith(Z(8(2(1(#))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="replaceDef">replaceDef {
\find(clReplace(str,searchChar,replChar))
\sameUpdateLevel\varcond(\notFreeIn(pos (variable), replChar (int term)), \notFreeIn(pos (variable), searchChar (int term)), \notFreeIn(pos (variable), str (Seq term)))
\add [and(equals(clReplace(str,searchChar,replChar),newSym),equals(seqDef{pos (variable)}(Z(0(#)),seqLen(str),if-then-else(equals(int::seqGet(str,pos),searchChar),replChar,int::seqGet(str,pos))),newSym))]==&gt;[] 
\heuristics(stringsIntroduceNewSym, defOpsReplace)
Choices: {Strings:on}}</entry>
<entry key="insert_eq_all">insert_eq_all {
\find(equals(sr,tr)==&gt;)
\addrules [auto_insert_eq {
\find(sr)
\replacewith(tr) 
\heuristics(simplify)
Choices: {}}] \replacewith([]==&gt;[]) 

Choices: {}}</entry>
<entry key="returnPermissionOwner">returnPermissionOwner {
\find(returnPermissionOwner(o,consPermissionOwnerList(owner,ol)))
\add []==&gt;[checkPermissionOwner(o,Z(0(#)),consPermissionOwnerList(owner,ol))] ;
\replacewith(ol) 
\heuristics(simplify_expression)
Choices: {permissions:on}}</entry>
<entry key="wd_LocSet_AllFieldsArr">wd_LocSet_AllFieldsArr {
\find(wd(allFields(o)))
\varcond( \not \isArray(o (java.lang.Object term)), )
\replacewith(and(wd(o),not(equals(o,null)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="leq_to_gt">leq_to_gt {
\find(leq(i,j))
\replacewith(not(gt(i,j))) 

Choices: {}}</entry>
<entry key="compound_assignment_op_minus_attr">compound_assignment_op_minus_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute-=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute-#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="seqNPermEmpty">seqNPermEmpty {
\find(seqNPerm(seqEmpty))
\replacewith(true) 
\heuristics(concrete)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="insert_eqv_once_lr">insert_eqv_once_lr {
\find(equiv(br,cr)==&gt;)
\addrules [insert_eqv {
\find(br)
\replacewith(cr) 

Choices: {}}] 

Choices: {}}</entry>
<entry key="wd_T_Logical_Op_And">wd_T_Logical_Op_And {
\find(T(and(a,b)))
\replacewith(and(T(a),T(b))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="true_to_not_false">true_to_not_false {
\find(equals(bo,TRUE))
\replacewith(not(equals(bo,FALSE))) 

Choices: {}}</entry>
<entry key="writePermissionAfterFullTransfer">writePermissionAfterFullTransfer {
\assumes ([writePermissionObject(o1,p)]==&gt;[]) 
\find(writePermissionObject(o2,transferPermission(FALSE,o1,o2,Z(0(#)),p)))
\replacewith(true) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="bitwiseXOr">assignmentBitwiseXOrLong3 {
\find(#normalassign ( (modal operator))\[{ .. #loc=#seLong0^#seLong1; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(javaBitwiseXOrLong(#seLong0,#seLong1)),#normalassign(post))) 
\heuristics(executeIntegerAssignment)
Choices: {programRules:Java}}</entry>
<entry key="subSeqTail">subSeqTailEQL {
\assumes ([equals(seqLen(seq),EQ)]==&gt;[]) 
\find(seqSub(seqConcat(seqSingleton(x),seq),Z(1(#)),add(Z(1(#)),EQ)))
\sameUpdateLevel\replacewith(seq) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="sortsDisjointModuloNull">sortsDisjointModuloNull {
\find(equals(x,y))
\varcond(\strict\sub(Null, G), \strict\sub(Null, H), \disjointModuloNull(G, H), )
\replacewith(and(equals(x,null),equals(y,null))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="ifElseUnfold">ifElseUnfold {
\find(#allmodal ( (modal operator))\[{ .. if (#nse)
    #s0
  else 
    #s1
 ... }\] (post))
\varcond(\new(#boolv (program Variable), boolean))
\replacewith(#allmodal ( (modal operator))\[{ .. boolean #boolv;#boolv=#nse;if (#boolv)
    #s0
  else  {
    #s1
  }
 ... }\] (post)) 
\heuristics(simplify_autoname)
Choices: {programRules:Java}}</entry>
<entry key="subsetOfAllLocs">subsetWithAllLocs {
\find(subset(s,allLocs))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="disjointToElementOf">disjointToElementOf {
\find(disjoint(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(or(not(elementOf(ov,fv,s)),not(elementOf(ov,fv,s2)))))) 
\heuristics(semantics_blasting)
Choices: {programRules:Java}}</entry>
<entry key="postdecrement">postdecrement {
\find(#allmodal ( (modal operator))\[{ .. #lhs1--; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs1=(#typeof(#lhs1))#lhs1-1; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="mod_homoEq">mod_homoEq {
\find(equals(mod(modNumLeft,modDenom),mod(modNumRight,modDenom)))
\replacewith(equals(mod(sub(modNumLeft,modNumRight),modDenom),Z(0(#)))) 
\heuristics(notHumanReadable, defOps_modHomoEq)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="reachOne">reachOne {
\find(reach(h,s,o,o2,Z(1(#))))
\replacewith(acc(h,s,o,o2)) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="subsetWithSetMinusLeftEQ">subsetWithSetMinusLeftEQ {
\assumes ([equals(setMinus(s,s2),EQ)]==&gt;[]) 
\find(subset(EQ,s3))
\sameUpdateLevel\replacewith(subset(s,union(s2,s3))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="createdOnHeapImpliesCreatedOnPermissions">createdOnHeapImpliesCreatedOnPermissions {
\assumes ([wellFormed(h),wellFormed(p),permissionsFor(p,h),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE)]==&gt;[]) 
\find(boolean::select(p,o,java.lang.Object::&lt;created&gt;))
\sameUpdateLevel\replacewith(TRUE) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="subSeqEmpty">subSeqEmpty {
\find(seqSub(seq,i,i))
\replacewith(seqEmpty) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="seqDef_induction_lower_concrete">seqDef_induction_lower_concrete {
\find(seqDef{uSub (variable)}(add(Z(neglit(1(#))),from),to,t))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqConcat(if-then-else(lt(add(Z(neglit(1(#))),from),to),seqSingleton(subst{uSub (variable)}(add(Z(neglit(1(#))),from),t)),seqEmpty),seqDef{uSub (variable)}(from,to,t))) 
\heuristics(simplify)
Choices: {sequences:on}}</entry>
<entry key="substringSubstring2">substringSubstring2 {
\assumes ([equals(seqSub(str,innerStartIdx,innerEndIdx),innerSub)]==&gt;[]) 
\find(seqSub(innerSub,outerStartIdx,outerEndIdx))
\sameUpdateLevel\add [imp(and(and(and(and(and(geq(innerStartIdx,Z(0(#))),geq(innerEndIdx,innerStartIdx)),leq(innerEndIdx,seqLen(str))),geq(outerStartIdx,Z(0(#)))),geq(outerEndIdx,outerStartIdx)),leq(outerEndIdx,sub(innerEndIdx,innerStartIdx))),and(equals(seqSub(innerSub,outerStartIdx,outerEndIdx),newSym),equals(seqSub(str,add(outerStartIdx,innerStartIdx),add(innerStartIdx,outerEndIdx)),newSym)))]==&gt;[] 
\heuristics(stringsIntroduceNewSym, stringsReduceSubstring)
Choices: {Strings:on}}</entry>
<entry key="typeStatic">typeStatic {
\find(s)
\sameUpdateLevel\add [equals(G::instance(s),TRUE)]==&gt;[] 

Choices: {}}</entry>
<entry key="ifTrue">ifTrue {
\assumes ([equals(#se,TRUE)]==&gt;[]) 
\find(==&gt;#allmodal ( (modal operator))\[{ .. if (#se)
    #s0
 ... }\] (post))
\replacewith([]==&gt;[#allmodal ( (modal operator))\[{ .. #s0 ... }\] (post)]) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="expand_modJlong">expand_modJlong {
\find(modJlong(i,i1))
\replacewith(moduloLong(jmod(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="sub_literals">sub_literals {
\find(sub(Z(iz),Z(jz)))
\replacewith(#sub(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="polyMod_zero">polyMod_zero {
\find(mod(Z(0(#)),divDenom))
\replacewith(Z(0(#))) 
\heuristics(concrete, polyDivision)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_LocSet_Singleton_Static">wd_LocSet_Singleton_Static {
\find(wd(singleton(o,f)))
\varcond(\isArray(o (java.lang.Object term)), \isStaticField(f (Field term)), )
\replacewith(and(and(wd(o),wd(f)),equals(o,null))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="divide_geq">divide_geq {
\find(geq(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(and(geq(elimGcd,Z(1(#))),equals(mod(elimGcdLeft,elimGcd),Z(0(#)))),leq(mod(elimGcdRight,elimGcd),add(Z(neglit(1(#))),elimGcd))),geq(div(elimGcdLeft,elimGcd),add(Z(1(#)),div(add(Z(neglit(1(#))),elimGcdRight),elimGcd))),geq(elimGcdLeft,elimGcdRight))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="ifthenelse_concrete">ifthenelse_concrete4 {
\find(equals(if-then-else(phi,then,else),else))
\replacewith(or(not(phi),equals(then,else))) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="replace_int_MAX">replace_int_MAX {
\find(int_MAX)
\replacewith(Z(7(4(6(3(8(4(7(4(1(2(#)))))))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="containsAxiomAntec">containsAxiomAntec {
\find(clContains(textString,searchString)==&gt;)
\varcond(\notFreeIn(iv (variable), textString (Seq term)), \notFreeIn(iv (variable), searchString (Seq term)))
\replacewith([exists{iv (variable)}(and(and(geq(iv,Z(0(#))),leq(add(iv,seqLen(searchString)),seqLen(textString))),equals(seqSub(textString,iv,add(iv,seqLen(searchString))),searchString)))]==&gt;[]) 
\heuristics(stringsExpandDefNormalOp)
Choices: {Strings:on}}</entry>
<entry key="sizeOfMapSingleton">sizeOfMapSingleton {
\find(mapSize(mapSingleton(key,value)))
\sameUpdateLevel\replacewith(Z(1(#))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="split_or_strong">split_or_strong {
\find(or(b,c)==&gt;)
\replacewith([c]==&gt;[b]) ;
\replacewith([b]==&gt;[]) 

Choices: {}}</entry>
<entry key="allocateInstanceWithLength">allocateInstanceWithLength {
\find(==&gt;#allmodal ( (modal operator))\[{ .. 
  #lhs=#t.#allocate(#len)@#t; ... }\] (post))
\varcond(\hasSort(#t2 (program Type), alphaObj), )
\add [and(and(not(equals(#lhs,null)),imp(wellFormed(heap),and(equals(boolean::select(heap,#lhs,java.lang.Object::&lt;created&gt;),FALSE),equals(length(#lhs),#len)))),equals(alphaObj::exactInstance(#lhs),TRUE))]==&gt;[] \replacewith([]==&gt;[update-application(elem-update(heap)(store(store(create(heap,#lhs),#lhs,java.lang.Object::&lt;transient&gt;,Z(0(#))),#lhs,java.lang.Object::&lt;transactionConditionallyUpdated&gt;,FALSE)),#allmodal(post))]) 
\heuristics(method_expand)
Choices: {permissions:off,programRules:Java}}</entry>
<entry key="jmod_axiom">jmod_axiom {
\find(jmod(divNum,divDenom))
\replacewith(add(divNum,mul(mul(jdiv(divNum,divDenom),Z(neglit(1(#)))),divDenom))) 
\heuristics(notHumanReadable, defOps_mod)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_T_Logical_Op_Neg">wd_T_Logical_Op_Neg {
\find(T(not(a)))
\replacewith(F(a)) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="bprod_invert_index">bprod_invert_index {
\find(bprod{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bprod{uSub1 (variable)}(neg(i1),neg(i0),subst{uSub (variable)}(neg(uSub1),t))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="subSeqCompleteSeqDefEQ">subSeqCompleteSeqDefEQ {
\assumes ([equals(seqDef{i (variable)}(Z(0(#)),u,a),EQ)]==&gt;[]) 
\find(seqSub(EQ,Z(0(#)),u))
\replacewith(seqDef{i (variable)}(Z(0(#)),u,a)) 
\heuristics(concrete, no_self_application)
Choices: {sequences:on}}</entry>
<entry key="instAll">instAll {
\assumes ([all{u (variable)}(b)]==&gt;[]) 
\find(t)
\add [subst{u (variable)}(t,b)]==&gt;[] 

Choices: {}}</entry>
<entry key="seqPermConcatFW">seqPermConcatFW {
\assumes ([seqPerm(s1,t1)]==&gt;[]) 
\find(seqPerm(s2,t2)==&gt;)
\add [seqPerm(seqConcat(s1,s2),seqConcat(t1,t2))]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="onlyCreatedObjectsAreObserved">onlyCreatedObjectsAreObserved {
\find(obs)
\sameUpdateLevel\varcond(\isObserver (obs (deltaObject term), h (Heap term)), )
\add [or(equals(obs,null),equals(boolean::select(h,obs,java.lang.Object::&lt;created&gt;),TRUE))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {programRules:Java}}</entry>
<entry key="less_add">less_add {
\find(==&gt;lt(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==&gt;[exists{j2 (variable)}(lt(add(i0,j2),add(i1,j2)))]) 

Choices: {}}</entry>
<entry key="subsetToElementOfRight">subsetToElementOfRight {
\find(==&gt;subset(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith([]==&gt;[all{ov (variable)}(all{fv (variable)}(imp(elementOf(ov,fv,s),elementOf(ov,fv,s2))))]) 
\heuristics(setEqualityBlastingRight)
Choices: {programRules:Java}}</entry>
<entry key="initialized class is not erroneous">initialized_class_is_not_erroneous {
\assumes ([equals(boolean::select(heap,null,alphaObj::&lt;classInitialized&gt;),TRUE),wellFormed(heap)]==&gt;[]) 
\find(boolean::select(heap,null,alphaObj::&lt;classErroneous&gt;))
\sameUpdateLevel\replacewith(FALSE) 
\heuristics(simplify, confluence_restricted)
Choices: {programRules:Java}}</entry>
<entry key="getOfArray2seq">getOfArray2seq {
\find(alpha::seqGet(array2seq(h,a),idx))
\add []==&gt;[and(leq(Z(0(#)),idx),lt(idx,length(a)))] ;
\replacewith(alpha::select(h,a,arr(idx))) 

Choices: {sequences:on}}</entry>
<entry key="remove_parentheses">remove_parentheses_lhs_left {
\find(#allmodal ( (modal operator))\[{ .. (#lhs)=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs=#e; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="expand_mulJint">expand_mulJint {
\find(mulJint(i,i1))
\replacewith(moduloInt(mul(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="elementOfArrayRangeConcrete">elementOfArrayRangeConcrete {
\find(elementOf(o,arr(idx),arrayRange(o2,lower,upper)))
\replacewith(and(and(equals(o,o2),leq(lower,idx)),leq(idx,upper))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="replace_short_RANGE">replace_short_RANGE {
\find(short_RANGE)
\replacewith(Z(6(3(5(5(6(#))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="permissionTransferReturnIdentityEQ">permissionTransferReturnIdentityEQ {
\assumes ([equals(p2,transferPermission(FALSE,o1,o2,Z(0(#)),p1))]==&gt;[]) 
\find(returnPermission(o2,o1,p2))
\replacewith(p1) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="lastIndexOfStr">lastIndexOfStr {
\find(clLastIndexOfCl(sourceStr,i,searchStr))
\varcond(\notFreeIn(iv (variable), sourceStr (Seq term)), \notFreeIn(iv (variable), i (int term)), \notFreeIn(iv (variable), searchStr (Seq term)))
\replacewith(ifExThenElse{iv (variable)}(and(and(and(gt(iv,Z(0(#))),geq(sub(i,iv),Z(0(#)))),leq(sub(add(seqLen(searchStr),i),iv),seqLen(sourceStr))),equals(seqSub(sourceStr,sub(i,iv),sub(add(seqLen(searchStr),i),iv)),searchStr)),sub(i,iv),Z(neglit(1(#))))) 
\heuristics(stringsExpandDefNormalOp)
Choices: {Strings:on}}</entry>
<entry key="ghostDeclaration">variableDeclarationGhostAssign {
\find(#allmodal ( (modal operator))\[{ .. ghost#t #v0 = #vi; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. ghost#t #v0;#v0=#vi; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="compound_assignment_op_plus_array">compound_assignment_op_plus_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]+=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]+#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="stringConcatObjectLeft">stringConcatObjectLeft {
\find(#normalassign ( (modal operator))\[{ .. #v=#seLeft+#sstrRight; ... }\] (post))
\sameUpdateLevel\add [equals(#seLeft,null),equals(strContent(sk),seqConcat(strContent(null),strContent(#sstrRight)))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) ;
\add []==&gt;[equals(#seLeft,null)] \replacewith(#normalassign ( (modal operator))\[{ .. #v=#seLeft.toString()+#sstrRight; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="applyEq">applyEqRigid {
\assumes ([equals(sr,tr1)]==&gt;[]) 
\find(sr)
\replacewith(tr1) 
\heuristics(apply_equations)
Choices: {}}</entry>
<entry key="preincrement">preincrement {
\find(#allmodal ( (modal operator))\[{ .. ++#lhs1; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs1=(#typeof(#lhs1))(#lhs1+1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="times_one">times_one_2 {
\find(mul(Z(1(#)),i))
\replacewith(i) 

Choices: {}}</entry>
<entry key="bprod_induction_upper_concrete">bprod_induction_upper_concrete {
\find(bprod{uSub (variable)}(i0,add(Z(1(#)),i2),t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(mul(bprod{uSub (variable)}(i0,i2,t),if-then-else(leq(i0,i2),subst{uSub (variable)}(i2,t),Z(1(#))))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="postdecrement_assignment_array">postdecrement_assignment_array {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=#e[#e0]--; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#lhs0 (program LeftHandSide))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#e0) #v0 = #e0;#typeof(#lhs0) #v1 = #v[#v0];#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1);#lhs0=#v1; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="wd_Seq_Get">wd_Seq_Get {
\find(wd(alpha::seqGet(s,n)))
\replacewith(and(and(and(wd(s),wd(n)),leq(Z(0(#)),n)),lt(n,seqLen(s)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="mapUpdateUnchanged2">mapUpdateUnchanged2 {
\find(equals(mapUpdate(m,key,value),m))
\replacewith(and(inDomain(m,key),equals(mapGet(m,key),value))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="elementOfInfiniteUnion2VarsEQ">elementOfInfiniteUnion2VarsEQ {
\assumes ([equals(infiniteUnion{av (variable), bv (variable)}(s),EQ)]==&gt;[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\varcond(\notFreeIn(bv (variable), f (Field term)), \notFreeIn(bv (variable), o (java.lang.Object term)), \notFreeIn(av (variable), f (Field term)), \notFreeIn(av (variable), o (java.lang.Object term)))
\replacewith(exists{av (variable)}(exists{bv (variable)}(elementOf(o,f,s)))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="castAdd">castAdd2 {
\assumes ([equals(cs,gt)]==&gt;[]) 
\find(gt)
\sameUpdateLevel\varcond(\strict\sub(C, G), )
\replacewith(C::cast(gt)) 

Choices: {}}</entry>
<entry key="selectCreatedOfAnonEQ">selectCreatedOfAnonEQ {
\assumes ([equals(anon(h,s,h2),EQ)]==&gt;[]) 
\find(boolean::select(EQ,o,java.lang.Object::&lt;created&gt;))
\sameUpdateLevel\replacewith(if-then-else(equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE),TRUE,boolean::select(h2,o,java.lang.Object::&lt;created&gt;))) 
\heuristics(simplify_heap_high_costs)
Choices: {programRules:Java}}</entry>
<entry key="getOfSeqSingleton">getOfSeqSingletonEQ {
\assumes ([equals(seqSingleton(x),EQ)]==&gt;[]) 
\find(alpha::seqGet(EQ,idx))
\sameUpdateLevel\replacewith(if-then-else(equals(idx,Z(0(#))),alpha::cast(x),alpha::cast(seqGetOutside))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: {sequences:on}}</entry>
<entry key="narrowSelectType">narrowSelectType {
\assumes ([wellFormed(h)]==&gt;[]) 
\find(beta::select(h,o,f))
\varcond(\fieldType(f (Field term), alpha), \strict\sub(alpha, beta), )
\replacewith(alpha::select(h,o,f)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="wd_RegEx_Star">wd_RegEx_Star {
\find(wd(repeatStar(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="bsum_same_summand">bsum_same_summand {
\find(bsum{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub (variable), t (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(if-then-else(geq(i1,i0),mul(t,sub(i1,i0)),Z(0(#)))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="closeType">closeTypeSwitched {
\assumes ([equals(GSub::instance(t1),TRUE)]==&gt;[]) 
\find(==&gt;equals(G::instance(t1),TRUE))
\closegoal\heuristics(closure)
Choices: {}}</entry>
<entry key="polySimp_mulAssoc">polySimp_mulAssoc {
\find(mul(mulAssocMono0,mul(mulAssocMono1,mulAssocAtom)))
\replacewith(mul(mul(mulAssocMono0,mulAssocMono1),mulAssocAtom)) 
\heuristics(polySimp_mulAssoc, polySimp_expand)
Choices: {}}</entry>
<entry key="tryEmpty">tryFinallyEmpty {
\find(#allmodal ( (modal operator))\[{ .. try {}#csfinally {
    #slist2
  }
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..  {#slist2} ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="moduloShortIsInShort">moduloShortIsInShort {
\find(inShort(moduloShort(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="throwNull">throwNull {
\find(#allmodal ( (modal operator))\[{ .. throw null; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. throw new java.lang.NullPointerException (); ... }\] (post)) 

Choices: {programRules:Java}}</entry>
<entry key="insertPermissionOwner">insertPermissionOwner {
\find(insertPermissionOwner(o,no,depth,consPermissionOwnerList(owner,ol)))
\add []==&gt;[and(geq(depth,Z(0(#))),checkPermissionOwner(o,depth,consPermissionOwnerList(owner,ol)))] ;
\replacewith(if-then-else(equals(depth,Z(0(#))),consPermissionOwnerList(no,consPermissionOwnerList(owner,ol)),consPermissionOwnerList(owner,insertPermissionOwner(o,no,sub(depth,Z(1(#))),ol)))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="eqSeqConcat2EQ">eqSeqConcat2EQ {
\assumes ([equals(seqConcat(s,s2),EQ)]==&gt;[]) 
\find(equals(seqConcat(s,s1),EQ))
\replacewith(equals(s1,s2)) 
\heuristics(simplify, no_self_application)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="box_and_left">box_and_left {
\find(#box ( (modal operator))\[{ .. #s ... }\] (and(post,post1))==&gt;)
\replacewith([and(#box ( (modal operator))\[{ .. #s ... }\] (post),#box ( (modal operator))\[{ .. #s ... }\] (post1))]==&gt;[]) 

Choices: {programRules:Java}}</entry>
<entry key="replace_int_HALFRANGE">replace_int_HALFRANGE {
\find(int_HALFRANGE)
\replacewith(Z(8(4(6(3(8(4(7(4(1(2(#)))))))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="expand_divJint">expand_divJint {
\find(divJint(i,i1))
\replacewith(moduloInt(jdiv(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="lenOfSeqSub">lenOfSeqSubEQ {
\assumes ([equals(seqSub(seq,from,to),EQ)]==&gt;[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(if-then-else(lt(from,to),sub(to,from),Z(0(#)))) 
\heuristics(find_term_not_in_assumes, simplify)
Choices: {sequences:on}}</entry>
<entry key="less_literals">less_literals {
\find(lt(Z(iz),Z(jz)))
\replacewith(#less(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="elementOfFreshLocs">elementOfFreshLocs {
\find(elementOf(o,f,freshLocs(h)))
\replacewith(and(not(equals(o,null)),not(equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE)))) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="subtraction">assignmentSubtractionBigint2 {
\find(#allmodal ( (modal operator))\[{ .. #loc=#seAny-#seBigint; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(sub(#seAny,#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: {bigint:on,programRules:Java}}</entry>
<entry key="createdInHeapToElementOf">createdInHeapToElementOf {
\find(createdInHeap(s,h))
\varcond(\notFreeIn(fv (variable), h (Heap term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), h (Heap term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(imp(elementOf(ov,fv,s),or(equals(ov,null),equals(boolean::select(h,ov,java.lang.Object::&lt;created&gt;),TRUE)))))) 
\heuristics(classAxiom)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Op_And">wd_Numerical_Op_BitAndLong {
\find(wd(javaBitwiseAndLong(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="less-or-equal than distinction">less_equal_than_comparison_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#se0&lt;=#se1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(leq(#se0,#se1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="binaryOrInInt">binaryOrInInt {
\find(binaryOr(left,right))
\sameUpdateLevel\add [imp(and(inInt(left),inInt(right)),inInt(binaryOr(left,right)))]==&gt;[] 
\heuristics(userTaclets1)
Choices: {}}</entry>
<entry key="binary_XOR">compound_binary_XOR_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e^#nse; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse) #v1 = #nse;#lhs=#v0^#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_String_Pred_Contains">wd_String_Pred_Contains {
\find(WD(clContains(l,c)))
\replacewith(and(wd(c),wd(l))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="equal_bsum">equal_bsum5 {
\find(==&gt;equals(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i2,i3,t2)))
\varcond(\notFreeIn(uSub2 (variable), i3 (int term)), \notFreeIn(uSub1 (variable), i3 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==&gt;[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(sub(add(uSub1,i2),i0),t2))))] ;
\add []==&gt;[equals(sub(i1,i0),sub(i3,i2))] 
\heuristics(comprehensions_high_costs)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="elementOfAllLocs">elementOfAllLocs {
\find(elementOf(o,f,allLocs))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="diamond_or_right">diamond_or_right {
\find(==&gt;#diamond ( (modal operator))\[{ .. #s ... }\] (or(post,post1)))
\replacewith([]==&gt;[or(#diamond ( (modal operator))\[{ .. #s ... }\] (post),#diamond ( (modal operator))\[{ .. #s ... }\] (post1))]) 

Choices: {programRules:Java}}</entry>
<entry key="predecrement_array">predecrement_array {
\find(#allmodal ( (modal operator))\[{ .. --#e[#e0]; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#e0) #v0 = #e0;#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]-1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="delete_unnecessary_cast">delete_unnecessary_cast {
\find(#allmodal ( (modal operator))\[{ .. #lhs=(#npit)#se; ... }\] (post))
\sameUpdateLevel\varcond(\hasSort(#npit (program NonPrimitiveType), G), \sub(\typeof(#se (program SimpleExpression)), G), )
\add []==&gt;[or(equals(#se,null),equals(G::instance(#se),TRUE))] \replacewith(#allmodal ( (modal operator))\[{ .. throw new java.lang.ClassCastException (); ... }\] (post)) ;
\add [or(equals(#se,null),equals(G::instance(#se),TRUE))]==&gt;[] \replacewith(update-application(elem-update(#lhs (program LeftHandSide))(#addCast(#se,#lhs)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="subsetSingletonRight">subsetSingletonRight {
\find(subset(s,singleton(o,f)))
\replacewith(or(equals(s,empty),equals(s,singleton(o,f)))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="binaryOrNeutralRight">binaryOrNeutralRight {
\find(binaryOr(left,Z(0(#))))
\replacewith(left) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="multiply_distribute">mul_distribute_5 {
\find(mul(add(i1,i2),i0))
\replacewith(add(mul(i0,i1),mul(i0,i2))) 

Choices: {}}</entry>
<entry key="seqNPermSwapNPerm">seqNPermSwapNPerm {
\find(seqNPerm(s1)==&gt;)
\varcond(\notFreeIn(jv (variable), s1 (Seq term)), \notFreeIn(iv (variable), s1 (Seq term)))
\add [all{iv (variable)}(all{jv (variable)}(imp(and(and(and(leq(Z(0(#)),iv),leq(Z(0(#)),jv)),lt(iv,seqLen(s1))),lt(jv,seqLen(s1))),seqNPerm(seqSwap(s1,iv,jv)))))]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="instanceof_known_dynamic_type">instanceof_known_dynamic_type {
\assumes ([equals(G::exactInstance(a),TRUE)]==&gt;[]) 
\find(H::instance(a))
\sameUpdateLevel\varcond(\sub(G, H), )
\replacewith(TRUE) 
\heuristics(evaluate_instanceof, simplify)
Choices: {}}</entry>
<entry key="wd_LocSet_AllFields">wd_LocSet_AllFields {
\find(wd(allFields(o)))
\varcond(\isArray(o (java.lang.Object term)), )
\replacewith(wd(o)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="same_boxes_left">same_boxes_left {
\assumes ([\[{ .. #s ... }\] (post)]==&gt;[]) 
\find(\[{ .. #s ... }\] (post1)==&gt;)
\add [\[{ .. #s ... }\] (and(post,post1))]==&gt;[] 

Choices: {programRules:Java}}</entry>
<entry key="subsetOfIntersectWithItSelf2">subsetOfIntersectWithItSelf2 {
\find(subset(s,intersect(s2,s)))
\replacewith(subset(s,s2)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="subsetOfIntersectWithItSelf1">subsetOfIntersectWithItSelf1 {
\find(subset(s,intersect(s,s2)))
\replacewith(subset(s,s2)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="polySimp_addLiterals">polySimp_addLiterals {
\find(add(add(i,Z(iz)),Z(jz)))
\replacewith(add(i,#add(Z(iz),Z(jz)))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="subsetSingletonRightEQ">subsetSingletonRightEQ {
\assumes ([equals(singleton(o,f),EQ)]==&gt;[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(or(equals(s,empty),equals(s,singleton(o,f)))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="indexOfSeqSingleton">indexOfSeqSingleton {
\find(seqIndexOf(seqSingleton(x),x))
\sameUpdateLevel\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="wd_LocSet_AllElemsArrLocsets">wd_LocSet_AllElemsArrLocsets {
\find(wd(allElementsOfArrayLocsets(h,o,l)))
\varcond( \not \isArray(o (java.lang.Object term)), )
\replacewith(and(and(and(and(and(wd(h),wd(o)),wd(l)),wellFormed(h)),not(equals(o,null))),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="seqPermConcatBW">seqPermConcatBW {
\assumes ([seqPerm(s1,t1)]==&gt;[]) 
\find(==&gt;seqPerm(seqConcat(s1,s2),seqConcat(t1,t2)))
\replacewith([]==&gt;[seqPerm(s2,t2)]) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="replace_long_MAX">replace_long_MAX {
\find(long_MAX)
\replacewith(Z(7(0(8(5(7(7(4(5(8(6(3(0(2(7(3(3(2(2(9(#))))))))))))))))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="predecrement">predecrement {
\find(#allmodal ( (modal operator))\[{ .. --#lhs1; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs1=(#typeof(#lhs1))(#lhs1-1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="eqSeqSingleton">eqSeqSingleton {
\find(equals(s,seqSingleton(x)))
\replacewith(and(equals(seqLen(s),Z(1(#))),equals(any::seqGet(s,Z(0(#))),x))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="moduloCharIsInChar">moduloCharIsInChar {
\find(inChar(moduloChar(t)))
\replacewith(true) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="bprod_equal_zero_right">bprod_equal_zero_right {
\find(==&gt;equals(bprod{uSub (variable)}(i0,i2,t),Z(0(#))))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\add []==&gt;[exists{uSub (variable)}(subst{uSub (variable)}(uSub,and(and(geq(uSub,i0),lt(uSub,i2)),equals(t,Z(0(#))))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="getOfSeq2Map">getOfSeq2Map {
\find(mapGet(seq2map(s),x))
\sameUpdateLevel\replacewith(if-then-else(and(and(equals(int::instance(x),TRUE),leq(Z(0(#)),int::cast(x))),lt(int::cast(x),seqLen(s))),any::seqGet(s,int::cast(x)),mapUndef)) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="multiply_inEq1">multiply_inEq1 {
\find(geq(multLeft,multRight)==&gt;)
\add [if-then-else(geq(multFac,Z(0(#))),geq(mul(multLeft,multFac),mul(multRight,multFac)),leq(mul(multLeft,multFac),mul(multRight,multFac)))]==&gt;[] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_LocSet_Union">wd_LocSet_Union {
\find(wd(union(l,s)))
\replacewith(and(wd(l),wd(s))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="assignment_negation">compound_assignment_1_new {
\find(#allmodal ( (modal operator))\[{ .. #lhs=!#seBool; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#seBool,TRUE),FALSE,TRUE)),#allmodal(post))) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="multiply_inEq0">multiply_inEq0 {
\find(leq(multLeft,multRight)==&gt;)
\add [if-then-else(geq(multFac,Z(0(#))),leq(mul(multLeft,multFac),mul(multRight,multFac)),geq(mul(multLeft,multFac),mul(multRight,multFac)))]==&gt;[] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_Seq_Pred_Perm">wd_Seq_Pred_Perm {
\find(WD(seqPerm(s,q)))
\replacewith(and(wd(s),wd(q))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_Numerical_Op_Neg">wd_Numerical_Op_BitNeg {
\find(wd(javaBitwiseNegation(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="precOfSeq">precOfSeq {
\find(prec(s1,s2))
\varcond(\notFreeIn(jv (variable), s2 (Seq term)), \notFreeIn(jv (variable), s1 (Seq term)), \notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s1 (Seq term)))
\replacewith(or(exists{iv (variable)}(and(and(and(and(leq(Z(0(#)),iv),lt(iv,seqLen(s1))),lt(iv,seqLen(s2))),prec(any::seqGet(s1,iv),any::seqGet(s2,iv))),all{jv (variable)}(imp(and(leq(Z(0(#)),jv),lt(jv,iv)),equals(any::seqGet(s1,jv),any::seqGet(s2,jv)))))),and(lt(seqLen(s1),seqLen(s2)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s1))),equals(any::seqGet(s1,iv),any::seqGet(s2,iv))))))) 

Choices: {}}</entry>
<entry key="methodCallEmpty">methodCallEmptyNoreturnBox {
\find(\[{ .. method-frame(result-&gt;#v0, #ex): {}
 ... }\] (post))
\replacewith(box(post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="sub_sub_elim">sub_sub_elim {
\find(neg(neg(i)))
\replacewith(i) 

Choices: {}}</entry>
<entry key="leq_add_one">leq_add_one {
\find(leq(i0,i1))
\replacewith(leq(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: {}}</entry>
<entry key="expand_subJint">expand_subJint {
\find(subJint(i,i1))
\replacewith(moduloInt(sub(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="compound_assignment_op_mod_attr">compound_assignment_op_mod_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute%=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute%#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="seqLengthUnfold">seqLengthUnfold {
\find(#allmodal ( (modal operator))\[{ .. #v=#nse.length; ... }\] (post))
\varcond(\new(#vNew (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #vNew = #nse;#v=#vNew.length; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="eqSeqSingleton2">eqSeqSingleton2 {
\assumes ([equals(seqSingleton(x),s2)]==&gt;[]) 
\find(equals(s,s2))
\replacewith(and(equals(seqLen(s),Z(1(#))),equals(any::seqGet(s,Z(0(#))),x))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="commuteUnion">commuteUnion {
\find(union(commLeft,commRight))
\replacewith(union(commRight,commLeft)) 
\heuristics(cnf_setComm)
Choices: {programRules:Java}}</entry>
<entry key="wellFormedStorePrimitive">wellFormedStorePrimitive {
\find(wellFormed(store(h,o,f,x)))
\succedentPolarity\varcond(\fieldType(f (Field term), alpha), \not\sub(beta, java.lang.Object), \not\sub(beta, LocSet), \sub(beta, alpha), )
\replacewith(wellFormed(h)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="bsum_induction_upper_concrete_2">bsum_induction_upper_concrete_2 {
\find(bsum{uSub (variable)}(Z(iz),Z(jz),t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(add(bsum{uSub (variable)}(Z(iz),sub(Z(jz),Z(1(#))),t),if-then-else(leq(Z(iz),sub(Z(jz),Z(1(#)))),subst{uSub (variable)}(sub(Z(jz),Z(1(#))),t),Z(0(#))))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_Numerical_Quant_Prod">wd_Numerical_Quant_Prod {
\find(wd(prod{j (variable)}(f,c)))
\replacewith(and(all{j (variable)}(wd(f)),all{j (variable)}(imp(equals(f,TRUE),wd(c))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="ineffectiveCast">ineffectiveCast {
\assumes ([equals(H::instance(t),TRUE)]==&gt;[]) 
\find(H::cast(t))
\sameUpdateLevel\add [equals(H::cast(t),t)]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {}}</entry>
<entry key="pullOut">pullOut {
\find(t)
\sameUpdateLevel\add [equals(t,sk)]==&gt;[] \replacewith(sk) 
\heuristics(semantics_blasting)
Choices: {}}</entry>
<entry key="unsignedShiftRightJintDef">unsignedShiftRightJintDef {
\find(unsignedshiftrightJint(left,right))
\replacewith(if-then-else(geq(left,Z(0(#))),shiftrightJint(left,right),addJint(shiftrightJint(left,right),shiftleftJint(Z(2(#)),sub(Z(1(3(#))),mod(right,Z(2(3(#))))))))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="distr_existsAnd2">distr_existsAnd2 {
\find(exists{u (variable)}(and(phi,psi)))
\varcond(\notFreeIn(u (variable), phi (formula)))
\replacewith(and(phi,exists{u (variable)}(psi))) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: {}}</entry>
<entry key="distr_existsAnd1">distr_existsAnd1 {
\find(exists{u (variable)}(and(phi,psi)))
\varcond(\notFreeIn(u (variable), psi (formula)))
\replacewith(and(exists{u (variable)}(phi),psi)) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: {}}</entry>
<entry key="createdInHeapWithSelectEQ">createdInHeapWithSelectEQ {
\assumes ([equals(LocSet::select(h,o,f),EQ)]==&gt;[]) 
\find(==&gt;createdInHeap(EQ,h))
\replacewith([]==&gt;[wellFormed(h)]) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="castDel">castDel2 {
\assumes ([equals(cs,gt)]==&gt;[]) 
\find(C::cast(gt))
\sameUpdateLevel\replacewith(cs) 

Choices: {}}</entry>
<entry key="ifthenelse_to_or_for2">ifthenelse_to_or_for2 {
\find(not(if-then-else(phi,b,c)))
\replacewith(and(or(not(phi),not(b)),or(phi,not(c)))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: {}}</entry>
<entry key="replace_short_HALFRANGE">replace_short_HALFRANGE {
\find(short_HALFRANGE)
\replacewith(Z(8(6(7(2(3(#))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="autoInduct_Lemma">autoInduct_Lemma {
\find(==&gt;and(all{uSub (variable)}(b),phi))
\replacewith([all{uSub (variable)}(b)]==&gt;[phi]) ;
\replacewith([]==&gt;[imp(and(leq(sk,Z(0(#))),subst{uSub (variable)}(sk,b)),subst{uSub (variable)}(sub(sk,Z(1(#))),b))]) ;
\replacewith([]==&gt;[imp(and(geq(sk,Z(0(#))),subst{uSub (variable)}(sk,b)),subst{uSub (variable)}(add(sk,Z(1(#))),b))]) ;
\replacewith([]==&gt;[subst{uSub (variable)}(Z(0(#)),b)]) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="inDomainOfMapEmpty">inDomainOfMapEmpty {
\find(inDomain(mapEmpty,x))
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="equiv_right">equiv_right {
\find(==&gt;equiv(b,c))
\replacewith([c]==&gt;[b]) ;
\replacewith([b]==&gt;[c]) 
\heuristics(beta)
Choices: {}}</entry>
<entry key="insert_constant_string_value">insert_constant_string_value {
\assumes ([wellFormed(heap)]==&gt;[]) 
\find(#csv)
\sameUpdateLevel\replacewith(if-then-else(equals(#constantvalue(#csv),null),null,strPool(Seq::cast(#constantvalue(#csv))))) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="sum_empty">sum_empty {
\find(sum{x (variable)}(FALSE,t))
\replacewith(Z(0(#))) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="close">closeAntec {
\assumes ([]==&gt;[b]) 
\find(b==&gt;)
\closegoal
Choices: {}}</entry>
<entry key="compound_assignment_op_plus_attr">compound_assignment_op_plus_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute+=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute+#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="compound_binary_neg">compound_binary_neg {
\find(#allmodal ( (modal operator))\[{ .. #lhs=~#nse; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #v0 = #nse;#lhs=~#v0; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="sizeOfMapUpdate">sizeOfMapUpdate {
\find(mapSize(mapUpdate(m,key,value)))
\add [imp(isFinite(m),equals(mapSize(mapUpdate(m,key,value)),if-then-else(inDomain(m,key),mapSize(m),add(mapSize(m),Z(1(#))))))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {}}</entry>
<entry key="getOfSwap">getOfSwap {
\find(alpha::seqGet(seqSwap(s1,iv,jv),idx))
\replacewith(if-then-else(not(and(and(and(leq(Z(0(#)),iv),leq(Z(0(#)),jv)),lt(iv,seqLen(s1))),lt(jv,seqLen(s1)))),alpha::seqGet(s1,idx),if-then-else(equals(idx,iv),alpha::seqGet(s1,jv),if-then-else(equals(idx,jv),alpha::seqGet(s1,iv),alpha::seqGet(s1,idx))))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="elementOfInfiniteUnionEQ">elementOfInfiniteUnionEQ {
\assumes ([equals(infiniteUnion{av (variable)}(s),EQ)]==&gt;[]) 
\find(elementOf(o,f,EQ))
\sameUpdateLevel\varcond(\notFreeIn(av (variable), f (Field term)), \notFreeIn(av (variable), o (java.lang.Object term)))
\replacewith(exists{av (variable)}(elementOf(o,f,s))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="eqSeqConcat5EQ">eqSeqConcat5EQ {
\assumes ([equals(seqConcat(seqSingleton(x),s2),EQ)]==&gt;[]) 
\find(equals(seqConcat(seqSingleton(y),s1),EQ))
\replacewith(and(equals(x,y),equals(s1,s2))) 
\heuristics(simplify, no_self_application)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="castedGetAny">castedGetAny {
\find(beta::cast(any::seqGet(seq,idx)))
\replacewith(beta::seqGet(seq,idx)) 
\heuristics(simplify)
Choices: {sequences:on}}</entry>
<entry key="sub">sub {
\find(sub(i,i0))
\replacewith(add(i,neg(i0))) 

Choices: {}}</entry>
<entry key="less_trans">less_trans {
\assumes ([lt(i,i0)]==&gt;[]) 
\find(lt(i0,i1)==&gt;)
\add [lt(i,i1)]==&gt;[] 

Choices: {}}</entry>
<entry key="newSym_eq">newSym_eq {
\find(equals(mul(newSymLeft,newSymLeftCoeff),newSymRight)==&gt;)
\add [equals(newSymLeft,add(l,newSymDef))]==&gt;[] 
\heuristics(polySimp_newSmallSym, polySimp_newSym, polySimp_leftNonUnit)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="nonNull">nonNull {
\find(nonNull(heapSV,o,depth))
\varcond(\notFreeIn(i (variable), depth (int term)), \notFreeIn(i (variable), heapSV (Heap term)), \notFreeIn(i (variable), o (java.lang.Object term)), \isReferenceArray(o (java.lang.Object term)), )
\replacewith(and(not(equals(o,null)),imp(gt(depth,Z(0(#))),all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,length(o))),nonNull(heapSV,java.lang.Object::select(heapSV,o,arr(i)),sub(depth,Z(1(#))))))))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="indexOfSeqConcatFirst">indexOfSeqConcatFirst {
\find(seqIndexOf(seqConcat(s1,s2),x))
\sameUpdateLevel\varcond(\notFreeIn(idx (variable), x (any term)), \notFreeIn(idx (variable), s2 (Seq term)), \notFreeIn(idx (variable), s1 (Seq term)))
\add []==&gt;[exists{idx (variable)}(and(and(leq(Z(0(#)),idx),lt(idx,seqLen(s1))),equals(any::seqGet(s1,idx),x)))] ;
\replacewith(seqIndexOf(s1,x)) 

Choices: {sequences:on}}</entry>
<entry key="cut">cut {
\add []==&gt;[cutFormula] ;
\add [cutFormula]==&gt;[] 
\heuristics(cut)
Choices: {}}</entry>
<entry key="sub_equations_right">sub_equations_right {
\assumes ([equals(i,i0)]==&gt;[]) 
\find(==&gt;equals(j,j0))
\add []==&gt;[equals(sub(j,i),sub(j0,i0))] 

Choices: {}}</entry>
<entry key="precOfInt">precOfInt {
\find(prec(a,b))
\replacewith(and(leq(Z(0(#)),a),lt(a,b))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="subst_to_eq">subst_to_eq_for {
\find(subst{u (variable)}(t,phi))
\sameUpdateLevel\add [equals(sk,t)]==&gt;[] \replacewith(subst{u (variable)}(sk,phi)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="wd_T_Resolve">wd_T_Resolve {
\find(T(a))
\varcond(\not\hasSubFormulas (a (formula)), )
\replacewith(and(WD(a),a)) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="ifthenelse_to_or_left">ifthenelse_to_or_left {
\find(equals(if-then-else(phi,then,else),t))
\replacewith(and(or(not(phi),equals(then,t)),or(phi,equals(else,t)))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: {}}</entry>
<entry key="pos_mult_eq_1_iff">pos_mult_eq_1_iff {
\find(imp(lt(Z(0(#)),i0),equals(mul(i0,i1),Z(1(#)))))
\replacewith(and(equals(i0,Z(1(#))),equals(i1,Z(1(#))))) 

Choices: {}}</entry>
<entry key="inShort">inShort {
\find(inShort(i))
\replacewith(true) 
\heuristics(concrete)
Choices: {intRules:arithmeticSemanticsIgnoringOF,programRules:Java}}</entry>
<entry key="leq_iff_diff_leq_0">leq_iff_diff_leq_0 {
\find(leq(i0,i1))
\replacewith(leq(sub(i0,i1),Z(0(#)))) 

Choices: {}}</entry>
<entry key="multiplication">assignmentMultiplicationBigint2 {
\find(#allmodal ( (modal operator))\[{ .. #loc=#seAny*#seBigint; ... }\] (post))
\replacewith(update-application(elem-update(#loc (program Variable))(mul(#seAny,#seBigint)),#allmodal(post))) 
\heuristics(executeIntegerAssignment)
Choices: {bigint:on,programRules:Java}}</entry>
<entry key="createdInHeapWithUnion">createdInHeapWithUnion {
\find(==&gt;createdInHeap(union(s,s2),h))
\replacewith([]==&gt;[createdInHeap(s2,h)]) ;
\replacewith([]==&gt;[createdInHeap(s,h)]) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="isFiniteOfMapSingleton">isFiniteOfMapSingleton {
\find(isFinite(mapSingleton(key,value)))
\sameUpdateLevel\replacewith(true) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="elimGcdGeq">elimGcdGeq {
\find(geq(elimGcdLeft,elimGcdRight))
\replacewith(if-then-else(and(geq(add(add(add(add(sub(elimGcd,Z(1(#))),mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#))),leq(add(add(add(mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#)))),geq(elimGcdLeftDiv,elimGcdRightDiv),geq(elimGcdLeft,elimGcdRight))) 
\heuristics(notHumanReadable, inEqSimp_pullOutGcd_geq, inEqSimp_pullOutGcd)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="reachDoesNotDependOnCreatedness">reachDoesNotDependOnCreatedness {
\find(reach(create(h,o3),s,o,o2,n))
\replacewith(reach(h,s,o,o2,n)) 
\heuristics(simplify)
Choices: {reach:on}}</entry>
<entry key="ifExthenelse1_eq">ifExthenelse1_eq2_for_phi {
\find(ifExThenElse{intVar (variable)}(and(phi,equals(t,intVar)),b,c))
\varcond(\notFreeIn(intVar (variable), t (int term)))
\replacewith(if-then-else(subst{intVar (variable)}(t,phi),subst{intVar (variable)}(t,b),c)) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="wd_F_Logical_Op_Eqv">wd_F_Logical_Op_Eqv {
\find(F(equiv(a,b)))
\replacewith(or(and(T(a),F(b)),and(F(a),T(b)))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="subsetToElementOf">subsetToElementOf {
\find(subset(s,s2))
\varcond(\notFreeIn(fv (variable), s2 (LocSet term)), \notFreeIn(fv (variable), s (LocSet term)), \notFreeIn(ov (variable), s2 (LocSet term)), \notFreeIn(ov (variable), s (LocSet term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(imp(elementOf(ov,fv,s),elementOf(ov,fv,s2))))) 
\heuristics(semantics_blasting)
Choices: {programRules:Java}}</entry>
<entry key="wd_Seq_Sub">wd_Seq_Sub {
\find(wd(seqSub(s,m,n)))
\replacewith(and(and(and(and(and(wd(s),wd(m)),wd(n)),leq(Z(0(#)),m)),leq(m,n)),leq(n,seqLen(s)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="inEqSimp_notLeq">inEqSimp_notLeq {
\find(not(leq(i,i0)))
\replacewith(geq(add(add(Z(neglit(1(#))),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="methodCall">passiveMethodCallStaticWithAssignment {
\find(#allmodal ( (modal operator))\[{ .. #lhs=@(#t.#mn(#elist)); ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#lhs (program LeftHandSide))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#lhs) #v0;method-call(#t.#mn(#elist);)#lhs=#v0; ... }\] (post)) 
\heuristics(method_expand)
Choices: {initialisation:enableStaticInitialisation,programRules:Java}}</entry>
<entry key="div_axiom">div_axiom {
\find(div(divNum,divDenom))
\sameUpdateLevel\add [or(equals(divDenom,Z(0(#))),and(and(equals(div(divNum,divDenom),quotient),leq(mul(quotient,divDenom),divNum)),if-then-else(geq(divDenom,Z(0(#))),geq(mul(quotient,divDenom),add(add(Z(1(#)),divNum),mul(Z(neglit(1(#))),divDenom))),geq(mul(quotient,divDenom),add(add(Z(1(#)),divNum),divDenom)))))]==&gt;[] 
\heuristics(notHumanReadable, polySimp_newSmallSym, defOps_div)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="lenNonNegative">lenNonNegative {
\find(seqLen(seq))
\sameUpdateLevel\add [leq(Z(0(#)),seqLen(seq))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {sequences:on}}</entry>
<entry key="expand_divJlong">expand_divJlong {
\find(divJlong(i,i1))
\replacewith(moduloLong(jdiv(i,i1))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="elimGcdLeq_antec">elimGcdLeq_antec {
\find(leq(elimGcdLeft,elimGcdRight)==&gt;)
\replacewith([or(or(leq(elimGcd,Z(0(#))),geq(add(add(add(add(neg(elimGcd),mul(mul(elimGcd,Z(neglit(1(#)))),elimGcdRightDiv)),elimGcdRight),mul(elimGcdLeftDiv,elimGcd)),mul(elimGcdLeft,Z(neglit(1(#))))),Z(0(#)))),leq(elimGcdLeftDiv,elimGcdRightDiv))]==&gt;[]) 
\heuristics(notHumanReadable, inEqSimp_pullOutGcd_antec, inEqSimp_pullOutGcd_leq, inEqSimp_pullOutGcd)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_Subst_Term">wd_Subst_Term {
\find(wd(subst{v (variable)}(u,t)))
\replacewith(and(wd(u),subst{v (variable)}(u,wd(t)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="javaShiftRightIntDef">javaShiftRightIntDef {
\find(shiftrightJint(left,right))
\replacewith(moduloInt(shiftright(left,mod(right,Z(2(3(#))))))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="indexOfSeqSub">indexOfSeqSub {
\find(seqIndexOf(seqSub(s,from,to),x))
\sameUpdateLevel\varcond(\notFreeIn(nx (variable), to (int term)), \notFreeIn(nx (variable), from (int term)), \notFreeIn(nx (variable), x (any term)), \notFreeIn(nx (variable), s (Seq term)))
\add []==&gt;[and(and(and(leq(from,seqIndexOf(s,x)),lt(seqIndexOf(s,x),to)),leq(Z(0(#)),from)),exists{nx (variable)}(and(and(leq(Z(0(#)),nx),lt(nx,seqLen(s))),equals(any::seqGet(s,nx),x))))] ;
\replacewith(sub(seqIndexOf(s,x),from)) 

Choices: {sequences:on}}</entry>
<entry key="postincrement_assignment_array">postincrement_assignment_array {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=#e[#e0]++; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#lhs0 (program LeftHandSide))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#e0) #v0 = #e0;#typeof(#lhs0) #v1 = #v[#v0];#v[#v0]=(#typeof(#e[#e0]))(#v[#v0]+1);#lhs0=#v1; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="apply_eq_pseudo_leq">apply_eq_pseudo_leq {
\assumes ([equals(mul(aePseudoLeft,aePseudoLeftCoeff),aePseudoRight)]==&gt;[]) 
\find(leq(aePseudoTargetLeft,aePseudoTargetRight))
\sameUpdateLevel\replacewith(if-then-else(and(equals(aePseudoTargetLeft,mul(aePseudoLeft,aePseudoTargetFactor)),gt(aePseudoLeftCoeff,Z(0(#)))),leq(mul(aePseudoRight,aePseudoTargetFactor),mul(aePseudoTargetRight,aePseudoLeftCoeff)),leq(aePseudoTargetLeft,aePseudoTargetRight))) 
\heuristics(notHumanReadable, polySimp_applyEqPseudo, polySimp_leftNonUnit)
Choices: {}}</entry>
<entry key="polyDiv_zero">polyDiv_zero {
\find(div(Z(0(#)),divDenom))
\replacewith(if-then-else(equals(divDenom,Z(0(#))),div(Z(0(#)),Z(0(#))),Z(0(#)))) 
\heuristics(polyDivision)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_F_Logical_Quant_All">wd_F_Logical_Quant_All {
\find(F(all{i (variable)}(a)))
\replacewith(exists{i (variable)}(F(a))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="moduloByteFixpoint">moduloByteFixpoint {
\assumes ([inByte(t)]==&gt;[]) 
\find(moduloByte(t))
\sameUpdateLevel\replacewith(t) 
\heuristics(simplify)
Choices: {intRules:arithmeticSemanticsCheckingOF}}</entry>
<entry key="inEqSimp_ltToLeq">inEqSimp_ltToLeq {
\find(lt(i,i0))
\replacewith(leq(add(add(Z(1(#)),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_makeNonStrict, inEqSimp_expand)
Choices: {}}</entry>
<entry key="wd_Heap_Pred_NonNull">wd_Heap_Pred_NonNull {
\find(WD(nonNull(h,o,i)))
\replacewith(and(and(wd(h),wd(o)),wd(i))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="subSeqHeadSeqDefEQ">subSeqHeadSeqDefEQ {
\assumes ([equals(seqDef{i (variable)}(Z(0(#)),u,a),EQ)]==&gt;[]) 
\find(seqSub(seqConcat(EQ,seq),Z(0(#)),u))
\replacewith(seqDef{i (variable)}(Z(0(#)),u,a)) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="seqNPermSingleton">seqNPermSingleton {
\find(seqNPerm(seqSingleton(si)))
\replacewith(equals(si,Z(0(#)))) 
\heuristics(simplify)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="wd_Numerical_Pred_InShort">wd_Numerical_Pred_InShort {
\find(WD(inShort(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="unionWithAllLocs">unionWithAllLocsRight {
\find(union(s,allLocs))
\replacewith(allLocs) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="eqSeqReverse2">eqSeqReverse2 {
\assumes ([equals(seqReverse(s2),t)]==&gt;[]) 
\find(equals(s,t))
\varcond(\notFreeIn(iv (variable), t (Seq term)), \notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\replacewith(and(equals(seqLen(s),seqLen(seqReverse(s2))),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(seqReverse(s2),iv)))))) 
\heuristics(no_self_application, simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="repeatZero">repeatZero {
\find(repeat(rexp,Z(0(#))))
\replacewith(regEx(seqEmpty)) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="skip assert">skipAssert_2 {
\find(#allmodal ( (modal operator))\[{ .. assert #e1; ... }\] (b))
\replacewith(#allmodal(b)) 
\heuristics(simplify_prog)
Choices: {assertions:off,programRules:Java}}</entry>
<entry key="stringConcatCharExpRight">stringConcatCharExpRight {
\find(#normalassign ( (modal operator))\[{ .. #v=#sstrLeft+#seRight; ... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(strContent(#sstrLeft),seqSingleton(#seRight)))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="wd_Seq_Pred_NPerm">wd_Seq_Pred_NPerm {
\find(WD(seqNPerm(s)))
\replacewith(wd(s)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_Numerical_Pred_Lt">wd_Numerical_Pred_Lt {
\find(WD(lt(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="createdInHeapWithUnionEQ">createdInHeapWithUnionEQ {
\assumes ([equals(union(s,s2),EQ)]==&gt;[]) 
\find(==&gt;createdInHeap(EQ,h))
\replacewith([]==&gt;[createdInHeap(s2,h)]) ;
\replacewith([]==&gt;[createdInHeap(s,h)]) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="wd_Seq_Concat">wd_Seq_Concat {
\find(wd(seqConcat(s,q)))
\replacewith(and(wd(s),wd(q))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="binaryAndOne">binaryAndOne {
\find(binaryAnd(left,Z(1(#))))
\replacewith(if-then-else(equals(mod(left,Z(2(#))),Z(0(#))),Z(0(#)),Z(1(#)))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="distr_forallOr2">distr_forallOr2 {
\find(all{u (variable)}(or(phi,psi)))
\varcond(\notFreeIn(u (variable), phi (formula)))
\replacewith(or(phi,all{u (variable)}(psi))) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: {}}</entry>
<entry key="distr_forallOr1">distr_forallOr1 {
\find(all{u (variable)}(or(phi,psi)))
\varcond(\notFreeIn(u (variable), psi (formula)))
\replacewith(or(all{u (variable)}(phi),psi)) 
\heuristics(notHumanReadable, distrQuantifier)
Choices: {}}</entry>
<entry key="assignmentSaveLocation">eval_order_access4 {
\find(#allmodal ( (modal operator))\[{ .. #v.#a=#nse; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#v (program Variable))),  \not \static(#a (program Variable)), )
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#v) #v0 = #v;#typeof(#nse) #v1 = #nse;#v0.#a=#v1; ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="commute_or">commute_or {
\find(or(commLeft,commRight))
\replacewith(or(commRight,commLeft)) 
\heuristics(cnf_orComm, conjNormalForm)
Choices: {}}</entry>
<entry key="polySimp_pullOutFactor3">polySimp_pullOutFactor3 {
\find(add(pullOutCommon,pullOutCommon))
\replacewith(mul(pullOutCommon,Z(2(#)))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: {}}</entry>
<entry key="polySimp_pullOutFactor2">polySimp_pullOutFactor2 {
\find(add(mul(pullOutCommon,pullOutLeft),pullOutCommon))
\replacewith(mul(pullOutCommon,add(pullOutLeft,Z(1(#))))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: {}}</entry>
<entry key="polySimp_pullOutFactor1">polySimp_pullOutFactor1 {
\find(add(pullOutCommon,mul(pullOutCommon,pullOutRight)))
\replacewith(mul(pullOutCommon,add(Z(1(#)),pullOutRight))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: {}}</entry>
<entry key="translate9">translate9 {
\find(clTranslateInt(Z(9(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(7(5(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="polySimp_pullOutFactor0">polySimp_pullOutFactor0 {
\find(add(mul(pullOutCommon,pullOutLeft),mul(pullOutCommon,pullOutRight)))
\replacewith(mul(pullOutCommon,add(pullOutLeft,pullOutRight))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: {}}</entry>
<entry key="translate8">translate8 {
\find(clTranslateInt(Z(8(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(6(5(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="createdInHeapWithEmpty">createdInHeapWithEmpty {
\find(createdInHeap(empty,h))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="wd_LocSet_Singleton">wd_LocSet_Singleton {
\find(wd(singleton(o,f)))
\varcond(\isArray(o (java.lang.Object term)), \not\isStaticField(f (Field term)), )
\replacewith(and(and(wd(o),wd(f)),not(equals(o,null)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="translate7">translate7 {
\find(clTranslateInt(Z(7(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(5(5(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="translate6">translate6 {
\find(clTranslateInt(Z(6(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(4(5(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="translate5">translate5 {
\find(clTranslateInt(Z(5(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(3(5(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="bprod_invert_index_concrete">bprod_invert_index_concrete {
\find(bprod{uSub (variable)}(mul(i0,Z(neglit(1(#)))),mul(i1,Z(neglit(1(#)))),t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bprod{uSub1 (variable)}(i1,i0,subst{uSub (variable)}(neg(uSub1),t))) 
\heuristics(simplify)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="translate4">translate4 {
\find(clTranslateInt(Z(4(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(2(5(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="translate3">translate3 {
\find(clTranslateInt(Z(3(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(1(5(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="translate2">translate2 {
\find(clTranslateInt(Z(2(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(0(5(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="compound_assignment_op_xor_array">compound_assignment_op_xor_array {
\find(#allmodal ( (modal operator))\[{ .. #e0[#e]^=#e1; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#e (program Expression))), \new(#v0 (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v0 = #e0;#typeof(#e) #v1 = #e;#v0[#v1]=(#typeof(#e0[#e]))(#v0[#v1]^#e1); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="translate1">translate1 {
\find(clTranslateInt(Z(1(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(9(4(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="sameTypeTrue">sameTypeTrue {
\assumes ([equals(G::exactInstance(x1),TRUE),equals(G::exactInstance(x2),TRUE)]==&gt;[]) 
\find(sameType(x1,x2))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="translate0">translate0 {
\find(clTranslateInt(Z(0(iz))))
\replacewith(seqConcat(clTranslateInt(Z(iz)),seqSingleton(C(8(4(#)))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="inDomainConcrete">inDomainConcrete {
\assumes ([]==&gt;[equals(mapUndef,y)]) 
\find(equals(mapGet(m,x),y)==&gt;)
\add [inDomain(m,x)]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {}}</entry>
<entry key="commute_and_2">commute_and_2 {
\find(and(and(commResidue,commLeft),commRight))
\replacewith(and(and(commResidue,commRight),commLeft)) 
\heuristics(cnf_andComm, conjNormalForm)
Choices: {}}</entry>
<entry key="elim_forall_eqSet_imp_phi">elim_forall_eqSet_imp_phi {
\find(all{locVar (variable)}(imp(and(subset(locVar,locSetTerm),subset(locSetTerm,locVar)),phi)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(all{locVar (variable)}(imp(equals(locSetTerm,locVar),phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="eqSeqConcat">eqSeqConcat {
\find(equals(s,seqConcat(s1,s2)))
\replacewith(and(and(equals(seqLen(s),add(seqLen(s1),seqLen(s2))),equals(seqSub(s,Z(0(#)),seqLen(s1)),s1)),equals(seqSub(s,seqLen(s1),seqLen(s)),s2))) 
\heuristics(simplify_ENLARGING)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="optAxiom">optAxiom {
\find(match(opt(rexp),string))
\replacewith(or(match(repeat(rexp,Z(0(#))),string),match(rexp,string))) 
\heuristics(simplify)
Choices: {Strings:on}}</entry>
<entry key="less_plus">less_plus {
\find(lt(Z(0(#)),add(i0,i1)))
\replacewith(lt(neg(i0),i1)) 

Choices: {}}</entry>
<entry key="measuredByCheck">measuredByCheck {
\assumes ([measuredBy(m)]==&gt;[]) 
\find(measuredByCheck(c))
\sameUpdateLevel\replacewith(prec(c,m)) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="polySimp_invertEq">polySimp_invertEq {
\find(equals(invertLeft,invertRight))
\replacewith(equals(mul(invertLeft,Z(neglit(1(#)))),mul(invertRight,Z(neglit(1(#)))))) 
\heuristics(polySimp_normalise, polySimp_directEquations)
Choices: {}}</entry>
<entry key="rotate_params">rotate_params {
\find(add(i,add(i0,i1)))
\replacewith(add(i0,add(i,i1))) 

Choices: {}}</entry>
<entry key="wd_Numerical_Op_Add">wd_Numerical_Op_AddLongOverFlow {
\find(wd(javaAddLongOverFlow(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="translate#">translate# {
\find(clTranslateInt(Z(#)))
\replacewith(seqEmpty) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="wd_Seq_Length">wd_Seq_Length {
\find(wd(seqLen(s)))
\replacewith(wd(s)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="applyOnElementary">applyOnElementary {
\find(update-application(u,elem-update(#pv (program Variable))(t)))
\replacewith(elem-update(#pv (program Variable))(update-application(u,t))) 
\heuristics(update_apply_on_update)
Choices: {}}</entry>
<entry key="methodCallThrow">methodCallParamThrow {
\find(#allmodal ( (modal operator))\[{ .. method-frame(result-&gt;#v0, #ex): {
    throw  #se;
    #slist
  }
 ... }\] (post))
\varcond(\isLocalVariable (#se (program SimpleExpression)), )
\replacewith(#allmodal ( (modal operator))\[{ .. throw #se; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="compound_unary_minus_eval">compound_unary_minus_eval {
\find(#allmodal ( (modal operator))\[{ .. #lhs=-#nse; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #v0 = #nse;#lhs=-#v0; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Op_Div">wd_Numerical_Op_DivLongOverFlow {
\find(wd(javaDivLongOverFlow(a,b)))
\replacewith(and(and(wd(a),wd(b)),not(equals(b,Z(0(#)))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="permOwner4">permOwner4 {
\find(owner4(o1,o2,o3,o4))
\replacewith(consPermissionOwnerList(o1,consPermissionOwnerList(o2,consPermissionOwnerList(o3,consPermissionOwnerList(o4,emptyPermissionOwnerList))))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="subSeqComplete">subSeqComplete {
\find(seqSub(seq,Z(0(#)),seqLen(seq)))
\replacewith(seq) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="permOwner3">permOwner3 {
\find(owner3(o1,o2,o3))
\replacewith(consPermissionOwnerList(o1,consPermissionOwnerList(o2,consPermissionOwnerList(o3,emptyPermissionOwnerList)))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="permOwner2">permOwner2 {
\find(owner2(o1,o2))
\replacewith(consPermissionOwnerList(o1,consPermissionOwnerList(o2,emptyPermissionOwnerList))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="permOwner1">permOwner1 {
\find(owner1(o1))
\replacewith(consPermissionOwnerList(o1,emptyPermissionOwnerList)) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="greater_than">compound_greater_than_comparison_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e&gt;#nse0; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse0 (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse0) #v1 = #nse0;#lhs=#v0&gt;#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="tryCatchThrow">tryMultipleCatchThrow {
\find(#allmodal ( (modal operator))\[{ .. try {throw #se;#slist} catch (#t #v0) {
    #slist1
  }                catch (#t2 #v1) {
    #slist3
  }
  #cs
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. if (#se==null) {
                           try {
      throw  new  java.lang.NullPointerException ();
    }                            catch (#t #v0) {
      #slist1
    }                            catch (#t2 #v1) {
      #slist3
    }
    #cs
  }
  else 
    if (#se instanceof #t) {
      #t #v0;
      #v0=(#t)#se;
      #slist1
    }
    else  {
                           try {
        throw  #se;
      }                            catch (#t2 #v1) {
        #slist3
      }
      #cs
    }
 ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_Numerical_Mod">wd_Numerical_Mod_Char {
\find(wd(moduloChar(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="seqSingletonUnfold">seqSingletonUnfold {
\find(#allmodal ( (modal operator))\[{ .. #v=\seq_singleton(#nse); ... }\] (post))
\varcond(\new(#vNew (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #vNew = #nse;#v=\seq_singleton(#vNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="exact_instance_definition_null">exact_instance_definition_null {
\find(equals(Null::exactInstance(obj),TRUE))
\varcond(\notFreeIn(bv (variable), bool (boolean term)))
\replacewith(equals(obj,null)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="wd_String_RmvZeros">wd_String_RmvZeros {
\find(wd(clRemoveZeros(c)))
\replacewith(wd(c)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="inEqSimp_gtToGeq">inEqSimp_gtToGeq {
\find(gt(i,i0))
\replacewith(geq(add(add(Z(neglit(1(#))),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))) 
\heuristics(notHumanReadable, inEqSimp_makeNonStrict, inEqSimp_expand)
Choices: {}}</entry>
<entry key="diamond_false">diamond_false {
\find(#diamond ( (modal operator))\[{ .. #s ... }\] (false))
\replacewith(false) 
\heuristics(modal_tautology)
Choices: {programRules:Java}}</entry>
<entry key="ifElseSkipThen">ifElseSkipThenConditionInBlock {
\find(#allmodal ( (modal operator))\[{ ..  {#loc=false;}if (#loc)
    #s0
  else 
    #s1
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..  {#loc=false;}#s1 ... }\] (post)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="reachEndOfUniquePath">reachEndOfUniquePath {
\assumes ([reach(h,allObjects(f),o,o2,n),equals(alpha::select(h,o2,f),null),equals(alpha::select(h,o3,f),null)]==&gt;[]) 
\find(reach(h,allObjects(f),o,o3,n2)==&gt;)
\varcond(\different (n (int term), n2 (int term)), )
\add [and(equals(o2,o3),equals(n,n2))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {reach:on}}</entry>
<entry key="ifElseFalse">ifElseFalse {
\assumes ([equals(#se,FALSE)]==&gt;[]) 
\find(==&gt;#allmodal ( (modal operator))\[{ .. if (#se)
    #s0
  else 
    #s1
 ... }\] (post))
\replacewith([]==&gt;[#allmodal ( (modal operator))\[{ .. #s1 ... }\] (post)]) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="subSeqSingleton2EQ">subSeqSingleton2EQ {
\assumes ([equals(seqSingleton(x),EQ)]==&gt;[]) 
\find(seqSub(EQ,l,u))
\replacewith(seqConcat(seqSub(seqEmpty,if-then-else(lt(l,Z(0(#))),l,Z(0(#))),if-then-else(lt(u,Z(0(#))),u,Z(0(#)))),seqConcat(if-then-else(and(leq(l,Z(0(#))),geq(u,Z(1(#)))),seqSingleton(x),seqEmpty),seqSub(seqEmpty,if-then-else(gt(l,Z(0(#))),l,Z(1(#))),if-then-else(gt(u,Z(0(#))),u,Z(1(#))))))) 
\heuristics(simplify_enlarging, no_self_application)
Choices: {sequences:on}}</entry>
<entry key="wd_String_IndexOfChar">wd_String_IndexOfChar {
\find(wd(clIndexOfChar(c,i,j)))
\replacewith(and(and(and(and(and(wd(i),wd(j)),wd(c)),leq(Z(0(#)),i)),leq(i,j)),lt(j,seqLen(c)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="polySimp_elimSub">polySimp_elimSub {
\find(sub(i,i0))
\replacewith(add(i,mul(i0,Z(neglit(1(#)))))) 
\heuristics(polySimp_elimSubNeg, polySimp_expand)
Choices: {}}</entry>
<entry key="startsWith">startsWith {
\find(clStartsWith(sourceStr,searchStr))
\replacewith(if-then-else(gt(seqLen(searchStr),seqLen(sourceStr)),false,equals(seqSub(sourceStr,Z(0(#)),seqLen(searchStr)),searchStr))) 
\heuristics(defOpsStartsEndsWith)
Choices: {Strings:on}}</entry>
<entry key="sub_equations_left">sub_equations_left {
\assumes ([equals(i,i0)]==&gt;[]) 
\find(equals(j,j0)==&gt;)
\add [equals(sub(j,i),sub(j0,i0))]==&gt;[] 

Choices: {}}</entry>
<entry key="equal_add">equal_add {
\find(==&gt;equals(i0,i1))
\varcond(\notFreeIn(j2 (variable), i1 (int term)), \notFreeIn(j2 (variable), i0 (int term)))
\replacewith([]==&gt;[exists{j2 (variable)}(equals(add(i0,j2),add(i1,j2)))]) 

Choices: {}}</entry>
<entry key="lenOfSeqConcat">lenOfSeqConcatEQ {
\assumes ([equals(seqConcat(seq,seq2),EQ)]==&gt;[]) 
\find(seqLen(EQ))
\sameUpdateLevel\replacewith(add(seqLen(seq),seqLen(seq2))) 
\heuristics(simplify)
Choices: {sequences:on}}</entry>
<entry key="equiv_left">equiv_left {
\find(equiv(b,c)==&gt;)
\replacewith([]==&gt;[b,c]) ;
\replacewith([b,c]==&gt;[]) 
\heuristics(beta)
Choices: {}}</entry>
<entry key="add_less_back">add_less_back_zero_2_comm {
\find(lt(add(i1,i),i))
\replacewith(lt(i1,Z(0(#)))) 

Choices: {}}</entry>
<entry key="seqNPermInvNPermReplace">seqNPermInvNPermReplace {
\find(seqNPerm(seqNPermInv(s1)))
\replacewith(seqNPerm(s1)) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="onlyCreatedObjectsAreObservedInLocSets">onlyCreatedObjectsAreObservedInLocSets {
\find(elementOf(o,f,obs)==&gt;)
\varcond(\isObserver (obs (LocSet term), h (Heap term)), )
\add [or(equals(o,null),equals(boolean::select(h,o,java.lang.Object::&lt;created&gt;),TRUE))]==&gt;[] 
\heuristics(inReachableStateImplication)
Choices: {programRules:Java}}</entry>
<entry key="writePermissionObject">writePermissionObject {
\find(writePermissionObject(o,p))
\replacewith(true) 
\heuristics(concrete)
Choices: {permissions:off}}</entry>
<entry key="rotate_or">rotate_or {
\find(or(b,or(c,d)))
\replacewith(or(c,or(b,d))) 

Choices: {}}</entry>
<entry key="bsum_shift_index">bsum_shift_index {
\find(bsum{uSub (variable)}(i0,i1,t))
\varcond(\notFreeIn(uSub1 (variable), t (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(bsum{uSub1 (variable)}(Z(0(#)),sub(i1,i0),subst{uSub (variable)}(add(uSub1,i0),t))) 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="exact_instance_definition_int">exact_instance_definition_int {
\find(equals(int::exactInstance(idx0),TRUE))
\varcond(\notFreeIn(iv (variable), idx0 (int term)))
\replacewith(exists{iv (variable)}(equals(idx0,iv))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="wd_Equality_Pred">wd_Equality_Pred {
\find(WD(equals(s,t)))
\replacewith(and(wd(s),wd(t))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="minAxiom">minAxiom {
\find(equals(min{x (variable)}(b,t),t2)==&gt;)
\varcond(\notFreeIn(y (variable), t2 (int term)), \notFreeIn(y (variable), t (int term)), \notFreeIn(y (variable), b (boolean term)), \notFreeIn(x (variable), t2 (int term)))
\add []==&gt;[exists{x (variable)}(and(equals(b,TRUE),all{y (variable)}(imp(equals(subst{x (variable)}(y,b),TRUE),geq(subst{x (variable)}(y,t),t)))))] ;
\add [and(all{y (variable)}(subst{x (variable)}(y,imp(equals(b,TRUE),geq(t,t2)))),exists{y (variable)}(subst{x (variable)}(y,and(equals(b,TRUE),equals(t,t2)))))]==&gt;[] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="eqSeqConcatEQ">eqSeqConcatEQ {
\assumes ([equals(seqConcat(s1,s2),EQ)]==&gt;[]) 
\find(equals(s,EQ))
\replacewith(and(and(equals(seqLen(s),add(seqLen(s1),seqLen(s2))),equals(seqSub(s,Z(0(#)),seqLen(s1)),s1)),equals(seqSub(s,seqLen(s1),seqLen(s)),s2))) 
\heuristics(simplify_ENLARGING, no_self_application)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="closeTrue">closeTrue {
\find(==&gt;true)
\closegoal\heuristics(closure)
Choices: {}}</entry>
<entry key="repeatOnce">repeatOnce {
\find(repeat(rexp,Z(1(#))))
\replacewith(rexp) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="getAnyOfArray2seq">getAnyOfArray2seq {
\find(any::seqGet(array2seq(h,a),idx))
\add []==&gt;[and(leq(Z(0(#)),idx),lt(idx,length(a)))] ;
\replacewith(any::select(h,a,arr(idx))) 

Choices: {sequences:on}}</entry>
<entry key="stringConcatIntExpRight">stringConcatIntExpRight {
\find(#normalassign ( (modal operator))\[{ .. #v=#sstrLeft+#seRight; ... }\] (post))
\sameUpdateLevel\add [equals(strContent(sk),seqConcat(strContent(#sstrLeft),clTranslateInt(#seRight)))]==&gt;[equals(sk,null)] \replacewith(update-application(elem-update(#v (program Variable))(sk),update-application(elem-update(heap)(create(heap,sk)),#normalassign(post)))) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {}}</entry>
<entry key="createdInHeapWithSetMinusFreshLocs">createdInHeapWithSetMinusFreshLocs {
\find(createdInHeap(setMinus(s,freshLocs(h)),h))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="seqPermDef">seqPermDef {
\find(seqPerm(s1,s2))
\varcond(\notFreeIn(s (variable), s2 (Seq term)), \notFreeIn(s (variable), s1 (Seq term)), \notFreeIn(iv (variable), s2 (Seq term)), \notFreeIn(iv (variable), s1 (Seq term)))
\replacewith(and(equals(seqLen(s1),seqLen(s2)),exists{s (variable)}(and(and(equals(seqLen(s),seqLen(s1)),seqNPerm(s)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s1,iv),any::seqGet(s2,int::seqGet(s,iv))))))))) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="wd_Numerical_Pred_Gt">wd_Numerical_Pred_Gt {
\find(WD(gt(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="defOfSeqRemove">defOfSeqRemove {
\find(seqRemove(s,iv))
\varcond(\notFreeIn(uSub (variable), iv (int term)), \notFreeIn(uSub (variable), s (Seq term)))
\replacewith(if-then-else(or(lt(iv,Z(0(#))),leq(seqLen(s),iv)),s,seqDef{uSub (variable)}(Z(0(#)),sub(seqLen(s),Z(1(#))),if-then-else(lt(uSub,iv),any::seqGet(s,uSub),any::seqGet(s,add(uSub,Z(1(#)))))))) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="commute_and">commute_and {
\find(and(commLeft,commRight))
\replacewith(and(commRight,commLeft)) 
\heuristics(cnf_andComm, conjNormalForm)
Choices: {}}</entry>
<entry key="maxAxiom">maxAxiom {
\find(equals(max{x (variable)}(b,t),t2)==&gt;)
\varcond(\notFreeIn(y (variable), t2 (int term)), \notFreeIn(y (variable), t (int term)), \notFreeIn(y (variable), b (boolean term)), \notFreeIn(x (variable), t2 (int term)))
\add []==&gt;[exists{x (variable)}(and(equals(b,TRUE),all{y (variable)}(imp(equals(subst{x (variable)}(y,b),TRUE),leq(subst{x (variable)}(y,t),t)))))] ;
\add [and(all{y (variable)}(subst{x (variable)}(y,imp(equals(b,TRUE),leq(t,t2)))),exists{y (variable)}(subst{x (variable)}(y,and(equals(b,TRUE),equals(t,t2)))))]==&gt;[] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_RegEx_Repeat">wd_RegEx_Repeat {
\find(wd(repeat(a,n)))
\replacewith(and(wd(a),leq(Z(0(#)),n))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="inEqSimp_commuteGeq">inEqSimp_commuteGeq {
\find(geq(commLeft,commRight))
\replacewith(leq(commRight,commLeft)) 
\heuristics(inEqSimp_commute, inEqSimp_expand)
Choices: {}}</entry>
<entry key="replace_byte_RANGE">replace_byte_RANGE {
\find(byte_RANGE)
\replacewith(Z(6(5(2(#))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="def_wellOrderLeqInt">def_wellOrderLeqInt {
\find(wellOrderLeqInt(intT1,intT2))
\replacewith(or(and(geq(intT1,intT2),lt(intT2,Z(0(#)))),and(leq(Z(0(#)),intT1),leq(intT1,intT2)))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="javaShiftLeftIntDef">javaShiftLeftIntDef {
\find(shiftleftJint(left,right))
\replacewith(moduloInt(shiftleft(left,mod(right,Z(2(3(#))))))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="bprod_empty">bprod_empty {
\find(bprod{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(1(#))) ;
\add []==&gt;[leq(i1,i0)] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="setMinusWithAllLocs">setMinusWithAllLocs {
\find(setMinus(s,allLocs))
\replacewith(empty) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="eq_or">eq_or {
\find(or(phi,phi))
\replacewith(phi) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="compound_assignment_op_div_attr">compound_assignment_op_div_attr {
\find(#allmodal ( (modal operator))\[{ .. #e0.#attribute/=#e; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e0 (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e0) #v = #e0;#v.#attribute=(#typeof(#attribute))(#v.#attribute/#e); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="sizeOfMapEmpty">sizeOfMapEmpty {
\find(mapSize(mapEmpty))
\sameUpdateLevel\replacewith(Z(0(#))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="left_add_mult_distrib">left_add_mult_distrib {
\find(add(mul(i0,i1),add(mul(i2,i1),i3)))
\replacewith(add(mul(add(i0,i2),i1),i3)) 

Choices: {}}</entry>
<entry key="bprod_one_factor_concrete2">bprod_one_factor_concrete2 {
\find(bprod{uSub (variable)}(add(Z(neglit(1(#))),i0),i0,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(subst{uSub (variable)}(add(Z(neglit(1(#))),i0),t)) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="bprod_one_factor_concrete1">bprod_one_factor_concrete1 {
\find(bprod{uSub (variable)}(i0,add(Z(1(#)),i0),t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i0 (int term)))
\replacewith(subst{uSub (variable)}(i0,t)) 
\heuristics(concrete)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="inEqSimp_geqRight">inEqSimp_geqRight {
\find(==&gt;geq(i,i0))
\replacewith([leq(add(add(Z(1(#)),mul(Z(neglit(1(#))),i0)),i),Z(0(#)))]==&gt;[]) 
\heuristics(notHumanReadable, inEqSimp_moveLeft, inEqSimp_expand)
Choices: {}}</entry>
<entry key="leq_trans">leq_trans {
\assumes ([leq(i,i0)]==&gt;[]) 
\find(leq(i0,i1)==&gt;)
\add [leq(i,i1)]==&gt;[] 

Choices: {}}</entry>
<entry key="binaryOrGte">binaryOrGte {
\find(binaryOr(left,right))
\sameUpdateLevel\add [imp(and(geq(left,Z(0(#))),geq(right,Z(0(#)))),and(and(geq(binaryOr(left,right),left),geq(binaryOr(left,right),right)),leq(binaryOr(left,right),mul(Z(2(#)),if-then-else(gt(left,right),left,right)))))]==&gt;[] 
\heuristics(userTaclets1)
Choices: {}}</entry>
<entry key="true_left">true_left {
\find(true==&gt;)
\replacewith([]==&gt;[]) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="replace_short_MIN">replace_short_MIN {
\find(short_MIN)
\replacewith(Z(neglit(8(6(7(2(3(#)))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="setIntersectUnfold">setIntersectUnfoldRight {
\find(#allmodal ( (modal operator))\[{ .. #v=\intersect(#seLeft,#nseRight); ... }\] (post))
\varcond(\new(#vRightNew (program Variable), \typeof(#nseRight (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nseRight) #vRightNew = #nseRight;#v=\intersect(#seLeft,#vRightNew); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="mul_literals">mul_literals {
\find(mul(Z(iz),Z(jz)))
\replacewith(#mul(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="referencedObjectIsCreatedRightEQ">referencedObjectIsCreatedRightEQ {
\assumes ([equals(deltaObject::select(h,o,f),EQ)]==&gt;[equals(EQ,null)]) 
\find(==&gt;equals(boolean::select(h,EQ,java.lang.Object::&lt;created&gt;),TRUE))
\replacewith([]==&gt;[wellFormed(h)]) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="sameTypeFalse">sameTypeFalse {
\assumes ([equals(G::exactInstance(x1),TRUE),equals(H::exactInstance(x2),TRUE)]==&gt;[]) 
\find(sameType(x1,x2))
\varcond(\not\same(G, H), )
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="moduloCharFixpointInline">moduloCharFixpointInline {
\find(moduloChar(t))
\replacewith(if-then-else(inChar(t),t,moduloChar(t))) 
\heuristics(defOps_expandModulo)
Choices: {intRules:javaSemantics}}</entry>
<entry key="ifExthenelse1_false">ifExthenelse1_false_for {
\find(ifExThenElse{intVar (variable)}(false,b,c))
\replacewith(c) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="translateNegLit">translateNegLit {
\find(clTranslateInt(Z(neglit(iz))))
\replacewith(seqConcat(seqSingleton(C(5(4(#)))),clTranslateInt(Z(iz)))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="known dynamic array type">array_store_known_dynamic_array_type {
\assumes ([equals(J::exactInstance(array),TRUE)]==&gt;[]) 
\find(arrayStoreValid(array,obj))
\sameUpdateLevel\varcond(\isReference[non_null]( J ), )
\replacewith(or(equals(obj,null),equals(#arrayBaseInstanceOf(J::exactInstance(array),obj),TRUE))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="closeFalse">closeFalse {
\find(false==&gt;)
\closegoal\heuristics(closure)
Choices: {}}</entry>
<entry key="returnUnfold">returnUnfold {
\find(#allmodal ( (modal operator))\[{ .. return #nse; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#nse (program NonSimpleExpression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nse) #v0 = #nse;return #v0; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="equal_bprod_same_index">equal_bprod3 {
\assumes ([equals(bprod{uSub1 (variable)}(i0,i1,t1),i),equals(bprod{uSub2 (variable)}(i0,i1,t2),j)]==&gt;[]) 
\find(==&gt;equals(j,i))
\varcond(\notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)))
\add []==&gt;[all{uSub1 (variable)}(imp(and(geq(uSub1,i0),lt(uSub1,i1)),equals(t1,subst{uSub2 (variable)}(uSub1,t2))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="compound_assignment_op_plus">compound_assignment_op_plus {
\find(#allmodal ( (modal operator))\[{ .. #v+=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #v=(#typeof(#v))(#v+(#e)); ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="schiffl_lemma_2">schiffl_lemma_2 {
\find(seqPerm(s,t)==&gt;)
\varcond(\notFreeIn(y (variable), t (Seq term)), \notFreeIn(y (variable), s (Seq term)), \notFreeIn(x (variable), t (Seq term)), \notFreeIn(x (variable), s (Seq term)), \notFreeIn(r (variable), t (Seq term)), \notFreeIn(r (variable), s (Seq term)), \notFreeIn(iv (variable), t (Seq term)), \notFreeIn(iv (variable), s (Seq term)))
\add [all{x (variable)}(all{y (variable)}(imp(and(and(and(and(and(equals(any::seqGet(s,x),any::seqGet(t,x)),equals(any::seqGet(s,y),any::seqGet(t,y))),leq(Z(0(#)),x)),lt(x,seqLen(s))),leq(Z(0(#)),y)),lt(y,seqLen(s))),exists{r (variable)}(and(and(and(and(equals(seqLen(r),seqLen(s)),seqNPerm(r)),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(t,int::seqGet(r,iv)))))),equals(int::seqGet(r,x),x)),equals(int::seqGet(r,y),y))))))]==&gt;[] 

Choices: {}}</entry>
<entry key="simplifySelectOfCreateEQ">simplifySelectOfCreateEQ {
\assumes ([equals(create(h,o),EQ)]==&gt;[]) 
\find(equals(beta::select(EQ,o2,f),sk)==&gt;)
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o2,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(and(equals(o,o2),not(equals(o,null))),if-then-else(equals(f,java.lang.Object::&lt;created&gt;),beta::cast(TRUE),beta::defaultValue),beta::select(h,o2,f)),sk)]==&gt;[]) ;
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o2,f))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(and(and(equals(o,o2),not(equals(o,null))),equals(f,java.lang.Object::&lt;created&gt;)),beta::cast(TRUE),beta::select(h,o2,f)),sk)]==&gt;[]) 
\heuristics(simplify_select)
Choices: {programRules:Java}}</entry>
<entry key="bsum_equal_split4">bsum_equal_split4 {
\assumes ([equals(bsum{uSub1 (variable)}(i1,i0,t1),i)]==&gt;[]) 
\find(==&gt;equals(bsum{uSub2 (variable)}(i2,i0,t2),i))
\varcond(\notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==&gt;[and(and(leq(i1,i0),leq(i2,i0)),if-then-else(lt(i2,i1),equals(bsum{uSub1 (variable)}(i1,i0,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),bsum{uSub2 (variable)}(i2,i1,t2)),equals(bsum{uSub1 (variable)}(i1,i2,t1),bsum{uSub2 (variable)}(i2,i0,sub(t2,subst{uSub1 (variable)}(uSub2,t1))))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="bsum_equal_split3">bsum_equal_split3 {
\find(==&gt;equals(bsum{uSub1 (variable)}(i1,i0,t1),bsum{uSub2 (variable)}(i2,i0,t2)))
\varcond(\notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==&gt;[and(and(leq(i1,i0),leq(i2,i0)),if-then-else(lt(i1,i2),equals(bsum{uSub1 (variable)}(i1,i2,t1),bsum{uSub2 (variable)}(i2,i0,sub(t2,subst{uSub1 (variable)}(uSub2,t1)))),equals(bsum{uSub1 (variable)}(i1,i0,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),bsum{uSub2 (variable)}(i2,i1,t2))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_String_Replace">wd_String_Replace {
\find(wd(clReplace(c,i,j)))
\replacewith(and(and(and(and(and(and(wd(i),wd(j)),wd(c)),leq(Z(0(#)),i)),leq(Z(0(#)),j)),lt(i,seqLen(c))),lt(j,seqLen(c)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="bsum_equal_split2">bsum_equal_split2 {
\assumes ([equals(bsum{uSub1 (variable)}(i0,i1,t1),i)]==&gt;[]) 
\find(==&gt;equals(bsum{uSub2 (variable)}(i0,i2,t2),i))
\varcond(\notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==&gt;[and(and(leq(i0,i1),leq(i0,i2)),if-then-else(lt(i2,i1),equals(bsum{uSub1 (variable)}(i2,i1,t1),bsum{uSub2 (variable)}(i0,i2,sub(t2,subst{uSub1 (variable)}(uSub2,t1)))),equals(bsum{uSub1 (variable)}(i0,i1,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),bsum{uSub2 (variable)}(i1,i2,t2))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="disjointWithEmpty">disjointWithEmpty {
\find(disjoint(empty,s))
\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="bsum_equal_split1">bsum_equal_split1 {
\find(==&gt;equals(bsum{uSub1 (variable)}(i0,i1,t1),bsum{uSub2 (variable)}(i0,i2,t2)))
\varcond(\notFreeIn(uSub2 (variable), i0 (int term)), \notFreeIn(uSub2 (variable), t1 (int term)), \notFreeIn(uSub2 (variable), i1 (int term)), \notFreeIn(uSub2 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), t2 (int term)), \notFreeIn(uSub1 (variable), i2 (int term)), \notFreeIn(uSub1 (variable), i1 (int term)), \notFreeIn(uSub1 (variable), i0 (int term)))
\add []==&gt;[and(and(leq(i0,i1),leq(i0,i2)),if-then-else(lt(i1,i2),equals(bsum{uSub1 (variable)}(i0,i1,sub(t1,subst{uSub2 (variable)}(uSub1,t2))),bsum{uSub2 (variable)}(i1,i2,t2)),equals(bsum{uSub1 (variable)}(i2,i1,t1),bsum{uSub2 (variable)}(i0,i2,sub(t2,subst{uSub1 (variable)}(uSub2,t1))))))] 
\heuristics(comprehensions)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="subsetOfIntersectWithItSelfEQ2">subsetOfIntersectWithItSelfEQ2 {
\assumes ([equals(intersect(s2,s),EQ)]==&gt;[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(subset(s,s2)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="synchronizedBlockEvalSync">synchronizedBlockEvalSync {
\find(#allmodal ( (modal operator))\[{ .. synchronized(#nsencr) {#slist} ... }\] (post))
\varcond(\new(#loc (program Variable), \typeof(#nsencr (program NonSimpleExpressionNoClassReference))), \isLocalVariable (#nsencr (program NonSimpleExpressionNoClassReference)), )
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#nsencr) #loc = #nsencr;synchronized(#loc) {#slist} ... }\] (post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_and_contradInEq1">inEqSimp_and_contradInEq1 {
\find(and(and(b,leq(contradLeft,contradRightSmaller)),geq(contradLeft,contradRightBigger)))
\replacewith(and(and(and(b,leq(contradLeft,contradRightSmaller)),geq(contradLeft,contradRightBigger)),geq(contradRightSmaller,contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_and_contradInEqs, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="subsetOfIntersectWithItSelfEQ1">subsetOfIntersectWithItSelfEQ1 {
\assumes ([equals(intersect(s,s2),EQ)]==&gt;[]) 
\find(subset(s,EQ))
\sameUpdateLevel\replacewith(subset(s,s2)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_and_contradInEq0">inEqSimp_and_contradInEq0 {
\find(and(leq(contradLeft,contradRightSmaller),geq(contradLeft,contradRightBigger)))
\replacewith(and(and(leq(contradLeft,contradRightSmaller),geq(contradLeft,contradRightBigger)),geq(contradRightSmaller,contradRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_and_contradInEqs, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="binaryOrSign">binaryOrSign {
\find(binaryOr(left,right))
\sameUpdateLevel\add [geq(mul(if-then-else(and(geq(left,Z(0(#))),geq(right,Z(0(#)))),Z(1(#)),Z(neglit(1(#)))),binaryOr(left,right)),Z(0(#)))]==&gt;[] 
\heuristics(userTaclets1)
Choices: {}}</entry>
<entry key="endsWith">endsWith {
\find(clEndsWith(sourceStr,searchStr))
\replacewith(if-then-else(gt(seqLen(searchStr),seqLen(sourceStr)),false,equals(seqSub(sourceStr,sub(seqLen(sourceStr),seqLen(searchStr)),seqLen(sourceStr)),searchStr))) 
\heuristics(defOpsStartsEndsWith)
Choices: {Strings:on}}</entry>
<entry key="polySimp_sepNegMonomial">polySimp_sepNegMonomial {
\find(equals(add(sepResidue,sepNegMono),Z(0(#))))
\replacewith(equals(mul(sepNegMono,Z(neglit(1(#)))),sepResidue)) 
\heuristics(polySimp_balance, polySimp_directEquations)
Choices: {}}</entry>
<entry key="equalCharacters">equalCharacters {
\find(equals(C(iz1),C(iz2)))
\replacewith(equals(Z(iz1),Z(iz2))) 
\heuristics(stringsSimplify)
Choices: {Strings:on}}</entry>
<entry key="definitionOfObjectsIsomorphic">definitionOfObjectsIsomorphic {
\find(==&gt;objectsIsomorphic(s1,t1,s2,t2))
\varcond(\notFreeIn(i (variable), t2 (Seq term)), \notFreeIn(i (variable), t1 (Seq term)), \notFreeIn(i (variable), s2 (Seq term)), \notFreeIn(i (variable), s1 (Seq term)))
\replacewith([]==&gt;[all{i (variable)}(imp(and(leq(Z(0(#)),i),lt(i,seqLen(t1))),and(imp(equals(java.lang.Object::instance(any::seqGet(t1,i)),TRUE),objectIsomorphic(s1,java.lang.Object::seqGet(t1,i),s2,java.lang.Object::seqGet(t2,i))),imp(equals(Seq::instance(any::seqGet(t1,i)),TRUE),objectsIsomorphic(s1,Seq::seqGet(t1,i),s2,Seq::seqGet(t2,i))))))]) 
\heuristics(comprehensions)
Choices: {}}</entry>
<entry key="elim_forall_subOfAll">elim_forall_subOfAll {
\find(all{locVar (variable)}(subset(locSetTerm,locVar)))
\varcond(\notFreeIn(locVar (variable), locSetTerm (LocSet term)))
\replacewith(equals(locSetTerm,empty)) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="condition">condition_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#se0 ?#se1 :#se2; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#se0,TRUE),#se1,#se2)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="polySimp_pullOutFactor3b">polySimp_pullOutFactor3b {
\find(add(add(i0,pullOutCommon),pullOutCommon))
\replacewith(add(i0,mul(pullOutCommon,Z(2(#))))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: {}}</entry>
<entry key="less_sub">less_sub {
\find(lt(i,i0))
\replacewith(lt(neg(i0),neg(i))) 

Choices: {}}</entry>
<entry key="allFieldsEq">allFieldsEq {
\find(equals(allFields(o1),allFields(o2)))
\replacewith(equals(o1,o2)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="emptyStatement">emptyStatement {
\find(#allmodal ( (modal operator))\[{ .. ; ... }\] (post))
\replacewith(#allmodal(post)) 
\heuristics(simplify_prog_subset, simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="applyOnSkip">applyOnSkip {
\find(update-application(u,skip))
\replacewith(skip) 
\heuristics(update_elim)
Choices: {}}</entry>
<entry key="wd_Numerical_Op_Mul">wd_Numerical_Op_MulLongOverFlow {
\find(wd(javaMulLongOverFlow(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="reachDefinition">reachDefinition {
\find(reach(h,s,o,o2,n))
\varcond(\notFreeIn(ov (variable), n (int term)), \notFreeIn(ov (variable), o2 (java.lang.Object term)), \notFreeIn(ov (variable), o (java.lang.Object term)), \notFreeIn(ov (variable), s (LocSet term)), \notFreeIn(ov (variable), h (Heap term)))
\replacewith(and(and(and(geq(n,Z(0(#))),not(equals(o,null))),not(equals(o2,null))),or(and(equals(n,Z(0(#))),equals(o,o2)),exists{ov (variable)}(and(reach(h,s,o,ov,sub(n,Z(1(#)))),acc(h,s,ov,o2)))))) 

Choices: {reach:on}}</entry>
<entry key="subsetSingletonLeftEQ">subsetSingletonLeftEQ {
\assumes ([equals(singleton(o,f),EQ)]==&gt;[]) 
\find(subset(EQ,s))
\sameUpdateLevel\replacewith(elementOf(o,f,s)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="seqDef_induction_upper">seqDef_induction_upper {
\find(seqDef{uSub (variable)}(from,to,t))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqConcat(seqDef{uSub (variable)}(from,sub(to,Z(1(#))),t),if-then-else(lt(from,to),seqSingleton(subst{uSub (variable)}(sub(to,Z(1(#))),t)),seqEmpty))) 

Choices: {sequences:on}}</entry>
<entry key="ex_bool">ex_bool {
\find(exists{x (variable)}(c))
\replacewith(or(subst{x (variable)}(FALSE,c),subst{x (variable)}(TRUE,c))) 
\heuristics(boolean_cases)
Choices: {}}</entry>
<entry key="subSeqConcat">subSeqConcat {
\find(seqSub(seqConcat(s1,s2),l,u))
\replacewith(seqConcat(seqSub(s1,l,if-then-else(lt(seqLen(s1),u),seqLen(s1),u)),seqSub(s2,if-then-else(lt(l,seqLen(s1)),Z(0(#)),sub(l,seqLen(s1))),sub(u,seqLen(s1))))) 
\heuristics(simplify_enlarging)
Choices: {sequences:on}}</entry>
<entry key="polySimp_pullOutFactor2b">polySimp_pullOutFactor2b {
\find(add(add(i0,mul(pullOutCommon,pullOutLeft)),pullOutCommon))
\replacewith(add(i0,mul(pullOutCommon,add(pullOutLeft,Z(1(#)))))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: {}}</entry>
<entry key="zero_less_mult_iff">zero_less_mult_iff {
\find(lt(Z(0(#)),mul(i0,i1)))
\replacewith(or(and(lt(Z(0(#)),i0),lt(Z(0(#)),i1)),and(lt(i0,Z(0(#))),lt(i1,Z(0(#)))))) 

Choices: {}}</entry>
<entry key="concrete_eq_4">concrete_eq_4 {
\find(equiv(b,false))
\replacewith(not(b)) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="polySimp_elimOneLeft1">polySimp_elimOneLeft1 {
\find(mul(mul(i0,Z(1(#))),i))
\replacewith(mul(i0,i)) 
\heuristics(polySimp_elimOneLeft, polySimp_expand)
Choices: {}}</entry>
<entry key="concrete_eq_3">concrete_eq_3 {
\find(equiv(b,true))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="expand_inChar">expand_inChar {
\find(inChar(i))
\replacewith(and(leq(i,char_MAX),leq(char_MIN,i))) 
\heuristics(defOps_expandRanges)
Choices: {intRules:arithmeticSemanticsCheckingOF,programRules:Java}}</entry>
<entry key="polySimp_elimOneLeft0">polySimp_elimOneLeft0 {
\find(mul(Z(1(#)),i))
\replacewith(i) 
\heuristics(polySimp_elimOneLeft, polySimp_expand)
Choices: {}}</entry>
<entry key="concrete_eq_2">concrete_eq_2 {
\find(equiv(false,b))
\replacewith(not(b)) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="concrete_eq_1">concrete_eq_1 {
\find(equiv(true,b))
\replacewith(b) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="ifSkipThen">ifSkipThenConditionInBlock {
\find(#allmodal ( (modal operator))\[{ ..  {#loc=false;}if (#loc)
    #s0
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..  {#loc=false;} ... }\] (post)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="same_boxes_right">same_boxes_right {
\assumes ([]==&gt;[\[{ .. #s ... }\] (post)]) 
\find(==&gt;\[{ .. #s ... }\] (post1))
\add []==&gt;[\[{ .. #s ... }\] (or(post,post1))] 

Choices: {programRules:Java}}</entry>
<entry key="false_to_not_true">false_to_not_true {
\find(equals(bo,FALSE))
\replacewith(not(equals(bo,TRUE))) 
\heuristics(concrete, simplify_boolean)
Choices: {}}</entry>
<entry key="translateJavaShiftLeft">translateJavaShiftLeftLong {
\find(javaShiftLeftLong(left,right))
\replacewith(shiftleftJlong(left,right)) 
\heuristics(javaIntegerSemantics)
Choices: {intRules:javaSemantics,programRules:Java}}</entry>
<entry key="wd_String_IndexOfStr">wd_String_IndexOfStr {
\find(wd(clIndexOfCl(l,i,c)))
\replacewith(and(and(and(and(wd(c),wd(i)),wd(l)),leq(Z(0(#)),i)),lt(add(i,seqLen(c)),seqLen(l)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="notLeft">notLeft {
\find(not(b)==&gt;)
\replacewith([]==&gt;[b]) 
\heuristics(alpha)
Choices: {}}</entry>
<entry key="emptyModality">emptyModalityDiamondTransaction {
\find(diamond_transaction(post))
\replacewith(false) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="subSeqSingletonEQ">subSeqSingletonEQ {
\assumes ([equals(seqSingleton(x),EQ)]==&gt;[]) 
\find(seqSub(EQ,Z(0(#)),Z(1(#))))
\replacewith(seqSingleton(x)) 
\heuristics(concrete)
Choices: {sequences:on}}</entry>
<entry key="multiply_eq">multiply_eq {
\find(equals(multLeft,multRight)==&gt;)
\add [equals(mul(multLeft,multFac),mul(multRight,multFac))]==&gt;[] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="ifthenelse_to_or_left2">ifthenelse_to_or_left2 {
\find(not(equals(if-then-else(phi,then,else),t)))
\replacewith(and(or(not(phi),not(equals(then,t))),or(phi,not(equals(else,t))))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: {}}</entry>
<entry key="polySimp_pullOutFactor1b">polySimp_pullOutFactor1b {
\find(add(add(i0,pullOutCommon),mul(pullOutCommon,pullOutRight)))
\replacewith(add(i0,mul(pullOutCommon,add(Z(1(#)),pullOutRight)))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: {}}</entry>
<entry key="diamondToBox">diamondToBoxTransaction {
\find(diamond_transaction\[{ .. #s ... }\] (post))
\replacewith(not(box_transaction\[{ .. #s ... }\] (not(post)))) 
\heuristics(boxDiamondConv)
Choices: {programRules:Java}}</entry>
<entry key="sortsDisjoint2">sortsDisjoint2 {
\find(equals(x,y))
\varcond(\not\sub(Null, H), \disjointModuloNull(G, H), )
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="sortsDisjoint1">sortsDisjoint1 {
\find(equals(x,y))
\varcond(\not\sub(Null, G), \disjointModuloNull(G, H), )
\replacewith(false) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="polySimp_rightDist">polySimp_rightDist {
\find(mul(distCoeff,add(distSummand0,distSummand1)))
\replacewith(add(mul(distCoeff,distSummand0),mul(distSummand1,distCoeff))) 
\heuristics(polySimp_dist, polySimp_expand)
Choices: {}}</entry>
<entry key="polySimp_homoEq">polySimp_homoEq {
\find(equals(homoLeft,homoRight))
\replacewith(equals(add(homoRight,mul(homoLeft,Z(neglit(1(#))))),Z(0(#)))) 
\heuristics(notHumanReadable, polySimp_homo, polySimp_expand)
Choices: {}}</entry>
<entry key="regExConcatOptRight">regExConcatOptRight {
\find(match(regExConcat(rexp1,opt(rexp2)),string))
\replacewith(or(match(rexp1,string),match(regExConcat(rexp1,rexp2),string))) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="equalityToSelect">equalityToSelect {
\find(equals(h,h2))
\varcond(\notFreeIn(fv (variable), h2 (Heap term)), \notFreeIn(fv (variable), h (Heap term)), \notFreeIn(ov (variable), h2 (Heap term)), \notFreeIn(ov (variable), h (Heap term)))
\replacewith(all{ov (variable)}(all{fv (variable)}(equals(any::select(h,ov,fv),any::select(h2,ov,fv))))) 
\heuristics(semantics_blasting)
Choices: {programRules:Java}}</entry>
<entry key="replace_char_RANGE">replace_char_RANGE {
\find(char_RANGE)
\replacewith(Z(6(3(5(5(6(#))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="lesser than distinction">less_than_comparison_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#se0&lt;#se1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(lt(#se0,#se1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="moduloIntFixpointInline">moduloIntFixpointInline {
\find(moduloInt(t))
\replacewith(if-then-else(inInt(t),t,moduloInt(t))) 
\heuristics(defOps_expandModulo)
Choices: {intRules:javaSemantics}}</entry>
<entry key="rotate_and">rotate_and {
\find(and(b,and(c,d)))
\replacewith(and(c,and(b,d))) 

Choices: {}}</entry>
<entry key="postdecrement_assignment_attribute">postdecrement_assignment_attribute {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=#e.#attribute--; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#lhs0 (program LeftHandSide))), \new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#typeof(#lhs0) #v1 = #v.#attribute;#v.#attribute=(#typeof(#attribute))(#v.#attribute-1);#lhs0=#v1; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="wd_F_Logical_Op_Cond_Form">wd_F_Logical_Op_Cond_Form {
\find(F(if-then-else(a,b,c)))
\replacewith(or(or(and(T(a),F(b)),and(F(a),F(c))),and(F(b),F(c)))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="seqDef_induction_lower">seqDef_induction_lower {
\find(seqDef{uSub (variable)}(from,to,t))
\varcond(\notFreeIn(uSub (variable), to (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqConcat(if-then-else(lt(from,to),seqSingleton(subst{uSub (variable)}(from,t)),seqEmpty),seqDef{uSub (variable)}(add(from,Z(1(#))),to,t))) 

Choices: {sequences:on}}</entry>
<entry key="eqSeqDef">eqSeqDef {
\find(equals(s,seqDef{i (variable)}(l,u,a)))
\varcond(\notFreeIn(iv (variable), a (any term)), \notFreeIn(iv (variable), u (int term)), \notFreeIn(iv (variable), l (int term)), \notFreeIn(iv (variable), s (Seq term)))
\replacewith(and(equals(seqLen(s),seqLen(seqDef{i (variable)}(l,u,a))),all{iv (variable)}(imp(and(leq(Z(0(#)),iv),lt(iv,seqLen(s))),equals(any::seqGet(s,iv),any::seqGet(seqDef{i (variable)}(l,u,a),iv)))))) 
\heuristics(simplify_enlarging)
Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="tryCatchFinallyThrow">tryCatchFinallyThrow {
\find(#allmodal ( (modal operator))\[{ .. try {throw #se;#slist} catch (#t #v0) {
    #slist1
  }
  #cs               finally {
    #slist2
  }
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. if (#se==null) {
                           try {
      throw  new  java.lang.NullPointerException ();
    }                            catch (#t #v0) {
      #slist1
    }
    #cs                           finally {
      #slist2
    }
  }
  else 
    if (#se instanceof #t) {
                           try {
        #t #v0;
        #v0=(#t)#se;
        #slist1
      }                           finally {
        #slist2
      }
    }
    else  {
                           try {
        throw  #se;
      }
      #cs                           finally {
        #slist2
      }
    }
 ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="activeUse">activeUseCharCast {
\find(#allmodal ( (modal operator))\[{ .. #sv=(char)#seByteShortIntLong; ... }\] (post))
\varcond(\new(#v0 (program Variable), \typeof(#sv (program StaticVariable))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#sv) #v0 = (char)#seByteShortIntLong;@(#sv)=#v0; ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {initialisation:disableStaticInitialisation,programRules:Java}}</entry>
<entry key="polySimp_pullOutFactor0b">polySimp_pullOutFactor0b {
\find(add(add(i0,mul(pullOutCommon,pullOutLeft)),mul(pullOutCommon,pullOutRight)))
\replacewith(add(i0,mul(pullOutCommon,add(pullOutLeft,pullOutRight)))) 
\heuristics(polySimp_pullOutFactor, polySimp_expand)
Choices: {}}</entry>
<entry key="predecrement_attribute">predecrement_attribute {
\find(#allmodal ( (modal operator))\[{ .. --#e.#attribute; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#v.#attribute=(#typeof(#attribute))(#v.#attribute-1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="concatRepeatContraction3Sym">concatRepeatContraction3Sym {
\find(regExConcat(regEx(seqEmpty),repeat(rexp,nTimes)))
\replacewith(repeat(rexp,nTimes)) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="box_true">box_true {
\find(#box ( (modal operator))\[{ .. #s ... }\] (true))
\replacewith(true) 
\heuristics(modal_tautology)
Choices: {programRules:Java}}</entry>
<entry key="wd_Logical_Op_OrSC">wd_Logical_Op_OrSC {
\find(WD(or(a,b)&lt;&lt;l (termLabel)&gt;&gt;))
\varcond(\hasLabel (l (termLabel), SC), )
\replacewith(and(WD(a),imp(not(a),WD(b)))) 
\heuristics(simplify)
Choices: {wdOperator:L,wdChecks:on}}</entry>
<entry key="commuteIntersection_2">commuteIntersection_2 {
\find(intersect(intersect(s,commLeft),commRight))
\replacewith(intersect(intersect(s,commRight),commLeft)) 
\heuristics(cnf_setComm)
Choices: {programRules:Java}}</entry>
<entry key="allFieldsSubsetOf">allFieldsSubsetOf {
\assumes ([subset(allFields(o),s)]==&gt;[]) 
\find(elementOf(o,f,s))
\sameUpdateLevel\replacewith(true) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="elim_double_block">elim_double_block_8 {
\find(#allmodal ( (modal operator))\[{ ..  {do#swhile ( #e );
  }
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. do#swhile ( #e );
 ... }\] (post)) 

Choices: {programRules:Java}}</entry>
<entry key="polySimp_addAssoc">polySimp_addAssoc {
\find(add(addAssocPoly0,add(addAssocPoly1,addAssocMono)))
\replacewith(add(add(addAssocPoly0,addAssocPoly1),addAssocMono)) 
\heuristics(polySimp_addAssoc, polySimp_expand)
Choices: {}}</entry>
<entry key="selectOfStore">selectOfStore {
\find(beta::select(store(h,o,f,x),o2,f2))
\replacewith(if-then-else(and(and(equals(o,o2),equals(f,f2)),not(equals(f,java.lang.Object::&lt;created&gt;))),beta::cast(x),beta::select(h,o2,f2))) 
\heuristics(semantics_blasting)
Choices: {programRules:Java}}</entry>
<entry key="seqDef_empty">seqDef_empty {
\find(seqDef{uSub (variable)}(from,idx,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), idx (int term)), \notFreeIn(uSub (variable), from (int term)))
\replacewith(seqEmpty) ;
\add []==&gt;[leq(idx,from)] 

Choices: {sequences:on}}</entry>
<entry key="int_diff_minus_eq">int_diff_minus_eq {
\find(sub(i0,neg(i1)))
\replacewith(add(i0,i1)) 

Choices: {}}</entry>
<entry key="applyEq_or_gen3">applyEq_or_gen3 {
\find(or(or(b,not(equals(applyEqLeft,applyEqOther))),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(or(b,not(equals(applyEqRight,applyEqOther))),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="polySimp_sepPosMonomial">polySimp_sepPosMonomial {
\find(equals(add(sepResidue,sepPosMono),Z(0(#))))
\replacewith(equals(sepPosMono,mul(sepResidue,Z(neglit(1(#)))))) 
\heuristics(notHumanReadable, polySimp_balance, polySimp_directEquations)
Choices: {}}</entry>
<entry key="applyEq_or_gen2">applyEq_or_gen2 {
\find(or(not(equals(applyEqLeft,applyEqOther)),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(not(equals(applyEqRight,applyEqOther)),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="mult_eq_1_iff">mult_eq_1_iff {
\find(equals(mul(i0,i1),Z(1(#))))
\replacewith(or(and(equals(i0,Z(1(#))),equals(i1,Z(1(#)))),and(equals(i0,Z(neglit(1(#)))),equals(i1,Z(neglit(1(#))))))) 

Choices: {}}</entry>
<entry key="applyEq_or_gen1">applyEq_or_gen1 {
\find(or(or(b,equals(applyEqLeft,applyEqOther)),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(or(b,equals(applyEqRight,applyEqOther)),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="applyEq_or_gen0">applyEq_or_gen0 {
\find(or(equals(applyEqLeft,applyEqOther),not(equals(applyEqLeft,applyEqRight))))
\replacewith(or(equals(applyEqRight,applyEqOther),not(equals(applyEqLeft,applyEqRight)))) 
\heuristics(apply_equations_andOr)
Choices: {}}</entry>
<entry key="less_add_one">less_add_one {
\find(lt(i0,i1))
\replacewith(lt(add(i0,Z(1(#))),add(i1,Z(1(#))))) 

Choices: {}}</entry>
<entry key="returnPermission_slice_split">returnPermission_slice_split {
\find(returnPermission(from,to,slice(consPermissionOwnerList(from,owners),slice(owners,p))))
\add []==&gt;[and(not(equals(from,to)),checkPermissionOwner(to,Z(0(#)),owners))] ;
\replacewith(slice(owners,returnPermission(from,to,p))) 
\heuristics(simplify)
Choices: {permissions:on}}</entry>
<entry key="apply_eq_monomials_rigid">apply_eq_monomials_rigid {
\assumes ([equals(applyEqDivisorr,i0r)]==&gt;[]) 
\find(applyEqDividend)
\replacewith(add(mul(#divideMonomials(applyEqDividend,applyEqDivisorr),add(i0r,mul(applyEqDivisorr,Z(neglit(1(#)))))),applyEqDividend)) 
\heuristics(notHumanReadable, apply_equations, polySimp_applyEqRigid)
Choices: {}}</entry>
<entry key="defMapRemove">defMapRemove {
\find(mapRemove(m,key))
\varcond(\notFreeIn(vy (variable), key (any term)), \notFreeIn(vy (variable), m (Map term)))
\replacewith(mapForeach{vy (variable)}(if-then-else(and(inDomain(m,vy),not(equals(vy,key))),TRUE,FALSE),mapGet(m,vy))) 

Choices: {}}</entry>
<entry key="hideAuxiliaryEq">hideAuxiliaryEq {
\find(equals(result,auxiliarySK)==&gt;)
\addrules [replaceKnownAuxiliaryConstant {
\find(auxiliarySK)
\inSequentState\replacewith(result) 
\heuristics(concrete)
Choices: {}}] \replacewith([]==&gt;[]) 
\heuristics(hide_auxiliary_eq)
Choices: {programRules:Java}}</entry>
<entry key="binary_AND">compound_binary_AND_2 {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#e&amp;#nse; ... }\] (post))
\varcond(\new(#v1 (program Variable), \typeof(#nse (program NonSimpleExpression))), \new(#v0 (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v0 = #e;#typeof(#nse) #v1 = #nse;#lhs=#v0&amp;#v1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="mod_axiom">mod_axiom {
\find(mod(divNum,divDenom))
\replacewith(add(divNum,mul(mul(div(divNum,divDenom),Z(neglit(1(#)))),divDenom))) 
\heuristics(notHumanReadable, defOps_mod)
Choices: {integerSimplificationRules:full}}</entry>
<entry key="repeatAxiom">repeatAxiom {
\find(match(repeat(rexp,nTimes),string))
\varcond(\notFreeIn(endIdx (variable), string (Seq term)), \notFreeIn(endIdx (variable), nTimes (int term)), \notFreeIn(endIdx (variable), rexp (RegEx term)))
\replacewith(if-then-else(lt(nTimes,Z(0(#))),false,if-then-else(equals(nTimes,Z(0(#))),equals(string,empty),exists{endIdx (variable)}(and(and(and(geq(endIdx,Z(0(#))),leq(endIdx,seqLen(string))),match(rexp,seqSub(string,Z(0(#)),endIdx))),match(repeat(rexp,sub(nTimes,Z(1(#)))),seqSub(string,endIdx,seqLen(string)))))))) 

Choices: {Strings:on}}</entry>
<entry key="eq_and_2">eq_and_2 {
\find(and(and(psi,phi),phi))
\replacewith(and(psi,phi)) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="inEqSimp_or_subsumption7">inEqSimp_or_subsumption7 {
\find(or(or(b,geq(subsumLeft,subsumRightSmaller)),equals(subsumLeft,subsumRightBigger)))
\replacewith(or(or(b,geq(subsumLeft,subsumRightSmaller)),and(gt(subsumRightSmaller,subsumRightBigger),equals(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="greater than distinction">greater_than_comparison_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#se0&gt;#se1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(gt(#se0,#se1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_or_subsumption6">inEqSimp_or_subsumption6 {
\find(or(geq(subsumLeft,subsumRightSmaller),equals(subsumLeft,subsumRightBigger)))
\replacewith(or(geq(subsumLeft,subsumRightSmaller),and(gt(subsumRightSmaller,subsumRightBigger),equals(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_subsumption5">inEqSimp_or_subsumption5 {
\find(or(or(b,equals(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger)))
\replacewith(or(or(b,and(gt(subsumRightSmaller,subsumRightBigger),equals(subsumLeft,subsumRightSmaller))),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_subsumption4">inEqSimp_or_subsumption4 {
\find(or(equals(subsumLeft,subsumRightSmaller),leq(subsumLeft,subsumRightBigger)))
\replacewith(or(and(gt(subsumRightSmaller,subsumRightBigger),equals(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_subsumption3">inEqSimp_or_subsumption3 {
\find(or(or(b,geq(subsumLeft,subsumRightSmaller)),geq(subsumLeft,subsumRightBigger)))
\replacewith(or(or(b,geq(subsumLeft,subsumRightSmaller)),and(geq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_subsumption2">inEqSimp_or_subsumption2 {
\find(or(geq(subsumLeft,subsumRightSmaller),geq(subsumLeft,subsumRightBigger)))
\replacewith(or(geq(subsumLeft,subsumRightSmaller),and(geq(subsumRightSmaller,subsumRightBigger),geq(subsumLeft,subsumRightBigger)))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="inEqSimp_or_subsumption1">inEqSimp_or_subsumption1 {
\find(or(or(b,leq(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger)))
\replacewith(or(or(b,and(geq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightSmaller))),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="wd_LocSet_Pred_ElementOf_Static">wd_LocSet_Pred_ElementOf_Static {
\find(WD(elementOf(o,f,l)))
\varcond(\isStaticField(f (Field term)), )
\replacewith(and(and(and(wd(o),wd(f)),wd(l)),equals(o,null))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="inEqSimp_or_subsumption0">inEqSimp_or_subsumption0 {
\find(or(leq(subsumLeft,subsumRightSmaller),leq(subsumLeft,subsumRightBigger)))
\replacewith(or(and(geq(subsumRightSmaller,subsumRightBigger),leq(subsumLeft,subsumRightSmaller)),leq(subsumLeft,subsumRightBigger))) 
\heuristics(notHumanReadable, inEqSimp_andOr_subsumption, inEqSimp_forNormalisation)
Choices: {}}</entry>
<entry key="wellFormedMemsetObjectEQ">wellFormedMemsetObjectEQ {
\assumes ([equals(memset(h,s,x),EQ)]==&gt;[]) 
\find(wellFormed(EQ))
\sameUpdateLevel\succedentPolarity\replacewith(or(and(wellFormed(h),equals(x,null)),equals(boolean::select(h,x,java.lang.Object::&lt;created&gt;),TRUE))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="neg_literal">neg_literal {
\find(neg(Z(iz)))
\replacewith(Z(neglit(iz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="wd_LocSet_InfiniteUnion">wd_LocSet_InfiniteUnion2 {
\find(wd(infiniteUnion{a (variable), b (variable)}(l)))
\replacewith(all{a (variable)}(all{b (variable)}(wd(l)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="readPermission">readPermission {
\find(readPermission(p))
\replacewith(readPermissionObject(currentThread,p)) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="inDomainOfMapUpdate">inDomainOfMapUpdate {
\find(inDomain(mapUpdate(m,key,value),x))
\replacewith(or(inDomain(m,x),equals(x,key))) 
\heuristics(simplify_enlarging)
Choices: {}}</entry>
<entry key="preincrement_attribute">preincrement_attribute {
\find(#allmodal ( (modal operator))\[{ .. ++#e.#attribute; ... }\] (post))
\varcond(\new(#v (program Variable), \typeof(#e (program Expression))))
\replacewith(#allmodal ( (modal operator))\[{ .. #typeof(#e) #v = #e;#v.#attribute=(#typeof(#attribute))(#v.#attribute+1); ... }\] (post)) 
\heuristics(simplify_expression)
Choices: {programRules:Java}}</entry>
<entry key="replace_short_MAX">replace_short_MAX {
\find(short_MAX)
\replacewith(Z(7(6(7(2(3(#))))))) 
\heuristics(defOps_expandRanges)
Choices: {}}</entry>
<entry key="simplifySelectOfStoreEQ">simplifySelectOfStoreEQ {
\assumes ([equals(store(h,o,f,x),EQ)]==&gt;[]) 
\find(equals(beta::select(EQ,o2,f2),sk)==&gt;)
\addrules [replaceKnownSelect {
\find(beta::select(EQ,o2,f2))
\inSequentState\replacewith(sk) 
\heuristics(concrete)
Choices: {}}] \replacewith([equals(if-then-else(and(and(equals(o,o2),equals(f,f2)),not(equals(f,java.lang.Object::&lt;created&gt;))),beta::cast(x),beta::select(h,o2,f2)),sk)]==&gt;[]) 
\heuristics(simplify_select)
Choices: {programRules:Java}}</entry>
<entry key="removeZeros">removeZeros {
\find(clRemoveZeros(l))
\replacewith(if-then-else(or(equals(l,seqEmpty),equals(int::seqGet(l,Z(0(#))),C(8(4(#))))),l,clRemoveZeros(seqSub(l,Z(1(#)),seqLen(l))))) 
\heuristics(integerToString)
Choices: {Strings:on}}</entry>
<entry key="cutUpperBound">cutUpperBound {
\assumes ([all{v (variable)}(or(or(or(leq(v,Z(neglit(1(#)))),geq(v,j)),b),a))]==&gt;[]) 
\find(==&gt;or(or(leq(k,Z(neglit(1(#)))),geq(k,i)),c))
\add [not(equals(k,i))]==&gt;[] ;
\add [equals(k,i)]==&gt;[] 
\heuristics(loopInvariant)
Choices: {}}</entry>
<entry key="unusedLabel">unusedLabel {
\find(#allmodal ( (modal operator))\[{ .. #lb:#s ... }\] (post))
\varcond(\not\freeLabelIn (#lb,#s), )
\replacewith(#allmodal ( (modal operator))\[{ .. #s ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="seqNPermComp">seqNPermComp {
\assumes ([and(seqNPerm(s2),equals(seqLen(s1),seqLen(s2)))]==&gt;[]) 
\find(seqNPerm(s1)==&gt;)
\varcond(\notFreeIn(u (variable), s2 (Seq term)), \notFreeIn(u (variable), s1 (Seq term)))
\add [seqNPerm(seqDef{u (variable)}(Z(0(#)),seqLen(s1),int::seqGet(s1,int::seqGet(s2,u))))]==&gt;[] 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="disjointAndSubset_6">disjointAndSubset_6 {
\assumes ([equals(intersect(s2,s1),empty)]==&gt;[]) 
\find(subset(s4,union(s3,s2))==&gt;)
\add [imp(equals(intersect(s1,s3),empty),equals(intersect(s1,s4),empty))]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="equal_literals">equal_literals {
\find(equals(Z(iz),Z(jz)))
\replacewith(#eq(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="disjointAndSubset_5">disjointAndSubset_5 {
\assumes ([equals(intersect(s2,s1),empty)]==&gt;[]) 
\find(subset(s4,union(s2,s3))==&gt;)
\add [imp(equals(intersect(s1,s3),empty),equals(intersect(s1,s4),empty))]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="disjointAndSubset_4">disjointAndSubset_4 {
\assumes ([equals(intersect(s1,s2),empty)]==&gt;[]) 
\find(subset(s4,union(s3,s2))==&gt;)
\add [imp(equals(intersect(s1,s3),empty),equals(intersect(s1,s4),empty))]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="wd_RegEx_Concat">wd_RegEx_Concat {
\find(wd(regExConcat(a,b)))
\replacewith(and(wd(a),wd(b))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="disjointAndSubset_3">disjointAndSubset_3 {
\assumes ([equals(intersect(s1,s2),empty)]==&gt;[]) 
\find(subset(s4,union(s2,s3))==&gt;)
\add [imp(equals(intersect(s1,s3),empty),equals(intersect(s1,s4),empty))]==&gt;[] 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="selectOfCreate">selectOfCreate {
\find(beta::select(create(h,o),o2,f))
\replacewith(if-then-else(and(equals(o,o2),not(equals(o,null))),if-then-else(equals(f,java.lang.Object::&lt;created&gt;),beta::cast(TRUE),beta::defaultValue),beta::select(h,o2,f))) ;
\replacewith(if-then-else(and(and(equals(o,o2),not(equals(o,null))),equals(f,java.lang.Object::&lt;created&gt;)),beta::cast(TRUE),beta::select(h,o2,f))) 
\heuristics(semantics_blasting)
Choices: {programRules:Java}}</entry>
<entry key="wd_RegEx_Opt">wd_RegEx_Opt {
\find(wd(opt(a)))
\replacewith(wd(a)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="orJintInInt">orJintInInt {
\find(orJint(left,right))
\sameUpdateLevel\add [inInt(orJint(left,right))]==&gt;[] 
\heuristics(userTaclets1)
Choices: {}}</entry>
<entry key="wd_LocSet_Intersect">wd_LocSet_Intersect {
\find(wd(intersect(l,s)))
\replacewith(and(wd(l),wd(s))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="seqIndexOf">seqIndexOf {
\find(seqIndexOf(s,t))
\varcond(\notFreeIn(m (variable), t (any term)), \notFreeIn(m (variable), s (Seq term)), \notFreeIn(n (variable), t (any term)), \notFreeIn(n (variable), s (Seq term)))
\add [imp(exists{n (variable)}(and(and(leq(Z(0(#)),n),lt(n,seqLen(s))),equals(any::seqGet(s,n),t))),and(and(and(leq(Z(0(#)),seqIndexOf(s,t)),lt(seqIndexOf(s,t),seqLen(s))),equals(any::seqGet(s,seqIndexOf(s,t)),t)),all{m (variable)}(imp(and(leq(Z(0(#)),m),lt(m,seqIndexOf(s,t))),not(equals(any::seqGet(s,m),t))))))]==&gt;[] 

Choices: {sequences:on}}</entry>
<entry key="bsum_empty">bsum_empty {
\find(bsum{uSub (variable)}(i0,i1,t))
\sameUpdateLevel\varcond(\notFreeIn(uSub (variable), i1 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(Z(0(#))) ;
\add []==&gt;[leq(i1,i0)] 

Choices: {integerSimplificationRules:full}}</entry>
<entry key="wd_Numerical_Op_Mod">wd_Numerical_Op_JavaModOverFlow {
\find(wd(javaModOverFlow(a,b)))
\replacewith(and(and(wd(a),wd(b)),not(equals(b,Z(0(#)))))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="ifElseSkipElse">ifElseSkipElseConditionInBlock {
\find(#allmodal ( (modal operator))\[{ ..  {#loc=true;}if (#loc)
    #s0
  else 
    #s1
 ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ ..  {#loc=true;}#s0 ... }\] (post)) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="wd_F_Resolve">wd_F_Resolve {
\find(F(a))
\varcond(\not\hasSubFormulas (a (formula)), )
\replacewith(and(WD(a),not(a))) 
\heuristics(simplify)
Choices: {wdOperator:Y,wdChecks:on}}</entry>
<entry key="elim_forall19">elim_forall19 {
\find(all{Gvar (variable)}(imp(and(equals(Hterm,Gvar),psi),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),imp(psi,phi)),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall18">elim_forall18 {
\find(all{Gvar (variable)}(imp(and(equals(Gvar,Hterm),psi),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),imp(psi,phi)),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall17">elim_forall17 {
\find(all{Gvar (variable)}(imp(and(equals(subGterm,Gvar),psi),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,imp(psi,phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall16">elim_forall16 {
\find(all{Gvar (variable)}(imp(and(equals(Gvar,subGterm),psi),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,imp(psi,phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall15">elim_forall15 {
\find(all{Gvar (variable)}(imp(and(psi,equals(Hterm,Gvar)),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),imp(psi,phi)),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall14">elim_forall14 {
\find(all{Gvar (variable)}(imp(and(psi,equals(Gvar,Hterm)),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),imp(psi,phi)),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="seqPermSym">seqPermSym {
\find(seqPerm(s1,s2))
\replacewith(seqPerm(s2,s1)) 

Choices: {moreSeqRules:on,sequences:on}}</entry>
<entry key="elim_forall13">elim_forall13 {
\find(all{Gvar (variable)}(imp(and(psi,equals(subGterm,Gvar)),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,imp(psi,phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall12">elim_forall12 {
\find(all{Gvar (variable)}(imp(and(psi,equals(Gvar,subGterm)),phi)))
\varcond(\notFreeIn(Gvar (variable), subGterm (subG term)))
\replacewith(subst{Gvar (variable)}(subGterm,imp(psi,phi))) 
\heuristics(elimQuantifier)
Choices: {}}</entry>
<entry key="elim_forall11">elim_forall11 {
\find(all{Gvar (variable)}(imp(equals(Hterm,Gvar),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="elementOfAllObjects">elementOfAllObjects {
\find(elementOf(o,f,allObjects(f2)))
\replacewith(equals(f,f2)) 
\heuristics(concrete)
Choices: {programRules:Java}}</entry>
<entry key="elim_forall10">elim_forall10 {
\find(all{Gvar (variable)}(imp(equals(Gvar,Hterm),phi)))
\varcond(\notFreeIn(Gvar (variable), Hterm (H term)))
\replacewith(or(subst{Gvar (variable)}(G::cast(Hterm),phi),equals(G::instance(Hterm),FALSE))) 
\heuristics(elimQuantifierWithCast, elimQuantifier)
Choices: {}}</entry>
<entry key="repeatPlusAxiom">repeatPlusAxiom {
\find(match(repeatPlus(rexp),string))
\varcond(\notFreeIn(nTimes (variable), string (Seq term)), \notFreeIn(nTimes (variable), rexp (RegEx term)))
\replacewith(exists{nTimes (variable)}(and(geq(nTimes,Z(1(#))),match(repeat(rexp,nTimes),string)))) 
\heuristics(simplify)
Choices: {Strings:on}}</entry>
<entry key="sign_case_distinction">sign_case_distinction {
\add [geq(signCasesLeft,Z(1(#)))]==&gt;[] ;
\add [equals(signCasesLeft,Z(0(#)))]==&gt;[] ;
\add [leq(signCasesLeft,Z(neglit(1(#))))]==&gt;[] 
\heuristics(inEqSimp_signCases)
Choices: {}}</entry>
<entry key="readPermissionOwe2">readPermissionOwe2 {
\find(readPermissionOwe2(o1,o2,p))
\varcond(\notFreeIn(pp (variable), o2 (java.lang.Object term)), \notFreeIn(ol (variable), o2 (java.lang.Object term)), \notFreeIn(ol0 (variable), o2 (java.lang.Object term)), \notFreeIn(pp (variable), o1 (java.lang.Object term)), \notFreeIn(ol (variable), o1 (java.lang.Object term)), \notFreeIn(ol0 (variable), o1 (java.lang.Object term)), \notFreeIn(pp (variable), p (Permission term)), \notFreeIn(ol (variable), p (Permission term)), \notFreeIn(ol0 (variable), p (Permission term)))
\replacewith(exists{ol0 (variable)}(exists{ol (variable)}(exists{pp (variable)}(equals(p,slice(ol0,slice(consPermissionOwnerList(o1,consPermissionOwnerList(o2,ol)),pp))))))) 
\heuristics(simplify_enlarging)
Choices: {permissions:on}}</entry>
<entry key="eq_eq">eq_eq {
\find(equiv(phi,phi))
\replacewith(true) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="inInt">inInt {
\find(inInt(i))
\replacewith(true) 
\heuristics(concrete)
Choices: {intRules:arithmeticSemanticsIgnoringOF,programRules:Java}}</entry>
<entry key="exRight">exRight {
\find(==&gt;exists{u (variable)}(b))
\add []==&gt;[subst{u (variable)}(t,b)] 
\heuristics(gamma)
Choices: {}}</entry>
<entry key="precOfPairInt">precOfPairInt {
\find(prec(pair(a,x),b))
\replacewith(and(leq(Z(0(#)),a),lt(a,b))) 
\heuristics(simplify)
Choices: {}}</entry>
<entry key="expand_unaryMinusJint">expand_unaryMinusJint {
\find(unaryMinusJint(i))
\replacewith(moduloInt(neg(i))) 
\heuristics(defOps_expandJNumericOp)
Choices: {}}</entry>
<entry key="wd_Seq_NPermInv">wd_Seq_NPermInv {
\find(wd(seqNPermInv(s)))
\replacewith(and(wd(s),seqNPerm(s))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wd_Seq_IndexOf">wd_Seq_IndexOf {
\find(wd(seqIndexOf(s,t)))
\replacewith(and(wd(s),wd(t))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="eq_or_2">eq_or_2 {
\find(or(or(psi,phi),phi))
\replacewith(or(psi,phi)) 
\heuristics(concrete)
Choices: {}}</entry>
<entry key="cnf_eqv">cnf_eqv {
\find(equiv(phi,psi))
\replacewith(and(or(phi,not(psi)),or(not(phi),psi))) 
\heuristics(notHumanReadable, cnf_expandIfThenElse, conjNormalForm)
Choices: {}}</entry>
<entry key="pow_literals">pow_literals {
\find(pow(Z(iz),Z(jz)))
\replacewith(#pow(Z(iz),Z(jz))) 
\heuristics(simplify_literals)
Choices: {}}</entry>
<entry key="boxToDiamond">boxToDiamondTransaction {
\find(box_transaction\[{ .. #s ... }\] (post))
\replacewith(not(diamond_transaction\[{ .. #s ... }\] (not(post)))) 
\heuristics(boxDiamondConv)
Choices: {programRules:Java}}</entry>
<entry key="applyOnRigidFormula">applyOnRigidFormula {
\find(update-application(u,phi))
\varcond(\applyUpdateOnRigid(u (update), phi (formula), result (formula)), )
\replacewith(result) 
\heuristics(update_apply)
Choices: {}}</entry>
<entry key="wd_LocSet_Singleton_Arr">wd_LocSet_Singleton_Arr {
\find(wd(singleton(o,arr(i))))
\varcond( \not \isArray(o (java.lang.Object term)), )
\replacewith(and(and(and(and(wd(o),wd(i)),not(equals(o,null))),leq(Z(0(#)),i)),lt(i,length(o)))) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="equality comparison">equality_comparison_simple {
\find(#allmodal ( (modal operator))\[{ .. #lhs=#se0==#se1; ... }\] (post))
\replacewith(update-application(elem-update(#lhs (program LeftHandSide))(if-then-else(equals(#se0,#se1),TRUE,FALSE)),#allmodal(post))) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="concatRepeatContraction3">concatRepeatContraction3 {
\find(regExConcat(repeat(rexp,nTimes),regEx(seqEmpty)))
\replacewith(repeat(rexp,nTimes)) 
\heuristics(concrete)
Choices: {Strings:on}}</entry>
<entry key="eval_order_iterated_assignments">iterated_assignments_11 {
\find(#allmodal ( (modal operator))\[{ .. #lhs0=#lhs1^=#e; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. #lhs1=(#typeof(#lhs1))(#lhs1^#e);#lhs0=#lhs1; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="throwLabel">throwLabel {
\find(#allmodal ( (modal operator))\[{ .. #lb:throw #se; ... }\] (post))
\replacewith(#allmodal ( (modal operator))\[{ .. throw #se; ... }\] (post)) 
\heuristics(simplify_prog)
Choices: {programRules:Java}}</entry>
<entry key="wd_RegEx">wd_RegEx {
\find(wd(regEx(s)))
\replacewith(wd(s)) 
\heuristics(simplify)
Choices: {wdChecks:on}}</entry>
<entry key="wellFormedStoreLocSet">wellFormedStoreLocSet {
\find(wellFormed(store(h,o,f,x)))
\succedentPolarity\varcond(\fieldType(f (Field term), alpha), \sub(LocSet, alpha), )
\replacewith(and(wellFormed(h),createdInHeap(x,h))) 
\heuristics(simplify_enlarging)
Choices: {programRules:Java}}</entry>
<entry key="inEqSimp_ltRight">inEqSimp_ltRight {
\find(==&gt;lt(i,i0))
\replacewith([geq(add(mul(Z(neglit(1(#))),i0),i),Z(0(#)))]==&gt;[]) 
\heuristics(notHumanReadable, inEqSimp_moveLeft, inEqSimp_expand)
Choices: {}}</entry>
<entry key="definitionAllElementsOfArray">definitionAllElementsOfArray {
\find(allElementsOfArray(h,array,singleton(o,f)))
\varcond(\notFreeIn(j (variable), f (Field term)), \notFreeIn(j (variable), o (java.lang.Object term)), \notFreeIn(j (variable), array (java.lang.Object term)), \notFreeIn(j (variable), h (Heap term)))
\replacewith(infiniteUnion{j (variable)}(if-then-else(and(leq(Z(0(#)),j),lt(j,length(array))),singleton(java.lang.Object::select(h,array,arr(j)),f),empty))) 
\heuristics(simplify)
Choices: {programRules:Java}}</entry>
<entry key="regExConcatRepeatLeft">regExConcatRepeatLeft {
\find(match(regExConcat(repeat(rexp1,nTimes),rexp2),string))
\varcond(\notFreeIn(string2 (variable), nTimes (int term)), \notFreeIn(string2 (variable), rexp2 (RegEx term)), \notFreeIn(string2 (variable), rexp1 (RegEx term)), \notFreeIn(string2 (variable), string (Seq term)), \notFreeIn(string1 (variable), nTimes (int term)), \notFreeIn(string1 (variable), rexp2 (RegEx term)), \notFreeIn(string1 (variable), rexp1 (RegEx term)), \notFreeIn(string1 (variable), string (Seq term)))
\replacewith(if-then-else(equals(nTimes,Z(0(#))),match(rexp2,string),if-then-else(lt(nTimes,Z(0(#))),false,exists{string1 (variable)}(exists{string2 (variable)}(and(and(match(repeat(rexp1,nTimes),string1),match(rexp2,string2)),equals(string,seqConcat(string1,string2)))))))) 
\heuristics(simplify)
Choices: {Strings:on}}</entry>
<entry key="bsum_induction_lower2">bsum_induction_lower2 {
\find(bsum{uSub (variable)}(i0,i2,t))
\varcond(\notFreeIn(uSub (variable), i2 (int term)), \notFreeIn(uSub (variable), i0 (int term)))
\replacewith(sub(bsum{uSub (variable)}(sub(i0,Z(1(#))),i2,t),if-then-else(lt(sub(i0,Z(1(#))),i2),subst{uSub (variable)}(sub(i0,Z(1(#))),t),Z(0(#))))) 

Choices: {integerSimplificationRules:full}}</entry>
</properties>
