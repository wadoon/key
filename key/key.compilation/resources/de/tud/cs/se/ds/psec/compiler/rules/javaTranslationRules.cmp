// IMPORTANT
// =========
//
// For any translation that should *not* be a final one in the
// execution, remember to call the next node by "#child-1".


// ###########################
// ### Splitting and loops ###
// ###########################

if_split_1_child {
	\taclets ("ifElseSplit", "ifSplit")
	\condition (#num-children == 1)
	\translation (
		#child-1
	)
}

if_split_2_children {
	\taclets ("ifElseSplit", "ifSplit")
	\condition (#num-children == 2)
	\translation (
		\load (#se)
		IFEQ l0
		#child-1
		l0: #child-2
	)
}

// This rule applies when the loop is the last statement in the program
while_loop_1_child {
	\taclets ("removeLoopForCompilation", "removeLoopForCompilationVoid")
	\condition (#num-children == 1)
	\translation (
		GOTO l1
		l2: #child-1
		l1: \load (#se)
		IFNE l2
		RETURN
	)
}

while_loop_2_children {
	\taclets ("removeLoopForCompilation", "removeLoopForCompilationVoid")
	\condition (#num-children == 2)
	\translation (
		GOTO l1
		l2: #child-1
		l1: \load (#se)
		IFNE l2
		#child-2
	)
}

// ####################
// ### Method Calls ###
// ####################

/*
methodCallWithAssignment {
	\taclets ("methodCallWithAssignment")
	\translation (
		ALOAD //TODO
		#child-1
	)
}
*/

//TODO This rule is currently only supporting methods
// in the same object ("this"-calls) that are non-void.
// Also, only INVOKEVIRTUAL calls are supported.
// Moreover, we so far only support methods returning
// primitive types.
operation_contract {
	\taclets ("Use Operation Contract")
	\translation (
		\load_params (#actualParams)
		\methodCall (#pm)
		ISTORE #actualResult
		#child-1
	)
}

method_body_expand {
	\taclets ("methodBodyExpand")
	\translation (
		\methodCall (#mb)
		#child-1
	)
}

method_call_super {
	\taclets ("methodCallSuper")
	\translation (
		// This SE taclet is translated to a methodBodyExpand,
		// and can therefore be ignored
		#child-1
	)
}

// ###############
// ### Returns ###
// ############### 

return_int {
	\taclets ("methodCallReturn")
	\condition (isSimpleType(#se))
	\translation (
		\load (#se)
		IRETURN
	)
}

return_void {
	\taclets ("methodCallEmptyReturn")
	\translation (
		RETURN
	)
}

// ###############
// ### Objects ###
// ###############

assignment_write_attribute_this {
	\taclets ("assignment_write_attribute_this")
	\translation (
		\load (#v)
		\load (#se)
		PUTFIELD #v.#a
		#child-1
	)
}

// For assignment_read_attribute, we ignore
// the possible NullPointerExceptions so far.
// In the future, we could try to prevent those.
assignment_read_attribute_object {
	\taclets ("assignment_read_attribute", "assignment_read_attribute_this")
	\condition (!isSimpleType(#v0))
	\translation (
		\load (#v)
		GETFIELD #v.#a
		ASTORE #v0
		#child-1
	)
}

assignment_read_attribute_primitive {
	\taclets ("assignment_read_attribute", "assignment_read_attribute_this")
	\condition (isSimpleType(#v0))
	\translation (
		\load (#v)
		GETFIELD #v.#a
		ISTORE #v0
		#child-1
	)
}

// Here we could make use of the fact that we
// already know whether a cast will succeed since
// the second sub branch of this taclet will be
// closed then.
check_cast {
	\taclets ("reference_type_cast")
	\translation (
		\load (#se)
		CHECKCAST #npit
		ASTORE #lhs
		#child-1
	)
}

equality_comparison_objects {
	\taclets ("equality_comparison_simple")
	\condition (!isSimpleType(#se0))
	\condition (!isSimpleType(#se1))
	\translation (
		ALOAD #se0
		ALOAD #se1
	    IF_ACMPNE l1
	    ICONST_1
	    GOTO l2
	    l1: ICONST_0
	    l2: ISTORE #lhs
	    #child-1
	)
}

// #######################
// ### Primitive Types ###
// #######################

equality_comparison_primitive {
	\taclets ("equality_comparison_simple")
	\condition (isSimpleType(#se0))
	\condition (isSimpleType(#se1))
	\translation (
		\load (#se0)
	    \load (#se1)
	    IF_ICMPNE l1
	    ICONST_1
	    GOTO l2
	    l1: ICONST_0
	   	l2: ISTORE #lhs
	   	#child-1
	)
}

// ################
// ### Booleans ###
// ################

xor {
	\taclets ("compound_assignment_xor_simple")
	\translation (
		\load (#seBool0)
	    \load (#seBool1)
	    IXOR
	    ISTORE #lhs
		#child-1
	)
}

// ##########################
// ### Integer arithmetic ###
// ##########################

assignment_no_result_var {
	\taclets ("assignment")
	\condition (!isResultVar(#se))
	\translation (
		\load (#se)
		ISTORE #loc
		#child-1
	)
}

assignment_result_var {
	\taclets ("assignment")
	\condition (isResultVar(#se))
	\translation (
		#child-1
	)
}

assignment_subtraction_int {
	\taclets ("assignmentSubtractionInt")
	\translation (
		\load (#seCharByteShortInt0)
		\load (#seCharByteShortInt1)
		ISUB
		ISTORE #loc
		#child-1
	)
}

assignment_addition_int {
	\taclets ("assignmentAdditionInt")
	\translation (
		\load (#seCharByteShortInt0)
		\load (#seCharByteShortInt1)
		IADD
		ISTORE #loc
		#child-1
	)
}

compound_assignment {
	\taclets ("compound_assignment_1_new")
	\translation (
		\load (#seBool)
		IFEQ l1
		ICONST_0
		GOTO l2
		l1: ICONST_1
		l2: ISTORE #lhs
		#child-1
	)
}

less_than_comparison {
	\taclets ("less_than_comparison_simple")
	\translation (
		\load (#se0)
		\load (#se1)
		IF_ICMPGE l1
		ICONST_1
		GOTO l2
		l1: ICONST_0
		l2: ISTORE #lhs
		#child-1
	)
}

greater_than_comparison {
	\taclets ("greater_than_comparison_simple")
	\translation (
		\load (#se0)
		\load (#se1)
		IF_ICMPLE l1
		ICONST_1
		GOTO l2
		l1: ICONST_0
		l2: ISTORE #lhs
		#child-1
	)
}

unary_minus_int {
	\taclets ("unaryMinusInt")
	\translation (
		\load (\negate (#seCharByteShortInt))
		ISTORE #loc
		#child-1
	)
}