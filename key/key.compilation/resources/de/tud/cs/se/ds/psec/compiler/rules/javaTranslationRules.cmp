// ###########################
// ### Splitting and loops ###
// ###########################

if_split_1_child {
	\taclets ("ifElseSplit", "ifSplit")
	\condition (#num-children == 1)
	\translation (
		#child-1
	)
}

if_split_2_children {
	\taclets ("ifElseSplit", "ifSplit")
	\condition (#num-children == 2)
	\translation (
		\load (#se)
		IFEQ l0
		#child-1
		l0: #child-2
	)
}

// This rule applies when the loop is the last statement in the program
while_loop_1_child {
	\taclets ("removeLoopForCompilation", "removeLoopForCompilationVoid")
	\condition (#num-children == 1)
	\translation (
		GOTO l1
		l2: #child-1
		l1: \load (#se)
		IFNE l2
		RETURN
	)
}

while_loop_2_children {
	\taclets ("removeLoopForCompilation", "removeLoopForCompilationVoid")
	\condition (#num-children == 2)
	\translation (
		GOTO l1
		l2: #child-1
		l1: \load (#se)
		IFNE l2
		#child-2
	)
}

// ###############
// ### Returns ###
// ############### 

// TODO Check that really an int is returned!!!
return_int {
	\taclets ("methodCallReturn")
	\translation (
		\load (#se)
		IRETURN
	)
}

return_void {
	\taclets ("methodCallEmptyReturn")
	\translation (
		RETURN
	)
}

// ##########################
// ### Integer arithmetic ###
// ##########################

assignment {
	\taclets ("assignment")
	\translation (
		\load (#se)
		ISTORE #loc
		#child-1
	)
}

assignment_subtraction_int {
	\taclets ("assignmentSubtractionInt")
	\translation (
		\load (#seCharByteShortInt0)
		\load (#seCharByteShortInt1)
		ISUB
		ISTORE #loc
		#child-1
	)
}

assignment_addition_int {
	\taclets ("assignmentAdditionInt")
	\translation (
		\load (#seCharByteShortInt0)
		\load (#seCharByteShortInt1)
		IADD
		ISTORE #loc
		#child-1
	)
}

compound_assignment {
	\taclets ("compound_assignment_1_new")
	\translation (
		\load (#seBool)
		IFEQ l1
		ICONST_0
		GOTO l2
		l1: ICONST_1
		l2: ISTORE #lhs
		#child-1
	)
}

equality_comparison {
	\taclets ("equality_comparison_simple")
	\translation (
		\load (#se0)
	    \load (#se1)
	    IF_ICMPNE l1
	    ICONST_1
	    GOTO l2
	    l1: ICONST_0
	   	l2: ISTORE #lhs
	   	#child-1
	)
}

greater_than_comparison {
	\taclets ("greater_than_comparison_simple")
	\translation (
		\load (#se0)
		\load (#se1)
		IF_ICMPLE l1
		ICONST_1
		GOTO l2
		l1: ICONST_0
		l2: ISTORE #lhs
		#child-1
	)
}

unary_minus_int {
	\taclets ("unaryMinusInt")
	\translation (
		\load (\negate (#seCharByteShortInt))
		ISTORE #loc
		#child-1
	)
}