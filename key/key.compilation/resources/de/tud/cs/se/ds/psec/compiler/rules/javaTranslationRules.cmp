// IMPORTANT
// =========
//
// For any translation that should *not* be a final one in the
// execution, remember to call the next node by "#child-1".


// #################
// ### Splitting ###
// #################

if_split_1_child {
	\taclets ("ifElseSplit", "ifSplit")
	\condition (#num-children == 1)
	\translation (
		#child-1
	)
}

if_split_2_children {
	\taclets ("ifElseSplit", "ifSplit")
	\condition (#num-children == 2)
	\translation (
		\load (#se)
		IFEQ l0
		#child-1
		l0: #child-2
	)
}

// #############
// ### Loops ###
// #############

while_loop_by_invariant {
	\taclets ("Loop (Scope) Invariant")
	\condition (#num-children == 2)
	\translation (
		#child-2
	)
}

loop_scope_idx_initialization {
	\taclets ("assignment")
	\condition (isBeforeLoopScope)
	\translation (
		\newGlobalLabel (\name (#loc, "_entry"))
		\newGlobalLabel (\name (#loc, "_exit"))
		
		\globalLabel (\name (#loc, "_entry")): #child-1
	)
}

loop_scope_idx_true {
	\taclets ("assignment")
	\condition (strEquals (#se, "true"))
	\translation (
		\globalLabel (\name (#loc, "_exit")): #child-1
	)
}

unlabeledContinueIndexedLoopScope {
	\taclets ("unlabeledContinueIndexedLoopScope")
	\translation (
		GOTO \globalLabel (\name (#lhs, "_entry"))
	)
}

// ####################
// ### Method Calls ###
// ####################

// TODO We so far only support methods returning
// primitive types.
//NOTE We could also take into account the other branches
// generated by the contract application, like Pre and NullReference. Then,
// the compiler could e.g. point out that the object the
// method is called on could be null (or more complex things).
operation_contract_nonstatic_nonvoid_nonsuper {
	\taclets ("Use Operation Contract")
	\condition (!isStatic(#pm))
	\condition (!isVoid(#pm))
	\condition (!isConstructor(#pm))
	\condition (!isSuperMethod(#pm, #methodBeingCompiled))
	\translation (
		ALOAD #actualSelf
		\load_params (#actualParams)
		INVOKEVIRTUAL #pm
		\store (#actualResult)
		#child-1
	)
}

operation_contract_nonstatic_nonvoid_super {
	\taclets ("Use Operation Contract")
	\condition (!isStatic(#pm))
	\condition (!isVoid(#pm))
	\condition (!isConstructor(#pm))
	\condition (isSuperMethod(#pm, #methodBeingCompiled))
	\translation (
		ALOAD #actualSelf
		\load_params (#actualParams)
		INVOKESPECIAL #pm
		\store (#actualResult)
		#child-1
	)
}

operation_contract_constructor_field_store {
	\taclets ("Use Operation Contract")
	\condition (isConstructor(#pm))
	\condition (isFieldReference(#actualResult))
	\translation (
		ALOAD 0
		NEW #containerType
		DUP
		\load_params (#actualParams)
		INVOKESPECIAL #pm
		\store (#actualResult)
		#child-1
	)
}

operation_contract_constructor_var_store {
	\taclets ("Use Operation Contract")
	\condition (isConstructor(#pm))
	\condition (!isFieldReference(#actualResult))
	\translation (
		NEW #containerType
		DUP
		\load_params (#actualParams)
		INVOKESPECIAL #pm
		\store (#actualResult)
		#child-1
	)
}

operation_contract_nonstatic_void_nonsuper {
	\taclets ("Use Operation Contract")
	\condition (!isStatic(#pm))
	\condition (isVoid(#pm))
	\condition (!isConstructor(#pm))
	\condition (!isSuperMethod(#pm, #methodBeingCompiled))
	\translation (
		ALOAD #actualSelf
		\load_params (#actualParams)
		INVOKEVIRTUAL #pm
		#child-1
	)
}

operation_contract_nonstatic_void_super {
	\taclets ("Use Operation Contract")
	\condition (!isStatic(#pm))
	\condition (isVoid(#pm))
	\condition (!isConstructor(#pm))
	\condition (isSuperMethod(#pm, #methodBeingCompiled))
	\translation (
		ALOAD #actualSelf
		\load_params (#actualParams)
		INVOKESPECIAL #pm
		#child-1
	)
}

operation_contract_static_nonvoid {
	\taclets ("Use Operation Contract")
	\condition (isStatic(#pm))
	\condition (!isVoid(#pm))
	\condition (!isConstructor(#pm))
	\translation (
		\load_params (#actualParams)
		INVOKESTATIC #pm
		\store (#actualResult)
		#child-1
	)
}

operation_contract_static_void {
	\taclets ("Use Operation Contract")
	\condition (isStatic(#pm))
	\condition (isVoid(#pm))
	\condition (!isConstructor(#pm))
	\translation (
		\load_params (#actualParams)
		INVOKESTATIC #pm
		#child-1
	)
}

method_call_super_constructor {
	\taclets ("superRemoveForCompilation")
	\condition (isConstructor (#mn))
	\translation (
		ALOAD 0
		\load_params (#selist)
		\superCall (#mn, #selist)
		#child-1
	)
}

// ###############
// ### Returns ###
// ###############

return_int_simple_type {
	\taclets ("methodCallReturn")
	\condition (isSimpleType(#se))
	\translation (
		\load (#se)
		IRETURN
	)
}

return_int_object_type {
	\taclets ("methodCallReturn")
	\condition (!isSimpleType(#se))
	\translation (
		\load (#se)
		ARETURN
	)
}

return_void {
	\taclets ("methodCallEmptyReturn")
	\translation (
		RETURN
	)
}

// ###############
// ### Objects ###
// ###############

assignment_write_attribute_this_no_result_var {
	\taclets ("assignment_write_attribute", "assignment_write_attribute_this")
	\condition (!isResultVar(#se))
	\translation (
		\load (#v)
		\load (#se)
		PUTFIELD #a
		#child-1
	)
}

assignment_write_attribute_this_result_var {
	\taclets ("assignment_write_attribute", "assignment_write_attribute_this")
	\condition (isResultVar(#se))
	\translation (
		#child-1
	)
}

// For assignment_read_attribute, we ignore
// the possible NullPointerExceptions so far.
// In the future, we could try to prevent those.
assignment_read_attribute {
	\taclets ("assignment_read_attribute", "assignment_read_attribute_this")
	\translation (
		\load (#v)
		GETFIELD #a
		\store (#v0)
		#child-1
	)
}

// Here we could make use of the fact that we
// already know whether a cast will succeed since
// the second sub branch of this taclet will be
// closed then.
check_cast {
	\taclets ("reference_type_cast")
	\translation (
		\load (#se)
		CHECKCAST #npit
		ASTORE #lhs
		#child-1
	)
}

equality_comparison_objects {
	\taclets ("equality_comparison_simple")
	\condition (!isSimpleType(#se0))
	\condition (!isSimpleType(#se1))
	\translation (
		\load (#se0)
		\load (#se1)
	    IF_ACMPNE l1
	    ICONST_1
	    GOTO l2
	    l1: ICONST_0
	    l2: ISTORE #lhs
	    #child-1
	)
}

// ###############
// ### Strings ###
// ###############

string_assgn {
	\taclets ("stringAssignment")
	\translation (
		LDC #slit
		ASTORE #v
		#child-1
	)
}

string_concat_int_exp_left {
	\taclets ("stringConcatIntExpLeft")
	\translation (
		NEW java/lang/StringBuilder
    	DUP
	    \load (#seLeft)
	    INVOKESTATIC java/lang/String.valueOf(I)Ljava/lang/String;
	    INVOKESPECIAL java/lang/StringBuilder.<init>(Ljava/lang/String;)V
	    \load (#sstrRight)
	    INVOKEVIRTUAL java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;
	    INVOKEVIRTUAL java/lang/StringBuilder.toString()Ljava/lang/String;
	    \store (#v)
		#child-1
	)
}

// #######################
// ### Primitive Types ###
// #######################

equality_comparison_primitive {
	\taclets ("equality_comparison_simple")
	\condition (isSimpleType(#se0))
	\condition (isSimpleType(#se1))
	\translation (
		\load (#se0)
	    \load (#se1)
	    IF_ICMPNE l1
	    ICONST_1
	    GOTO l2
	    l1: ICONST_0
	   	l2: ISTORE #lhs
	   	#child-1
	)
}

// ################
// ### Booleans ###
// ################

xor {
	\taclets ("compound_assignment_xor_simple")
	\translation (
		\load (#seBool0)
	    \load (#seBool1)
	    IXOR
	    ISTORE #lhs
		#child-1
	)
}

// ##########################
// ### Integer arithmetic ###
// ##########################

assignment_no_result_var {
	\taclets ("assignment")
	\condition (!isResultVar(#se))
	\translation (
		\load (#se)
		\store (#loc)
		#child-1
	)
}

assignment_result_var {
	\taclets ("assignment")
	\condition (isResultVar(#se))
	\translation (
		#child-1
	)
}

assignment_subtraction_int {
	\taclets ("assignmentSubtractionInt")
	\translation (
		\load (#seCharByteShortInt0)
		\load (#seCharByteShortInt1)
		ISUB
		ISTORE #loc
		#child-1
	)
}

assignment_addition_int {
	\taclets ("assignmentAdditionInt")
	\translation (
		\load (#seCharByteShortInt0)
		\load (#seCharByteShortInt1)
		IADD
		ISTORE #loc
		#child-1
	)
}

compound_assignment {
	\taclets ("compound_assignment_1_new")
	\translation (
		\load (#seBool)
		IFEQ l1
		ICONST_0
		GOTO l2
		l1: ICONST_1
		l2: ISTORE #lhs
		#child-1
	)
}

less_than_comparison {
	\taclets ("less_than_comparison_simple")
	\translation (
		\load (#se0)
		\load (#se1)
		IF_ICMPGE l1
		ICONST_1
		GOTO l2
		l1: ICONST_0
		l2: ISTORE #lhs
		#child-1
	)
}

greater_than_comparison {
	\taclets ("greater_than_comparison_simple")
	\translation (
		\load (#se0)
		\load (#se1)
		IF_ICMPLE l1
		ICONST_1
		GOTO l2
		l1: ICONST_0
		l2: ISTORE #lhs
		#child-1
	)
}

unary_minus_int {
	\taclets ("unaryMinusInt")
	\translation (
		\load (#seCharByteShortInt)
		INEG
		ISTORE #loc
		#child-1
	)
}