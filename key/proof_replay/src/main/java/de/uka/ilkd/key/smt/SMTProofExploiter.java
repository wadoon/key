package de.uka.ilkd.key.smt;

import de.uka.ilkd.key.logic.Namespace;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.proof.Proof;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeProperty;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import java.util.*;

public class SMTProofExploiter {
    private final Map<String, Term> skMap = new HashMap<>();
    protected String smtOutput;
    protected final Goal original;
    protected final Proof proof;

    // translation needs to be aware of the context, i.e. the bound variables at the current
    // translation context (contained in SMTExprInContext)!
    protected final Map<SMTExprInContext, Term> translationToTermMap;

    private final ParseTreeProperty<Namespace<NamedParserRuleContext>>
        namespaces = new ParseTreeProperty<>();

    // HashMap is linked to make debugging easier
    private final Map<String, SMTProofParser.ProofsexprContext> symbolTable = new LinkedHashMap<>();

    /**
     * the current "main goal" of the proof
     */
    protected Goal goal;
    protected ParseTree tree;
    protected SMTProofParser.ProofsexprContext proofStart;

    public SMTProofExploiter(SMTProblem problem) {
        goal = problem.getGoal();
        original = goal;
        proof = goal.proof();
        translationToTermMap = new LinkedHashMap<>();
    }

    public ParseTreeProperty<Namespace<NamedParserRuleContext>> getNamespaces() {
        return namespaces;
    }

    public ParseTree getTree() {
        return tree;
    }

    public SMTProofParser.ProofsexprContext getProofStart() {
        return proofStart;
    }

    protected SMTProofParser.SmtoutputContext parse(String s) {
        return parse(CharStreams.fromString(s));
    }

    private SMTProofParser.SmtoutputContext parse(CharStream input) {
        SMTProofLexer lexer = new SMTProofLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        SMTProofParser parser = new SMTProofParser(tokens);

        BailOutErrorStrategy errorStrategy = new BailOutErrorStrategy();
        parser.setErrorHandler(errorStrategy);
        return parser.smtoutput();
    }

    protected void findProofStart() {
        // Determine start of actual proof (root of proof tree, last rule application before
        // deriving contradiction). This is the first proofsexpr we encounter that is not inside
        // a var_binding.
        // tree must be walked after parsing (rulename would always be null otherwise)
        ParseTreeWalker.DEFAULT.walk(new SMTProofBaseListener() {
            @Override
            public void enterProofsexpr(SMTProofParser.ProofsexprContext ctx) {
                if (ctx.rulename != null) {
                    String rulename = ctx.rulename.getText();
                    if (!rulename.equals("let")) {
                        if (proofStart == null) {
                            // this could be the first real proof node ...
                            proofStart = ctx;
                        }
                    }
                }
                super.exitProofsexpr(ctx);
            }

            @Override
            public void exitVar_binding(SMTProofParser.Var_bindingContext ctx) {
                // was inside var_binding, so not proof start
                proofStart = null;
                super.exitVar_binding(ctx);
            }
        }, tree);
    }

    public Proof getProof() {
        return proof;
    }

    public ParserRuleContext getSymbolDef(String symbol, ParserRuleContext ctx) {
        // term may be a new symbol introduced by the let binder
        Namespace<NamedParserRuleContext> ctxNS = namespaces.get(ctx);
        if (ctxNS != null) {
            NamedParserRuleContext nprc = ctxNS.lookup(symbol);
            if (nprc != null) {
                //System.out.println(symbol + " (shared proof or noproofterm)");
                return nprc.getCtx();
            }
        }
        return null;
    }

    public Term getTranslationToTerm(String smtExpr) {
        // get from root context, i.e. empty bound vars list
        SMTExprInContext exprInContext = new SMTExprInContext(smtExpr, new LinkedList<>());
        return translationToTermMap.get(exprInContext);
    }

    public void addTranslationToTerm(String smtExpr, Term keyTerm) {
        // root context -> empty list
        SMTExprInContext exprInContext = new SMTExprInContext(smtExpr, new LinkedList<>());
        translationToTermMap.put(exprInContext, keyTerm);
    }

    public void putSkolemSymbol(String symbol, Term def) {
        skMap.put(symbol, def);
    }

    public Term getSkolemSymbolDef(String symbol) {
        return skMap.get(symbol);
    }

    public static class SMTExprInContext {
        public final String smtExpr;
        public final Deque<QuantifiableVariable> boundVars;

        public SMTExprInContext(String smtExpr, Deque<QuantifiableVariable> boundVars) {
            this.smtExpr = smtExpr;
            this.boundVars = boundVars;
        }

        @Override
        public boolean equals(Object other) {
            if (this == other) {
                return true;
            }
            if (!(other instanceof SMTExprInContext)) {
                return false;
            }
            SMTExprInContext key = (SMTExprInContext) other;
            return smtExpr.equals(key.smtExpr) && boundVars.equals(key.boundVars);
        }

        @Override
        public int hashCode() {
            int result = smtExpr.hashCode();
            result = 31 * result + boundVars.hashCode();
            return result;
        }
    }
}
