package de.uka.ilkd.key.smt.quant_inst;

import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.rule.TacletApp;
import de.uka.ilkd.key.smt.*;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * This class prototypically extracts quantifier instantiations from a Z3 proof and adds the
 * instantiated formulas to the sequent (directly at the beginning of the proof). Currently, this
 * does not really work though, since the found instantiations contain many useless ones (mainly
 * because of redundant symbols in Z3), for example:<br>
 * <code><pre>(quant-inst (or (not a!41)
 *              (= (typeguard u_butler sort_S)
 *                 (instanceof u_butler sort_S)))) </pre></code> gets translated back to:<br>
 * <code> S::instanceof(u_butler)=TRUE <-> S::instanceof(u_butler)=TRUE </code>.
 *
 * @author Wolfram Pfeifer
 */
public class QuantInstExploiter extends SMTProofExploiter {
    Set<Term> instantiations = new HashSet<>();

    public QuantInstExploiter(SMTProblem problem) {
        super(problem);

        SMTSolver solver = problem.getSolvers().iterator().next();
        smtOutput = solver.getSolverOutput();
    }

    public void apply() {
        tree = parse(smtOutput);

        findProofStart();

        BindingsCollector bindingsCollector = new BindingsCollector(this);
        tree.accept(bindingsCollector);

        QuantInstExtractor extractor = new QuantInstExtractor(this, goal);
        proofStart.accept(extractor);

        for (Term inst : instantiations) {
            // for every found instantiation, add it as a cut
            TacletApp cutApp = ReplayTools.createCutApp(goal, inst);
            List<Goal> goals = ReplayTools.applyInteractive(goal, cutApp).toList();
            goal = goals.get(1);
        }
    }

    public void addInstantiation(Term inst) {
        instantiations.add(inst);
    }
}
