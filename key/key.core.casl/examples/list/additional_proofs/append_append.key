\sorts {
    Nat \extends java.lang.Object;
    /*! @defaultValue(nil) */
    NatList;
}
\functions {
    \unique Nat Nat(int);
    \unique NatList nil;
    \unique NatList cons(Nat, NatList);
    NatList append(NatList, NatList);
    NatList reverse(NatList);
    int len(NatList);
    Nat get(NatList, int);
    NatList remove(NatList, int);
}
\axioms {
    natlist_induction {
        \schemaVar \formula phi;
        \schemaVar \variable NatList base;
        \schemaVar \variable Nat first;

        \find( ==> \forall base; phi )
        \varcond( \notFreeIn(first,phi) )

        "base case": \replacewith( ==>  {\subst base; nil} phi );
        "1. case": \replacewith( ==> \forall first; \forall base;  ( phi -> {\subst base; cons(first, base)} phi ) )
    };
    natlist_ctor_split {
        \schemaVar \term NatList natlist;
        \schemaVar \skolemTerm Nat first;
        \schemaVar \skolemTerm NatList rest;
        \find(natlist) \sameUpdateLevel
        \varcond(\new(first, \dependingOn(natlist)), \new(rest, \dependingOn(natlist)))
        \replacewith(nil) \add(natlist = nil ==>);
        \replacewith(cons(first, rest)) \add(natlist = cons(first, rest) ==>)
    };
    append_nil_l {
        \schemaVar \term NatList l;
        \find( append(nil, l) )
        \replacewith( l )
    };
    append_cons_e_l1_l2 {
        \schemaVar \term NatList l1;
        \schemaVar \term NatList l2;
        \schemaVar \term Nat e;
        \find( append(cons(e, l1), l2) )
        \replacewith( cons(e, append(l1, l2)) )
    };
    reverse_nil {
        \find( reverse(nil) )
        \replacewith( nil )
    };
    reverse_cons_e_l {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \find( reverse(cons(e, l)) )
        \replacewith( append(reverse(l), cons(e, nil)) )
    };
    len_nil {
        \find( len(nil) )
        \replacewith( 0 )
    };
    len_cons_e_l {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \find( len(cons(e, l)) )
        \replacewith( 1+len(l) )
    };
    get_cons_e_l_0 {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \find( get(cons(e, l), 0) )
        \replacewith( e )
    };
    get_cons_e_l_i {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \schemaVar \term int i;
        \find( get(cons(e, l), i) )
        \replacewith( get(l, i-1) )
    };
    remove_cons_e_l_0 {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \find( remove(cons(e, l), 0) )
        \replacewith( l )
    };
    remove_cons_e_l_j {
        \schemaVar \term Nat e;
        \schemaVar \term NatList l;
        \schemaVar \term int j;
        \find( remove(cons(e, l), j) )
        \replacewith( cons(e, remove(l, j-1)) )
    };
}

\problem {
	 \forall NatList l1; \forall NatList l2; \forall  NatList l3; append(append(l1,l2), l3) = append(l1, append(l2,l3))
}