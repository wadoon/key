\sorts {
    Nat \extends java.lang.Object;
    /*! @defaultValue(tip) */
    NatSet;
}
\functions {
    \unique Nat Nat(int);
    NatSet tip;
    NatSet bin(Nat, NatSet);
    NatSet set_add(NatSet, Nat);
    NatSet remove(NatSet, Nat);
    boolean eqv(NatSet, NatSet);
    boolean contains(NatSet, Nat);
    int len(NatSet);
}
\axioms {
    natset_induction {
        \schemaVar \formula phi;
        \schemaVar \variable NatSet base;
        \schemaVar \variable Nat e;

        \find( ==> \forall base; phi )
        \varcond( \notFreeIn(e,phi) )

        "base case": \replacewith( ==>  {\subst base; tip} phi );
        "1. case": \replacewith( ==> \forall e; \forall base;  ( phi -> {\subst base; bin(e, base)} phi ) )
    };
    natset_ctor_split {
        \schemaVar \term NatSet natset;
        \schemaVar \skolemTerm Nat e;
        \schemaVar \skolemTerm NatSet els;
        \find(natset) \sameUpdateLevel
        \varcond(\new(e, \dependingOn(natset)), \new(els, \dependingOn(natset)))
        \replacewith(tip) \add(natset = tip ==>);
        \replacewith(bin(e, els)) \add(natset = bin(e, els) ==>)
    };
    eqv_tip_tip {
        \find( eqv(tip, tip) )
        \replacewith( true )
    };
    eqv_s1_s2 {
        \schemaVar \term Nat n;
        \schemaVar \term NatSet s1;
        \schemaVar \term NatSet s2;
        \find( eqv(s1, s2) )
        \replacewith( contains(s1,n) = contains(s2,n) )
    };
    eq_NatSet_n1_n2 {
        \schemaVar \term NatSet n1;
        \schemaVar \term NatSet n2;
        \find( n1 = n2 )
        \replacewith( eqv(n1, n2) )
        \heuristics( eqv )
    };
    remove_match {
    	   \schemaVar \term Nat n;
	   \schemaVar \term NatSet s;
    	   \find( remove(bin(n, s), n) )
	   \replacewith( s )
    };
    remove {
    	   \schemaVar \term Nat n1, n2;
	   \schemaVar \term NatSet s;
	   \find( remove(bin(n1, s), n2) )
	   \replacewith( bin(n1, remove(s, n2)) )
    };
}
\problem {
	 remove(bin(Nat(1), bin(Nat(2), bin(Nat(3), tip()))), Nat(2)) = bin(Nat(1), bin(Nat(3), tip()))
}