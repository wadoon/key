
Operator  (Dominic)
=======

folgende Methoden herausfaktorisieren in 

   TypeCheckingAndInferenceService: Diese Klasse in TermFactory beim Term zusammenbauen verwenden um Sorten zu bestimmen und welldefinedness zu checken

    Sort sort(ImmutableArray<Term> terms);
    boolean validTopLevel(Term term);

Ziel: Operator unabhängig vom Term und u.U. spezielle TermFactories ohne Validation (schneller)

Classes still depending on either Term or KeYJavaType
-----------------------------------------------------

- AbstractTermTransformer
- IObserverFunction
- IProgramMethod
- ProgramVariable
- LocationVariable
- ObserverFunction
- ProgramConstant
- ProgramMethod
- ProgramSV
- ProgramVariable
- SubstOp
- TermTransformer
- UpdateApplication
- WarySubstOp

New Type Checker
----------------

Example Call:

``
return TypeCheckingAndInferenceService.getTypeCheckerFor(op).sort(subs, op);
``

Term (Dominic)
====

    public boolean isContainsJavaBlockRecursive();
    public JavaBlock javaBlock();

aus allgemeinem Interface entfernen und Unterinterface JavaDLTerm einführen.


Services  (Richard)
=======

0. Services sollte noch Namespaces und ConstructionServices kapseln
1. Füge TheoryServices hinzu <- verlagere Methoden aus TypeConverter (DONE)
2. Danach TypeConverter, JavaInfo, JavaModel konsolidieren  und in JavaServices kapseln 
    - gekapselt in JavaServices (DONE)
3. Danach Services verallg. getProgramServices


Logic package
===========

0. Trennen Logik (Term, Operator) und Calculus (Sequent und co)   z.b. logic.syntax    logic.calculus
1. SchemaVariables nach rules.syntax/schema
	1a. ProgramSVSort auflösen und als einzelne Unterklassen von ProgramSV  
                  - sort bekommt wieder richtige Bedeutung und mach JavaBooleanExpression unnötig 
         1b. ProgramSV unabhängig von Java
2. TermFactory, TermBuilder verallg. mit JavaDLTermFactory etc.



 



// unwichtig

- Sorted interface: ifthenelse —> G::its
