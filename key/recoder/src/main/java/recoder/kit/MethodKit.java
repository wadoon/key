package recoder.kit;

import recoder.NamedModelElement;
import recoder.ProgramFactory;
import recoder.abstraction.ClassType;
import recoder.abstraction.Member;
import recoder.abstraction.Method;
import recoder.abstraction.Type;
import recoder.convenience.Naming;
import recoder.convenience.TreeWalker;
import recoder.java.*;
import recoder.java.declaration.*;
import recoder.java.declaration.modifier.Abstract;
import recoder.java.declaration.modifier.VisibilityModifier;
import recoder.java.expression.operator.CopyAssignment;
import recoder.java.expression.operator.New;
import recoder.java.reference.*;
import recoder.java.statement.Return;
import recoder.list.generic.ASTArrayList;
import recoder.list.generic.ASTList;
import recoder.service.*;
import recoder.util.Debug;
import recoder.util.Queue;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class MethodKit {
    public static ASTList<Expression> createArguments(ParameterContainer p) {
        int c = p.getParameterDeclarationCount();
        ASTArrayList aSTArrayList = new ASTArrayList(c);
        for (int i = 0; i < c; i++)
            aSTArrayList.add(VariableKit.createVariableReference(p.getParameterDeclarationAt(i)));
        return (ASTList<Expression>) aSTArrayList;
    }

    public static MethodReference createMethodReference(MethodDeclaration decl) {
        ProgramFactory factory = decl.getFactory();
        return factory.createMethodReference(factory.createIdentifier(decl.getName()), createArguments(decl));
    }

    public static MethodReference createMethodReference(ReferencePrefix prefix, MethodDeclaration decl) {
        ProgramFactory factory = decl.getFactory();
        return factory.createMethodReference(prefix, factory.createIdentifier(decl.getName()), createArguments(decl));
    }

    public static New createNew(ConstructorDeclaration decl) {
        return decl.getFactory().createNew(null, TypeKit.createTypeReference(decl), createArguments(decl));
    }

    public static MethodDeclaration createAbstractMethodDeclaration(MethodDeclaration decl, boolean forInterface) {
        int abstractPos;
        ProgramFactory factory = decl.getFactory();
        if (decl.isStatic())
            throw new IllegalArgumentException("A static method cannot made abstract!");
        StatementBlock body = decl.getBody();
        decl.setBody(null);
        MethodDeclaration res = decl.deepClone();
        decl.setBody(body);
        Abstract anAbstract = factory.createAbstract();
        ASTList<DeclarationSpecifier> modList = res.getDeclarationSpecifiers();
        if (modList == null) {
            abstractPos = -1;
        } else {
            abstractPos = modList.indexOf(anAbstract);
        }
        VisibilityModifier vismod = res.getVisibilityModifier();
        if (forInterface) {
            if (abstractPos >= 0)
                modList.remove(abstractPos);
            if (vismod != null)
                modList.remove(vismod);
        } else if (abstractPos < 0) {
            ASTArrayList aSTArrayList;
            if (modList == null)
                res.setDeclarationSpecifiers(aSTArrayList = new ASTArrayList(1));
            aSTArrayList.add((vismod == null) ? 0 : 1, anAbstract);
        } else {
            return res;
        }
        return res;
    }

    public static MethodDeclaration createAdapterMethod(ReferencePrefix delegationObject, MethodDeclaration method) {
        MethodDeclaration clone = method.deepClone();
        clone.setComments(new ASTArrayList(new DocComment("/** generated by createAdapterMethod */")));
        clone.setBody(new StatementBlock(new ASTArrayList()));
        MethodReference call = createMethodReference(delegationObject, method);
        clone.getBody().getBody().add(call);
        return clone;
    }

    public static ClassDeclaration createPackerClass(String packerClassName, List<ParameterDeclaration> parameters) {
        Debug.printlno("debugPackifier", "creating packer class " + packerClassName);
        JavaProgramFactory javaProgramFactory = JavaProgramFactory.getInstance();
        ASTArrayList aSTArrayList1 = new ASTArrayList();
        for (int j = 0; j < parameters.size(); j++) {
            ParameterDeclaration parameter = parameters.get(j);
            ASTArrayList aSTArrayList = new ASTArrayList();
            aSTArrayList.add(javaProgramFactory.createPublic());
            Identifier fieldName = javaProgramFactory.createIdentifier(parameter.getVariables().get(0).getName());
            FieldDeclaration fd = javaProgramFactory.createFieldDeclaration(parameter.getTypeReference(), fieldName);
            fd.setDeclarationSpecifiers(aSTArrayList);
            aSTArrayList1.add(fd);
        }
        ASTArrayList aSTArrayList2 = new ASTArrayList();
        aSTArrayList2.add(javaProgramFactory.createPublic());
        StatementBlock statements;
        ConstructorDeclaration constructor = javaProgramFactory.createConstructorDeclaration(javaProgramFactory.createPublic(), javaProgramFactory.createIdentifier(packerClassName), null, null, statements = javaProgramFactory.createStatementBlock());
        for (int i = 0; i < parameters.size(); i++) {
            ParameterDeclaration parameter = parameters.get(i);
            String paramString = parameter.getVariables().get(0).getName();
            FieldReference fieldRef = javaProgramFactory.createFieldReference(javaProgramFactory.createThisReference(), javaProgramFactory.createIdentifier(paramString));
            CopyAssignment assign = javaProgramFactory.createCopyAssignment(fieldRef, javaProgramFactory.createVariableReference(javaProgramFactory.createIdentifier(paramString)));
            statements.getBody().add(assign);
        }
        aSTArrayList1.add(constructor);
        aSTArrayList2 = new ASTArrayList();
        aSTArrayList2.add(javaProgramFactory.createPublic());
        ClassDeclaration packClass = javaProgramFactory.createClassDeclaration(aSTArrayList2, javaProgramFactory.createIdentifier(packerClassName), javaProgramFactory.createExtends(javaProgramFactory.createTypeReference(javaProgramFactory.createPackageReference(javaProgramFactory.createPackageReference(javaProgramFactory.createIdentifier("java")), javaProgramFactory.createIdentifier("lang")), javaProgramFactory.createIdentifier("Object"))), javaProgramFactory.createImplements(), aSTArrayList1);
        Debug.printlno("debugPackifier", "created packer " + packerClassName);
        return packClass;
    }

    public static List<MethodDeclaration> getGetters(SourceInfo si, FieldSpecification f) {
        Debug.assertNonnull(si, f);
        List<MethodDeclaration> res = new ArrayList<MethodDeclaration>();
        TypeDeclaration tdecl = (TypeDeclaration) f.getContainingClassType();
        if (tdecl instanceof recoder.java.declaration.InterfaceDeclaration)
            return res;
        ASTList<MemberDeclaration> aSTList = tdecl.getMembers();
        if (aSTList == null)
            return res;
        Type fieldType = si.getType(f);
        for (int i = aSTList.size() - 1; i >= 0; i--) {
            MemberDeclaration md = aSTList.get(i);
            if (md instanceof MethodDeclaration) {
                MethodDeclaration m = (MethodDeclaration) md;
                if ((fieldType instanceof recoder.abstraction.PrimitiveType) ? (
                        m.getReturnType() != fieldType) :

                        !si.isWidening(fieldType, m.getReturnType())) {
                    StatementBlock body = m.getBody();
                    if (body != null) {
                        ASTList<Statement> aSTList1 = body.getBody();
                        if (aSTList1 != null) {
                            Statement last = aSTList1.get(aSTList1.size() - 1);
                            if (last instanceof Return) {
                                Expression expr = ((Return) last).getExpression();
                                if (expr instanceof FieldReference) {
                                    FieldReference fr = (FieldReference) expr;
                                    if (si.getField(fr) == f)
                                        res.add(m);
                                }
                            }
                        }
                    }
                }
            }
        }
        return res;
    }

    public static boolean rename(ChangeHistory ch, CrossReferenceSourceInfo xr, MethodDeclaration method, String newName) {
        Debug.assertNonnull(xr, method, newName);
        Debug.assertNonnull(method.getName());
        Debug.assertBoolean(!(method instanceof ConstructorDeclaration));
        if (!newName.equals(method.getName())) {
            List<MemberReference> refs = xr.getReferences(method);
            MiscKit.rename(ch, method, newName);
            for (int i = refs.size() - 1; i >= 0; i--)
                MiscKit.rename(ch, (NamedProgramElement) refs.get(i), newName);
            return true;
        }
        return false;
    }

    public static List<Method> getRedefinedMethods(Method m) {
        Debug.assertNonnull(m);
        if (m instanceof recoder.abstraction.Constructor)
            return new ArrayList<Method>(0);
        ClassType ct = m.getContainingClassType();
        String mname = m.getName();
        List<Type> msig = m.getSignature();
        List<Method> result = new ArrayList<Method>();
        List<? extends ClassType> supers = ct.getSupertypes();
        for (int i = supers.size() - 1; i >= 0; i--) {
            List<? extends Method> meths = supers.get(i).getAllMethods();
            for (int j = meths.size() - 1; j >= 0; j--) {
                Method m2 = meths.get(j);
                if (m2.getName().equals(mname) && m2.getSignature().equals(msig))
                    result.add(m2);
            }
        }
        return result;
    }

    public static List<Method> getRedefiningMethods(CrossReferenceSourceInfo xr, Method m) {
        Debug.assertNonnull(m);
        if (m instanceof recoder.abstraction.Constructor)
            return new ArrayList<Method>(0);
        ClassType ct = m.getContainingClassType();
        String mname = m.getName();
        List<Type> msig = m.getSignature();
        List<Method> result = new ArrayList<Method>();
        List<? extends ClassType> subs = xr.getAllSubtypes(ct);
        for (int i = subs.size() - 1; i >= 0; i--) {
            List<? extends Method> meths = subs.get(i).getMethods();
            for (int j = meths.size() - 1; j >= 0; j--) {
                Method m2 = meths.get(j);
                if (m2.getName().equals(mname) && m2.getSignature().equals(msig))
                    result.add(m2);
            }
        }
        return result;
    }

    public static boolean isMain(NameInfo ni, Method m) {
        if (!m.isPublic())
            return false;
        if (!m.isStatic())
            return false;
        if (!m.getName().equals("main"))
            return false;
        if (m.getReturnType() != null)
            return false;
        List<Type> list = m.getSignature();
        if (list.size() != 1)
            return false;
        return (list.get(0) == ni.getArrayType(ni.getJavaLangString()));
    }

    public static boolean isSerializationMethod(NameInfo ni, Method m) {
        if (m.getName().equals("writeObject") && m.isPrivate() && m.getReturnType() == null && m.getSignature().size() == 1 && m.getSignature().get(0) == ni.getClassType("java.io.ObjectOutputStream"))
            return true;
        if (m.getName().equals("readObject") && m.isPrivate() && m.getReturnType() == null && m.getSignature().size() == 1 && m.getSignature().get(0) == ni.getClassType("java.io.ObjectInputStream"))
            return true;
        if (m.getName().equals("writeReplace") && m.getReturnType() == ni.getJavaLangObject() && m.getSignature().isEmpty())
            return true;
        return m.getName().equals("readResolve") && m.getReturnType() == ni.getJavaLangObject() && m.getSignature().isEmpty();
    }

    public static MethodDeclaration cloneHeader(MethodDeclaration md) {
        StatementBlock body = md.getBody();
        md.setBody(null);
        MethodDeclaration result = md.deepClone();
        md.setBody(body);
        return result;
    }

    public static Method getDefinedMethod(ClassType type, String name, List<Type> signature) {
        List<? extends Method> methods = type.getMethods();
        for (int j = methods.size() - 1; j >= 0; j--) {
            Method m = methods.get(j);
            if (name.equals(m.getName()) && signature.equals(m.getSignature()))
                return m;
        }
        return null;
    }

    public static List<Method> getRedefinedMethods(NameInfo ni, ClassType base, String name, List<Type> signature) {
        List<? extends ClassType> supers = base.getSupertypes();
        List<Method> result = new ArrayList<Method>();
        boolean hasClass = false;
        for (int i = 0; i < supers.size(); i++) {
            ClassType ct = supers.get(i);
            Method m = getDefinedMethod(ct, name, signature);
            if (m != null)
                if (!ct.isInterface()) {
                    result.add(0, m);
                    hasClass = true;
                } else {
                    result.add(m);
                }
        }
        if (!hasClass) {
            ClassType ct = base;
            do {
                ct = TypeKit.getSuperClass(ni, ct);
                Method m = getDefinedMethod(ct, name, signature);
                if (m != null) {
                    result.add(0, m);
                    break;
                }
            } while (ct != ni.getJavaLangObject());
        }
        return result;
    }

    public static Problem checkMethodRedefinition(ProgramModelInfo pmi, Method redefined, Method redefining) {
        if (redefining instanceof recoder.abstraction.Constructor)
            return null;
        if (redefined.isFinal() || redefined.getContainingClassType().isFinal())
            return new FinalOverwrite(redefined);
        if (redefined.getReturnType() != redefining.getReturnType())
            return new DifferentReturnTypeOverwrite(redefined);
        if (TypeKit.isLessVisible(redefining, redefined))
            return new MorePrivateOverwrite(redefined);
        if (!redefining.isStatic() && redefined.isStatic())
            return new NonStaticOverwrite(redefined);
        List<? extends ClassType> exceptions = redefining.getExceptions();
        if (exceptions != null) {
            List<? extends ClassType> redefinedex = redefined.getExceptions();
            if (redefinedex == null || !TypeKit.isCovered(pmi, redefinedex, exceptions))
                return new UncoveredExceptionsOverwrite(redefined);
        }
        return null;
    }

    public static Problem checkMethodDeclaration(NameInfo ni, SourceInfo si, TypeDeclaration context, MethodDeclaration candidate) {
        if (context instanceof recoder.java.declaration.InterfaceDeclaration &&
                !TypeKit.isValidInterfaceMember(candidate))
            return new IllegalInterfaceMember(candidate);
        if (candidate instanceof recoder.abstraction.Constructor) {
            if (!candidate.getName().equals(context.getName()))
                return new NameConflict(context);
        } else if (Naming.isKeyword(candidate.getName())) {
            return new IllegalName(candidate);
        }
        ASTList<MemberDeclaration> aSTList = context.getMembers();
        String name = candidate.getName();
        List<Type> signature = candidate.getSignature();
        if (aSTList != null)
            for (int j = aSTList.size() - 1; j >= 0; j--) {
                MemberDeclaration md = aSTList.get(j);
                if (md instanceof MethodDeclaration) {
                    MethodDeclaration m = (MethodDeclaration) md;
                    if (m.getName().equals(name) && m.getSignature().equals(signature))
                        return new NameConflict(m);
                }
            }
        if (candidate instanceof recoder.abstraction.Constructor)
            return null;
        List<Method> redefined = getRedefinedMethods(ni, context, name, signature);
        for (int i = 0; i < redefined.size(); i++) {
            Problem problem = checkMethodRedefinition(si, redefined.get(i), candidate);
            if (problem != null)
                return problem;
        }
        return null;
    }

    public static List<MemberReference> getReferences(CrossReferenceSourceInfo xr, Method m, NonTerminalProgramElement root, boolean scanTree) {
        Debug.assertNonnull(xr, m, root);
        List<MemberReference> result = new ArrayList<MemberReference>();
        if (scanTree) {
            TreeWalker tw = new TreeWalker(root);
            if (m instanceof recoder.abstraction.Constructor) {
                while (tw.next(ConstructorReference.class)) {
                    ConstructorReference cr = (ConstructorReference) tw.getProgramElement();
                    if (xr.getConstructor(cr) == m)
                        result.add(cr);
                }
            } else {
                while (tw.next(MethodReference.class)) {
                    MethodReference mr = (MethodReference) tw.getProgramElement();
                    if (xr.getMethod(mr) == m)
                        result.add(mr);
                }
            }
        } else {
            List<MemberReference> refs = xr.getReferences(m);
            for (int i = 0, s = refs.size(); i < s; i++) {
                MemberReference mr = refs.get(i);
                if (MiscKit.contains(root, mr))
                    result.add(mr);
            }
        }
        return result;
    }

    public static List<Method> getAllRelatedMethods(CrossReferenceSourceInfo xrsi, ClassType type, String methodName, List<Type> signature) {
        Debug.assertNonnull(xrsi, type, methodName, signature);
        RelatedMethodsHelper rmh = new RelatedMethodsHelper(xrsi, type, methodName, signature);
        return rmh.findRelatedMethods();
    }

    public static List<Method> getAllRelatedMethods(CrossReferenceSourceInfo xrsi, Method method) {
        Debug.assertNonnull(method);
        return getAllRelatedMethods(xrsi, method.getContainingClassType(), method.getName(), method.getSignature());
    }

    public static List<Method> getAllRelatedMethods(NameInfo ni, CrossReferenceSourceInfo xrsi, ClassType type, String methodName, List<Type> signature) {
        Set<ClassType> visited = new HashSet<ClassType>();
        Queue q = new Queue();
        q.enqueue(type);
        visited.add(type);
        List<Method> result = new ArrayList<Method>();
        while (!q.isEmpty()) {
            type = (ClassType) q.dequeue();
            Method m = getDefinedMethod(type, methodName, signature);
            if (m != null)
                result.add(m);
            List<Method> redefined = getRedefinedMethods(ni, type, methodName, signature);
            for (int i = redefined.size() - 1; i >= 0; i--) {
                ClassType ct = redefined.get(i).getContainingClassType();
                if (visited.add(ct))
                    q.enqueue(ct);
            }
            if (m != null || !redefined.isEmpty()) {
                List<? extends ClassType> types = xrsi.getSubtypes(type);
                for (int j = types.size() - 1; j >= 0; j--) {
                    ClassType ct = types.get(j);
                    if (visited.add(ct))
                        q.enqueue(ct);
                }
            }
        }
        return result;
    }

    private static class RelatedMethodsHelper {
        private final List<Method> methods = new ArrayList<Method>();

        private final Set<ClassType> searchedUp = new HashSet<ClassType>();

        private final Set<ClassType> searchedDown = new HashSet<ClassType>();

        private final CrossReferenceSourceInfo xrsi;

        private final ClassType starting_type;

        private final String methodName;

        private final List<Type> signature;

        public RelatedMethodsHelper(CrossReferenceSourceInfo xrsi, ClassType type, String methodName, List<Type> signature) {
            this.xrsi = xrsi;
            this.methodName = methodName;
            this.signature = signature;
            this.starting_type = type;
        }

        public List<Method> findRelatedMethods() {
            addMethodsFromSubTypes(this.starting_type);
            return this.methods;
        }

        private void addMethodsFromSubTypes(ClassType type) {
            if (!this.searchedDown.add(type))
                return;
            List<? extends ClassType> subTypes = this.xrsi.getSubtypes(type);
            if (subTypes.isEmpty()) {
                addMethodsFromSuperTypes(type);
            } else {
                for (int i = subTypes.size() - 1; i >= 0; i--) {
                    ClassType child = subTypes.get(i);
                    addMethodsFromSubTypes(child);
                }
            }
        }

        private void addMethodsFromSuperTypes(ClassType type) {
            if (!this.searchedUp.add(type))
                return;
            Method m = MethodKit.getDefinedMethod(type, this.methodName, this.signature);
            if (m != null) {
                this.methods.add(m);
                addMethodsFromSubTypes(type);
            }
            List<? extends ClassType> superTypes = type.getSupertypes();
            for (int i = superTypes.size() - 1; i >= 0; i--) {
                ClassType parent = superTypes.get(i);
                addMethodsFromSuperTypes(parent);
            }
        }
    }
}
