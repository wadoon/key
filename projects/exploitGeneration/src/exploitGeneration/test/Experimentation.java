import java.io.File;
import java.util.LinkedList;
import java.util.List;

import junit.framework.TestCase;

import org.junit.Test;

import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.collection.ImmutableSet;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.op.IProgramMethod;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
import de.uka.ilkd.key.proof.init.ProofOblInput;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.FunctionalOperationContract;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.SymbolicExecutionTreeBuilder;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
import de.uka.ilkd.key.symbolic_execution.profile.SymbolicExecutionJavaProfile;
import de.uka.ilkd.key.symbolic_execution.util.IFilter;
import de.uka.ilkd.key.symbolic_execution.util.JavaUtil;
import de.uka.ilkd.key.symbolic_execution.util.KeYEnvironment;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionEnvironment;
import de.uka.ilkd.key.ui.CustomConsoleUserInterface;

/**
 * @author Huy Do
 *
 */
public class Experimentation extends TestCase {
   @Test
   public void testSymbolicExecutionExperimentation() throws Exception {
      // Load source code
      KeYEnvironment<CustomConsoleUserInterface> env = KeYEnvironment.load(SymbolicExecutionJavaProfile.getDefaultInstance(), new File("data/simpleExample/Simple.java"), null, null);
      try {
         // Find type
         KeYJavaType type = env.getJavaInfo().getKeYJavaType("Simple");
         assertNotNull(type);
         // Find method
         ImmutableList<IProgramMethod> methods = env.getJavaInfo().getAllProgramMethods(type);
         IProgramMethod pm = JavaUtil.search(methods, new IFilter<IProgramMethod>() {
            @Override
            public boolean select(IProgramMethod element) {
               return "Simple::magic".equals(element.name().toString());
            }
         });
         assertNotNull(pm);
         // Find contract
         ImmutableSet<Contract> contracts = env.getServices().getSpecificationRepository().getContracts(pm.getContainerType(), pm);         
         Contract contract = contracts.iterator().next(); // TODO; In case of also you have multiple contracts. Select the one you need         
         ProofOblInput input = new FunctionalOperationContractPO(env.getInitConfig(), (FunctionalOperationContract)contract, true, true);
         // Create proof
         Proof proof = env.createProof(input);
         assert (proof != null);
         
         /// Configure proof for symbolic execution
         SymbolicExecutionEnvironment.configureProofForSymbolicExecution(proof,
                                                                         1000,
                                                                         false,
                                                                         false,
                                                                         false,
                                                                         false);

         // Create symbolic execution tree which contains only the start node at beginning
         SymbolicExecutionTreeBuilder builder = new SymbolicExecutionTreeBuilder(env.getMediator(),
                                                                                 proof,
                                                                                 false,
                                                                                 false);
         // Run proof
         env.getUi().startAndWaitForAutoMode(proof);
         // Update symbolic execution tree
         builder.analyse();
         List<IExecutionNode> listNodes=new LinkedList<IExecutionNode>();
         // Print symbolic execution tree
         ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(builder.getStartNode());
         while (iterator.hasNext()) {
            IExecutionNode next = iterator.next();
            System.out.println(next);
            if(next instanceof IExecutionTermination)
               listNodes.add(next.getParent());
         }
         assertTrue(listNodes.size()>0);
         //print value
         IExecutionVariable[] vars = ((IExecutionStateNode) listNodes.get(0)).getVariables();
         for(IExecutionVariable var:vars){
            System.out.println(var.getName()+" : " );
            //System.out.println(var.getParentValue());
            IExecutionValue[] values = var.getValues();            
            for(IExecutionValue value: values){
               System.out.println(value.getValueString());
            }
            
         }
         System.out.println(listNodes.get(0).getPathCondition());
         //check ExploitModel
         ExploitModel em=new ExploitModel();
         for(IExecutionNode node:listNodes){
            em.initiateExploitModelFromNode(node);
         }
        
         em.printExploitModel(1);
      }
      finally {
         if (env != null) {
            env.dispose();
         }
      }
   }
}
