import java.io.File;
import java.util.LinkedList;
import java.util.List;

import junit.framework.TestCase;

import org.junit.Test;

import de.tud.exploitgen.processing.exploit.*;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.collection.ImmutableSet;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.op.IProgramMethod;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.proof.init.ProofOblInput;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.FunctionalOperationContract;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.SymbolicExecutionTreeBuilder;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
import de.uka.ilkd.key.symbolic_execution.profile.SymbolicExecutionJavaProfile;
import de.uka.ilkd.key.symbolic_execution.util.IFilter;
import de.uka.ilkd.key.symbolic_execution.util.JavaUtil;
import de.uka.ilkd.key.symbolic_execution.util.KeYEnvironment;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionEnvironment;
import de.uka.ilkd.key.ui.CustomUserInterface;

/**
 * @author Huy Do
 *
 */
public class Experimentation extends TestCase {
   @Test
   public void testSymbolicExecutionExperimentation() throws Exception {
      // Load source code
      KeYEnvironment<CustomUserInterface> env = KeYEnvironment.load(SymbolicExecutionJavaProfile.getDefaultInstance(), new File("C:\\Implementation\\Development\\KeY\\eclipse_workspace\\exploitGenExperiment\\src\\examplesKEG\\ReferenceType.java"), null, null);
      try {
         // Find type
         KeYJavaType type = env.getJavaInfo().getKeYJavaType("examplesKEG.ReferenceType");
         assertNotNull(type);
         // Find method
         ImmutableList<IProgramMethod> methods = env.getJavaInfo().getAllProgramMethods(type);
         IProgramMethod pm = JavaUtil.search(methods, new IFilter<IProgramMethod>() {
            @Override
            public boolean select(IProgramMethod element) {
               return "examplesKEG.ReferenceType::magic".equals(element.name().toString());
            }
         });
         assertNotNull(pm);
         // Find contract
         ImmutableSet<Contract> contracts = env.getServices().getSpecificationRepository().getContracts(pm.getContainerType(), pm);         
         Contract contract = contracts.iterator().next(); // TODO; In case of also you have multiple contracts. Select the one you need         
         ProofOblInput input = new FunctionalOperationContractPO(env.getInitConfig(), (FunctionalOperationContract)contract, true, true);
         // Create proof
         Proof proof = env.createProof(input);
         assert (proof != null);
         
         /// Configure proof for symbolic execution
         SymbolicExecutionEnvironment.configureProofForSymbolicExecution(proof,
                                                                         1000,
                                                                         false,
                                                                         false,
                                                                         false,
                                                                         false);

         // Create symbolic execution tree which contains only the start node at beginning
         SymbolicExecutionTreeBuilder builder = new SymbolicExecutionTreeBuilder(env.getMediator(),
                                                                                 proof,
                                                                                 false,
                                                                                 false,false);
         // Run proof
         env.getUi().startAndWaitForAutoMode(proof);
         // Update symbolic execution tree
         builder.analyse();
         List<IExecutionNode> listNodes=new LinkedList<IExecutionNode>();
         // Print symbolic execution tree
         ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(builder.getStartNode());
         while (iterator.hasNext()) {
            IExecutionNode next = iterator.next();
            System.out.println(next);
            if(next instanceof IExecutionTermination){
               listNodes.add(next.getParent());
               print(((IExecutionStateNode<?>) next.getParent()).getVariables(), 1);
            }
         }
         /*
         assertTrue(listNodes.size()>0);
         //print(((IExecutionStateNode)listNodes.get(0)).getVariables(),1);
         //print value
         
         IExecutionVariable[] vars = ((IExecutionStateNode) listNodes.get(1)).getVariables();
         for(IExecutionVariable var:vars){
            System.out.println(var.getName()+" : " );
            //System.out.println(var.getParentValue());
            IExecutionValue[] values = var.getValues();            
            for(IExecutionValue value: values){
               System.out.println(value.getValueString());
            }
            
         }
         System.out.println(listNodes.get(0).getPathCondition());
         //check ExploitModel      
         
         ExploitModelBuilder emc=new ExploitModelBuilder(env.getServices());
         emc.initiateExploitModelFromNode(listNodes.get(0));
         emc.getExploitModel().printExploitModel(1);*/
         
        
      }
      finally {
         if (env != null) {
            env.dispose();
         }
      }
   }
   
   private void print(IExecutionVariable[] variables, int level) throws Exception {
      for (IExecutionVariable var : variables) {
         for (int i = 0; i < level; i++) {
            System.out.print('\t');
         }
         System.out.println(var.getName());
         IExecutionValue[] values = var.getValues();
         for (IExecutionValue value : values) {
            print(value.getChildVariables(), level + 1);
         }
      }
   }
}
