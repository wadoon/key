package de.tud.exploitgen.findsecret.distribution;


import de.tud.exploitgen.findsecret.distribution.gensrc.DistributionInputBaseListener;
import de.tud.exploitgen.findsecret.distribution.gensrc.DistributionInputParser;
import de.tud.exploitgen.findsecret.distribution.gensrc.DistributionInputParser.DistributionContext;
import de.tud.exploitgen.findsecret.distribution.gensrc.DistributionInputParser.Frequency_ZEROContext;
import de.tud.exploitgen.findsecret.distribution.gensrc.DistributionInputParser.Frequency_postNumContext;
import de.tud.exploitgen.findsecret.distribution.gensrc.DistributionInputParser.PartitionContext;
import de.tud.exploitgen.util.KEGConstant;

public class ANTLRDistributionListener extends DistributionInputBaseListener {	
	private DistributionTransformer transformer; //reuse transformer of iscc language

	public DistributionTransformer getTransformer() {
		return transformer;
	}

	public void setTransformer(DistributionTransformer transformer) {
		this.transformer = transformer;
	}
	
	
	
	
	@Override
	public void enterFormula(DistributionInputParser.FormulaContext ctx) {
		//System.out.println("we found formula: " + ctx.getText());
		transformer.setWorkWithValue(false);
	}
	
	
	
	@Override
	public void enterFrequency_postNum(Frequency_postNumContext ctx) {
		//System.out.println("we found frequency: " + ctx.getText());
		transformer.setWorkWithValue(true);
		transformer.add2StackTerm(ctx.getText(), true);
		
	}

	@Override
	public void enterFrequency_ZERO(Frequency_ZEROContext ctx) {
		//System.out.println("we found frequency: " + ctx.getText());
		transformer.setWorkWithValue(true);
		transformer.add2StackTerm(ctx.getText(), true);
	}

	@Override
	public void enterPartition(PartitionContext ctx) {
		transformer.initiateStackTerm();
		//System.out.println("we found partition: " + ctx.getText());
		}

	@Override
	public void exitPartition(PartitionContext ctx) {
		transformer.add2MapResult();
	}

	
	
	@Override 
	public void exitArith_expr_Minus(DistributionInputParser.Arith_expr_MinusContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.MINUS);
	}
	
	
	
	@Override 
	public void exitArith_expr_Plus(DistributionInputParser.Arith_expr_PlusContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.PLUS);
	}
	
	@Override 
	public void exitArith_term_Div(DistributionInputParser.Arith_term_DivContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.DIV);
	}
	
	@Override 
	public void exitArith_term_Mult(DistributionInputParser.Arith_term_MultContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.MULT);
	}
	
		
	@Override 
	public void exitFactor_Power(DistributionInputParser.Factor_PowerContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.POWER);
	}
	
	@Override 
	public void exitFactor_Round(DistributionInputParser.Factor_RoundContext ctx) {
		transformer.resolveStackTermByUnaryOp(KEGConstant.ROUND);
	}
	
	
	@Override public void enterFactor_floor(DistributionInputParser.Factor_floorContext ctx) {		
		
	}
	
	@Override public void exitFactor_floor(DistributionInputParser.Factor_floorContext ctx) {
		transformer.resolveStackTermByUnaryOp(KEGConstant.FLOOR);
	}
	
	
	
	//with fraction operator, we temporarily consider it as a division operator
	@Override public void exitFactor_Fraction(DistributionInputParser.Factor_FractionContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.DIV);
	}
	
	
	@Override public void enterFactor_num_mul_param(DistributionInputParser.Factor_num_mul_paramContext ctx) {		
		//get param as the second child of ctx
		transformer.add2StackTerm(ctx.getChild(1).getText(), false);
	}
	
	@Override public void exitFactor_num_mul_param(DistributionInputParser.Factor_num_mul_paramContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.MULT);
	}
	
	//add to the stack of term a term respreseting for parameter
	@Override public void enterFactor_param(DistributionInputParser.Factor_paramContext ctx) {
		transformer.add2StackTerm(ctx.getText(), false);
	}
	
	
	//add to stack of term a term representing for integer number
	@Override public void enterInt_num(DistributionInputParser.Int_numContext ctx) {
		System.out.println("int number: " + ctx.getText());
		transformer.add2StackTerm(ctx.getText(), true);
	}
	
	
	@Override 
	public void exitLogic_expr_OR(DistributionInputParser.Logic_expr_ORContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.OR);
	}
	
	
	@Override public void exitExists_expr(DistributionInputParser.Exists_exprContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.EXISTS);
	}
	
	@Override public void enterQvar_expr_param(DistributionInputParser.Qvar_expr_paramContext ctx) {
		transformer.add2StackTerm(ctx.getText(), false);
	}
	
	
	@Override public void enterQvar_expr_param_equals_expr(DistributionInputParser.Qvar_expr_param_equals_exprContext ctx) {
		//get parameter as sub(0) of ctx
		transformer.add2StackTerm(ctx.getChild(0).getText(), false);
	}
	
	@Override public void exitQvar_expr_param_equals_expr(DistributionInputParser.Qvar_expr_param_equals_exprContext ctx) {		
		transformer.resolveStackTermByBinaryOp(KEGConstant.EQ);
	}
	
	@Override public void exitLogic_term_AND(DistributionInputParser.Logic_term_ANDContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.AND);
	}
	
	
	@Override public void exitCompare_term_Greater(DistributionInputParser.Compare_term_GreaterContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.GT);
	}
	
	
	@Override public void exitCompare_term_Greater_or_equal(DistributionInputParser.Compare_term_Greater_or_equalContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.GE);
	}
	
	@Override public void exitCompare_term_Less(DistributionInputParser.Compare_term_LessContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.LT);
	}
	
	
	@Override public void exitCompare_term_Less_or_equal(DistributionInputParser.Compare_term_Less_or_equalContext ctx) {
		//System.out.println("less or equal detected! " + ctx.getText());
		transformer.resolveStackTermByBinaryOp(KEGConstant.LE);
	}
	
	
	@Override public void exitCompare_term_Equal(DistributionInputParser.Compare_term_EqualContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.EQ);
	}

	
	@Override
	public void exitMinus_Arith_expr(DistributionInputParser.Minus_Arith_exprContext ctx) {
		transformer.resolveStackTermByUnaryOp(KEGConstant.MINUS);
	}
	@Override
	public void enterCompare_term_trio(DistributionInputParser.Compare_term_trioContext ctx) {
		transformer.initStackTrioOp();	
	}
	@Override
	public void exitGreater_or_equal(DistributionInputParser.Greater_or_equalContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.GE);
	}
	@Override
	public void exitGreater(DistributionInputParser.GreaterContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.GT);	
	}
	@Override
	public void exitLess_or_equal(DistributionInputParser.Less_or_equalContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.LE);
	}
	@Override
	public void exitLess(DistributionInputParser.LessContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.LT);
	}
	@Override
	public void exitEqual(DistributionInputParser.EqualContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.EQ);
	}
	
	@Override
	public void exitCompare_term_trio(DistributionInputParser.Compare_term_trioContext ctx) {
		transformer.resolveTrioComparison();
	}

	@Override
	public void enterDistribution(DistributionContext ctx) {
		//System.out.println("we find distribution: " + ctx.getText());
	}
	
	
	
	
}
