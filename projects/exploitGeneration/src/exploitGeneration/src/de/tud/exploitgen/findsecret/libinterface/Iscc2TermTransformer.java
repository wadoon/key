package de.tud.exploitgen.findsecret.libinterface;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import de.tud.exploitgen.findsecret.libinterface.gensrc.CountingResultLexer;
import de.tud.exploitgen.findsecret.libinterface.gensrc.CountingResultParser;
import de.tud.exploitgen.findsecret.libinterface.gensrc.CountingResultParser.Arith_exprContext;
import de.tud.exploitgen.findsecret.libinterface.gensrc.CountingResultParser.ResultContext;
import de.tud.exploitgen.findsecret.libinterface.gensrc.CountingResultParser.Result_caseContext;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;

public class Iscc2TermTransformer {
	private String isccResultString;
	private TermBuilder termBuilder;
	private TermFactory termFactory;
	private Services services;
	private Map<Term, Term> mapResult;
	private List<Term> listParameters;
	//private Stack<String> stack4Translate; 
	
	private Stack<Term> stackValueTermTranslation; //stack storing term to translate value
	private Stack<Term> stackConditionTermTranslation; //stack storing term to translate condition
	
	//flag: true if we are resolving stackValueTermTranslation, false if we are resolving stackConditionTermTranslation
	private boolean workWithValue;  
	
	public Iscc2TermTransformer(String isccResult, Services services){
		this.isccResultString = isccResult;
		this.services = services;
		this.termBuilder = services.getTermBuilder();	
		this.termFactory = services.getTermFactory();
		mapResult = new HashMap<Term,Term>();
		listParameters = new LinkedList<Term>();
		//stack2Translate = new Stack<String>();
	}
	
	
	public void initiateStackTerm(){
		stackValueTermTranslation = new Stack<Term>();
		stackConditionTermTranslation = new Stack<Term>();
	}
	
	public void setWorkWithValue(boolean workWithValue) {
		this.workWithValue = workWithValue;
	}

	

	//resolve stack term basing on matched binary operator
	public void resolveStackTermByBinaryOp(int operator){
		Term factor1, factor2;
		Term synTerm;
		if(workWithValue){
			//System.out.println("stackValueTermTranslation: " + stackValueTermTranslation);
			factor2 = stackValueTermTranslation.pop();
			factor1 = stackValueTermTranslation.pop();
		}else{
			//System.out.println("stackConditionTermTranslation: " + stackConditionTermTranslation);
			factor2 = stackConditionTermTranslation.pop();
			factor1 = stackConditionTermTranslation.pop();
		}
		//System.out.println("factor1: " + factor1 );
		//System.out.println("factor2: " + factor2 );
		if (operator==OperatorList.AND){
			synTerm = termBuilder.and(factor1, factor2);			
		}
		else if(operator == OperatorList.DIV){
			synTerm = termBuilder.div(factor1, factor2);			
		}
		else if(operator == OperatorList.EQ){
			synTerm = termBuilder.equals(factor1, factor2);
		}
		else if(operator == OperatorList.EXISTS){
			if(TermParser.isEquals(factor1)){
				//extract the sub 0
				Term qvTerm = factor1.sub(0);
				QuantifiableVariable qv = new LogicVariable(new Name(qvTerm.toString()),qvTerm.sort());
				synTerm = termBuilder.ex(qv, termBuilder.and(factor1, factor2));
			}else{
				QuantifiableVariable qv = new LogicVariable(new Name(factor1.toString()),factor1.sort());
				synTerm = termBuilder.ex(qv, factor2);
			}
		}
		else if(operator == OperatorList.GE){
			synTerm = termBuilder.geq(factor1, factor2);
		}
		else if(operator == OperatorList.GT){
			synTerm = termBuilder.gt(factor1, factor2);
		}
		else if(operator == OperatorList.LE){
			synTerm = termBuilder.leq(factor1, factor2);
		}
		else if(operator == OperatorList.LT){
			synTerm = termBuilder.lt(factor1, factor2);
		}
		else if(operator == OperatorList.MINUS){
			synTerm = termBuilder.minus(factor1, factor2);
		}
		else if(operator == OperatorList.MULT){
			synTerm = termBuilder.mul(factor1, factor2);
		}
		else if(operator == OperatorList.OR){
			synTerm = termBuilder.or(factor1, factor2);
		}
		else if(operator == OperatorList.PLUS){
			synTerm = termBuilder.add(factor1, factor2);
		}
		else if(operator == OperatorList.POWER){
			synTerm = termBuilder.power(factor1, factor2);
		}else
			synTerm = null;
		
		if(synTerm!=null){
			if(workWithValue)
				stackValueTermTranslation.push(synTerm);
			else
				stackConditionTermTranslation.push(synTerm);
		}
	}
	
	//resolve stack term basing on matched unary operator
	public void resolveStackTermByUnaryOp(int operator){
		/*
		 * TODO: what should we do with floor and round: 
		 * at the moment we basically do nothing
		 * */		
	}
	
	//create a term with terminal text and add it to stack
	public void add2StackTerm(String terminalText, boolean isNumber){
		Term addTerm=null;
		if(isNumber){
			addTerm = termBuilder.zTerm(terminalText);
		}else{
			//first check in list of parameters
			for(int i=0;i< listParameters.size();i++)
				if(terminalText.equals(listParameters.get(i).toString())){
					addTerm = listParameters.get(i);
					break;
				}			
			if(addTerm==null)
				addTerm = TermUtil.createIntVarTerm(terminalText, services);
		}
		
		
		if(workWithValue){
			//System.out.println("add to stackValueTermTranslation: "+ addTerm);
			stackValueTermTranslation.push(addTerm);
		}else{
			//System.out.println("add to stackConditionTermTranslation: "+ addTerm);
			stackConditionTermTranslation.push(addTerm);
		}
	}
	
	//add pair (value: condition) created into map result
	public void add2MapResult(){
		Term value = null;
		Term condition = null;
		if(stackValueTermTranslation!=null)
			if(!stackValueTermTranslation.empty())
				value = stackValueTermTranslation.pop();
		
		if(stackConditionTermTranslation!=null)
			if(!stackConditionTermTranslation.empty())
				condition = stackConditionTermTranslation.pop();
		
		if(value!=null)
			mapResult.put(value, condition); //condition can be null
	}
	
	
	
	public void add2ListParameters(String paraName){
		Term paraTerm = TermUtil.createIntVarTerm(paraName, services);
		listParameters.add(paraTerm);
	}
	
	public String getIsccResultString() {
		return isccResultString;
	}



	public void setIsccResultString(String isccResultString) {
		this.isccResultString = isccResultString;
	}



	public TermBuilder getTermBuilder() {
		return termBuilder;
	}



	public TermFactory getTermFactory() {
		return termFactory;
	}



	public void translateIsccResult2MapTerm(){
		Map<Term, Term> resultMap = new HashMap<Term, Term>();
		CountingResultLexer lexer = new CountingResultLexer(new ANTLRInputStream(isccResultString));
		
	    // Get a list of matched tokens
	    CommonTokenStream tokens = new CommonTokenStream(lexer);	  
	    // Pass the tokens to the parser
	    CountingResultParser parser = new CountingResultParser(tokens);
	    // Specify our entry point
	    ResultContext resultContex = parser.result();
	    
	    // Walk it and attach our listener
	    
	    ParseTreeWalker walker = new ParseTreeWalker();
	    
	    ANTLRIsccResultListener listener = new ANTLRIsccResultListener();
	    listener.setTransformer(this);
	    
	    //listener.enterResult(result);
	    lexer.reset();
	    walker.walk(listener, resultContex);
	    //System.out.println("list Parameter: " + listParameters);	    
	}


	public Map<Term, Term> getMapResult() {
		return mapResult;
	}

}
