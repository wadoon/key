package de.tud.exploitgen.findsecret.barvinokinterface;
/**
 * transform a ParametricPolytope object into iscc format.
 * for example: P := [n,m] -> { [i,j] : 0 <= i <= n && i <= j <= m };
				card P;
 * */
import java.util.List;

import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConfig;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.logic.Term;

public class Term2IsccTransformer {
	
	public static String transformParaPolytope2Iscc(ParametricPolytope pp){
		String result = "";
		result += getParameters(pp)+ " -> {" + getVariables(pp) + ":" 
					+ transformExpression2String(pp.getConstraint()) + "};";
		return result;
	}
	
	
	public static String transformExpression2String(Term expression){ 	      
	      if(TermParser.isInteger(expression)){
	         return String.valueOf(TermParser.getIntegerValue(expression));
	      }
	      else if(TermParser.isLocationVariable(expression)){
	         return expression.toString();
	      }
	      else if(TermParser.isBooleanTrue(expression)){
	         return "true";
	      }
	      else if(TermParser.isBooleanFalse(expression)){
	         return "false";
	      }
	      else if(HeapHandler.isHeapSelectFunction(expression)){
	         return HeapHandler.getFieldNameOfSelect(expression, KEGConfig.SEPARATOR);                     
	      }  
	      else if(HeapHandler.isLengthFunction(expression)){
	         return HeapHandler.getVarName4LengthFunction(expression,KEGConfig.SEPARATOR);
	      }            
	      else if(TermParser.isBinaryFunction(expression)){
	         return "(" + 
	               transformExpression2String(expression.sub(0)) +
	               getBinaryOperatorString(expression) +
	               transformExpression2String(expression.sub(1)) +
	               ")";         
	      }
	      else if(TermParser.isUnaryFunction(expression)){
	         return "(" + 
	               getUnaryOperatorString(expression) +
	               transformExpression2String(expression.sub(0)) + 
	               ")";
	         
	      }
	      else if(KeYResourceHandler.isArtificialVariable(expression)){
	    	  return expression.toString();
	      }
	      else if(TermParser.isFunction(expression)){
	         return "(" +
	               
	               ")";
	      }else
	         return "";
	   }   
	
	/*
	 * set of parameters are bounded by []
	 * */
	private static String getParameters(ParametricPolytope pp){
		String result = "[";
		List<String> parameters = pp.getParameters();
		if(!parameters.isEmpty()){
			for(int i=0; i<parameters.size()-1;i++)
				result += parameters.get(i)+",";
			result += parameters.get(parameters.size()-1).toString();
		}
		result +="]";
		return result;
	}
	
	/*
	 * set of variables are bounded by []
	 * */
	private static String getVariables(ParametricPolytope pp){
		String result = "[";
		List<String> vars = pp.getVars();
		if(!vars.isEmpty()){
			for(int i=0; i<vars.size()-1;i++)
				result += vars.get(i)+",";
			result += vars.get(vars.size()-1).toString();
		}
		result +="]";
		return result;
	}
	
	
	
	/*get operation string of binary operator (+, -, *, / , >, <, <=,>=, == )*/
   private static String getBinaryOperatorString(Term expression){
      //arithmetic operators
      if(TermParser.isAddition(expression))
         return " + ";
      else if(TermParser.isSubtraction(expression))
         return " - ";
      else if(TermParser.isMultiplication(expression))
         return " * ";
      else if(TermParser.isDivision(expression))
         return " / ";
      
      //Comparison operators
      else if(TermParser.isGreaterThan(expression))
         return " > ";
      else if(TermParser.isGreaterOrEquals(expression))
         return " >= " ;
      else if(TermParser.isLessThan(expression))
         return " < ";
      else if(TermParser.isLessOrEquals(expression))
         return " <= ";
      else if(TermParser.isEquals(expression))
         return " = ";
     
      //binary logical operators
      if(TermParser.isAnd(expression))
         return " && ";
      else if(TermParser.isOr(expression))
         return " || ";      
      else   
         return "";
   } 
   
   /*get logical operator*/
   private static String getLogicalOperatorString(Term expression){
      
      //binary logical operators
      if(TermParser.isAnd(expression))
         return " && ";
      else if(TermParser.isOr(expression))
         return " || ";
      else   
         return "";
   }
   
   
   /* get operation string of unary operator (-)*/
   private static String getUnaryOperatorString(Term expression){
      if(TermParser.isIntegerNegation(expression))
         return "-";
      else if(TermParser.isUnaryMinusFunction(expression))
         return "-";
      else if (TermParser.isNot(expression))
         return "!";
      else
         return "";
   }   
   
   
}
