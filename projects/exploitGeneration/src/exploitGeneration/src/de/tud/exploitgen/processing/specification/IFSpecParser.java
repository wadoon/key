/**
 * 
 */
package de.tud.exploitgen.processing.specification;
import java.io.File;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.*;

import org.apache.commons.io.FileUtils;



/**
 * this class is used to parse specifications about information flow security in Java source code 
 * at this version, the specification's format is below:
 *! l1 l2 l3 ... ln | h1 h2 ... hm ; 
 *....
 *which means that the information flow from source: h1, h2 .. hm to destination: l1, l2, ... ln is forbidden.
 * Regular Expression is used to parse current format of specification
 * @author Huy Do
 *
 */
public class IFSpecParser {
   private File javaFile; //Java file need to be parsed
   public final String SEPARATOR = "\\|";   //destinations and sources are separated by '|'
   //regular expression of low variables (destination) in a declaration
   public final String VAR_PATTERN= "[A-Za-z_][A-Za-z0-9_.]*";
   
 //regular expression of a declaration in a specification
   public final String DECLAR_PATTERN = 
         "(?<=[!|;])" +                      //start after '!' or ';'
         "(\\s+" + VAR_PATTERN + ")+" +
         "\\s+" + SEPARATOR +                         //'|' is the separation sign, separates left part(destination: low values) and right part (source: high values)
         "(\\s+" + VAR_PATTERN +")+" +        //declarations of high variables (source),separated by blank space
         "\\s+" +                              //should have blank space before finish
         "(?=[;])";                          //finish before ';'
   
   //regular expression of information flow security specification
   public final String IFSPEC_PATTERN="\\/\\*!" +    //must start with sign '/*!' at the beginning of line
         "(" +                                     //start of a declarations
            "(\\s+" + VAR_PATTERN + ")+" +        //declarations of low variables(destination), separated by blank space
   		   "\\s+" + SEPARATOR +                        //'|' is the separation sign, separates left part(destination: low values) and right part (source: high values)
   		   "(\\s+" + VAR_PATTERN + ")+" +        //declarations of high variables (source),separated by blank space
   		   "\\s+;\\s*" +                         //';' makes the end of one declaration
   		")+" +                                      //end of a declarations      
   		"\\s+!\\*\\/";  //ended by sign '!*/' at the end of line   
  
    
          
   /**
    * @param javaFile
    */
   public IFSpecParser(File javaFile) {
      super();
      this.javaFile = javaFile;           
   }  
   
   public IFSpecParser(){
      this.javaFile=null;
   }
   
   /*
    * get all information flow security specifications in source code
    * */
   public List<String> getIFSpecifications(String input) throws IOException{      
      Pattern pattern =Pattern.compile(IFSPEC_PATTERN);    
      Matcher matcher=pattern.matcher(input);     
      List<String> result=new LinkedList<String>();           
      while(matcher.find()){
         result.add(matcher.group());
      }
      return result;      
   }
   
   /*
    * get all single declarations in a specification
    * */
   public List<String> getSingleDeclaration(String input)throws IOException{
      Pattern pattern =Pattern.compile(DECLAR_PATTERN);    
      Matcher matcher=pattern.matcher(input);     
      List<String> result=new LinkedList<String>();           
      while(matcher.find()){
         result.add(matcher.group());
      }
      return result;
   }
   
   /*
    * get low variables (destination: left phrase)
    * */
   public String getDestinationPhrase(String input){
      String[] out=input.split(SEPARATOR);
      return out[0];
   }
   
   /*
    * get high variables (source: right phrase)
    * */
   public String getSourcePhrase(String input){
      String[] out=input.split(SEPARATOR);
      return out[1];
   }
   
   /*
    * get all variables in a phrase
    * */
   public List<String> getVariables(String input){
      Pattern pattern =Pattern.compile(VAR_PATTERN);    
      Matcher matcher=pattern.matcher(input);     
      List<String> result=new LinkedList<String>();           
      while(matcher.find()){
         result.add(matcher.group());
      }
      return result;
   }
   
   /*
    * parse all specifications and return a list of IFBarrier
    * */
   public List<IFBarrier> parseSpecification2GetListBarrier() throws IOException{
      List<IFBarrier> result=new LinkedList<IFBarrier>();
      
      //get content of java source code
      String content = FileUtils.readFileToString(javaFile);
      
      //get all specifications
      List<String> specs=getIFSpecifications(content);
      
      //solve each specification
      for(String spec:specs){
         //get all single declaration in the specification
         List<String> declars =getSingleDeclaration(spec);
         //solve each declaration to get IFBarrier object
         for(String declar:declars){
            List<String> source=getVariables(getSourcePhrase(declar));
            List<String> destination=getVariables(getDestinationPhrase(declar));
            IFBarrier ifBar=new IFBarrier(source, destination);
            result.add(ifBar);
         }
      }
      return result;
   }  
   
   
}
