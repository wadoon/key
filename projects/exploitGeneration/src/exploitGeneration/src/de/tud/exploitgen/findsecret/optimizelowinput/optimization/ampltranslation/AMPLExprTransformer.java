package de.tud.exploitgen.findsecret.optimizelowinput.optimization.ampltranslation;

import de.tud.exploitgen.util.AbstractExprTransformer;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.logic.Term;

public class AMPLExprTransformer extends AbstractExprTransformer{

	@Override
	public String getBinaryOperatorString(Term expression) {
		   if(TermParser.isAddition(expression))
	          return " + ";
	       else if(TermParser.isSubtraction(expression))
	          return " - ";
	       else if(TermParser.isMultiplication(expression))
	          return " * ";
	       else if(TermParser.isDivision(expression))
	          return " / ";
	       
	       //Comparison operators
	       else if(TermParser.isGreaterThan(expression))
	          return " > ";
	       else if(TermParser.isGreaterOrEquals(expression))
	          return " >= " ;
	       else if(TermParser.isLessThan(expression))
	          return " < ";
	       else if(TermParser.isLessOrEquals(expression))
	          return " <= ";
	       else if(TermParser.isEquals(expression))
	          return " = ";
	      
	       //binary logical operators
	       if(TermParser.isAnd(expression))
	          return " and ";
	       else if(TermParser.isOr(expression))
	          return " or ";      
	       else   
	          return "";
	}

	@Override
	public String getUnaryOperatorString(Term expression) {
	  if(TermParser.isIntegerNegation(expression))
	         return "-";
	      else if(TermParser.isUnaryMinusFunction(expression))
	         return "-";
	      else if (TermParser.isNot(expression))
	         return " not ";
	      else
	         return "";
	}

	
	public String transformExpression2StringNoParenthesis(Term expression){ 	  
		String result = super.transformExpression2String(expression);
		/* Eliminate opening and closing parentheses */
		return result.substring(1, result.length()-1);		
	}

	@Override
	public String getExistsExpression(Term expression) {
		// TODO Auto-generated method stub
		return null;
	}
	
	
}
