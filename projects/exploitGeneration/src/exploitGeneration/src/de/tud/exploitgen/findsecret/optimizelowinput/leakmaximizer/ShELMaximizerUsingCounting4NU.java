package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.math.BigInteger;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;

public class ShELMaximizerUsingCounting4NU extends
		LeakageMaximizerUsingCounting4NU {

	
	
	public ShELMaximizerUsingCounting4NU(
			List<PPCountingResult> listCountingResults, Services services,
			List<String> listLowVars, String optSolver,
			SecretDistribution sDistribution, BigInteger sumAllFrequencies) {
		
		super(listCountingResults, services, listLowVars, optSolver, sDistribution,
				sumAllFrequencies);
		printInfoOfListMatchableCountingSolutions();
		System.out.println("sumAllFrequencies:: "+ sumAllFrequencies);
	}

	@Override
	protected OptimalSolution findOptimalSolution4SingleCase(
			MatchableCountingSolution matchCountSolution) {
		return findOptimalSolution4SingleCase(matchCountSolution, KEGConstant.SHANNON_ENTROPY);
	}

	@Override
	protected double computeLeakage(OptimalSolution bestSolution) {
		double S = sumAllFrequencies.doubleValue();
		System.out.println("sumAllFrequencies = " + sumAllFrequencies);
		return (Math.log(S) - bestSolution.getOptimizeValue()/S)/Math.log(2);
	}

	@Override
	protected OptimalSolution resolveConstantSolution(
			MatchableCountingSolution matchCountSolution) {
		/*
		 * calculate scaled shannon entropy leakage
		 * */
		Map<String, Long>  mapSumOi = new HashMap<String, Long>();
		for(CountingSolution cs: matchCountSolution.getListCountingSolutions()){
			if(mapSumOi.containsKey(cs.getOutputValue())){
				Long sumOi= mapSumOi.get(cs.getOutputValue());
				sumOi += TermParser.getIntegerValue(cs.getValue(), services)*
						sDistribution.getPartitions().get(cs.getPartitionIdx()).getFrequency();
				
				mapSumOi.put(cs.getOutputValue(), sumOi);
			}else{
				Long sumOi = TermParser.getIntegerValue(cs.getValue(), services)*
						sDistribution.getPartitions().get(cs.getPartitionIdx()).getFrequency();
				
				mapSumOi.put(cs.getOutputValue(), sumOi);
			}
			
		}
		//System.out.println("mapSumOi:: " + mapSumOi);
		double optimizeValue = 0;
		for(String outValue: mapSumOi.keySet()){
			if(mapSumOi.get(outValue)>0)
				optimizeValue += mapSumOi.get(outValue)*Math.log(mapSumOi.get(outValue));
		}
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		return new OptimalSolution(solution, optimizeValue);

	}


	@Override
	protected double computeOptimalValueUsingSolution(
			MatchableCountingSolution countingResults,
			Map<String, Long> optSolution) {
		
		Map<String, Double>  mapSumOi = new HashMap<String, Double>();
		for(CountingSolution cs: countingResults.getListCountingSolutions()){
			if(mapSumOi.containsKey(cs.getOutputValue())){
				Double sumOi= mapSumOi.get(cs.getOutputValue());
				sumOi += TermUtil.computeDouble(cs.getValue(), optSolution, services)*
						sDistribution.getPartitions().get(cs.getPartitionIdx()).getFrequency();
				
				mapSumOi.put(cs.getOutputValue(), sumOi);
			}else{
				Double sumOi = TermUtil.computeDouble(cs.getValue(), optSolution, services)*
						sDistribution.getPartitions().get(cs.getPartitionIdx()).getFrequency();
				
				mapSumOi.put(cs.getOutputValue(), sumOi);
			}	
		}
		//System.out.println("mapSumOi:: " + mapSumOi);
		double optimizeValue = 0;
		for(String outValue: mapSumOi.keySet())
			if(mapSumOi.get(outValue)>0)
			optimizeValue += mapSumOi.get(outValue)*Math.log(mapSumOi.get(outValue));
		return optimizeValue;
	}

}
