/*
 * this class eliminates all duplicate quantifiable variables existing in the term
 * */
package de.tud.exploitgen.findsecret.counting;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.util.Pair;

public class QVarPreprocessing {
	private Term term;
	private Services services;
	private int idx;
	public QVarPreprocessing(Term term, Services services) {
		super();
		this.term = term;
		this.services = services;
		idx=0;
	}
	
	public Term preprocess(){
		return removeDuplicateQVar(term);
	}
	
	private Term removeDuplicateQVar(Term t){
		if(t!=null){
	        if(t.subs().size()>0){
	            if(t.boundVars().isEmpty()){            
	               int size =t.subs().size();
	               Term[] subs = new Term[size];               
	               for(int i=0;i<size;i++){
	                  subs[i] = removeDuplicateQVar(t.sub(i));
	               }
	               return services.getTermFactory().createTerm(t.op(), subs, t.boundVars(),t.javaBlock());
	            }else{
	            	return replaceQuantifiedTerm(t);
	            }
	         }else{
	        	 return t;
	         }
		}else
			return null;
	}
	
	/*replace all bound vars appearing in t by destination*/
	   private Term replace(Term t, QuantifiableVariable source, Term destination){
		  TermFactory tf = services.getTermBuilder().tf();
	      if(t!=null){
	         if(t.toString().equals(source.name().toString())){
	            //return termBuilder.var(destination);
	            return destination;
	         }else{			
	            if(t.subs().size()>0){
	               int size =t.subs().size();
	               Term[] subs = new Term[size];
	               for(int i=0;i<size;i++){
	                  subs[i] = replace(t.sub(i),source, destination);
	               }
	               return tf.createTerm(t.op(), subs, t.boundVars(),t.javaBlock());
	            }else{
	               return t;
	            }
	         }            
	      }else{
	         return null;
	      }
	   }
	   
	 
	 private Pair<QuantifiableVariable,QuantifiableVariable> createReplaceQVar(Term t){
		 ImmutableArray<QuantifiableVariable> qVars = t.boundVars();
		 if(!qVars.isEmpty()){
			 QuantifiableVariable qv = qVars.get(0);
			 LogicVariable lv = new LogicVariable(new Name(qv.name().toString() + "_" + idx), qv.sort());
			 idx++; //raise idx to make sure that there is no two quantifiable variables have the same name
			 return new Pair<QuantifiableVariable,QuantifiableVariable>(qv,lv);
		 }else
			 return null;
	 }
	 
	 private Term replaceQuantifiedTerm(Term t){
		 Pair<QuantifiableVariable,QuantifiableVariable> pairQV = createReplaceQVar(t);
		 if(pairQV!=null){
			 QuantifiableVariable oriQV = pairQV.first;
			 QuantifiableVariable repQV = pairQV.second;
			 TermFactory tf = services.getTermFactory();
			 TermBuilder tb = services.getTermBuilder();
			 ImmutableArray<Term> subs = t.subs();
			 int size =subs.size();
             Term[] rSubs = new Term[size];
             for(int i=0;i<size;i++){
            	 rSubs[i] = replace(subs.get(i), oriQV, tb.var(repQV));
             }
             for(int i=0;i<size;i++)
            	 rSubs[i] = removeDuplicateQVar(rSubs[i]);
			 return tf.createTerm(t.op(), rSubs, new ImmutableArray<QuantifiableVariable>(repQV),t.javaBlock());
		 }else
			 return null;
	 }
}
