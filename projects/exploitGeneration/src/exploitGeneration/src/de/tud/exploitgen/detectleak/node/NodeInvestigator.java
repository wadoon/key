/**
 * 
 */
package de.tud.exploitgen.detectleak.node;


import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import org.key_project.util.collection.ImmutableArray;
import org.key_project.util.collection.ImmutableList;
import org.key_project.util.collection.ImmutableSet;

import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.ModelBuilderVisitor;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstanceFactory;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariableFactory;

import de.tud.exploitgen.detectleak.simplifier.AnonHeapAnalyzer;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.IExecVarHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.ModelVariableGenerator;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
//import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.Choice;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Sequent;
import de.uka.ilkd.key.logic.SequentFormula;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.proof.ApplyStrategy;
import de.uka.ilkd.key.proof.ApplyStrategy.ApplyStrategyInfo;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.proof.Node;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.InitConfig;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.proof.io.ProofSaver;
import de.uka.ilkd.key.proof.mgt.AxiomJustification;
import de.uka.ilkd.key.proof.mgt.ProofEnvironment;
import de.uka.ilkd.key.proof.mgt.RuleJustification;
import de.uka.ilkd.key.rule.BuiltInRule;
import de.uka.ilkd.key.rule.OneStepSimplifier;
import de.uka.ilkd.key.rule.Taclet;
import de.uka.ilkd.key.rule.tacletbuilder.TacletBuilder;
import de.uka.ilkd.key.settings.ProofSettings;
import de.uka.ilkd.key.strategy.JavaCardDLStrategy.Factory;
import de.uka.ilkd.key.strategy.StrategyProperties;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionConstraint;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
//import de.uka.ilkd.key.util.DelimitedRelease;
import de.uka.ilkd.key.symbolic_execution.model.impl.ExecutionConstraint;
import de.uka.ilkd.key.symbolic_execution.profile.JavaIntRemovingProfile;
import de.uka.ilkd.key.symbolic_execution.profile.SimplifyTermProfile;
import de.uka.ilkd.key.symbolic_execution.strategy.JavaIntRemovingStrategy;
import de.uka.ilkd.key.symbolic_execution.strategy.SimplifyTermStrategy;
import de.uka.ilkd.key.symbolic_execution.strategy.SymbolicExecutionStrategy;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionSideProofUtil;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionUtil;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionUtil.SiteProofVariableValueInput;
import de.uka.ilkd.key.util.ProofStarter;

/**
 * supply methods investigating node to get information of:
 *    - node contract
 *    - model variables (used in checking noninterference and building exploit model)
 *    - artificial variable (just used in checking noninterference)
 * @author Huy Do
 *
 */
public class NodeInvestigator {   
   private final IExecutionNode<?> node;
   private final Services services;
   private final TermBuilder termBuilder;
   private final HeapHandler heapHandler;
   private final Term tt = new TermFactory().createTerm(Junctor.TRUE);
   
   //private Model model; //contains all of ModelVariable and relations between them
   private List<Term> artificialVars; //contains  artificial variable detected while investigate node
   
   private String SELF_NAME=""; //contain SELF_NAME (mostly it is self)
   private Stack<String> sHeapName; //contains name of object in heap, served for creating name of heap variables during recursively investigating heap
   private final int depth; //depth of sub-field's sequence being investigated
   private final KeYJavaMethod method; //use to extract information from declassification specification
   
   private List<KTGModel> listModel; //contains list of Model created from the node
   private ModelTree selfModelTree; //store all models created during investigating heap (start from self object)
   private Term nodeUsefulConstraints; //store all "useful" node constrains created by using conjunction (serverd for FormulaBuilder class)
   private Term nodeAllConstraints; //store all node constrains created by using conjunction (serverd for FormulaBuilderS class)
   private Map<KTGModel, List<ModelVariable>> mapArrModelVars; //the list contains all non-heap Model Variable appears in arrayIdxTerm of all variables of a model 
   
   private List<Term> listArrays; //list of all array terms detected
   private List<Term> listArrayElements; //list of quantified array's elements
   private List<Term> listQVars; //list of quantifiable variables   
   private AnonHeapAnalyzer anonHeapAnalyzer;
   private Term postHeap; //heap at final state
 
   /*
    * list of foundation terms: heap, self, anonheap, static variable, method parameter
    * we use it to construct ptcFoundation in FormulaBuilderS class
    * */
   private List<Term> listFoundations; 
   
   /**
    * @param services
    */
   public NodeInvestigator(IExecutionNode<?> node, KeYJavaMethod method, int depth) {      
      super();
      this.node = node;
      this.services = node.getServices();
      heapHandler = new HeapHandler(services);
      termBuilder=new TermBuilder(new TermFactory(), services);
      //model = Model.constructModel();
      sHeapName=new Stack<String>();
      artificialVars = new LinkedList<Term>();
      listQVars = new LinkedList<Term>();
      this.depth = depth; //default          
      //listModel = new ArrayList<Model>();
      this.selfModelTree = new ModelTree();
      this.method = method;    
      listFoundations = new LinkedList<Term>();
      
      System.out.println("§§§§§§§§§§§§§§§§§§");
      /*
      Sequent sequent = node.getProofNode().sequent();
      ImmutableList<Goal> goals = node.getProof().openGoals();
      System.out.println("open goal size: " + goals.size());
      Goal[] goalArray = new Goal[goals.size()]; 
    		  goals.toArray(goalArray);
      for(int i=0;i<goalArray.length;i++)
    	  System.out.println(goalArray[i]);
      //Sequent sequent = node.getProof().openGoals().head().sequent();
      
      for (SequentFormula sf : sequent.antecedent()) {
         System.out.println(sf.formula());
      }
      System.out.println("==>");
      for (SequentFormula sf : sequent.succedent()) {
    	  System.out.println(sf.formula());      
      }*/
      extractPostHeap();
      System.out.println("§§§§§§§§§§§§§§§§§§");
   }  
   
  
   
   private Term getUsefulConstraint() {
      IExecutionConstraint[] constraints = node.getConstraints(); 
      System.out.println("Variable values at node");
      try {
    	  for (IExecutionVariable var : node.getVariables()) {
    		  System.out.println(var.getName() + ":" + Arrays.toString(var.getValues()));
    	  }
    	  
      } catch (ProofInputException e) {
    	  // TODO Auto-generated catch block
    	  e.printStackTrace();
      }
      
      Term result = tt;
      //System.out.println(" -- node constraint: -- ");
      for(IExecutionConstraint ec: constraints){ 
         Term t = ec.getTerm();             
         System.out.println(t);
         if(!KeYResourceHandler.containUselessConstraint(t)){            
            /*if(TermParser.isForAllQuantifier(t)){
               SMTWorker st = new SMTWorker(services, new Configuration(false,false));
               StringBuffer sb = st.translateTerm(t, new Vector<QuantifiableVariable>(), services);
               System.out.println("forall quantifier:  " + sb.toString());               
            }*/
              
            //System.out.println(t);  
            //t = KeYResourceHandler.removeUnnecessaryTerm(t);
            //t = heapHandler.replaceSelectFunctionByItsField(t, KEGConfig.SEPARATOR);
            //t = heapHandler.replaceLengthFunctionByVar(t, KEGConfig.SEPARATOR);     
            
            //t = heapHandler.simplifyAnonSelectFunction(t);
            t = heapHandler.removeJavaCastInt(t);
            t = heapHandler.sum2Bsum(t);
            t = KeYResourceHandler.replaceObjectCreatedEqualTrueTermByTrue(t);
            t = heapHandler.simplifyITE(t);
            System.out.println(t);
            result = termBuilder.and(result,t);                
         }else{
        	 //System.out.println("useless constraint: " + t);
         }            
      }
      //System.out.println("---------");
      return result;      
   }
   
   private Term getAllConstraint(){
      IExecutionConstraint[] constraints = node.getConstraints();  
      Term result = tt;
      //System.out.println(" -- node constraint: -- ");
      for(IExecutionConstraint ec: constraints){ 
         Term t = ec.getTerm();   
         //System.out.println(t);     
         //System.out.println(t);
         t = heapHandler.simplifyAnonSelectFunction(t);
         t = heapHandler.removeJavaCastInt(t);
         t = heapHandler.sum2Bsum(t);
         //System.out.println(t);
         result = termBuilder.and(result,t);                                     
      }
      //System.out.println("---------");
      return result;      
   }
   
   private void constructNodeConstraints(){
	  IExecutionConstraint[] constraints = node.getConstraints(); 	      
      nodeUsefulConstraints = tt;
      nodeAllConstraints = tt;
      
      //System.out.println(" -- node constraint: -- ");
      for(IExecutionConstraint ec: constraints){ 
         Term t = ec.getTerm();    
         t = heapHandler.removeJavaCastInt(t);
         System.out.println(ProofSaver.printTerm(t,services));      
         t = heapHandler.sum2Bsum(t);
         //System.out.println("simplified term: \n" + ProofSaver.printTerm(TermUtil.simplifyTerm(t, services), services));
         t = heapHandler.simplifyITE(t);
         t = heapHandler.simplifyAnonSelectFunction( t);
         System.out.println("simplified constraint: \n" +ProofSaver.printTerm(t,services));
         nodeAllConstraints = termBuilder.and(nodeAllConstraints,t);
         
         if(!KeYResourceHandler.containUselessConstraint(t)){                    
            //t = heapHandler.simplifyAnonSelectFunction(t);
            /*t = heapHandler.removeJavaCastInt(t);
            t = heapHandler.sum2Bsum(t);
            t = KeYResourceHandler.replaceObjectCreatedEqualTrueTermByTrue(t);
            t = heapHandler.simplifyITE(t);*/
        	t = KeYResourceHandler.replaceObjectCreatedEqualTrueTermByTrue(t);
            System.out.println("useful constraint: " + t);
            nodeUsefulConstraints = termBuilder.and(nodeUsefulConstraints,t);                
         }else{
        	 //System.out.println("useless constraint: " + t);
         }            
      }
      //System.out.println("---------");
         
   }
   
   private void constructModels() throws ProofInputException{
      /*
       * Create the initial Model, without any concrete values assigned to
       * primitive integer values in it.
       */
            
       //investigate heap to add all fields, static variables and method parameters into model   
       //nodeUsefulConstraints = getUsefulConstraint();
	   constructNodeConstraints();
       System.out.println("useful constraints:" + nodeUsefulConstraints);
       anonHeapAnalyzer = new AnonHeapAnalyzer(nodeUsefulConstraints, services);
       System.out.println("anonHeapAnalyzer map 2 anon heap::: " + anonHeapAnalyzer.getMap2AnonHeap());
       nodeUsefulConstraints = heapHandler.simplifyAnonSelectFunction(nodeUsefulConstraints);
       nodeUsefulConstraints = anonHeapAnalyzer.replaceForEmbeddedLengthFunction(nodeUsefulConstraints);
       System.out.println("simplified useful constraints:" + nodeUsefulConstraints);
       //anonHeapAnalyzer.printMap();
       
       
       
       IExecutionVariable[] vars = node.getVariables();
       
       /*recursively investigate program variable. 
        * Because the sub-field sequence might be infinite, we have to set up the depth on investigating*/
 
       for(IExecutionVariable var: vars){
          System.out.println("variables: " + var.getName());          
          if(IExecVarHandler.isSelf(var)){               
        	 SELF_NAME=var.getName();   
             addSelfToModel(var); 
             //add self to listFoundations
             add2ListFoundations(var.createSelectTerm());
             investigateProgramVariable(var,0,selfModelTree);             
          }       
       }       

      

      
       for(IExecutionVariable var: vars){
    	   if(SymbolicExecutionUtil.isBaseHeap(var.getProgramVariable(), services.getTypeConverter().getHeapLDT())){
    		   System.out.println("found heap!!!" + Arrays.toString(var.getValues()));              
    	   }
    	   else if(IExecVarHandler.isStatic(var) || IExecVarHandler.isParameter(var)){ //solve static variables and method's parameters
             //System.out.println("detected static or parameter or artificial varibales! " + var.getName());
             for(ModelTree mt: selfModelTree.getAllLeafModelTrees())
                investigateProgramVariable(var,0, mt);     
          } else {
        	  System.out.println("==>"+var.getName());
          }
       }
       
       //manipulate exploit model to indicate the container for static variables
       listModel = selfModelTree.getAllLeafModels();
       //System.out.println("NUMBER OF MODELS: " + listModel.size());
       for(KTGModel model: listModel){
          maniputlateModel2SolveStaticVar(model);
          //System.out.println("model created:::::: \n" + model.toString());
       }
       
       buildListArraysAndElements(); //listQAElements is used to eliminate all array index variable of quantified array's elements       
       System.out.println("listArrayElements: " + listArrayElements);
       
       for(KTGModel model: listModel){          
          for(ModelVariable mv: model.getVariables()){ 
        	  System.out.println("ModelVariable " + mv.getIdentifier() + " : " + mv.getSymbolicValue());
        	  if(KeYResourceHandler.isArtificialVariable(mv.getSymbolicValue(), services))
        		  System.out.println("ModelVariable " + mv.getIdentifier() + " value is an artificial variable");
             investigateArtificialVars(mv.getSymbolicValue());
             investigateArtificialVars(mv.getValueCondition());
             /*investigateHeapVariables(mv.getSymbolicValue());
             investigateHeapVariables(mv.getValueCondition());*/
          }       
       }
       
       manipulateModel2SolveArrIdxTerm();
       
       /*find artificial variables from node constraint
         node constraint also wrap path condition*/       
       investigateArtificialVars(nodeUsefulConstraints);      
       
       //check all models, find array variable without length and add it
       for(KTGModel model: listModel)
    	  addLength4Array(model);
       
       investigateHeapVariables(nodeAllConstraints);
       investigateHeapVariables(postHeap);
       System.out.println("list foundations before correcting: " +listFoundations);
       removeFalseFoundation();
       System.out.println("list foundations: " +listFoundations);
       removeFalseArtificialVar();
       /*for(Term t: artificialVars){
    	   if(TermParser.isArray(t))
    		   testUsingPostHeap(t);
       }*/
   }
   
   /**
    * called if var is heap (started by "self")
    * @throws ProofInputException 
    * */
   private void addSelfToModel(IExecutionVariable var) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
      final ModelInstance selfInstance = ModelInstanceFactory.constructModelInstance(container);      
      final ModelVariable self = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), var.getName());
      self.setParentIdentifier(null);
      //model.add(self, selfInstance);   
      KTGModel m = KTGModel.constructModel();
      m.add(self, selfInstance);
      selfModelTree.setModel(m);
      
      //listModel.add(model);
   }
   
   /**
    * investigate self object to retrieve information of all fields and add it into exploit model
    * counter represents precisely the depth of investigating
    * */
   private void investigateProgramVariable(IExecutionVariable var, int level, ModelTree modelTree) throws ProofInputException{
      
      /*System.out.println("detected var: " + var.getName()+ " array index: " + var.getArrayIndex() + 
            " program variable: " + var.getProgramVariable() + " type: " + var.getValues()[0].getValue().sort());   */
      //if (var.getProgramVariable() instanceof IProgramVariable){            
         
         String identifier = IExecVarHandler.getIdentifier(var, services);
         /*if(!HeapHandler.isParameter(var)){
            if(!sHeapName.isEmpty())
               identifier=getReferenceName()+"_"+identifier;
         }*/
         //System.out.println("detected var: " + identifier);
         
        /* if(!model.inModel(identifier)){            
            addVarToModel(var, modelTree.getModel());
         } */
         //Model model = modelTree.getModel();         
         
         if(level<depth){             
            //recursively work with child variable of this variable
            if(var.getValues()!=null){
               IExecutionValue[] values =var.getValues();
               if(values.length>1){
                  List<ModelTree> leafs = modelTree.getAllLeafModelTrees();       
                  /*System.out.println(" variable " + identifier + " has condition value, its number of value is: " + values.length);
                  for(IExecutionValue value1: values){
                     System.out.println("value: " + value1.getValue() + " condition: " + value1.getConditionString());
                  }
                  System.out.println("\n\nnumber of current leaf model trees: " + leafs.size());      */            
                  for(ModelTree leaf: leafs){
                     KTGModel model = leaf.getModel();
                     //System.out.println(" variable " + identifier + " has condition value, its number of value is: " + values.length);
                     
                     for(IExecutionValue value:values){                                               
                       //for each value, we create a new child for current ModelTree
                    	 Term valueTerm;
                  	   /*if the valuestring of a variable is unknown, then its value should not be null term 
                  	    * we simply use select form of var for the value ‚*/
                  	   if (value.getValueString()==null){
                  		   System.out.println(var.getName() + " is unknown");
                  		   System.out.println(value.getVariable().getName() + " :::->-> " + var.createSelectTerm());
                  		   valueTerm = var.createSelectTerm();
                  	   }else{
                  		   System.out.println(value.getVariable().getName() + " :::-> " + values[0].getValueString());
                  		   valueTerm = value.getValue();
                  	   }  		   
                        
                        ModelTree subTree = new ModelTree(KTGModel.constructModel(model));
                        //System.out.println("add variable" + identifier + " with value " + value.getValue() + " \n        to subtree " + subTree.toString()  );    
                        if(!subTree.getModel().hasVar(identifier)){
                           addVarToModel(var, valueTerm, value.getCondition(), subTree);
                        }
                        sHeapName.push(IExecVarHandler.getVarName(var, services));
                        /*if(leaf.getSmallestChild()!=null)
                           subTree.setClosestSibling(leaf.getSmallestChild());*/
                        leaf.addChild(subTree);                        
                        IExecutionVariable[] vchilds=value.getChildVariables();   
                        /*System.out.println("number of children of " + identifier + ": " + vchilds.length);
                        System.out.println("level: " + level);*/
                        for(IExecutionVariable vchild:vchilds){                      
                           investigateProgramVariable(vchild, level+1, subTree);                      
                        }                        
                        sHeapName.pop();
                        //System.out.println("ModelTree created: \n" + modelTree.getModel().toString());                         
                     }
                     
                  }
               }else{
                //if there is only one value, the condition is true
                  //TODO: ask Martin to fix this bug
            	   Term valueTerm;
            	   /*if the valuestring of a variable is unknown, then its value should not be null term 
            	    * we simply use select form of var for the value ‚*/
            	   if (values[0].getValueString()==null){
            		   System.out.println(var.getName() + " is unknown");
            		   System.out.println(values[0].getVariable().getName() + " :::->-> " + var.createSelectTerm());
            		   valueTerm = var.createSelectTerm();
            	   }else{
            		   System.out.println(values[0].getVariable().getName() + " :::-> " + values[0].getValueString());
            		   valueTerm = values[0].getValue();
            	   }  		   
             
                  KTGModel model = modelTree.getModel();
                  if(!model.hasVar(identifier)){                        
                     addVarToModel(var, valueTerm, termBuilder.tt(), modelTree);
                  }
                  sHeapName.push(IExecVarHandler.getVarName(var, services));
                  IExecutionVariable[] vchilds=values[0].getChildVariables();   
                  //System.out.println("number of children of " + identifier + ": " + vchilds.length); 
                  for(IExecutionVariable vchild:vchilds){                      
                     investigateProgramVariable(vchild, level+1, modelTree);                      
                  }
                  sHeapName.pop(); 
               }
            }
         }
      //}
   }
   
   /**
    * adds a field of the class to model, links to container object
    * */
   private void addVarToModel(final IExecutionVariable var, Term symbolicValue, Term valueCondition, ModelTree modelTree) throws ProofInputException{     
      String identifier = IExecVarHandler.getIdentifier(var, services);
      if(IExecVarHandler.isParameter(var)){ 
    	  //remove prefix "_"
    	  identifier =identifier.substring(1);
      }
      
      ModelVariable variable;
      if(var.getProgramVariable() instanceof IProgramVariable){ //normal program variable
         if(IExecVarHandler.isArray(var)){
            System.out.println(var + " is array!");
            
            variable = new ModelArrayVariable(var.getProgramVariable(),identifier);
         }else{
            variable=new ModelVariable(var.getProgramVariable(),identifier);
         }     
      }else{ //array's element is not treated as program variable, so we have to solve it separately
         //System.out.println(var + " is an array's element!");         
         if(TermParser.isArray(var.createSelectTerm()))
            variable = new ModelArrayVariable(ModelVariableGenerator.createProgramVariable(var),identifier);
         else
            variable = new ModelVariable(ModelVariableGenerator.createProgramVariable(var),identifier);
      }   
      variable.setRawSymbolicValue(symbolicValue);
      /*System.out.println("RAW symbolic value of " + identifier + " before correcting: " + symbolicValue);
      Term resolvedSValue= resolveTermByBelowUpdates(symbolicValue);
      System.out.println("RAW symbolic value of " + identifier + " AFTER RESOLVING: " + resolvedSValue);
      variable.setRawSymbolicValue(resolvedSValue);*/
      
      
      Term correctedSymbolicValue = anonHeapAnalyzer.replaceFreshVariableByCorrectedOne(symbolicValue);
      System.out.println(var.getName() + " : " + correctedSymbolicValue);
      variable.setSymbolicValue(correctedSymbolicValue);
      variable.setValueCondition(valueCondition);
      //variable.setArrayIdx(var.getgetArrayIndex());
      Term idxTerm = var.getArrayIndex();
      if(idxTerm!=null){
         variable.setArrayIdxTerm(idxTerm);
         if(TermParser.isInteger(idxTerm, services))
            variable.setArrayIdx((int)TermParser.getIntegerValue(idxTerm, services));
      }
      
      //assign select form
      variable.setSelectForm(var.createSelectTerm());
      //System.out.println("select form: " + variable.getSelectForm());
      
      
      if(IExecVarHandler.isParameter(var)){  //assign true flag for method's parameter
         variable.setParameter(true);
         //remove prefix "_"
         
      }
      
      if(IExecVarHandler.isStatic(var)){
         variable.setStatic(true);
         variable.setDeclareClassName(IExecVarHandler.getAccessClassNameOfStaticVar(var));
      }else
         variable.setStatic(false);         
      
      Object instance;
      if (IExecVarHandler.isPrimitive(var)) {
          //The term is a static variable. Identify and connect it with its parent class.
          instance = ModelBuilderVisitor.resolvePrimitiveType(variable.getProgramVariable());
      } else {
          instance = ModelInstanceFactory.constructModelInstance(variable.getProgramVariable().getKeYJavaType());
      }
      /*
       * Add the variable and its instance to the Model. This might seem
       * premature, but must be done to preserve referential integrity and
       * avoiding extra work.
       */
      modelTree.getModel().add(variable, instance);
      if(!sHeapName.isEmpty()){
         String referenceName = getReferenceName();
         variable.setParentIdentifier(referenceName);
         modelTree.getModel().assignField(variable, modelTree.getModel().getVariable(referenceName));
      }
      
      //add var to all sub ModelTree of this current modelTree
      for(ModelTree subtree: modelTree.getChildren())
         addVarToModel(var, symbolicValue, valueCondition, subtree);
      //add var to the closest sibling of current modelTree
      /*if(modelTree.getClosestSibling()!=null)
         addVarToModel(var, symbolicValue, valueCondition, modelTree.getClosestSibling());*/
   }  
   
   /*
    * when resolving loop by using loop invariant, SED (Symbolic Execution Debugger) may create fresh variables
    * to represent the value of fields, we have to detect them and add them into model
    * 
    * */
   private void investigateArtificialVars(final Term t){
      if(t!=null){       
         /*if(HeapHandler.isHeapSelectFunction(t) && !HeapHandler.isAnonHeapSelectFunction(t)){
            //processSelectFunction(t);            
         }else if(HeapHandler.isLengthFunction(t, services)){
            //processLengthFunction(t);          
            
         }else*/ 
    	 if(KeYResourceHandler.isArtificialVariable(t, services) /*&& !TermUtil.haveAncestorInList(t, listArrayElements)*/){        
            //we have to check if term has been added into model or not
            //if true, it is parameter and we do not add it into list of artificial variables       
            Term addTerm = refineTerm(t);
            System.out.println("refine term: " + addTerm);
            //Term addTerm = t;
            //if(!model.hasVar(addTerm.toString())){                  
               add2ArtificialVars(addTerm);
            //}           
         }else{ //recursively call to subterms.
            //investigate quantifiable variable
             if(t.boundVars()!=null){
                if(t.boundVars().size()>0){
                   for(QuantifiableVariable qv: t.boundVars()){
                      Term qvterm = termBuilder.var(qv);
                      if(!TermUtil.inListTerm(qvterm, listQVars))
                         listQVars.add(qvterm);
                   }
                }
             }
            ImmutableArray<Term> subterms=t.subs();
            for(Term st:subterms){
               investigateArtificialVars(st);
            }          
         }         
      }      
   }
   
   /*private void addQuantifiableVars(Term t){
      ImmutableArray<QuantifiableVariable> qVars = t.boundVars();
      for(QuantifiableVariable qv: qVars){
         mapQuantifiableVars.containsKey(qv.name().toString()){
            mapQuantifiableVars.put(qv.name().toString(), qv);
         }
      }
   }*/
   
   private void add2ArtificialVars(Term t){          
      if((!TermUtil.inListTerm(t, artificialVars)) && (!TermUtil.inListTerm(t, listQVars))){   
         //System.out.println("detected artificial var: " + t);
         artificialVars.add(t);
      }
   }
   
   /*
    * constructs reference name from stack, if object obj is a field of heap self, then the heap name is self_obj
    * */
   private String getReferenceName() {  
      String heapName="";
      if(sHeapName.size()>0){
         heapName=sHeapName.get(0);
         for(int i=1;i<sHeapName.size();i++){
            heapName +=KEGConstant.SEPARATOR + sHeapName.get(i);
         }
      }
      return heapName;
   }
   
   
   /*
    * basically, all static variable are listed when we look into the array of program variables, not in heap
    * however, we would like to match static variable with some specific variables that their class is the real container of it.
    * so we have to manipulate the model
    * */
   
   private void maniputlateModel2SolveStaticVar(KTGModel model){
      List<ModelVariable> lMV = model.getVariables();
          
      /*
       * now we resolve lMV in the following way:
       * take all ModelVariable mv in lMV
       * if mv is static then
       * find a ModelVariable container in lMV that its type is same with the type of container class of mv
       * set mv as a field of container
       * */
      //System.out.println("+++ BEGIN static resolving");
      for(ModelVariable mv: lMV){ 
         
         if(mv.isStatic()){
          //System.out.println(mv.getIdentifier() + " is static and the name is " + mv.getVariableName());
            String containerName = mv.getDeclareClassName();
            for(ModelVariable mvc: lMV){
               if(containerName.equals(mvc.getTypeName())){
                  model.assignField(mv, mvc);                  
               }
            }
         }        
      }
      //System.out.println("+++ END static resolving");
   }
   
   
  
   /*
    * if arrayIdxTerm is not null, it must be investigated to detect and add unknown model variable into the model
    * these variables are necessary in generating JUnit file
    * */
   private void investigateArrayIdxTerm(Term t, KTGModel model){
      if(t!=null){
         if(KeYResourceHandler.isArtificialVariable(t, services) && !TermUtil.haveAncestorInList(t, listArrayElements)){
            //a new model variable is detected, add it into model
            Term addTerm = refineTerm(t);         
            ModelVariable mv = ModelVariableGenerator.createModelVariable(addTerm, services);
            mv.setFresh(true);
            mv.setSelectForm(t);
            List<ModelVariable> lmv = mapArrModelVars.get(model);
            lmv.add(mv);
         }else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=t.subs();
            for(Term st:subterms){
               investigateArrayIdxTerm(st, model);
            }
         }         
      }
   }
   
   /*
    * arayIdxTerm might contain variables that are not listed in the model (local variables, artificial variables)
    * so it is necessary to detect them and add them into model
    * because we need them in generating JUnit test (create fixture for execution) 
    * */
   private void manipulateModel2SolveArrIdxTerm(){
      /*initiate for mapArrModelVars*/
      mapArrModelVars = new HashMap<KTGModel,List<ModelVariable>>(); 
      for(KTGModel model: listModel){
         List<ModelVariable> lmv = new LinkedList<ModelVariable>();
         mapArrModelVars.put(model, lmv);         
      }
      /*investigate array index terms to detect to-add model variables and store them in corresponding list*/
      for(KTGModel model: listModel){
         for(ModelVariable mv: model.getVariables())
            investigateArrayIdxTerm(mv.getArrayIdxTerm(), model);            
      }
      
      //Now, resolve each model to add new investigated model variables
      for(KTGModel model: listModel){
         List<ModelVariable> lmv = mapArrModelVars.get(model);
         for(ModelVariable mv: lmv){
            if(!model.hasVar(mv.getIdentifier()))
               model.add(mv, ModelVariableGenerator.createInstance(mv));
         }         
      }
   }
   
   
   
   /*
    * process length function to detect and add unknown model variable into model
    * */   
   private void processLengthFunction(final Term t, KTGModel model){
      String rootName = HeapHandler.getRootNameOfSelectAndLength(t, services);
      if(model.hasVar(rootName)){ //this is legal model variable, add it into model 
         ModelVariable length = ModelVariableGenerator.createModelVariable(t, services);      
         //if length is not in model, we process it
         if(!model.hasVar(length.getIdentifier())){
            model.add(length,ModelVariableGenerator.createInstance(length));
            Term sub0 = t.sub(0);
            if(HeapHandler.isHeapSelectFunction(sub0) && !HeapHandler.isAnonHeapSelectFunction(sub0, services)){
               processSelectFunction(sub0, model);
            }else{
               ModelVariable array = ModelVariableGenerator.createModelVariable(sub0,services);
               if(!model.hasVar(array.getIdentifier())){
                  model.add(array, ModelVariableGenerator.createInstance(array));                  
               }   
            }
            ModelVariable array = ModelVariableGenerator.createModelVariable(sub0,services);
            length.setParentIdentifier(array.getIdentifier());
            model.assignField(length, model.getVariable(array.getIdentifier()));
         }
      }else{
         add2ArtificialVars(refineTerm(t));
         investigateArtificialVars(t.sub(0));         
      }
   }
   
   /*
    * process select function to detect and add unknown model variable into model
    * */   
   private void processSelectFunction(final Term t, KTGModel model){  
      String rootName = HeapHandler.getRootNameOfSelectAndLength(t,services);
      if(model.hasVar(rootName)){  //this is legal model variable, add it into model   
         ModelVariable mv = ModelVariableGenerator.createModelVariable(t,services); //create Model variable
         if(!model.hasVar(mv.getIdentifier())){ 
            //if mv is not in model, add it and resolve it
             model.add(mv,ModelVariableGenerator.createInstance(mv));
             Term sub2 = t.sub(2);
             if(HeapHandler.isArrayIdxFunction(sub2)){ //if mv is an element of array 
                if(HeapHandler.isArrayElementNumber(sub2)){ 
                   //if the index is number, then assign the index number
                   mv.setArrayIdx((int)HeapHandler.getArrayIndexNumber(sub2, services));
                   //if the index is length function, then call process length function                   
                }else if(HeapHandler.isLengthFunction(sub2,services)){                                      
                   processLengthFunction(sub2,model);
                   /*after processing length function, length variable is added to the model
                   assign index object as length function */
                   ModelVariable length = ModelVariableGenerator.createModelVariable(sub2,services);
                   mv.setArrayIdxValue(model.getVariable(length.getIdentifier()));                   
                } else{
                   //if the index is variable or select function, then assign array index object
                   ModelVariable idxMv = ModelVariableGenerator.createModelVariable(sub2.sub(0),services);
                   if(!model.hasVar(idxMv.getIdentifier())){
                      //if index object is not in the model, add it into model
                      if(HeapHandler.isHeapSelectFunction(sub2.sub(0)) && !HeapHandler.isAnonHeapSelectFunction(sub2.sub(0),services))
                         processSelectFunction(sub2.sub(0),model);
                      else                         
                         model.add(idxMv, ModelVariableGenerator.createInstance(idxMv));
                   }
                   //assign index object
                   mv.setArrayIdxValue(model.getVariable(idxMv.getIdentifier()));
                }
             }else {
                //if sub2 is an variable, basically do nothing
             }             
             //check if mv has been assigned as a field of referee object
             Term sub1 = t.sub(1);
             ModelVariable referMv = ModelVariableGenerator.createModelVariable(sub1,services);
             if(!model.hasVar(referMv.getIdentifier())){
                //if refer object has not been added into model, add it and process it
                if(HeapHandler.isHeapSelectFunction(t) && !HeapHandler.isAnonHeapSelectFunction(t,services))
                   processSelectFunction(sub1,model);
                else
                   model.add(referMv, ModelVariableGenerator.createInstance(referMv));
                
             }
             //assign field: mv is a field of referMv
             mv.setParentIdentifier(referMv.getIdentifier());
             model.assignField(mv, model.getVariable(referMv.getIdentifier()));
             
         }else{
            /*if mv is already in the model, we do nothing because basically
             * Term t is resolved already    */    
             
         }       
      }else{//add this select function to artificial variables collection
         add2ArtificialVars(refineTerm(t));
         investigateArtificialVars(t.sub(1));
         investigateArtificialVars(t.sub(2));
      }
   }
   
   private void buildListArraysAndElements(){
      listArrayElements = new LinkedList<Term>();
      listArrays = new LinkedList<Term>();
      for(KTGModel model: listModel){          
         for(ModelVariable mv: model.getVariables()){                                
            //listQuantifiedArrays = TermUtil.mergeListTerm(listQuantifiedArrays, TermUtil.extractQuantifiedArrays(mv.getValueCondition()));
            listArrays = TermUtil.mergeListTerm(listArrays, TermUtil.extractArrays(mv.getValueCondition()));
            listArrays = TermUtil.mergeListTerm(listArrays, TermUtil.extractArrays(mv.getSelectForm()));
         }       
      }     
      //listQuantifiedArrays = TermUtil.mergeListTerm(listQuantifiedArrays, TermUtil.extractQuantifiedArrays(nodeConstraints));
      listArrays = TermUtil.mergeListTerm(listArrays, TermUtil.extractArrays(nodeUsefulConstraints));
      //System.out.println("listArrays::: " + listArrays);
      
      for(KTGModel model: listModel){          
         for(ModelVariable mv: model.getVariables()){                                
            listArrayElements = TermUtil.mergeListTerm(listArrayElements, TermUtil.extractArrayElements(mv.getValueCondition(),listArrays));
            listArrayElements = TermUtil.mergeListTerm(listArrayElements, TermUtil.extractArrayElements(mv.getSymbolicValue(),listArrays));
         }       
      }     
      listArrayElements = TermUtil.mergeListTerm(listArrayElements, TermUtil.extractArrayElements(nodeUsefulConstraints,listArrays));   
      //System.out.println("listArrayElements::: " + listArrayElements);
   }
  
   private Term refineTerm(final Term t){
      //Term result = KeYResourceHandler.removeUnnecessaryTerm(t);
      Term result = heapHandler.replaceLengthFunctionByVar(t, KEGConstant.SEPARATOR);
      result = heapHandler.replaceSelectFunctionByItsField(result, KEGConstant.SEPARATOR);
      return result;
   }
   
   
   
   
   public NodeDetail extractNodeDetail() throws ProofInputException{
      //Term constraint = getUsefulConstraint();
      constructModels(); //construct Model of ModelVariable and artificial variables  
      System.out.println("artificial vars of the node: " + artificialVars);
      return new NodeDetail(node, listModel, listArrays, listArrayElements,
            artificialVars, nodeUsefulConstraints, nodeAllConstraints, SELF_NAME, postHeap, listFoundations);      
   }   
   
   
   /*
    * sometimes an array variable  does not have length variable as one of its children (for example: array variable with the value is unknown)
    * we will create an artificial length variable and add it to the set of children of the array variable
    * */
   private void addLength4Array(KTGModel model){
	   List<ModelVariable> variables = model.getVariables();
	   //List<Pair<Pair<ModelVariable, Term>,ModelVariable>> listPairLengthArray = new LinkedList<Pair<Pair<ModelVariable, Term>,ModelVariable>>();
	   List<ModelVariable> listNoLengthArrays = new LinkedList<ModelVariable>();
	   for(ModelVariable var: variables){
		   if(var instanceof ModelArrayVariable){
			 	List<ModelVariable> fields = ((ModelInstance)var.getValue()).getFields();
			 	if((fields==null)||(fields.size()==0)){ //here we have to add length variable
			 		listNoLengthArrays.add(var);			 		
			 		
			 	}
		   }
	   }
	   for(ModelVariable array: listNoLengthArrays){
		   Term lengthTerm = termBuilder.dotLength(array.getSelectForm());
		   ModelVariable length = ModelVariableGenerator.createModelVariable(lengthTerm, services);
		   length.setValueCondition(termBuilder.tt());
		   System.out.println(array.getIdentifier()+ " :***: " + array.getSymbolicValue());
		   if(!array.getSymbolicValue().toString().equals("null")){ // TODO: should compare to termBuilder.NULL
			   Term lengthValue = termBuilder.dotLength(array.getSymbolicValue());
			   lengthValue = anonHeapAnalyzer.replaceFreshVariableByCorrectedOne(lengthValue);
			   length.setSymbolicValue(lengthValue);			   
		   }else
			   length.setSymbolicValue(null);
		   System.out.println(length.getIdentifier()+ " :******: " + length.getSymbolicValue());
		   model.add(length,ModelVariableGenerator.createInstance(length));
		   length.setParentIdentifier(array.getIdentifier());
          model.assignField(length, model.getVariable(array.getIdentifier()));
	   }		
   }
   
   //extract post heap from proof
   private void extractPostHeap() {	   
	   /*System.out.println("\n:::::::Value of Heap");
       System.out.println(ProofSaver.printAnything(node.getProofNode().sequent(), services));
       
       System.out.println("=====================================");*/
       SiteProofVariableValueInput varinp = SymbolicExecutionUtil.createExtractTermSequent(services, node.getProofNode(), 
    		   SymbolicExecutionUtil.findModalityWithMaxSymbolicExecutionLabelId(node.getProofNode().sequent()), null, services.getTermBuilder().getBaseHeap(), true);
       
       System.out.println(varinp.getSequentToProve());
       ApplyStrategy.ApplyStrategyInfo info;
		try {
			info = SymbolicExecutionSideProofUtil.startSideProof(node.getProof(), 
			           node.getProof().getEnv(),
			           varinp.getSequentToProve(), 
			           StrategyProperties.METHOD_NONE,
			           StrategyProperties.LOOP_NONE,
			           StrategyProperties.QUERY_OFF,
			           StrategyProperties.SPLITTING_DELAYED);
			Goal goal = info.getProof().openGoals().head(); 
		       //System.out.println(goal);
		       /*System.out.println("=====================================");
		       Iterator<SequentFormula> seqFormulas = goal.sequent().antecedent().iterator();

		      while(seqFormulas.hasNext())  {  	   
		    	   
		    	   System.out.println("antecedent: " + seqFormulas.next());
		       }
*/		      Iterator<SequentFormula> sucseqFormulas = goal.sequent().succedent().iterator();

		      while(sucseqFormulas.hasNext())  {  	   		    	   
		    	   Term succFormula = sucseqFormulas.next().formula();
		    	   if(succFormula.op().toString().equals("ResultPredicate"))
		    		   postHeap = succFormula.sub(0);
		    	  break;		    	   
		       }

		} catch (ProofInputException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		System.out.println("postHeap:::: \n" + ProofSaver.printTerm(postHeap, services));
       
    }
   
   private void investigateHeapVariables(Term t){
	   if(t!=null){
		   if(t.subs()==null || t.subs().size()==0){
			   if(KeYResourceHandler.isFreshVarNotProgramVariable(t, services))
				   add2ListFoundations(t);
		   }else{
			   for(Term sub:t.subs())
				   investigateHeapVariables(sub);
		   }
	   }
   }
   
   private void add2ListFoundations(Term t){
	   if(!TermUtil.inListTerm(t, listFoundations) && (!TermUtil.inListTerm(t, listQVars))){   
	         System.out.println("detected foundation: " + t);
	         listFoundations.add(t);
	      }
   }
   
   
   /*
    * 
    * */
   private Term resolveTermByBelowUpdates(Term t){
	// get the updates	 
	   
	  ImmutableList<Term> updates = TermBuilder.goBelowUpdates2(node.getModalityPIO().subTerm()).first; 
	  System.out.println(updates);
	  // adding the updates in front of the term
	  Term updatedTerm = method.getServices().getTermBuilder().applySequential(updates, t);
	  final Term formula;
	  boolean isSub=false;
	  /* if(TermParser.isFormula(updatedTerm)){
		   //System.out.println("term is formula");
		   formula = updatedTerm;		   
	   }else{
*/		   //create a formula from escape hatch expression
		   Name predSymbol = new Name(services.getTermBuilder().newName("SimplificationWrapper"));
		   Function pred=new Function(predSymbol, Sort.FORMULA, t.sort());
		   formula = termBuilder.func(pred, updatedTerm);
		   isSub= true;
		   
	   //}
	  System.out.println("formula ::: " + ProofSaver.printAnything(formula, services));
	  //return TermUtil.resolveJavaIntFunctions(updatedTerm, services);
	  
	  InitConfig	initConfig =	new InitConfig(services.copy(new SimplifyTermProfile(), false));
	  Proof proof = new Proof("resolvePoststate", formula, "header", initConfig);
      ImmutableSet<Choice> choices = services.getProof().getInitConfig().getActivatedChoices(); 
      
      initConfig.setActivatedChoices(choices);
      // Initialize InitConfig with settings from the original InitConfig.
      final ProofSettings clonedSettings = services.getProof().getInitConfig().getSettings() != null ? new ProofSettings(services.getProof().getInitConfig().getSettings()) : null;
      initConfig.setSettings(clonedSettings);
      initConfig.setTaclet2Builder((HashMap<Taclet, TacletBuilder<? extends Taclet>>) services.getProof().getInitConfig().getTaclet2Builder().clone());
      initConfig.setTaclets(services.getProof().getInitConfig().getTaclets());
      // Create new ProofEnvironment and initialize it with values from initial one.
      ProofEnvironment env = new ProofEnvironment(initConfig);
      
      for (Taclet taclet : initConfig.activatedTaclets()) {
          initConfig.getJustifInfo().addJustification(taclet, services.getProof().getInitConfig().getJustifInfo().getJustification(taclet));
       }
       for (BuiltInRule rule : initConfig.builtInRules()) {
          RuleJustification origJusti = services.getProof().getInitConfig().getJustifInfo().getJustification(rule);
          if (origJusti == null) {
             assert rule instanceof OneStepSimplifier;
             origJusti = AxiomJustification.INSTANCE;
          }
          initConfig.getJustifInfo().addJustification(rule, origJusti);
       }	  	 
	     // Start auto mode
	     ProofStarter starter = new ProofStarter(false);
	     try {
			starter = SymbolicExecutionSideProofUtil.createSideProof(env, Sequent.EMPTY_SEQUENT.addFormula(new SequentFormula(formula), false, true).sequent(), "resolveJavaInt");
		} catch (ProofInputException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	      starter.setMaxRuleApplications(1000);
	      StrategyProperties strategyProperties = SymbolicExecutionStrategy.getSymbolicExecutionStrategyProperties(true, false, false, false, false, false);
	      starter.setStrategy(new SimplifyTermStrategy(proof, strategyProperties));
	      ApplyStrategyInfo result = starter.start();

	      
	      //System.out.println(result.getAppliedRuleApps());

	      Proof finalProof = starter.getProof();
	     
	     //extract result	     
	     System.out.println(ProofSaver.printAnything(finalProof.openGoals().head().sequent(), services));
	     Iterator<SequentFormula> sucseqFormulas = finalProof.openGoals().head().sequent().succedent().iterator();

	      while(sucseqFormulas.hasNext())  {  	   		    	   
	    	   Term succFormula = sucseqFormulas.next().formula();
	    	   if(succFormula.op().toString().equals("SimplificationWrapper"))
	    		   return succFormula.sub(0);
	    	 		    	   
	       }
	      
		   return t;                
	}

   /*
    * somtimes, a model variable is accidently considered as artificial variable
    * we remove it by check whether or not it is in the model
    * */
   private void removeFalseArtificialVar(){
	   List<Term> postArtVars = new LinkedList<Term>();
	   for(Term artTerm: artificialVars){
		   boolean inModel = false;
		   for(KTGModel m: listModel){
			   if(m.getVariable(artTerm.toString())!=null){
				   inModel = true;
				   break;
			   }			   
		   }
		   if(!inModel)
			   postArtVars.add(artTerm);
	   }
	   artificialVars = postArtVars;
		   
   }
  
   /*
    * somtimes, a foundation is accidently considered as artificial variable
    * we remove it by check whether or not it is in the model
    * */
   private void removeFalseFoundation(){
	   List<Term> postFoundation = new LinkedList<Term>();
	   for(Term t: listFoundations){
		   boolean inModel = false;
		   if(!t.toString().equals(SELF_NAME) && !t.equals(services.getTypeConverter().getHeapLDT().getHeap())){		   
			   for(KTGModel m: listModel){
				   ModelVariable var = m.getVariable(t.toString());
				   if(var!=null){
					   if(!var.isParameter()){
						   inModel = true;
						   break;
					   }
				   }			   
			   }			  
		   }
		   if(!inModel)
			   postFoundation.add(t);
	   }
	   listFoundations = postFoundation;
		   
   }
   
   private void testUsingPostHeap(Term arr){
	   TermBuilder termBuilder = services.getTermBuilder();
	   Term term = termBuilder.dotArr(arr, termBuilder.zTerm(0));
	   System.out.println("BEFORE USING POSTHEAP: " + ProofSaver.printTerm(term,services));
	   //term = termBuilder.select(term.sort(), postHeap, arr, term.sub(2));
	   //System.out.println("AFTER USING POSTHEAP: " +  ProofSaver.printTerm(replacedByPostHeap, services));
	   //System.out.println("AFTER SIMPLIFYING: " + TermUtil.simplifyTerm(term, services));
	   System.out.println("AFTER SIMPLIFYING: " +  ProofSaver.printTerm(resolveTermByBelowUpdates(term), services));
	   //TODO: ask Richard: why it return n instead of 0?
   }

}
