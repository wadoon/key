package de.tud.exploitgen.findsecret.optimizelowinput;


import java.util.LinkedList;
import java.util.List;
import java.util.Map;



import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

/*
 * this class generate the best low input for next experiment in the sense that it maximizes the leakage (measured by Shannon Entropy or other metric) 
 * 
 * */
public class BestLowInputProducer {	
	
	private List<PPCountingResult> listCountingResults;
	
	//private CountingResultTree countTree; //is created from listCountingResult
	private Services services;
	private List<MatchableCountingSolution> listMatchableSolutions;
	private long numberOfHighValues; //number of possible high values calculated via currentKnowlegde
	private List<String> listLowVars;
	public BestLowInputProducer(List<PPCountingResult> listCountingResults, Services services, long numberOfHighValues, List<String> listLowVars) {
		super();
		this.listCountingResults = listCountingResults;
		this.services = services;
		this.numberOfHighValues = numberOfHighValues;
		this.listLowVars = listLowVars;
		//countTree = new CountingResultTree();
		resolvePPCountingResult();
		/*for(PPCountingResult countResult: listCountingResults){
			countResult.printAllPossibleResults();
		}*/
		extract2ListMatchableCountingSolution();
	}
	
	/*
	 * add zero result into each PPCountingResult 
	 * */
	private void resolvePPCountingResult(){		
		for(PPCountingResult countResult: listCountingResults){
			countResult.setListResults(countResult.replaceOrCondition());
			//countResult.addZeroResult(services.getTermBuilder());			
		}		
	}
	
	
	private void extract2ListMatchableCountingSolution(){	
		CountingResultTree countTree = new CountingResultTree();
		for(PPCountingResult countResult: listCountingResults){			
			for(CountingResultTree leaf: countTree.getAllLeaves()){
				List<CountingResultTree> leaves = new LinkedList<CountingResultTree>();				
				for(CountingSolution condResult: countResult.getListResult()){
					if(!TermParser.isBooleanFalse(condResult.getCondition()))
						leaves.add(new CountingResultTree(condResult));
				}		
				leaf.addChildren(leaves, services);
			}
		}
		//remove all leaf that don't have enough childs (=listCountingResults.size)
		listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
		for(CountingResultTree tre: countTree.getAllLeaves()){
			List<Term> listCountTerms = tre.getListCountTerms();
			if(listCountTerms.size() == listCountingResults.size()){
				//create new condition: sum of all possible counting values must equal to numberOfHighValues
				TermBuilder tb = services.getTermBuilder();
				Term sum = tb.zero();
				for(Term t: listCountTerms){
					sum = tb.add(sum, t);
				}
				Term possCondition = tb.equals(sum, tb.zTerm((int)numberOfHighValues));
				Z3Solver z31 = new Z3Solver(possCondition, services);
				Term condition = tre.getConditionTerm();
				if(!z31.checkValid()){ //if possCondition is not valid then add it
					condition = tb.and(possCondition, condition);
				}
				Z3Solver z3 = new Z3Solver(condition, services);
				Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
				if(uniqueModel!=null){
					if(uniqueModel.second==1) //there is only one model
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,true));
					else
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));
				}
			}
		}
	}
	
	
	
	/*
	 * we are using naive approach to find best low input 
	 * basically we find low input that make all low-depended output probability are identical  
	 * */
	
	public Map<String,Long> findBestLowInputsUsingNaiveApproach(){

		List<Map<String,Long>> result = new LinkedList<Map<String, Long>>();
		TermBuilder tb = services.getTermBuilder();
		//List<CountingResultTree> listAggregatedCountResults = countTree.getAllLeaves();
		/*System.out.println("======== listAggregatedCountResults information: ==========");
		System.out.println("number of leaves: " + listAggregatedCountResults.size());
		for(CountingResultTree aggregatedCountResult: listAggregatedCountResults){
			aggregatedCountResult.printInfo();
		}*/
		
		//for(CountingResultTree aggregatedCountResult: listAggregatedCountResults){
		for(MatchableCountingSolution matchableSolution: listMatchableSolutions){
			List<Term> listCountTerms = matchableSolution.getListCountTerms();
			if(listCountTerms.size()>1){
				Term equalityTerm = tb.tt();
				Term value_0 = listCountTerms.get(0);			
				for(int i = 1; i<listCountTerms.size();i++){
					Term value_i = listCountTerms.get(i);
					equalityTerm = tb.and(equalityTerm, tb.equals(value_0, value_i));
				}
				Term optimalTerm = tb.and(equalityTerm,matchableSolution.getConditionTerm());
				Z3Solver solver = new Z3Solver(optimalTerm, services);
				Map<String, Long> optimalValue = solver.solveFormula2GetMapValues();
				if(optimalValue!=null)
					result.add(optimalValue);
			}
		}	
		//now we have a list of best low input, TODO: find the best of the best :D
		//at the moment just simply return the first element		
		return result.get(0);
	}
	
	public Map<String, Long> findBestLowInputsUsingConvexSolver(){
		/*try LocalSolver*/		
		//OptimizationSolver cSolver = new OptLocalSolver(listMatchableSolutions, services);
		OptimizationSolver cSolver = new AMPLSolver(listMatchableSolutions, services);
		return cSolver.findSolution();
		
	}
	
}
