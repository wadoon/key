package de.tud.exploitgen.findsecret.counting;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.TerminalNode;

import de.tud.exploitgen.findsecret.counting.gensrc.*;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.Compare_term_trioContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.EqualContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.GreaterContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.Greater_or_equalContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.LessContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.Less_or_equalContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.Minus_Arith_exprContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.Result_conditionContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.Result_pharse_emptyContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.Result_value_arith_exprContext;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.Result_value_inftyContext;
import de.tud.exploitgen.util.KEGConstant;

public class ANTLRIsccResultListener extends CountingResultBaseListener{	
	private Iscc2TermTransformer transformer;	
	
	
	public Iscc2TermTransformer getTransformer() {
		return transformer;
	}
	public void setTransformer(Iscc2TermTransformer transformer) {
		this.transformer = transformer;
	}
	
	
	@Override public void enterResult(CountingResultParser.ResultContext ctx) {
		//System.out.println("enter ResultContext: " + ctx.getText() + ", num of childs: " + ctx.getChildCount());
	}

	@Override public void exitResult(CountingResultParser.ResultContext ctx) { }
	
	@Override  public void enterParam_set_Empty(CountingResultParser.Param_set_EmptyContext ctx)  {
		//System.out.println("enter Param_set_EmptyContext: " + ctx.getText() + ", num of childs: " + ctx.getChildCount());
	}
	
	@Override public void exitParam_set_Empty(CountingResultParser.Param_set_EmptyContext ctx) { }
	
	@Override public void enterParam_set_non_empty(CountingResultParser.Param_set_non_emptyContext ctx) {
		//System.out.println("enter Param_set_non_emptyContext: " + ctx.getText() + ", num of childs: " + ctx.getChildCount());
		if(transformer !=null)
			for(int i=1; i<ctx.getChildCount(); i+=2)
				transformer.add2ListParameters(ctx.getChild(i).getText());
	}
	
	@Override public void exitParam_set_non_empty(CountingResultParser.Param_set_non_emptyContext ctx) { }
	
	
	@Override public void enterResult_options(CountingResultParser.Result_optionsContext ctx) { 
		//System.out.println("enter Result_optionsContext: " + ctx.getText() + ", num of childs: " + ctx.getChildCount());
	}
	
	@Override public void exitResult_options(CountingResultParser.Result_optionsContext ctx) { }
	
	@Override 
	public void enterResult_case_with_condition(CountingResultParser.Result_case_with_conditionContext ctx) {

		transformer.initiateStackTerm();
	}
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitResult_case_with_condition(CountingResultParser.Result_case_with_conditionContext ctx) {
		//System.out.println("result case: " + ctx.getText());
		transformer.add2MapResult();
	}
	
	
	/*@Override
	public void enterResult_value(Result_valueContext ctx) {
		transformer.setWorkWithValue(true);
	}
	@Override
	public void exitResult_value(Result_valueContext ctx) {
		
	}*/
	
	@Override
	public void enterResult_condition(Result_conditionContext ctx) {
		transformer.setWorkWithValue(false);
	}
	@Override
	public void enterResult_value_arith_expr(Result_value_arith_exprContext ctx) {
		transformer.setWorkWithValue(true);
	}
	@Override
	public void exitResult_value_arith_expr(Result_value_arith_exprContext ctx) {		
	}
	@Override
	public void enterResult_value_infty(Result_value_inftyContext ctx) {
		transformer.setWorkWithValue(true);
	}
	@Override
	public void exitResult_value_infty(Result_value_inftyContext ctx) {
		//in case the value is infinity, we set a very big number for it
		transformer.add2StackTerm("999999999999999999999999999999", true); //TODO: what is big enough number for infinity
	}
	@Override
	public void exitResult_condition(Result_conditionContext ctx) {		
	}
	
	@Override 
	public void enterResult_case_no_condition(CountingResultParser.Result_case_no_conditionContext ctx) {
		transformer.initiateStackTerm();
	}
	
	@Override public void exitResult_case_no_condition(CountingResultParser.Result_case_no_conditionContext ctx) {
		//transformer.translateFromStack2Result();
		transformer.add2MapResult();
	}
	
	
	@Override 
	public void enterArith_expr_Minus(CountingResultParser.Arith_expr_MinusContext ctx) { 
	}
	
	@Override 
	public void exitArith_expr_Minus(CountingResultParser.Arith_expr_MinusContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.MINUS);
	}
	
	@Override 
	public void enterArith_expr_Arith_term(CountingResultParser.Arith_expr_Arith_termContext ctx) {		
	}
	
	@Override 
	public void exitArith_expr_Arith_term(CountingResultParser.Arith_expr_Arith_termContext ctx) { }
	
	@Override 
	public void enterArith_expr_Plus(CountingResultParser.Arith_expr_PlusContext ctx) {
				
	}
	
	@Override 
	public void exitArith_expr_Plus(CountingResultParser.Arith_expr_PlusContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.PLUS);
	}
	
	@Override 
	public void enterArith_term_factor(CountingResultParser.Arith_term_factorContext ctx) {		
	}
	
	@Override 
	public void exitArith_term_factor(CountingResultParser.Arith_term_factorContext ctx) { }
	
	@Override 
	public void enterArith_term_Div(CountingResultParser.Arith_term_DivContext ctx) {	}
	
	@Override 
	public void exitArith_term_Div(CountingResultParser.Arith_term_DivContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.DIV);
	}
	
	@Override 
	public void enterArith_term_Mult(CountingResultParser.Arith_term_MultContext ctx) { 	}
	
	@Override 
	public void exitArith_term_Mult(CountingResultParser.Arith_term_MultContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.MULT);
	}
	
	@Override 
	public void enterFactor_Power(CountingResultParser.Factor_PowerContext ctx) { 
	
	}
	
	@Override 
	public void exitFactor_Power(CountingResultParser.Factor_PowerContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.POWER);
	}
	
	@Override 
	public void enterFactor_Round(CountingResultParser.Factor_RoundContext ctx) {		}
	
	@Override 
	public void exitFactor_Round(CountingResultParser.Factor_RoundContext ctx) {
		transformer.resolveStackTermByUnaryOp(KEGConstant.ROUND);
	}
	
	@Override 
	public void enterINT(CountingResultParser.INTContext ctx) { 
	}
	
	@Override public void exitINT(CountingResultParser.INTContext ctx) { }
	
	@Override public void enterFactor_floor(CountingResultParser.Factor_floorContext ctx) {		
		
	}
	
	@Override public void exitFactor_floor(CountingResultParser.Factor_floorContext ctx) {
		transformer.resolveStackTermByUnaryOp(KEGConstant.FLOOR);
	}
	
	@Override public void enterFactor_Fraction(CountingResultParser.Factor_FractionContext ctx) {
		//System.out.println("factor_fraction: " + ctx.getText() + ", number of child: " + ctx.getChildCount());
	}
	
	//with fraction operator, we temporarily consider it as a division operator
	@Override public void exitFactor_Fraction(CountingResultParser.Factor_FractionContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.DIV);
	}
	
	@Override public void enterFactor_Parentheses_Arith_Expr(CountingResultParser.Factor_Parentheses_Arith_ExprContext ctx) {		
	}
	
	@Override public void exitFactor_Parentheses_Arith_Expr(CountingResultParser.Factor_Parentheses_Arith_ExprContext ctx) { }
	
	@Override public void enterFactor_num_mul_param(CountingResultParser.Factor_num_mul_paramContext ctx) {		
		//get param as the second child of ctx
		transformer.add2StackTerm(ctx.getChild(1).getText(), false);
	}
	
	@Override public void exitFactor_num_mul_param(CountingResultParser.Factor_num_mul_paramContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.MULT);
	}
	
	//add to the stack of term a term respreseting for parameter
	@Override public void enterFactor_param(CountingResultParser.Factor_paramContext ctx) {
		transformer.add2StackTerm(ctx.getText(), false);
	}
	
	@Override public void exitFactor_param(CountingResultParser.Factor_paramContext ctx) {		
	}
	
	//add to stack of term a term representing for integer number
	@Override public void enterInt_num(CountingResultParser.Int_numContext ctx) {	
		transformer.add2StackTerm(ctx.getText(), true);
	}
	
	@Override public void exitInt_num(CountingResultParser.Int_numContext ctx) { }
	
	@Override public void enterLogic_expr_OR(CountingResultParser.Logic_expr_ORContext ctx) {	}
	
	@Override public void exitLogic_expr_OR(CountingResultParser.Logic_expr_ORContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.OR);
	}
	
	@Override public void enterLogic_expr_Exist(CountingResultParser.Logic_expr_ExistContext ctx) {		
	}
	
	@Override public void exitLogic_expr_Exist(CountingResultParser.Logic_expr_ExistContext ctx) {
	}
	
	@Override public void enterLogic_expr_logic_term(CountingResultParser.Logic_expr_logic_termContext ctx) {
	}
	
	@Override public void exitLogic_expr_logic_term(CountingResultParser.Logic_expr_logic_termContext ctx) { }
	
	@Override public void enterExists_expr(CountingResultParser.Exists_exprContext ctx) {		
	}
	
	@Override public void exitExists_expr(CountingResultParser.Exists_exprContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.EXISTS);
	}
	
	@Override public void enterQvar_expr_param(CountingResultParser.Qvar_expr_paramContext ctx) {
		transformer.add2StackTerm(ctx.getText(), false);
	}
	
	@Override public void exitQvar_expr_param(CountingResultParser.Qvar_expr_paramContext ctx) { }
	
	@Override public void enterQvar_expr_param_equals_expr(CountingResultParser.Qvar_expr_param_equals_exprContext ctx) {
		//get parameter as sub(0) of ctx
		transformer.add2StackTerm(ctx.getChild(0).getText(), false);
	}
	
	@Override public void exitQvar_expr_param_equals_expr(CountingResultParser.Qvar_expr_param_equals_exprContext ctx) {		
		transformer.resolveStackTermByBinaryOp(KEGConstant.EQ);
	}
	
	@Override public void enterLogic_term_logic_factor(CountingResultParser.Logic_term_logic_factorContext ctx) {	
	}
	@Override public void exitLogic_term_logic_factor(CountingResultParser.Logic_term_logic_factorContext ctx) { }
	
	@Override public void enterLogic_term_AND(CountingResultParser.Logic_term_ANDContext ctx) {		
	}
	
	@Override public void exitLogic_term_AND(CountingResultParser.Logic_term_ANDContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.AND);
	}
	
	@Override public void enterLogic_factor_compare(CountingResultParser.Logic_factor_compareContext ctx) {		
	}
	
	@Override public void exitLogic_factor_compare(CountingResultParser.Logic_factor_compareContext ctx) { }
	
	@Override public void enterLogic_factor_Parentheses_Logic_Expr(CountingResultParser.Logic_factor_Parentheses_Logic_ExprContext ctx) {
	}
	
	@Override public void exitLogic_factor_Parentheses_Logic_Expr(CountingResultParser.Logic_factor_Parentheses_Logic_ExprContext ctx) { }
	
	@Override public void enterCompare_term_Greater(CountingResultParser.Compare_term_GreaterContext ctx) {
	}
	
	@Override public void exitCompare_term_Greater(CountingResultParser.Compare_term_GreaterContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.GT);
	}
	
	@Override public void enterCompare_term_Greater_or_equal(CountingResultParser.Compare_term_Greater_or_equalContext ctx) {		
	}
	
	@Override public void exitCompare_term_Greater_or_equal(CountingResultParser.Compare_term_Greater_or_equalContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.GE);
	}
	
	@Override public void enterCompare_term_Less(CountingResultParser.Compare_term_LessContext ctx) { 
	}
	
	@Override public void exitCompare_term_Less(CountingResultParser.Compare_term_LessContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.LT);
	}
	
	@Override public void enterCompare_term_Less_or_equal(CountingResultParser.Compare_term_Less_or_equalContext ctx) {
	}
	
	@Override public void exitCompare_term_Less_or_equal(CountingResultParser.Compare_term_Less_or_equalContext ctx) {
		//System.out.println("less or equal detected! " + ctx.getText());
		transformer.resolveStackTermByBinaryOp(KEGConstant.LE);
	}
	
	@Override public void enterCompare_term_Equal(CountingResultParser.Compare_term_EqualContext ctx) {
	}
	
	@Override public void exitCompare_term_Equal(CountingResultParser.Compare_term_EqualContext ctx) {
		transformer.resolveStackTermByBinaryOp(KEGConstant.EQ);
	}

	
	@Override public void enterEveryRule(ParserRuleContext ctx) {	}
	
	@Override public void exitEveryRule(ParserRuleContext ctx) { }
	
	@Override public void visitTerminal(TerminalNode node) { 
		//transformer.add2StackTerm(node.getText());
	}

	
	@Override public void visitErrorNode(ErrorNode node) { }
	@Override
	public void exitResult_pharse_empty(Result_pharse_emptyContext ctx) {
		transformer.resolveEmptyResultPharse();
	}
	@Override
	public void exitMinus_Arith_expr(Minus_Arith_exprContext ctx) {
		transformer.resolveStackTermByUnaryOp(KEGConstant.MINUS);
	}
	@Override
	public void enterCompare_term_trio(Compare_term_trioContext ctx) {
		transformer.initStackTrioOp();	
	}
	@Override
	public void exitGreater_or_equal(Greater_or_equalContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.GE);
	}
	@Override
	public void exitGreater(GreaterContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.GT);	
	}
	@Override
	public void exitLess_or_equal(Less_or_equalContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.LE);
	}
	@Override
	public void exitLess(LessContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.LT);
	}
	@Override
	public void exitEqual(EqualContext ctx) {
		transformer.add2StackTrioOp(KEGConstant.EQ);
	}
	
	@Override
	public void exitCompare_term_trio(Compare_term_trioContext ctx) {
		transformer.resolveTrioComparison();
	}
	
	
	
}
