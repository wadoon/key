package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.math.BigInteger;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import localsolver.LSExpression;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;

public class GELMaximizerUsingCounting4NU extends
		LeakageMaximizerUsingCounting4NU {
	// listNumOfPartitions.get(i) = number of H satisfying K(H) && fp_i(H)
	private List<Long> listCardOfPartitions; 
	
	public GELMaximizerUsingCounting4NU(
			List<PPCountingResult> listCountingResults, Services services,
			List<String> listLowVars, String optSolver,
			SecretDistribution sDistribution, BigInteger sumAllFrequencies, List<Long> listNumOfPartitions) {
		super(listCountingResults, services, listLowVars, optSolver, sDistribution,
				sumAllFrequencies);
		this.listCardOfPartitions = listNumOfPartitions;
	}
	public GELMaximizerUsingCounting4NU(
			List<PPCountingResult> listCountingResults, Services services,
			List<String> listLowVars, String optSolver,
			SecretDistribution sDistribution, BigInteger sumAllFrequencies) {
		super(listCountingResults, services, listLowVars, optSolver, sDistribution,
				sumAllFrequencies);
		this.listCardOfPartitions = null;
	}

	@Override
	protected OptimalSolution findOptimalSolution4SingleCase(
			MatchableCountingSolution matchCountSolution) {
		return findOptimalSolution4SingleCase(matchCountSolution, KEGConstant.GUESSING_ENTROPY);
	}

	@Override
	protected double computeLeakage(OptimalSolution bestSolution) {
		if(listCardOfPartitions!=null){
			double scaledPreEntropy = 0;
			for(int i=0;i<listCardOfPartitions.size();i++){
				double sumOperand = 0;
				for(int j=0;j<i;j++){
					sumOperand +=listCardOfPartitions.get(j);
				}
				sumOperand += ((double)(listCardOfPartitions.get(i)+1))/2;
				sumOperand *= listCardOfPartitions.get(i);
				sumOperand *= sDistribution.getPartitions().get(i).getFrequency();
				
				scaledPreEntropy += sumOperand;
			}
			return (scaledPreEntropy-bestSolution.getOptimizeValue())/sumAllFrequencies.doubleValue();
		}else
			return -1;
	}

	@Override
	protected OptimalSolution resolveConstantSolution(
			MatchableCountingSolution matchCountSolution) {
		/*
		 * calculate scaled GUESSING entropy leakage
		 * */
		
		Map<String, List<CountingSolution>> mapByOutValue = 
				transformListMatchableCountingSolution2Map(matchCountSolution.getListCountingSolutions());
		Map<String, List<Double>> mapCalcValue = new HashMap<String,List<Double>>();
		for(String outValue: mapByOutValue.keySet()){
			List<CountingSolution> listCS = mapByOutValue.get(outValue);
			List<Double> listValue = new LinkedList<Double>();
			for(int i=0;i<listCS.size();i++)
				listValue.add((double)TermParser.getIntegerValue(listCS.get(i).getValue(), services));
			mapCalcValue.put(outValue, listValue);
		}
		//compute value
		double optValue = computeValueFromMap(mapByOutValue, mapCalcValue);
		
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		return new OptimalSolution(solution, optValue);
	}

	
	private double computeValueFromMap(Map<String, List<CountingSolution>> mapByOutValue, Map<String, List<Double>> mapCalcValue){
		//compute value
		double optValue =0;
		for(String outValue: mapCalcValue.keySet()){
			List<Double> listValue = mapCalcValue.get(outValue);
			List<CountingSolution> listCS= mapByOutValue.get(outValue);
			
			for(int i=0; i<listValue.size();i++){
				double sumOperand = 0;
				for(int j=0;j<i;j++){
					sumOperand +=listValue.get(j).doubleValue();
				}
				sumOperand += (listValue.get(i).doubleValue()+1)/2;
				sumOperand *= listValue.get(i);
				sumOperand *= sDistribution.getPartitions().get(
						listCS.get(i).getPartitionIdx()
						).getFrequency();
				
				optValue += sumOperand;
			}
		}
		return optValue;
	}

	@Override
	protected double computeOptimalValueUsingSolution(
			MatchableCountingSolution countingResults,
			Map<String, Long> optSolution) {
		Map<String, List<CountingSolution>> mapByOutValue = 
				transformListMatchableCountingSolution2Map(countingResults.getListCountingSolutions());
		Map<String, List<Double>> mapCalcValue = new HashMap<String,List<Double>>();
		for(String outValue: mapByOutValue.keySet()){
			List<CountingSolution> listCS = mapByOutValue.get(outValue);
			List<Double> listValue = new LinkedList<Double>();
			for(int i=0;i<listCS.size();i++)
				listValue.add(TermUtil.computeDouble(listCS.get(i).getValue(), optSolution, services));
			mapCalcValue.put(outValue, listValue);
		}
		//compute value
		double optValue = computeValueFromMap(mapByOutValue, mapCalcValue);
		return optValue;
	}

	public static Map<String, List<CountingSolution>> transformListMatchableCountingSolution2Map(List<CountingSolution> listCountingSolutions){
		Map<String, List<CountingSolution>> mapByOutValue = new HashMap<String, List<CountingSolution>>();
		for(CountingSolution cs: listCountingSolutions){
			if(mapByOutValue.containsKey(cs.getOutputValue())){
				mapByOutValue.get(cs.getOutputValue()).add(cs);
			}else{
				List<CountingSolution> listCS = new LinkedList<CountingSolution>();
				listCS.add(cs);
				mapByOutValue.put(cs.getOutputValue(), listCS);
			}
		}
		//sort all lists of map
		for(String outValue: mapByOutValue.keySet()){
			List<CountingSolution> listCS = mapByOutValue.get(outValue);
			Collections.sort(listCS);				
		}
		return mapByOutValue;
	}
}
