grammar CountingResult;

@header {
package de.tud.exploitgen.findsecret.libinterface.gensrc;

import de.uka.ilkd.key.logic.Term;
}

/***********************************
LEXER RULES
************************************/
Neg_num: MINUS Pos_num;
Pos_num: NONZERODIGIT (ZERO|NONZERODIGIT)* ;
FLOOR: 'floor' ; //floor function
OR : 'or';
AND: 'and' ;	
INFINITY: 'infty';
EXISTS: 'exists' ;
ZERO: '0';
POWER: '^' ;
NONZERODIGIT: '1'..'9';

Param: LETTER (NONZERODIGIT | ZERO |LETTER)* ;

LETTER: 'a'..'z'|'A'..'Z'|'_' ;

WS: (' ' | '\t')+ ;

GT: '>' ;
GE: '>=' ;
LT: '<' ;
LE: '<=' ;
EQ:	'=' ;

MULT: '*' ;
DIV: '/' ;
PLUS: '+';
MINUS: '-';

/********************************* 
PARSER RULES 
********************************/

result: param_set WS '->' WS result_pharse ;

param_set: '[]' #Param_set_Empty
		   | '[' Param (',' WS Param)* ']' #Param_set_non_empty;

result_pharse: '{' WS result_options WS '}';

result_options: result_case (';' WS result_case)* ;

result_case: 
	result_value WS ':' WS result_condition #Result_case_with_condition
	|result_value  #Result_case_no_condition
	; 

result_value: arith_expr | INFINITY;

result_condition: logic_expr;



arith_expr: 
	arith_expr WS PLUS WS arith_expr #Arith_expr_Plus
	|arith_expr WS MINUS WS arith_expr #Arith_expr_Minus
	|arith_term #Arith_expr_Arith_term
	;

arith_term: 
	arith_term WS MULT WS arith_term #Arith_term_Mult
	|arith_term WS DIV WS arith_term #Arith_term_Div
	|factor #Arith_term_factor;

factor: int_num #INT
		| factor DIV factor #Factor_Fraction
		| '[' factor ']' #Factor_Round //round operator
		| factor POWER factor		 #Factor_Power
		| Param #Factor_param
		| int_num Param #Factor_num_mul_param
		| '(' arith_expr ')' #Factor_Parentheses_Arith_Expr
		| FLOOR '(' factor ')' #Factor_floor
		;  


int_num /*returns[String output]*/: Pos_num //{$output=$Pos_num.text} 
	| Neg_num //{$output=$Neg_num.text} 
	| ZERO //{$output=$ZERO.text} 
	;

logic_expr: 
	logic_expr WS OR WS logic_expr #Logic_expr_OR
	| exists_expr #Logic_expr_Exist
	|logic_term #Logic_expr_logic_term
	; 

exists_expr: EXISTS WS '(' qvar_expr ':' WS logic_expr ')';

qvar_expr:  Param  #Qvar_expr_param
			| Param WS '=' WS arith_expr #Qvar_expr_param_equals_expr
			; 

logic_term: 
	logic_term WS AND WS logic_term #Logic_term_AND
	|logic_factor #Logic_term_logic_factor;


logic_factor: compare_term #Logic_factor_compare
			| '(' logic_expr ')' #Logic_factor_Parentheses_Logic_Expr 
			;

compare_term:
	arith_expr WS GT WS arith_expr #Compare_term_Greater
	|arith_expr WS GE WS arith_expr #Compare_term_Greater_or_equal
	|arith_expr WS LE WS arith_expr #Compare_term_Less
	|arith_expr WS LT WS arith_expr #Compare_term_Less_or_equal
	|arith_expr WS EQ WS arith_expr #Compare_term_Equal
	;