/**
 * 
 */
package de.tud.exploitgen.util;
import java.math.BigInteger;
import java.util.LinkedList;

import com.csvanefalk.keytestgen.StringConstants;
import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.parsers.TermParserException;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.PrimitiveType;
import de.uka.ilkd.key.ldt.HeapLDT;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.Equality;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.IfExThenElse;
import de.uka.ilkd.key.logic.op.IfThenElse;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.ObserverFunction;
import de.uka.ilkd.key.logic.op.Operator;
import de.uka.ilkd.key.logic.op.ProgramMethod;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.logic.op.Quantifier;
import de.uka.ilkd.key.logic.op.SortDependingFunction;
import de.uka.ilkd.key.logic.op.SortedOperator;
import de.uka.ilkd.key.logic.sort.ArraySort;
import de.uka.ilkd.key.logic.sort.NullSort;
import de.uka.ilkd.key.logic.sort.Sort;

/**
 * this class is originally written by Christopher Svanefalk in keytestgen project (TermParserTools)
 * some methods are rewritten or added by Huy
 */
public final class TermParser {
   /**
    * The sort names of the various binary functions represented in the KeY
    * {@link Term} hierarchy. Note that equality is not a part of this list,
    * since it is represented by its own operational type {@link Equality}.
    */
   private static final LinkedList<String> binaryFunctions;

   /**
    * The sort names for various Java Exceptions, as they are modelled in
    * KeYTestGen
    */
   private static final LinkedList<String> exceptionSorts;

   /**
    * The sort names of the literal kinds supported by KeYTestGen.
    */
   private static final LinkedList<String> literals;

   /**
    * Used for storing an index over all operator types currently handled by
    * KeYTestGen
    */
   private static final LinkedList<String> operators;

   /**
    * The names of the various primitive types in Java. As of the
    * implementation of this class (November 2012), KeY does not support
    * floating point types (i.e. <b>float</b> and <b>double</b>), and neither
    * does KeYTestGen2.
    */
   private static final LinkedList<String> primitiveTypes;

   /**
    * The names of the quantifiers supported by KeY: forall and exists
    */
   private static final LinkedList<String> quantifiers;

   /**
    * The sort names of the unary functions as supported by KeYTestGen.
      */
   private static final LinkedList<String> unaryFunctions;
   
   /**
    * the sort names of the minus functions 
    * added by Huy
    * */
   private static final LinkedList<String> unaryMinusFunctions;
   
   /**
    * added by Huy: collection of all string representing for multiplication, division,addition and subtraction in KeY with various types
    * */
   private static final LinkedList<String> multiplicationOperators;  
   private static final LinkedList<String> divisionOperators;
   private static final LinkedList<String> additionOperators;
   private static final LinkedList<String> subtractionOperators;
   private static final LinkedList<String> powerOperators;
   
   /**
    *
    */
   private static final LinkedList<String> builtinFunctions;

   static {

       primitiveTypes = new LinkedList<String>();
       TermParser.primitiveTypes.add(StringConstants.INTEGER);
       TermParser.primitiveTypes.add(StringConstants.BOOLEAN);
       TermParser.primitiveTypes.add(StringConstants.LONG);
       TermParser.primitiveTypes.add(StringConstants.BYTE);

       literals = new LinkedList<String>();
       TermParser.literals.add(StringConstants.NUMBERS);

       unaryFunctions = new LinkedList<String>();
       TermParser.unaryFunctions.add(StringConstants.Z);
       TermParser.unaryFunctions.add(StringConstants.NEGATE_LITERAL);
       unaryFunctions.add(StringConstants.NOT); //added by Huy
       unaryFunctions.add("javaUnaryMinusInt");
       unaryFunctions.add("javaUnaryMinusLong");
       
       unaryMinusFunctions = new LinkedList<String>();
       unaryMinusFunctions.add("javaUnaryMinusInt");
       unaryMinusFunctions.add("javaUnaryMinusLong");
       
      
       
       operators = new LinkedList<String>();
       TermParser.operators.add(StringConstants.AND);
       TermParser.operators.add(StringConstants.OR);
       TermParser.operators.add(StringConstants.NOT);
       TermParser.operators.add(StringConstants.GREATER_OR_EQUALS);
       TermParser.operators.add(StringConstants.LESS_OR_EQUALS);
       TermParser.operators.add(StringConstants.GREATER_THAN);
       TermParser.operators.add(StringConstants.LESS_THAN);
       TermParser.operators.add(StringConstants.MULTIPLICATION);
       TermParser.operators.add(StringConstants.DIVISION);
       TermParser.operators.add(StringConstants.ADDITION);
       TermParser.operators.add(StringConstants.SUBTRACTION);
       TermParser.operators.add(StringConstants.EQUALS);
       TermParser.operators.add(StringConstants.IMPLIES);

       exceptionSorts = new LinkedList<String>();
       TermParser.exceptionSorts.add(StringConstants.EXCEPTION_BASE);

       quantifiers = new LinkedList<String>();
       TermParser.quantifiers.add(StringConstants.FORALL);
       TermParser.quantifiers.add(StringConstants.EXISTS);

       builtinFunctions = new LinkedList<String>();
       builtinFunctions.add(StringConstants.LENGTH);
       builtinFunctions.add(StringConstants.ARRAYSTOREVALID);
       
       /********************************
        * added by Huy: initiate for addition, subtraction, multiplication, division string collections
        * */
       additionOperators = new LinkedList<String>();
       additionOperators.add(StringConstants.ADDITION);
       additionOperators.add("javaAddInt"); 
       additionOperators.add("javaAddLong");
       
       subtractionOperators = new LinkedList<String>();
       subtractionOperators.add(StringConstants.SUBTRACTION);
       subtractionOperators.add("javaSubInt");
       subtractionOperators.add("javaSubLong");
       
       multiplicationOperators = new LinkedList<String>();
       multiplicationOperators.add(StringConstants.MULTIPLICATION);
       multiplicationOperators.add("javaMulInt");
       multiplicationOperators.add("javaMulLong");
       
       divisionOperators = new LinkedList<String>();
       divisionOperators.add(StringConstants.DIVISION);
       divisionOperators.add("javaDivInt");
       divisionOperators.add("javaDivLong");
       divisionOperators.add("jdiv");
       divisionOperators.add("div");
       
       powerOperators = new LinkedList<String>();
       powerOperators.add("power");
       /***********************************************/
       
       binaryFunctions = new LinkedList<String>();
       binaryFunctions.addAll(additionOperators);
       binaryFunctions.addAll(subtractionOperators);
       binaryFunctions.addAll(multiplicationOperators);
       binaryFunctions.addAll(divisionOperators);
       
       TermParser.binaryFunctions.add(StringConstants.GREATER_OR_EQUALS);
       TermParser.binaryFunctions.add(StringConstants.LESS_OR_EQUALS);
       TermParser.binaryFunctions.add(StringConstants.GREATER_THAN);
       TermParser.binaryFunctions.add(StringConstants.LESS_THAN);
       TermParser.binaryFunctions.add(StringConstants.EQUALS);    //added by Huy    
      //added by Huy: infact in KeY, logical functions AND, OR are also binary function
       binaryFunctions.add(StringConstants.AND);
       binaryFunctions.add(StringConstants.OR);
       
       /*binaryFunctions = new LinkedList<String>();
       TermParser.binaryFunctions.add(StringConstants.GREATER_OR_EQUALS);
       TermParser.binaryFunctions.add(StringConstants.LESS_OR_EQUALS);
       TermParser.binaryFunctions.add(StringConstants.GREATER_THAN);
       TermParser.binaryFunctions.add(StringConstants.LESS_THAN);
       TermParser.binaryFunctions.add(StringConstants.EQUALS);    //added by Huy    
       TermParser.binaryFunctions.add(StringConstants.MULTIPLICATION);
       TermParser.binaryFunctions.add(StringConstants.DIVISION);
       TermParser.binaryFunctions.add(StringConstants.ADDITION);
       TermParser.binaryFunctions.add(StringConstants.SUBTRACTION);
       //add other binary function string
       binaryFunctions.add("javaAddInt"); 
       binaryFunctions.add("javaAddLong");
       binaryFunctions.add("javaSubInt");
       binaryFunctions.add("javaSubLong");
       binaryFunctions.add("javaMulInt");
       binaryFunctions.add("javaMulLong");
       binaryFunctions.add("javaDivInt");
       binaryFunctions.add("javaDivLong");
       
       
       ;*/
       
   }

   /**
    * Extracts the name of a field, given a representation on the form:
    * <code>[package].[class]::$[field]</code>
    *
    * @param term
    * @return
    */
   public static String extractName(final Term term) {

       final String fullName = term.toString();
       final int splitterIndex = fullName.lastIndexOf('$');

       if (splitterIndex == -1) {
           return term.toString();
       }

       return fullName.substring(splitterIndex + 1).replaceAll("[^A-Za-z0-9]", "");
   }

   /**
    * Retrieves the short-hand name of the variable a given Term represents.
    * For example, in the Term
    * <p/>
    * <pre>
    * com.example.MyClass::$myVariable,
    * </pre>
    * <p/>
    * the returned shorthand is <i>myVariable</i>.
    *
    * @param term the Term to process
 * @param services TODO
    * @return the short-hand name of the variable represented by the Term. If
    * the Term does not represent a variable, the regular toString
    * output of the Terms {@link Operator} instance is returned.
    */
   public static String getVariableNameForTerm(final Term term, Services services) {

       if (term.sort() == services.getTypeConverter().getHeapLDT().getFieldSort()) {
           if (term.op() instanceof Function) {
               Function field = (Function) term.op();
               if ( field.isUnique() ) {
                   return HeapLDT.getPrettyFieldName(field).replaceAll("[^A-Za-z0-9]", "");
               }
           }          
       }
       if(term.subs().size()==0)
    	   return term.toString();
       throw new IllegalArgumentException("The term " + term + " seems not to represent a field.");
   }

   /**
    * @param term the Term to check
    * @return true if the term has children, false otherwise.
    */
   public static boolean hasChildren(final Term term) {

       return term.subs().size() != 0;
   }

   /**
    * @param term the term
    * @return if the term represents addition
    * @revised by Huy: true iff the term operator is in additionOperators
    */
   public static boolean isAddition(final Term term) {
      return additionOperators.contains(term.op().toString());
       //return term.op().toString().equals(StringConstants.ADDITION);
   }

   /**
    * @param term the term
    * @return true iff. the term represents an AND junctor
    */
   public static boolean isAnd(final Term term) {

       return term.op().name().toString().equals(StringConstants.AND);
   }

   /**
    * @param term the term
    * @return true iff. the term represents an arithmetic comparator, i.e. GEQ,
    * GREATER_THAN, LEQ, or LESS_THAN.
    */
   public static boolean isArithmeticComparator(final Term term, final Services services) {

       return TermParser.isGreaterOrEquals(term, services) ||
               TermParser.isGreaterThan(term, services) ||
               TermParser.isLessOrEquals(term, services) ||
               TermParser.isLessThan(term, services) ||
               TermParser.isIntegerType(term.sub(0), services);
   }

   public static boolean isBinaryFunction(final Term term) {

       final String sortName = term.op().name().toString();

       return TermParser.binaryFunctions.contains(sortName);
   }
   
   //added by Huy
   public static boolean isLogicalBinaryFunction(final Term term){
      if((TermParser.isAnd(term))||(TermParser.isOr(term)))
         return true;
      return false;
   }

   /**
    * Check if the given Term represents a binary function, such as any of the
    * {@link Junctor} instances.
    *
    * @param term
    * @return
    */
   public static boolean isBinaryFunction2(final Term term) {
       /*
        * Since Not also qualifies as a junctor, albeit a unary one, check this
        * first.
        */
       if (TermParser.isNot(term)) {
           return false;
       }

       final de.uka.ilkd.key.logic.op.Operator operator = term.op();

       return (operator instanceof Junctor) || (operator instanceof Equality);
   }

   /**
    * @param term the term
    * @return true iff. the term is of boolean type, false otherwise.
    */
   public static boolean isBoolean(final Term term) {
       return term.sort().name().toString().equals(StringConstants.BOOLEAN);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a boolean constant, false
    * otherwise.
    */
   public static boolean isBooleanConstant(final Term term) /*throws TermParserException*/ {
       return TermParser.isBooleanFalse(term) || TermParser.isBooleanTrue(term);
   }

   /**
    * @param term the term
    * @return true iff. the term represents the boolean constant FALSE, false
    * otherwise.
    */
   public static boolean isBooleanFalse(final Term term) /*throws TermParserException*/ {
       //if (TermParser.isBoolean(term)) {
           return term.op().name().toString().equalsIgnoreCase(StringConstants.FALSE)?true:false;
                 
       /*} else {
           throw new TermTransformerException("Attempted to apply boolean operation to non-boolean literal");
       }*/
   }

   /**
    * @param term the term
    * @return true iff. the term represents the boolean constant TRUE, false
    * otherwise.
    */
   public static boolean isBooleanTrue(final Term term)/* throws TermTransformerException*/ {
       //if (TermParser.isBoolean(term)) {
          return term.op().name().toString().equalsIgnoreCase(StringConstants.TRUE)?true:false;          
       /*} else {
           throw new TermTransformerException("Attempted to apply boolean operation to non-boolean literal");
       }*/
   }

   /**
    * @param term the term
    * @return if the term represents division
    * @revised by Huy: return true iff term operator string is in list divisionOperators
    */
   public static boolean isDivision(final Term term) {
      return divisionOperators.contains(term.op().toString());
       //return term.op().toString().equals(StringConstants.DIVISION);
   }

   /**
    * @param term the term
    * @return true iff. the term represents an EQUALS junctor
    */
   public static boolean isEquals(final Term term) {

       return term.op() instanceof Equality;
   }

   /**
    * @param term the term
    * @return true iff. the term represents a Java Exception
    */
   public static boolean isExceptionSort(final Term term) {

       return TermParser.exceptionSorts.contains(term.sort().name().toString());
   }

   /**
    * @param term the term
    * @return true iff. the term represents the EXISTS quantifier, false
    * otherwise.
    */
   public static boolean isExistsQuantifier(final Term term) {

       return term.op() == Quantifier.EX;
   }

   /**
    * @param term the term
    * @return true iff. the term represents the FOR-ALL quantifier, false
    * otherwise.
    */
   public static boolean isForAllQuantifier(final Term term) {

       return term.op() == Quantifier.ALL;
   }

   /**
    * @param term the term
    * @return true iff. the term represents a Formula, false otherwise.
    */
   public static boolean isFormula(final Term term) {

       return term.sort() == Sort.FORMULA;
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link Function}
    */
   public static boolean isFunction(final Term term) {

       return term.op() instanceof Function;
   }

   /**
    * @param term the term
 * @param services TODO
    * @return true iff. the term represents a GEQ operator
    */
   public static boolean isGreaterOrEquals(final Term term, Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getGreaterOrEquals();
   }

   /**
    * @param term the term
 * @param services TODO
    * @return true iff. the term represents a GREATER_THAN operator
    */
   public static boolean isGreaterThan(final Term term, Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getGreaterThan();
   }

   /**
    * @param term the term
    * @return true iff. the term represents an {@link IfExThenElse} statement.
    */
   public static boolean isIfExThenElse(final Term term) {

       return term.op() instanceof IfExThenElse;
   }

   /**
    * @param term the term
    * @return true iff. the term represents an {@link IfThenElse} statement.
    */
   public static boolean isIfThenElse(final Term term) {

       return term.op() instanceof IfThenElse;
   }

   public static boolean isImplication(final Term term) {

       return term.op() == Junctor.IMP;
   }
   
   public static boolean isIntegerConst(final Term term, Services services){
      return isInteger(term, services)||isIntegerNegation(term, services);
   }

   /**
    * @param term the term
 * @param services TODO
    * @return true iff. the term represents a negative number, i.e. the Z
    * function, false otherwise.
    */
   public static boolean isInteger(final Term term, Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getNumberSymbol();
   }

   /**
    * @param term the term
 * @param services TODO
    * @return true iff. the term represents a negative number, i.e. the Z
    * function, false otherwise.
    */
   public static boolean isIntegerNegation(final Term term, Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getNegativeNumberSign();
   }

   /**
    * @param term the term
 * @param services TODO
    * @return true iff the term represents a minus function "-" (javaUnaryMinusInt), false otherwise
    * @author Huy
    * */
   public static boolean isUnaryMinusFunction(final Term term, Services services) {
      return term.op() == services.getTypeConverter().getIntegerLDT().getJavaUnaryMinusInt() ||
              term.op() == services.getTypeConverter().getIntegerLDT().getJavaUnaryMinusLong()
              ||term.op()==services.getTypeConverter().getIntegerLDT().getNeg()
              ||term.op().name().toString().equals("javaUnaryMinusInt");

   }
   
   public static boolean isIntegerType(final Term term, final Services services) {
       return term.sort() == services.getTypeConverter().getIntegerLDT().targetSort();
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link Junctor}
    */
   public static boolean isJunctor(final Term term) {

       return term.op() instanceof Junctor;
   }

   /**
    * @param term the term
 * @param services TODO
    * @return true iff. the term represents a LEQ operator
    */
   public static boolean isLessOrEquals(final Term term, Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getLessOrEquals();
   }

   /**
    * @param term the term
 * @param services TODO
    * @return true iff. the term represents a LESS_THAN operator
    */
   public static boolean isLessThan(final Term term, Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getLessThan();
   }

   public static boolean isLiteral(final Term term) {

       final String sortName = term.sort().name().toString();

       return TermParser.literals.contains(sortName);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link LocationVariable}.
    */
   public static boolean isLocationVariable(final Term term) {

       return term.op() instanceof LocationVariable;
   }

   public static boolean isLogicVariable(final Term term) {

       return term.op() instanceof LogicVariable;
   }

   /**
    * @param term the term
    * @return if the term represents multiplication
    * @revised by Huy: return true iff the term operator string is in list multiplicationOperators
    */
   public static boolean isMultiplication(final Term term) {
      return multiplicationOperators.contains(term.op().toString());
       //return term.op().toString().equals(StringConstants.MULTIPLICATION);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a NOT junctor
    */
   public static boolean isNot(final Term term) {

       return term.op() == Junctor.NOT;
   }

   /**
    * @param term the term
    * @return true iff. the term represents the {@link NullSort}
    */
   public static boolean isNullSort(final Term term) {

       return term.sort() instanceof NullSort;
   }

   /**
    * @param term the term
    * @return true iff. the term represents an {@link ObserverFunction}
    * construct.
    */
   public static boolean isObserverFunction(final Term term) {

       return term.op() instanceof ObserverFunction;
   }

   /**
    * @param term the term
    * @return true iff. the term represents an or junctor
    */
   public static boolean isOr(final Term term) {
       return term.op() == Junctor.OR;

   }

   /**
    * @return true iff. the term is of a primitive type, false otherwise.
    */
   public static boolean isPrimitiveType(final String type) {
       return TermParser.primitiveTypes.contains(type);
   }

   /**
    * Check if the given term represents a program construct with a supported
    * primitive type as its base type, such as a method or local variable
    * declaration.
    *
    * @param term the term to check
    * @return true if the Term represents an integer program construct, false
    * otherwise
    */
   public static boolean isPrimitiveType(final Term term) {

       final String sortName = term.sort().name().toString();

       return TermParser.primitiveTypes.contains(sortName);
   }

   /**
    * @param term the term
    * @return true iff. the term represents aa {@link ProgramMethod}.
    */
   public static boolean isProgramMethod(final Term term) {

       return term.op() instanceof ProgramMethod;
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link ProgramVariable}.
    */
   public static boolean isProgramVariable(final Term term) {

       return term.op() instanceof ProgramVariable;
   }

   public static boolean isQuantifier(final Term term) {

       return term.op() instanceof Quantifier;
   }

   /**
    * @param term the term
    * @return true iff. the term represents the RESULT constant
    */
   public static boolean isResult(final Term term) {

       return term.op().name().equals(StringConstants.RESULT);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link SortDependingFunction}
    */
   public static boolean isSortDependingFunction(final Term term) {

       return term.op() instanceof SortDependingFunction;
   }
   
   
   /**
    * @param term the term
    * @return true iff. the term represents a {@link SortedOperator}, which is
    * one of the two fundamental base sorts for Terms in KeY.
    */
   public static boolean isSortedOperator(final Term term) {

       return term.op() instanceof SortedOperator;
   }

   /**
    * @param term the term
    * @return if the term represents subtraction
    * @revised by Huy: return true iff the term operator string is in list subtractionOperators 
    */
   public static boolean isSubtraction(final Term term) {
      return subtractionOperators.contains(term.op().toString());
       //return term.op().toString().equals(StringConstants.SUBTRACTION);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a unary function, false otherwise.
    */
   public static boolean isUnaryFunction(final Term term) {

       final String operatorName = term.op().name().toString();

       return TermParser.unaryFunctions.contains(operatorName);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a variable, false otherwise.
    */
   public static boolean isVariable(final Term term) {

       final Operator operator = term.op();

       return operator instanceof Function || operator instanceof ProgramVariable;
   }
   
   /**
    * @param term the term
    * @return true iff. the term is a pair of term
    * */
   
   public static boolean isPair(final Term term){
      final Operator operator = term.op();
      return operator.name().toString().equals("pair")? true : false;
   }
   /**
    * @param term the term
    * @return true iff. the term represents an array, false otherwise.
    */
   public static boolean isArray(final Term term) {

       return term.sort() instanceof ArraySort;
   }
   
   
   
   /**
    * @param term the term
    * @return iff. the term is a field of the class
    * added by Huy
    * */
   public static boolean isField(Term term){  
	  if(term!=null){
		  
	      if(term.sort().toString().equals("Field"))
	         return true;
	      else
	         return false;
	  }else
		  return false;
   }

   
   
   /**
    * @param term the term
    * @return true iff. the term represents a built-in function, false
    * otherwise.
    */
   public static boolean isBuiltinFunction(final Term term) {

       final Operator operator = term.op();
       final String operatorName = term.op().name().toString();
       return operator instanceof Function && builtinFunctions.contains(operatorName);
   }

   /**
    * @param term the term to check
    * @return true if the term represents an array-length check, or false otherwise.
    */
   public static boolean isArrayLengthCheck(Term term) {
       return term.op().toString().equalsIgnoreCase(StringConstants.LENGTH) && term.op().arity() == 1;
   }

   /**
    * Generate an identifier String for a variable. Such an identifier is used
    * in order to uniquely distinguish an instance of a {@link ModelVariable}.
    * <p/>
    * If the variable is defined by a {@link SortDependingFunction}, the
    * identifier will be generated by recursively exploring the nesting
    * hierarchy this variable is a part of.
    *
    * @param term the {@link Term} representing the variable
    * @return the identifier String.
    * @see KTGModel
    */
   public static String resolveIdentifierString(final Term term, final String separator, Services services) {

       final Operator operator = term.op();

       term.toString();

       /*
        * Base case 1: underlying definition is a LocationVariable and hence
        * does not consist of any more nested recursions, so we just extract
        * the current variable name and go back.
        */
       if (operator.getClass() == LocationVariable.class) {

           final String name = TermParser.getVariableNameForTerm(term, services);

           return name;
           // return isPrimitiveType(term) ? "self_" + name : name;
       }

       /*
        * Base case 2: underlying definition is a Function, and hence either
        * represents the symbolic heap or the root object instance ("self"). In
        * this case we also cannot go any further. We are not interested in the
        * symbolic heap here, so we simply return the root name.
        */
       else if ((operator.getClass() == Function.class) && !operator.toString().equals("heap")) {
           return "self";
       }

       /*
        * Recursive case: underlying definition is still recursively defined,
        * so keep unwinding it.
        */
       else {

           if (TermParser.isNullSort(term.sub(1))) {
               return TermParser.getVariableNameForTerm(term.sub(2), services);
           }

           // Handle the special case where the SDF is an array accessor
           else if (term.sub(2).toString().startsWith(StringConstants.ARRAY)) {
               return TermParser.resolveIdentifierString(term.sub(1),
                                                              separator, services) + TermParser.resolveArrayAccessor(term.sub(
                       2), services);
           } else {
               return TermParser.resolveIdentifierString(term.sub(1),
                                                              separator, services) + separator + TermParser.getVariableNameForTerm(
                       term.sub(2), services);
           }
       }
   }

   /**
    * @param term the term to check
    * @return true if the term represents and Array, or false otherwise
    */
   public static boolean isArrayType(Term term) {
       return term.sort() instanceof ArraySort;
   }

   private static String resolveArrayAccessor(final Term term, Services services) {

       return "[" + TermParser.resolveNumber(term.sub(0), services) + "]";
   }

   public static String resolveNumber(final Term term, Services services) {

       if (term.op() == services.getTypeConverter().getIntegerLDT().getNumberTerminator()) {
           return "";
       } else if (term.op() == services.getTypeConverter().getIntegerLDT().getNumberSymbol()) {
           return TermParser.resolveNumber(term.sub(0), services) + "";
       } else {
           return TermParser.resolveNumber(term.sub(0), services) + term.op().name().toString();
       }
   }

   /**
    * @param term a term of boolean type
    * @return a boolean value corresponding to the value of the term.
    */
   public static boolean translateToJavaBoolean(final Term term) throws TermParserException {
       if (TermParser.isBooleanConstant(term)) {
           return TermParser.isBooleanTrue(term) ? true : false;
       } else {
           throw new TermTransformerException("Attempted to apply boolean operation to non-boolean literal");
       }
   }

   public static long getIntegerValue(Term term, Services services) {
       long value = Long.MAX_VALUE;
       
       
       if (TermParser.isIntegerNegation(term.sub(0), services)) {
           value = Long.parseLong("-" + TermParser.resolveNumber(term.sub(0).sub(0), services));
       } else {
           value = Long.parseLong(TermParser.resolveNumber(term.sub(0), services));
       }
       return value;
   }
   
   public static BigInteger getBigIntegerValue(Term term, Services services) {
	   BigInteger value;
	   if (TermParser.isIntegerNegation(term.sub(0), services)) {
           value = new BigInteger("-" + TermParser.resolveNumber(term.sub(0).sub(0), services));
       } else {
           value = new BigInteger(TermParser.resolveNumber(term.sub(0), services));
       }
	   return value;
   }
   //added by Huy
   public static boolean isAnonFunction(Term term, Services services){     
       //return services.getTypeConverter().getHeapLDT().getAnon() == term.op(); 
	   return term.op().name().toString().equals("anon");
   }
   
   //added by Huy
   public static boolean isHeapSort(Term term, Services services){
       return term.sort() == services.getTypeConverter().getHeapLDT().targetSort();
   }
   
  //added by Huy
   public static boolean isBSumFunction(Term term, Services services) {
      return term.op() == services.getTypeConverter().getIntegerLDT().getBsum();
   }
   
     //added by Huy
   public static boolean isSumFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getSum();
   }
   
   //added by Huy
   public static boolean isJavaCastByteFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getJavaCastByte();
   }

   public static boolean isJavaCastShortFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getJavaCastShort();
   }
   
   public static boolean isJavaCastIntFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getJavaCastInt();
   }

   public static boolean isJavaCastLongFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getJavaCastLong();
   }

   public static boolean isJavaCastCharFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getJavaCastChar();
   }

   
   //added by Huy
   public static boolean isInIntFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getInBounds(PrimitiveType.JAVA_INT);
   }
   
   //added by Huy
   public static boolean isMaxFunction(Term term){
      return term.op().name().toString().equals(StringConstants.MAX);         
   }
   
   //added by Huy
   public static boolean isMinFunction(Term term){
      return term.op().name().toString().equals(StringConstants.MIN);         
   }
   
   public static boolean isComprehension(Term term, Services services){
	   return isBSumFunction(term, services) || isMaxFunction(term) || isMinFunction(term);
   }
   
   //added by Huy
   public static boolean isAllFieldsFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getLocSetLDT().getAllFields();
   }
   
 //added by Huy
   public static boolean isSelectFunction(Term term, final Services services) {
       return term.op() == services.getTypeConverter().getHeapLDT().getSelect(services.getTypeConverter().getHeapLDT().getSortOfSelect(term.op()), services);
   }
   
   //added by Huy
   public static boolean isPowerFunction(Term term, Services services) {
       return term.op() == services.getTypeConverter().getIntegerLDT().getPower();
   }
   
   //added by Huy
   public static boolean isSeqDef(Term term){
	   return term.op().name().toString().equals("seqDef");
   }
   
   public static boolean isCreateFunction(Term t){
	   if(isFunction(t) && t.op().name().toString().equals("create"))
		   return true;
	   return false;
   
   }
   
   public static boolean isStoreFunction(Term t){
	   if(isFunction(t) && t.op().name().toString().equals("store"))
		   return true;
	   return false;
   }
   
   public static boolean isAllFieldsFunction(Term t){
	   if(isFunction(t) && t.op().name().toString().equals("allFields"))
		   return true;
	   return false;
   }
   
   public static boolean isMemsetFunction(Term t){
	   if(isFunction(t) && t.op().name().toString().equals("memset"))
		   return true;
	   return false;
   }
   
   public static boolean isArrayRangeFunction(Term t){
	   if(isFunction(t) && t.op().name().toString().equals("arrayRange"))
		   return true;
	   return false;
   }
}
