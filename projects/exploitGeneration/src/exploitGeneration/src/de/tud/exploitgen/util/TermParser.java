/**
 * 
 */
package de.tud.exploitgen.util;
import java.util.LinkedList;

import com.csvanefalk.keytestgen.StringConstants;
import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.parsers.TermParserException;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.Equality;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.IfExThenElse;
import de.uka.ilkd.key.logic.op.IfThenElse;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.ObserverFunction;
import de.uka.ilkd.key.logic.op.Operator;
import de.uka.ilkd.key.logic.op.ProgramMethod;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.logic.op.Quantifier;
import de.uka.ilkd.key.logic.op.SortDependingFunction;
import de.uka.ilkd.key.logic.op.SortedOperator;
import de.uka.ilkd.key.logic.sort.ArraySort;
import de.uka.ilkd.key.logic.sort.NullSort;

/**
 * this class is originally written by Christopher Svanefalk in keytestgen project (TermParserTools)
 * some methods are rewritten or added by Huy
 */
public final class TermParser{
   /**
    * The sort names of the various binary functions represented in the KeY
    * {@link Term} hierarchy. Note that equality is not a part of this list,
    * since it is represented by its own operational type {@link Equality}.
    */
   private static final LinkedList<String> binaryFunctions;

   /**
    * The sort names for various Java Exceptions, as they are modelled in
    * KeYTestGen
    */
   private static final LinkedList<String> exceptionSorts;

   /**
    * The sort names of the literal kinds supported by KeYTestGen.
    */
   private static final LinkedList<String> literals;

   /**
    * Used for storing an index over all operator types currently handled by
    * KeYTestGen
    */
   private static final LinkedList<String> operators;

   /**
    * The names of the various primitive types in Java. As of the
    * implementation of this class (November 2012), KeY does not support
    * floating point types (i.e. <b>float</b> and <b>double</b>), and neither
    * does KeYTestGen2.
    */
   private static final LinkedList<String> primitiveTypes;

   /**
    * The names of the quantifiers supported by KeY: forall and exists
    */
   private static final LinkedList<String> quantifiers;

   /**
    * The sort names of the unary functions as supported by KeYTestGen.
      */
   private static final LinkedList<String> unaryFunctions;
   
   /**
    * the sort names of the minus functions 
    * added by Huy
    * */
   private static final LinkedList<String> unaryMinusFunctions;
   
   /**
    * added by Huy: collection of all string representing for multiplication, division,addition and subtraction in KeY with various types
    * */
   private static final LinkedList<String> multiplicationOperators;  
   private static final LinkedList<String> divisionOperators;
   private static final LinkedList<String> additionOperators;
   private static final LinkedList<String> subtractionOperators;
   
   /**
    *
    */
   private static final LinkedList<String> builtinFunctions;

   static {

       primitiveTypes = new LinkedList<String>();
       TermParser.primitiveTypes.add(StringConstants.INTEGER);
       TermParser.primitiveTypes.add(StringConstants.BOOLEAN);
       TermParser.primitiveTypes.add(StringConstants.LONG);
       TermParser.primitiveTypes.add(StringConstants.BYTE);

       literals = new LinkedList<String>();
       TermParser.literals.add(StringConstants.NUMBERS);

       unaryFunctions = new LinkedList<String>();
       TermParser.unaryFunctions.add(StringConstants.Z);
       TermParser.unaryFunctions.add(StringConstants.NEGATE_LITERAL);
       unaryFunctions.add(StringConstants.NOT); //added by Huy
       unaryFunctions.add("javaUnaryMinusInt");
       unaryFunctions.add("javaUnaryMinusLong");
       
       unaryMinusFunctions = new LinkedList<String>();
       unaryMinusFunctions.add("javaUnaryMinusInt");
       unaryMinusFunctions.add("javaUnaryMinusLong");
       
       binaryFunctions = new LinkedList<String>();
       TermParser.binaryFunctions.add(StringConstants.GREATER_OR_EQUALS);
       TermParser.binaryFunctions.add(StringConstants.LESS_OR_EQUALS);
       TermParser.binaryFunctions.add(StringConstants.GREATER_THAN);
       TermParser.binaryFunctions.add(StringConstants.LESS_THAN);
       TermParser.binaryFunctions.add(StringConstants.EQUALS);    //added by Huy    
       TermParser.binaryFunctions.add(StringConstants.MULTIPLICATION);
       TermParser.binaryFunctions.add(StringConstants.DIVISION);
       TermParser.binaryFunctions.add(StringConstants.ADDITION);
       TermParser.binaryFunctions.add(StringConstants.SUBTRACTION);
       //add other binary function string
       binaryFunctions.add("javaAddInt"); 
       binaryFunctions.add("javaAddLong");
       binaryFunctions.add("javaSubInt");
       binaryFunctions.add("javaSubLong");
       binaryFunctions.add("javaMulInt");
       binaryFunctions.add("javaMulLong");
       binaryFunctions.add("javaDivInt");
       binaryFunctions.add("javaDivLong");
       
       //added by Huy: infact in KeY, logical functions AND, OR are also binary function
      /* binaryFunctions.add(StringConstants.AND);
       binaryFunctions.add(StringConstants.OR);*/
       
       operators = new LinkedList<String>();
       TermParser.operators.add(StringConstants.AND);
       TermParser.operators.add(StringConstants.OR);
       TermParser.operators.add(StringConstants.NOT);
       TermParser.operators.add(StringConstants.GREATER_OR_EQUALS);
       TermParser.operators.add(StringConstants.LESS_OR_EQUALS);
       TermParser.operators.add(StringConstants.GREATER_THAN);
       TermParser.operators.add(StringConstants.LESS_THAN);
       TermParser.operators.add(StringConstants.MULTIPLICATION);
       TermParser.operators.add(StringConstants.DIVISION);
       TermParser.operators.add(StringConstants.ADDITION);
       TermParser.operators.add(StringConstants.SUBTRACTION);
       TermParser.operators.add(StringConstants.EQUALS);
       TermParser.operators.add(StringConstants.IMPLIES);

       exceptionSorts = new LinkedList<String>();
       TermParser.exceptionSorts.add(StringConstants.EXCEPTION_BASE);

       quantifiers = new LinkedList<String>();
       TermParser.quantifiers.add(StringConstants.FORALL);
       TermParser.quantifiers.add(StringConstants.EXISTS);

       builtinFunctions = new LinkedList<String>();
       builtinFunctions.add(StringConstants.LENGTH);
       builtinFunctions.add(StringConstants.ARRAYSTOREVALID);
       
       /********************************
        * added by Huy: initiate for addition, subtraction, multiplication, division string collections
        * */
       additionOperators = new LinkedList<String>();
       additionOperators.add(StringConstants.ADDITION);
       additionOperators.add("javaAddInt"); 
       additionOperators.add("javaAddLong");
       
       subtractionOperators = new LinkedList<String>();
       subtractionOperators.add(StringConstants.SUBTRACTION);
       subtractionOperators.add("javaSubInt");
       subtractionOperators.add("javaSubLong");
       
       multiplicationOperators = new LinkedList<String>();
       multiplicationOperators.add(StringConstants.MULTIPLICATION);
       multiplicationOperators.add("javaMulInt");
       multiplicationOperators.add("javaMulLong");
       
       divisionOperators = new LinkedList<String>();
       divisionOperators.add(StringConstants.DIVISION);
       divisionOperators.add("javaDivInt");
       divisionOperators.add("javaDivLong");
       /***********************************************/
       
   }

   /**
    * Extracts the name of a field, given a representation on the form:
    * <code>[package].[class]::$[field]</code>
    *
    * @param term
    * @return
    */
   public static String extractName(final Term term) {

       final String fullName = term.toString();
       final int splitterIndex = fullName.lastIndexOf('$');

       if (splitterIndex == -1) {
           return term.toString();
       }

       return fullName.substring(splitterIndex + 1).replaceAll("[^A-Za-z0-9]", "");
   }

   /**
    * Retrieves the short-hand name of the variable a given Term represents.
    * For example, in the Term
    * <p/>
    * <pre>
    * com.example.MyClass::$myVariable,
    * </pre>
    * <p/>
    * the returned shorthand is <i>myVariable</i>.
    *
    * @param term the Term to process
    * @return the short-hand name of the variable represented by the Term. If
    * the Term does not represent a variable, the regular toString
    * output of the Terms {@link Operator} instance is returned.
    */
   public static String getVariableNameForTerm(final Term term) {

       final Operator operator = term.op();
       final String name = operator.name().toString();

       final String[] splitName = name.split("::\\$");
       return splitName[splitName.length - 1].replaceAll("[^A-Za-z0-9]", "");
   }

   /**
    * @param term the Term to check
    * @return true if the term has children, false otherwise.
    */
   public static boolean hasChildren(final Term term) {

       return term.subs().size() != 0;
   }

   /**
    * @param term the term
    * @return if the term represents addition
    * @revised by Huy: true iff the term operator is in additionOperators
    */
   public static boolean isAddition(final Term term) {
      return additionOperators.contains(term.op().toString());
       //return term.op().toString().equals(StringConstants.ADDITION);
   }

   /**
    * @param term the term
    * @return true iff. the term represents an AND junctor
    */
   public static boolean isAnd(final Term term) {

       return term.op().name().toString().equals(StringConstants.AND);
   }

   /**
    * @param term the term
    * @return true iff. the term represents an arithmetic comparator, i.e. GEQ,
    * GREATER_THAN, LEQ, or LESS_THAN.
    */
   public static boolean isArithmeticComparator(final Term term) {

       return TermParser.isGreaterOrEquals(term) ||
               TermParser.isGreaterThan(term) ||
               TermParser.isLessOrEquals(term) ||
               TermParser.isLessThan(term) ||
               TermParser.isIntegerType(term.sub(0));
   }

   public static boolean isBinaryFunction(final Term term) {

       final String sortName = term.op().name().toString();

       return TermParser.binaryFunctions.contains(sortName);
   }
   
   //added by Huy
   public static boolean isLogicalBinaryFunction(final Term term){
      if((TermParser.isAnd(term))||(TermParser.isOr(term)))
         return true;
      return false;
   }

   /**
    * Check if the given Term represents a binary function, such as any of the
    * {@link Junctor} instances.
    *
    * @param term
    * @return
    */
   public static boolean isBinaryFunction2(final Term term) {
       /*
        * Since Not also qualifies as a junctor, albeit a unary one, check this
        * first.
        */
       if (TermParser.isNot(term)) {
           return false;
       }

       final de.uka.ilkd.key.logic.op.Operator operator = term.op();

       return (operator instanceof Junctor) || (operator instanceof Equality);
   }

   /**
    * @param term the term
    * @return true iff. the term is of boolean type, false otherwise.
    */
   public static boolean isBoolean(final Term term) {
       return term.sort().name().toString().equals(StringConstants.BOOLEAN);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a boolean constant, false
    * otherwise.
    */
   public static boolean isBooleanConstant(final Term term) /*throws TermParserException*/ {
       return TermParser.isBooleanFalse(term) || TermParser.isBooleanTrue(term);
   }

   /**
    * @param term the term
    * @return true iff. the term represents the boolean constant FALSE, false
    * otherwise.
    */
   public static boolean isBooleanFalse(final Term term) /*throws TermParserException*/ {
       //if (TermParser.isBoolean(term)) {
           return term.op().name().toString().equals(StringConstants.FALSE)?true:false;
                 
       /*} else {
           throw new TermTransformerException("Attempted to apply boolean operation to non-boolean literal");
       }*/
   }

   /**
    * @param term the term
    * @return true iff. the term represents the boolean constant TRUE, false
    * otherwise.
    */
   public static boolean isBooleanTrue(final Term term)/* throws TermTransformerException*/ {
       //if (TermParser.isBoolean(term)) {
          return term.op().name().toString().equals(StringConstants.TRUE)?true:false;          
       /*} else {
           throw new TermTransformerException("Attempted to apply boolean operation to non-boolean literal");
       }*/
   }

   /**
    * @param term the term
    * @return if the term represents division
    * @revised by Huy: return true iff term operator string is in list divisionOperators
    */
   public static boolean isDivision(final Term term) {
      return divisionOperators.contains(term.op().toString());
       //return term.op().toString().equals(StringConstants.DIVISION);
   }

   /**
    * @param term the term
    * @return true iff. the term represents an EQUALS junctor
    */
   public static boolean isEquals(final Term term) {

       return term.op() instanceof Equality;
   }

   /**
    * @param term the term
    * @return true iff. the term represents a Java Exception
    */
   public static boolean isExceptionSort(final Term term) {

       return TermParser.exceptionSorts.contains(term.sort().name().toString());
   }

   /**
    * @param term the term
    * @return true iff. the term represents the EXISTS quantifier, false
    * otherwise.
    */
   public static boolean isExistsQuantifier(final Term term) {

       return term.op().name().toString().equals(StringConstants.EXISTS);
   }

   /**
    * @param term the term
    * @return true iff. the term represents the FOR-ALL quantifier, false
    * otherwise.
    */
   public static boolean isForAllQuantifier(final Term term) {

       return term.op().name().toString().equals(StringConstants.FORALL);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a Formula, false otherwise.
    */
   public static boolean isFormula(final Term term) {

       final String sortName = term.sort().name().toString();

       return sortName.equals("Formula");
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link Function}
    */
   public static boolean isFunction(final Term term) {

       return term.op() instanceof Function;
   }

   /**
    * @param term the term
    * @return true iff. the term represents a GEQ operator
    */
   public static boolean isGreaterOrEquals(final Term term) {

       return term.op().name().toString().equals(StringConstants.GREATER_OR_EQUALS);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a GREATER_THAN operator
    */
   public static boolean isGreaterThan(final Term term) {

       return term.op().name().toString().equalsIgnoreCase(StringConstants.GREATER_THAN);
   }

   /**
    * @param term the term
    * @return true iff. the term represents an {@link IfExThenElse} statement.
    */
   public static boolean isIfExThenElse(final Term term) {

       return term.op() instanceof IfExThenElse;
   }

   /**
    * @param term the term
    * @return true iff. the term represents an {@link IfThenElse} statement.
    */
   public static boolean isIfThenElse(final Term term) {

       return term.op() instanceof IfThenElse;
   }

   public static boolean isImplication(final Term term) {

       return term.op().name().toString().equals(StringConstants.IMPLIES);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a negative number, i.e. the Z
    * function, false otherwise.
    */
   public static boolean isInteger(final Term term) {

       final String name = term.op().name().toString();

       return name.equals("Z");
   }

   /**
    * @param term the term
    * @return true iff. the term represents a negative number, i.e. the Z
    * function, false otherwise.
    */
   public static boolean isIntegerNegation(final Term term) {

       final String name = term.op().name().toString();

       return name.equals("neglit");
   }

   /**
    * @param term the term
    * @return true iff the term represents a minus function "-" (javaUnaryMinusInt), false otherwise
    * @author Huy
    * */
   public static boolean isUnaryMinusFunction(final Term term){
      final String name = term.op().name().toString();
      return unaryMinusFunctions.contains(name);
   }
   
   public static boolean isIntegerType(final Term term) {
       final String name = term.sort().toString();
       return name.equals("int");
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link Junctor}
    */
   public static boolean isJunctor(final Term term) {

       return term.op() instanceof Junctor;
   }

   /**
    * @param term the term
    * @return true iff. the term represents a LEQ operator
    */
   public static boolean isLessOrEquals(final Term term) {

       return term.op().name().toString().equals(StringConstants.LESS_OR_EQUALS);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a LESS_THAN operator
    */
   public static boolean isLessThan(final Term term) {

       return term.op().name().toString().equals(StringConstants.LESS_THAN);
   }

   public static boolean isLiteral(final Term term) {

       final String sortName = term.sort().name().toString();

       return TermParser.literals.contains(sortName);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link LocationVariable}.
    */
   public static boolean isLocationVariable(final Term term) {

       return term.op() instanceof LocationVariable;
   }

   public static boolean isLogicVariable(final Term term) {

       return term.op() instanceof LogicVariable;
   }

   /**
    * @param term the term
    * @return if the term represents multiplication
    * @revised by Huy: return true iff the term operator string is in list multiplicationOperators
    */
   public static boolean isMultiplication(final Term term) {
      return multiplicationOperators.contains(term.op().toString());
       //return term.op().toString().equals(StringConstants.MULTIPLICATION);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a NOT junctor
    */
   public static boolean isNot(final Term term) {

       return term.op().name().toString().equals(StringConstants.NOT);
   }

   /**
    * @param term the term
    * @return true iff. the term represents the {@link NullSort}
    */
   public static boolean isNullSort(final Term term) {

       return term.sort() instanceof NullSort;
   }

   /**
    * @param term the term
    * @return true iff. the term represents an {@link ObserverFunction}
    * construct.
    */
   public static boolean isObserverFunction(final Term term) {

       return term.op() instanceof ObserverFunction;
   }

   /**
    * @param term the term
    * @return true iff. the term represents an or junctor
    */
   public static boolean isOr(final Term term) {

       if (TermParser.isBinaryFunction2(term)) {

           return term.op().name().toString().equals(StringConstants.OR);

       } else {

           return false;
       }
   }

   /**
    * @return true iff. the term is of a primitive type, false otherwise.
    */
   public static boolean isPrimitiveType(final String type) {
       return TermParser.primitiveTypes.contains(type);
   }

   /**
    * Check if the given term represents a program construct with a supported
    * primitive type as its base type, such as a method or local variable
    * declaration.
    *
    * @param term the term to check
    * @return true if the Term represents an integer program construct, false
    * otherwise
    */
   public static boolean isPrimitiveType(final Term term) {

       final String sortName = term.sort().name().toString();

       return TermParser.primitiveTypes.contains(sortName);
   }

   /**
    * @param term the term
    * @return true iff. the term represents aa {@link ProgramMethod}.
    */
   public static boolean isProgramMethod(final Term term) {

       return term.op() instanceof ProgramMethod;
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link ProgramVariable}.
    */
   public static boolean isProgramVariable(final Term term) {

       return term.op() instanceof ProgramVariable;
   }

   public static boolean isQuantifier(final Term term) {

       return term.op() instanceof Quantifier;
   }

   /**
    * @param term the term
    * @return true iff. the term represents the RESULT constant
    */
   public static boolean isResult(final Term term) {

       return term.op().name().equals(StringConstants.RESULT);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a {@link SortDependingFunction}
    */
   public static boolean isSortDependingFunction(final Term term) {

       return term.op() instanceof SortDependingFunction;
   }
   
   
   /**
    * @param term the term
    * @return true iff. the term represents a {@link SortedOperator}, which is
    * one of the two fundamental base sorts for Terms in KeY.
    */
   public static boolean isSortedOperator(final Term term) {

       return term.op() instanceof SortedOperator;
   }

   /**
    * @param term the term
    * @return if the term represents subtraction
    * @revised by Huy: return true iff the term operator string is in list subtractionOperators 
    */
   public static boolean isSubtraction(final Term term) {
      return subtractionOperators.contains(term.op().toString());
       //return term.op().toString().equals(StringConstants.SUBTRACTION);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a unary function, false otherwise.
    */
   public static boolean isUnaryFunction(final Term term) {

       final String operatorName = term.op().name().toString();

       return TermParser.unaryFunctions.contains(operatorName);
   }

   /**
    * @param term the term
    * @return true iff. the term represents a variable, false otherwise.
    */
   public static boolean isVariable(final Term term) {

       final Operator operator = term.op();

       return operator instanceof Function || operator instanceof ProgramVariable;
   }
   
   /**
    * @param term the term
    * @return true iff. the term is a pair of term
    * */
   
   public static boolean isPair(final Term term){
      final Operator operator = term.op();
      return operator.name().toString().equals("pair")?true:false;
   }
   /**
    * @param term the term
    * @return true iff. the term represents an array, false otherwise.
    */
   public static boolean isArray(final Term term) {

       return term.sort() instanceof ArraySort;
   }
   
   
   /**
    * @param term the term
    * @return iff. the term is a field of the class
    * added by Huy
    * */
   public static boolean isField(Term term){      
      if(term.sort().toString().equals("Field"))
         return true;
      else
         return false;
   }
   
   
   /**
    * @param term the term
    * @return iff. the term is a static field of the class
    * added by Huy
    * */
   public static boolean isStaticField(Term term){
      if(HeapHandler.isHeapSelectFunction(term)){
         if(HeapHandler.getObjectNameOfSellect(term).startsWith("null"))
            return true;
      }
      return false;
   }
   
   /**
    * @param term the term
    * @return iff. the term is not a program variable, but is a artificial variable with primitive type (integer, boolean)
    * added by Huy
    * used for loop invariant variables
    * */
   
   public static boolean isArtificialVariable(final Term term){
	   if(isPrimitiveType(term)&&((term.subs()).size()==0) && !isField(term))
		   return true;
	   return false;
   }
   
   /**
    * @param term the term
    * @return true iff. the term represents a built-in function, false
    * otherwise.
    */
   public static boolean isBuiltinFunction(final Term term) {

       final Operator operator = term.op();
       final String operatorName = term.op().name().toString();
       return operator instanceof Function && builtinFunctions.contains(operatorName);
   }

   /**
    * @param term the term to check
    * @return true if the term represents an array-length check, or false otherwise.
    */
   public static boolean isArrayLengthCheck(Term term) {
       return term.op().toString().equalsIgnoreCase(StringConstants.LENGTH) && term.op().arity() == 1;
   }

   /**
    * Generate an identifier String for a variable. Such an identifier is used
    * in order to uniquely distinguish an instance of a {@link ModelVariable}.
    * <p/>
    * If the variable is defined by a {@link SortDependingFunction}, the
    * identifier will be generated by recursively exploring the nesting
    * hierarchy this variable is a part of.
    *
    * @param term the {@link Term} representing the variable
    * @return the identifier String.
    * @see Model
    */
   public static String resolveIdentifierString(final Term term, final String separator) {

       final Operator operator = term.op();

       term.toString();

       /*
        * Base case 1: underlying definition is a LocationVariable and hence
        * does not consist of any more nested recursions, so we just extract
        * the current variable name and go back.
        */
       if (operator.getClass() == LocationVariable.class) {

           final String name = TermParser.getVariableNameForTerm(term);

           return name;
           // return isPrimitiveType(term) ? "self_" + name : name;
       }

       /*
        * Base case 2: underlying definition is a Function, and hence either
        * represents the symbolic heap or the root object instance ("self"). In
        * this case we also cannot go any further. We are not interested in the
        * symbolic heap here, so we simply return the root name.
        */
       else if ((operator.getClass() == Function.class) && !operator.toString().equals("heap")) {
           return "self";
       }

       /*
        * Recursive case: underlying definition is still recursively defined,
        * so keep unwinding it.
        */
       else {

           if (TermParser.isNullSort(term.sub(1))) {
               return TermParser.getVariableNameForTerm(term.sub(2));
           }

           // Handle the special case where the SDF is an array accessor
           else if (term.sub(2).toString().startsWith(StringConstants.ARRAY)) {
               return TermParser.resolveIdentifierString(term.sub(1),
                                                              separator) + TermParser.resolveArrayAccessor(term.sub(
                       2));
           } else {
               return TermParser.resolveIdentifierString(term.sub(1),
                                                              separator) + separator + TermParser.getVariableNameForTerm(
                       term.sub(2));
           }
       }
   }

   /**
    * @param term the term to check
    * @return true if the term represents and Array, or false otherwise
    */
   public static boolean isArrayType(Term term) {
       return term.sort() instanceof ArraySort;
   }

   private static String resolveArrayAccessor(final Term term) {

       return "[" + TermParser.resolveNumber(term.sub(0)) + "]";
   }

   public static String resolveNumber(final Term term) {

       final String numberString = term.op().name().toString();

       if (numberString.equals("#")) {
           return "";
       } else if (numberString.equalsIgnoreCase(StringConstants.Z)) {
           return TermParser.resolveNumber(term.sub(0)) + "";
       } else {
           return TermParser.resolveNumber(term.sub(0)) + numberString;
       }
   }

   /**
    * @param term a term of boolean type
    * @return a boolean value corresponding to the value of the term.
    */
   public static boolean translateToJavaBoolean(final Term term) throws TermParserException {
       if (TermParser.isBooleanConstant(term)) {
           return TermParser.isBooleanTrue(term) ? true : false;
       } else {
           throw new TermTransformerException("Attempted to apply boolean operation to non-boolean literal");
       }
   }

   public static int getIntegerValue(Term term) {
       int value = Integer.MAX_VALUE;
       if (TermParser.isIntegerNegation(term.sub(0))) {
           value = Integer.parseInt("-" + TermParser.resolveNumber(term.sub(0).sub(0)));
       } else {
           value = Integer.parseInt(TermParser.resolveNumber(term.sub(0)));
       }
       return value;
   }
}
