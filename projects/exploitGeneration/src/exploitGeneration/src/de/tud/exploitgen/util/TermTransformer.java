package de.tud.exploitgen.util;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;




public class TermTransformer {
	
	private final int rootLevel = 0;
	
	private Services services;
	private TermBuilder termBuilder;
	public TermTransformer(Services services) {
		super();
		this.services = services;		
		termBuilder = services.getTermBuilder();
		
	}
	
	/*
	 * ===============transform If-Then-Else term (serving parametric counting)===================	 
	 * because barvinok tool does not support ITE (if-then-else), we have to preprocess term containing ITE
	 * solution ITE(cond?trueCase:falseCase) -> (cond && trueCase) or (!cond && falseCase)
	 * */
	private boolean hasITE(Term t){
		return t.toString().contains("if-then-else(");
	}
	
	public Term transformITE(Term t){
		if(hasITE(t)){
			if(TermParser.isExistsQuantifier(t)||TermParser.isForAllQuantifier(t) || TermParser.isUnaryFunction(t)){
				int size = t.subs().size();
				Term[] subTerms = new Term[size];
				for(int i= 0;i<size;i++){
					subTerms[i] = transformITE(t.sub(i));
				}
				return termBuilder.tf().createTerm(t.op(), subTerms , t.boundVars(), t.javaBlock());
			}
			if(isBoolAncestorOfITE(t)){
				if(TermParser.isIfThenElse(t)){
					return transformITE(replaceITETerm(t));
				}else {
					Term termITE = getSubITETerm(t);
					Term trueCase = constructCaseTerm(t, termITE, true, rootLevel);
					Term falseCase = constructCaseTerm(t, termITE, false, rootLevel);
					Term aggregatedTerm = termBuilder.or(trueCase, falseCase);
					return transformITE(aggregatedTerm);
				}
			}else{				
				System.err.println("insufficient term input!!! : " + t.toString());
				return null;
			}				
		}else
			return t;
	}
	
	private Term constructCaseTerm(Term ancestorTerm, Term termITE, boolean cond, int level){
		int size = ancestorTerm.subs().size();
		Term[] subTerms = new Term[size];
		
		for(int i=0;i<size;i++){
			Term subI = ancestorTerm.sub(i);
			if(subI.toString().equals(termITE.toString())){
				if(cond){
					subTerms[i] = termITE.sub(1);					
				}else{
					subTerms[i] = termITE.sub(2);						
				}
			}
			else if(subI.toString().contains(termITE.toString())){
				int nextLevel = level+1;
				subTerms[i] = constructCaseTerm(subI, termITE, cond, nextLevel);
			}else
				subTerms[i] = ancestorTerm.sub(i);
		}
		if(level==rootLevel){
			Term conditionTerm = null;
			if(cond)
				conditionTerm = termITE.sub(0);
			else
				conditionTerm = termBuilder.not(termITE.sub(0));
			return termBuilder.and(
				conditionTerm, 
				termBuilder.tf().createTerm(ancestorTerm.op(), subTerms , ancestorTerm.boundVars(), ancestorTerm.javaBlock()));
		}else{
			return termBuilder.tf().createTerm(ancestorTerm.op(), subTerms , ancestorTerm.boundVars(), ancestorTerm.javaBlock());
		}
	}
	
	private Term getSubITETerm(Term termContainITE){
		if(TermParser.isIfThenElse(termContainITE))
			return termContainITE;
		else{
			for(Term sub: termContainITE.subs())
				if(hasITE(sub))
					return getSubITETerm(sub);
			return null;
		}
	}
	
	
	
	private Term replaceITETerm(Term t){
		return termBuilder.or(
        		termBuilder.and(t.sub(0), t.sub(1)), 
        		termBuilder.and(
        				termBuilder.not(t.sub(0)), 
        				t.sub(2)
        				)
        		);
        		
	}
	
	
	
	private boolean isBoolAncestorOfITE(Term t){
		//return (TermParser.isBoolean(t) || (TermParser.isExistsQuantifier(t)) || (TermParser.isForAllQuantifier(t));
		return TermParser.isFormula(t);
	}
	//=====================================================================
	
	/*
	 * ===============transform BitwiseXOr (serving Z3Solver that does not support bitwise XOr) ===================
	 * */
	public Term transformBWXORTerm(Term t, int numBit){
    	if(TermParser.isBWXor(t)){
    		Term term1= transformBWXORTerm(t.sub(0), numBit);
    		Term term2= transformBWXORTerm(t.sub(1), numBit);
    		return transformBWXOr(term1, term2, numBit);    		
    	}else if(TermParser.isIntegerConst(t, services)){
    		return t;
    	}else if(t.subs().size()>0){
    		int size =t.subs().size();
            Term[] subs = new Term[size];
            for(int i=0;i<size;i++){
               subs[i] = transformBWXORTerm(t.sub(i),numBit);
            }
            return termBuilder.tf().createTerm(t.op(), subs, t.boundVars(),t.javaBlock());
    	}else
    		return t;
    		
    }
    
    /*
     * because many external tool (parametric counting, non-linear optimization...) do not support bitwise XOR operator, 
     * we convert bitwise XOR to a Term consisting of ITE, mod as followings:
     * result = (ite(t1%2==t2%2)?0:1) + 2*(ite((t1/2)%2==(t2/2)%2)?0:1) + 4*(ite(((t1/2)/2)%2==((t2/2)/2)%2)?0:1) + ... (numBit times)
     * 
     * */
    private Term transformBWXOr(final Term term1, final Term term2, int numBit){
 	   Term result = termBuilder.zero();
 	   int weight = 1;
 	   Term num2 = termBuilder.zTerm(2);
 	   Term t1 = term1;
 	   Term t2 = term2;
 	   for(int i=0;i<numBit;i++){
 		   Term xorBitI = termBuilder.ife(
 				   termBuilder.equals(
 						   termBuilder.mod(t1, num2), 
 						   termBuilder.mod(t2, num2)
 						   ), 
 				   termBuilder.zero(), 
 				   termBuilder.one());
 		   xorBitI = termBuilder.mul(xorBitI, termBuilder.zTerm(weight));
 		   result = termBuilder.add(result, xorBitI);
 		   
 		   weight *=2;
 		   t1 = termBuilder.div(t1, num2);
 		   t2 = termBuilder.div(t2, num2);
 	   }
 	   return result;	   
    }
    
    public Term transformModInTerm(final Term term){
    	if(TermParser.isModulo(term)){
    		Term term1= transformModInTerm(term.sub(0));
    		Term term2= transformModInTerm(term.sub(1));
    		return transformMod(term1, term2);    		
    	}else if(TermParser.isIntegerConst(term, services)){
    		return term;
    	}else if(term.subs().size()>0){
    		int size =term.subs().size();
            Term[] subs = new Term[size];
            for(int i=0;i<size;i++){
               subs[i] = transformModInTerm(term.sub(i));
            }
            return termBuilder.tf().createTerm(term.op(), subs, term.boundVars(),term.javaBlock());
    	}else
    		return term;
    }
    
    /*
     * mod(a,b) is transformed into a-(a/b)*b
     * */
    private Term transformMod(final Term dividend, final Term division){
    	return termBuilder.minus(dividend, 
    			termBuilder.mul(
    					termBuilder.div(dividend, division), 
    					division));
    }
    
    
    /*
     * transform sum function t to bsum function 
     * */
     public Term sum2Bsum(Term t){
        if(TermParser.isSumFunction(t, services)){
           if(t.boundVars().size()>1){
              //TODO: how to work with sum function containing more than one bounded variables?            
              return t;
           }else{
              return new QuantifiedFunctionResolver(t, services).transformSum2Bsum();
           }
        }else if(t.subs().size()>0){
           int size =t.subs().size();
           Term[] subs = new Term[size];
           for(int i=0;i<size;i++){
              subs[i] = sum2Bsum(t.sub(i));
           }
           return termBuilder.tf().createTerm(t.op(), subs, t.boundVars(),t.javaBlock());
        }else
           return t;
     }
     
    
}
