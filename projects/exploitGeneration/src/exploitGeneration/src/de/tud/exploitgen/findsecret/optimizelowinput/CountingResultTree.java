package de.tud.exploitgen.findsecret.optimizelowinput;

import java.util.LinkedList;
import java.util.List;

import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;

/*
 * each parametric polytopes can lead to more than one counting result (represented by class CountingSolution), 
 * it is convenient to combine these results using tree structure,
 * the child node accumulates the information of its father node
 * after constructing the tree, we only have to use leaf nodes in analyzing because they contain all necessary information
 * 
 * */
public class CountingResultTree{
	private CountingSolution condResult;		
	private List<CountingResultTree> children;
	private List<CountingSolution> listCountingSolutions;
	private Term conditionTerm;	
		
	public CountingResultTree(){
		condResult = null;
		children = new LinkedList<CountingResultTree>();
		this.listCountingSolutions = new LinkedList<CountingSolution>();		
		this.conditionTerm = null;
	}
	
	public CountingResultTree(CountingSolution condResult) {
		super();
		this.condResult = condResult;
		this.children = new LinkedList<CountingResultTree>();
		this.listCountingSolutions = new LinkedList<CountingSolution>();
		this.listCountingSolutions.add(condResult);
		this.conditionTerm = condResult.getCondition();
	}

	public List<CountingSolution> getListCountingSolutions() {
		return listCountingSolutions;
	}

	public void setListCountingSolutions(List<CountingSolution> listCountTerms) {
		this.listCountingSolutions = listCountTerms;
	}

	public Term getConditionTerm() {
		return conditionTerm;
	}

	public void setConditionTerm(Term conditionTerm) {
		this.conditionTerm = conditionTerm;
	}

	public CountingSolution getCondResult() {
		return condResult;
	}

	
	public void addChildren(List<CountingResultTree> children, Services services) {
		
		for(CountingResultTree child: children)
			if(canAdd(child, services)){
				addChild(child, services);				
			}		
	}
	
	
	public void add2ListCountTerms(List<CountingSolution> countTerms){
		if(countTerms!=null)
			for(CountingSolution term: countTerms)
				listCountingSolutions.add(term);
	}
	
	/*
	 * check if the child node should be added to children list of this node
	 * it is added if an only if the new aggregated condition is satisfiable
	 * */
	public boolean canAdd(CountingResultTree child, Services services){
		if(conditionTerm==null) //root can add any children
			return true;
		else{
			TermBuilder tb = services.getTermBuilder();
			Term newCondition = tb.and(conditionTerm, child.getConditionTerm());
			Z3Solver solver = new Z3Solver(newCondition, services);
			//System.out.println("newCondition: " + newCondition);
			if(solver.checkSatisfiable()){	
				//System.out.println("good!!!");
				return true;
			}
			else{
				//System.out.println("BAD!!!");
				return false;
				
			}
		}
	}
	
	public boolean redundantCondition(CountingResultTree child, Services services){
		TermBuilder tb = services.getTermBuilder();
		Term checkTerm = tb.imp(conditionTerm, child.getConditionTerm());
		Z3Solver solver = new Z3Solver(checkTerm, services);
		if(solver.checkValid()){	
			return true;
		}
		else{
			return false;
			
		}

	}
	
	public void addChild(CountingResultTree child, Services services){
		TermBuilder tb = services.getTermBuilder();
		Term newCondition;
		//accumulate information of parent node into child node
		if(conditionTerm!=null && child.getConditionTerm()!=null){
			//check if conditionTerm of child is redundant or not	
			if(!redundantCondition(child, services)){
				newCondition = tb.and(conditionTerm, child.getConditionTerm());
			}else{
				newCondition = conditionTerm;
			}
		}
		else if(conditionTerm==null && child.getConditionTerm()!=null)
			newCondition = child.getConditionTerm();
		else if(conditionTerm!=null && child.getConditionTerm()==null)
			newCondition = conditionTerm;
		else
			newCondition = null;
			
		child.setConditionTerm(newCondition);		
		
		/*if(child.getCondResult().isConstValue()) //do not care about constant value
			child.setListCountTerms(this.getListCountTerms());
		else*/
			child.add2ListCountTerms(this.getListCountingSolutions());		
		children.add(child);
	}
	
	
	public List<CountingResultTree> getAllLeaves(){
    //performing tree traversal to get all leaf nodes      
      if(isLeaf()){
         List<CountingResultTree> result = new LinkedList<CountingResultTree>();
         result.add(this);
         return result;
      }else{
         List<CountingResultTree> result = new LinkedList<CountingResultTree>();
         for(CountingResultTree mt: children)
            result.addAll(mt.getAllLeaves());
         return result;
      }    
   }
		 
	public boolean isLeaf(){
	   return (children.size()==0);	   
	}
	
	public void printInfo(){
		System.out.println("+++++");
		System.out.println("listCountTerms: " + listCountingSolutions);
		System.out.println("conditionTerm: " + conditionTerm);
		System.out.println("+++++");
	}
	
}