package de.tud.exploitgen.processing.simplifier;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.logic.sort.SortImpl;
/**
 * this class aims to unify all quantifiable variable existing in @Term term
 * we make use of a layered convention quantifiable variable name system and
 * replace each quantifiable variable by its corresponding pre-defined one up to its level 
 * */

public class QuantifiableVarUnifier {
   private Term term;
   private Services services;
   private TermBuilder termBuilder;
   private Map<Integer, ImmutableArray<QuantifiableVariable>> mapLevelQV;
   private static Sort INT_SORT = new SortImpl(new Name("int"));
   /**
    * @param term
    * @param services
    */
   public QuantifiableVarUnifier(Term term, Services services) {
      super();
      this.term = term;
      this.services = services;
      termBuilder=new TermBuilder(new TermFactory(), services);      
   }
   
   /*transform */
   private Term transform(Term t, int level){
      if(t!=null){
         if(t.subs().size()>0){
            if(t.boundVars().isEmpty()){            
               int size =t.subs().size();
               Term[] subs = new Term[size];               
               for(int i=0;i<size;i++){
                  subs[i] = transform(t.sub(i),level);
               }
               return termBuilder.tf().createTerm(t.op(), subs, t.boundVars(),t.javaBlock());
            }else{                         
               //replace all quantifiable variables in t by quantifiable variable at this level (stored in mapLevelQV)
               ImmutableArray<QuantifiableVariable> levelBoundVars = mapLevelQV.get(level);               
               int size =t.subs().size();
               Term[] subs = new Term[size];
               ImmutableArray<QuantifiableVariable> currentBoundVars = t.boundVars();
               List<QuantifiableVariable> newBoundVars = new LinkedList<QuantifiableVariable>();
               for(int j=0;j<currentBoundVars.size();j++)
                  newBoundVars.add(levelBoundVars.get(j));
               
               //System.out.println("source: " + currentBoundVars.get(0).toString() + " destination: " + newBoundVars.get(0) );
               for(int i=0;i<size;i++){                  
                  subs[i] = replace(t.sub(i), currentBoundVars.get(0), termBuilder.var(newBoundVars.get(0)));                  
                  for(int j=1;j<currentBoundVars.size();j++)
                     subs[i] = replace(subs[i], currentBoundVars.get(j), termBuilder.var(newBoundVars.get(j)));                  
               }
               Term replacedTerm = termBuilder.tf().createTerm(t.op(), subs, new ImmutableArray<QuantifiableVariable>(newBoundVars),t.javaBlock());
               //System.out.println("replaced Term: " + replacedTerm);
               //return analysed replaced term
               Term[] subsRTerm = new Term[size];   
               int nextLevel = level+1;
               for(int i=0;i<size;i++){
                  subsRTerm[i] = transform(replacedTerm.sub(i), nextLevel);
               }
               Term finalTerm = termBuilder.tf().createTerm(replacedTerm.op(), subsRTerm, replacedTerm.boundVars(),replacedTerm.javaBlock());
               //System.out.println("final replaced Term: " + finalTerm);
               return finalTerm;
            }
         }else
            return t;
      }else
         return null;
   }
   
   /*replace all bound vars appearing in t by destination*/
   private Term replace(Term t, QuantifiableVariable source, Term destination){
      if(t!=null){
         if(t.toString().equals(source.name().toString())){
            //return termBuilder.var(destination);
            return destination;
         }else{
            if(t.subs().size()>0){
               int size =t.subs().size();
               Term[] subs = new Term[size];
               for(int i=0;i<size;i++){
                  subs[i] = replace(t.sub(i),source, destination);
               }
               return termBuilder.tf().createTerm(t.op(), subs, t.boundVars(),t.javaBlock());
            }else{
               return t;
            }
         }            
      }else{
         return null;
      }
   }
   
     
   public Term unifyQuantifiableVars(){
      QuantifiableVariable qv = findQuantifiableVariable(term);
      if(qv!=null){
         initializeMapLevelQV(10, qv); //TODO: the depth of level should be extracted from analysed term
         return transform(term, 0);
      }else
         return term;
   } 
   
   /*find a quantifiable variable existing inside t*/
   private QuantifiableVariable findQuantifiableVariable(Term t){
      Stack<Term> stack = new Stack<Term>();
      stack.push(t);
      while(!stack.empty()){
         Term topTerm = stack.pop();
         if(!topTerm.boundVars().isEmpty())
            return (topTerm.boundVars().get(0));
         else if(topTerm.subs().size()>0){
            for(Term st: topTerm.subs())
               stack.push(st);
         }
      }
      return null;
   }
   
   private void initializeMapLevelQV(int maxLevel, QuantifiableVariable qv){
      mapLevelQV = new HashMap<Integer, ImmutableArray<QuantifiableVariable>>();
      for(int i=0;i<maxLevel;i++){
         List<QuantifiableVariable> listLevelI = new LinkedList<QuantifiableVariable>();
         for(int j=0;j<maxLevel;j++){         
            listLevelI.add(new LogicVariable(new Name("_idx"+String.valueOf(i)+String.valueOf(j)), qv.sort()));
         }
         ImmutableArray<QuantifiableVariable> levelI = new ImmutableArray<QuantifiableVariable>(listLevelI);
         mapLevelQV.put(i, levelI);
      }
   }
}
