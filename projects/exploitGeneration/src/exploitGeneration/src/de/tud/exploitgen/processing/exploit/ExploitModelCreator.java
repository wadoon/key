/**
 * 
 */
package de.tud.exploitgen.processing.exploit;

import java.util.LinkedList;
import java.util.List;

import com.csvanefalk.keytestgen.core.model.implementation.Model;

import de.tud.exploitgen.processing.node.NodeDetail;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.logic.Term;


/**
 * @author Huy Do
 *
 */
public class ExploitModelCreator {
   private NodeDetail nodeD1, nodeD2;
   //private int idx1, idx2;
   
   /**
    * @param nodeD1
    * @param nodeD2
    */
   public ExploitModelCreator(NodeDetail nodeD1, NodeDetail nodeD2) {
      super();
      this.nodeD1 = nodeD1;
      this.nodeD2 = nodeD2;      
   }

   public ExploitModel getMergedExploitModel(int idx1, int idx2){
       Model model1 = nodeD1.getModel(idx1);
       Model model2 = nodeD2.getModel(idx2);
       //merge model2 to model1 and vice versa, to make sure that two model have the same number of ModelVariable
       Model merModel1 = model1.merge(model2);
       Model merModel2 = model2.merge(model1);
       String heapName = nodeD1.getHeapName();
       return new ExploitModel(merModel1, merModel2, heapName);
   }
   
   public ExploitModel getPureExploitModel(int idx1, int idx2){
      Model model1 = Model.constructModel(nodeD1.getModel(idx1));
      Model model2 = Model.constructModel(nodeD2.getModel(idx2));
      String heapName = nodeD1.getHeapName();
      return new ExploitModel(model1, model2, heapName);
  }
   
   /*
    * combine all artificial variables in two NodeDetail
    * */
   public List<Term> getSynthesisArtificialVar(){
      List<Term> result = new LinkedList<Term>();
      
      for(Term t: nodeD1.getArtificialVariable()){
         result.add(t);
      }
      
      for(Term t: nodeD2.getArtificialVariable()){
         if(!TermUtil.inListTerm(t, result)){
            result.add(t);
         }
      }   
      return result;
   }
   
  
}
