package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;


public class GELMaximizerUsingCounting4Uniform extends LeakageMaximizerUsingCounting4Uniform{
	//private long numberOfHighValues; //number of possible high values calculated via currentKnowlegde	
	public GELMaximizerUsingCounting4Uniform(List<PPCountingResult> listCountingResults,
			Services services, List<String> listLowVars, BigInteger numberOfHighValues, String optSolver) {
		super(listCountingResults, services, listLowVars,optSolver,numberOfHighValues);
		//this.numberOfHighValues = numberOfHighValues;	
		extract2ListMatchableSolutions();
	}

	

	@Override
	protected OptimalSolution resolveConstantSolution(MatchableCountingSolution matchCountSolution) {
		/*
		 * calculate scaled guessing-entropy-leakage
		 * */
		double optimizeValue = 0;
		for(CountingSolution cs: matchCountSolution.getListCountingSolutions()){
			long cG = TermParser.getIntegerValue(cs.getValue(), services);
			if(cG>0)
				optimizeValue += cG * (cG+1);			
		}
		System.out.println("GE Optimal value by constant counting solution: " + optimizeValue);
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		System.out.println(" with solution " + solution);
		return new OptimalSolution(solution, optimizeValue);
	}
	
	
	protected OptimalSolution findGlobalOptimalSolution(List<OptimalSolution> listSolution){
		return findMimimumSolution(listSolution);
	}



	@Override
	protected OptimalSolution findOptimalSolution4SingleCase(
			MatchableCountingSolution matchCountSolution) {
		return findOptimalSolution4SingleCase(matchCountSolution, KEGConstant.GUESSING_ENTROPY);		
	}



	/*
	 * shannon-entropy-based leakage = (S_{j-1}+1)/2 - bestSolution.optimalValue /(2*S_{j-1})
	 * */
	@Override
	protected double computeLeakage(OptimalSolution bestSolution) {
		double S = numberOfHighValues.doubleValue();
		return (S+1)/2 - 
				bestSolution.getOptimizeValue()/(2*S);
	}



	@Override
	protected double computeOptimalValueUsingSolution(
			MatchableCountingSolution countingResults,
			Map<String, Long> optSolution) {
		
		double optimizeValue = 0;
		for(CountingSolution cs: countingResults.getListCountingSolutions()){
			double cG = TermUtil.computeDouble(cs.getValue(), optSolution, services);
			if(cG>0){
				optimizeValue += cG * (cG+1);	
			}			
		}
		return optimizeValue;
	}

	


	/*@Override
	protected void extract2ListMatchableCountingSolution() {
		System.out.println("start extracting to list of matchable counting solution!");
		CountingResultTree countTree = new CountingResultTree();
		for(PPCountingResult countResult: listCountingResults){			
			for(CountingResultTree leaf: countTree.getAllLeaves()){
				List<CountingResultTree> leaves = new LinkedList<CountingResultTree>();				
				for(CountingSolution condResult: countResult.getListResults()){
					if(!TermParser.isBooleanFalse(condResult.getCondition()))
						leaves.add(new CountingResultTree(condResult));
				}		
				leaf.addChildren(leaves, services);
			}
		}
		System.out.println("all leaves have been added!");
		//remove all leaf that don't have enough childs (=listCountingResults.size)
		listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
		for(CountingResultTree tre: countTree.getAllLeaves()){
			List<Term> listCountTerms = tre.getListCountTerms();
			if(listCountTerms.size() == listCountingResults.size()){
				//create new condition: sum of all possible counting values must equal to numberOfHighValues
				TermBuilder tb = services.getTermBuilder();
				Term sum = tb.zero();
				for(Term t: listCountTerms){
					sum = tb.add(sum, t);
				}
				//Term possCondition = tb.equals(sum, tb.zTerm((int)numberOfHighValues));
				Term possCondition = tb.equals(sum, tb.zTerm(String.valueOf(numberOfHighValues)));
				Z3Solver z31 = new Z3Solver(possCondition, services);
				Term condition = tre.getConditionTerm();
				if(!z31.checkValid()){ //if possCondition is not valid then add it
					condition = tb.and(possCondition, condition);
				}
				Z3Solver z3 = new Z3Solver(condition, services);
				Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
				if(uniqueModel!=null){
					if(uniqueModel.second==1) //there is only one model
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,true));
					else
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));
				}
			}		
		}
		System.out.println("finish extracting! We found " + listMatchableSolutions.size() + " matchable solutions");		
	}*/
	
}
