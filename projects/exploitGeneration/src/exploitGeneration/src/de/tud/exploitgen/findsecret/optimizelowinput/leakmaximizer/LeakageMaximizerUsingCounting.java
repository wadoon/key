package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.util.Pair;

public abstract class LeakageMaximizerUsingCounting implements LeakageMaximizer {
	protected List<PPCountingResult> listCountingResults;	
	//private CountingResultTree countTree; //is created from listCountingResult	
	protected Services services;
	protected List<String> listLowVars;
	protected List<MatchableCountingSolution> listMatchableSolutions;	
	protected String optSolver;
	//protected abstract void extract2ListMatchableCountingSolution();
	
	protected abstract OptimalSolution findOptimalSolution4SingleCase(MatchableCountingSolution matchCountSolution);
	protected abstract OptimalSolution findGlobalOptimalSolution(List<OptimalSolution> listOptimalSolutions);
	protected abstract double computeLeakage(OptimalSolution bestSolution);
	/*
	 * compute Shannon-entropy-leakage for the case all counting term is constant
	 * */
	protected abstract OptimalSolution resolveConstantSolution(MatchableCountingSolution matchCountSolution);
	
	
	
	
	public LeakageMaximizerUsingCounting(List<PPCountingResult> listCountingResults, Services services, List<String> listLowVars, String optSolver) {
		super();
		this.listCountingResults = listCountingResults;		 
		this.services = services;
		this.listLowVars = listLowVars;
		this.optSolver = optSolver;
		
		//resolvePPCountingResult();
	}	
	
	public Pair<Map<String,Long>, Double> findLowInputMaximizingLeakge(){
		List<OptimalSolution> listOptimalSolutions = new LinkedList<OptimalSolution>();
		for(MatchableCountingSolution countingSolution: listMatchableSolutions){
			//countingSolution.printInfo();
			OptimalSolution solution = findOptimalSolution(countingSolution);
			
			//solution.printInfo();
			if(solution!=null ){				
				double realOptValue= computeOptimalValueUsingSolution(countingSolution, solution.getSolution());
				solution.setOptimizeValue(realOptValue);
				listOptimalSolutions.add(solution);
			}
		}
		if(listOptimalSolutions.size()>0){
			OptimalSolution bestSolution = findGlobalOptimalSolution(listOptimalSolutions);
			
			double maximumLeakage = computeLeakage(bestSolution);
			return new Pair<Map<String,Long>, Double>(bestSolution.getSolution(),maximumLeakage);
		}else
			return null;
	}
	
	public void printInfoOfListCountingResults(){
		System.out.println("information about list counting result:");
		for(int i=0;i<listCountingResults.size();i++){
			System.out.println("number of count result " + i + " : " + listCountingResults.get(i).getListResults().size());
			for(CountingSolution result: listCountingResults.get(i).getListResults()){
				System.out.println("  value: "+ result.getValue() + "; \ncondition: " + result.getCondition());
			}
		}
		System.out.println("----");
	}	
	
	public void printInfoOfListMatchableCountingSolutions(){
		System.out.println("information about list of matchable counting solution:");
		for(MatchableCountingSolution mcSolution: listMatchableSolutions)
			mcSolution.printInfo();
		System.out.println("----");
	}	
	
	protected OptimalSolution findOptimalSolution(MatchableCountingSolution countSolution){
		if(countSolution.allCountTermsIsConstant(services)){
			return resolveConstantSolution(countSolution);			
			
		}else{		
			if(countSolution.isUniqueModel()){//there is only one satisfying model
				return resolve4UniqueSolution(countSolution);
			}
			else{
				return findOptimalSolution4SingleCase(countSolution);
			}
		}				 
	}
	
	

	protected OptimalSolution findMimimumSolution(List<OptimalSolution> listSolution){
		if(listSolution.size()>0){
			System.out.println("number of found solution: " + listSolution.size());
			OptimalSolution bestSolution = listSolution.get(0);	
			bestSolution.printInfo();
			for(int i=1; i<listSolution.size(); i++){
				listSolution.get(i).printInfo();
				if(bestSolution.getOptimizeValue()>listSolution.get(i).getOptimizeValue())
					bestSolution = listSolution.get(i);
			}
			System.out.println("best solution found:");
			bestSolution.printInfo();
			return bestSolution;
			
		}else
			return null;
	}
	
	protected OptimalSolution findMaximumSolution(List<OptimalSolution> listSolution){
		if(listSolution.size()>0){			
			OptimalSolution bestSolution = listSolution.get(0);	
			bestSolution.printInfo();
			for(int i=1; i<listSolution.size(); i++){
				listSolution.get(i).printInfo();
				if(bestSolution.getOptimizeValue()<listSolution.get(i).getOptimizeValue())
					bestSolution = listSolution.get(i);
			}
			System.out.println("best solution found:");
			bestSolution.printInfo();
			return bestSolution;			
		}else
			return null;
	}
	
	
	protected abstract void extract2ListMatchableCountingSolution();
	
	protected void extract2ListMatchableSolutions(){
		//resolvePPCountingResult();
		extract2ListMatchableCountingSolution();
		if(listMatchableSolutions.size()==0){
			
			resolvePPCountingResult();
			extract2ListMatchableCountingSolution();
		}
	}
	
	/*
	 * add zero result into each PPCountingResult 
	 * */
	protected void resolvePPCountingResult(){		
		for(PPCountingResult countResult: listCountingResults){			
			countResult.addZeroResult(services.getTermBuilder());	
			countResult.setListResults(countResult.replaceOrCondition());
		}		
	}
	
	
	protected abstract OptimalSolution findOptimalSolution4SingleCase(MatchableCountingSolution matchCountSolution, int metric);
	
	protected abstract double computeOptimalValueUsingSolution(MatchableCountingSolution countingResults, Map<String, Long> optSolution);
	
	protected OptimalSolution resolve4UniqueSolution(
			MatchableCountingSolution matchCountSolution) {
		Map<String,Long> solution = matchCountSolution.getUniqueSolution();
		double optimizeValue = computeOptimalValueUsingSolution(matchCountSolution, solution);
		return new OptimalSolution(solution, optimizeValue);
	}
}
