package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.math.BigInteger;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;
/*
 * with non uniform distribution, the parametric counting-based approach can only be applied for a  
 * */
public abstract class LeakageMaximizerUsingCounting4NU extends
		LeakageMaximizerUsingCounting {
	protected SecretDistribution sDistribution;
	protected BigInteger sumAllFrequencies;
	
	
	public LeakageMaximizerUsingCounting4NU(
			List<PPCountingResult> listCountingResults, Services services,
			List<String> listLowVars, String optSolver,
			SecretDistribution sDistribution, BigInteger sumAllFrequencies) {
		super(listCountingResults, services, listLowVars, optSolver);
		this.sDistribution = sDistribution;
		this.sumAllFrequencies = sumAllFrequencies;
		System.out.println("sumAllFrequencies ::: " + sumAllFrequencies);
		assignInfo4AllCountingSolutionInPPCountingResult();
		//extract2ListMatchableCountingSolution();	
		extract2ListMatchableSolutions();
	}


	@Override
	protected OptimalSolution findGlobalOptimalSolution(
			List<OptimalSolution> listOptimalSolutions) {
		return findMimimumSolution(listOptimalSolutions);
	}

	@Override
	protected void extract2ListMatchableCountingSolution() {
		//System.out.println("start extracting to list of matchable counting solution!");
				CountingResultTree countTree = new CountingResultTree();
				for(PPCountingResult countResult: listCountingResults){	
					//countResult.printInfo();
					for(CountingResultTree leaf: countTree.getAllLeaves()){
						List<CountingResultTree> leaves = new LinkedList<CountingResultTree>();				
						for(CountingSolution condResult: countResult.getListResults()){
							if(!TermParser.isBooleanFalse(condResult.getCondition()))
								leaves.add(new CountingResultTree(condResult));
						}		
						leaf.addChildren(leaves, services);
					}
				}
				List<CountingResultTree> listAllCountingResults = countTree.getAllLeaves();
				System.out.println("all leaves have been added! number of leaves: " + listAllCountingResults.size());
				
				/*for(CountingResultTree tre: listAllCountingResults){
					tre.printInfo();
				}*/
				//remove all leaf that don't have enough childs (=listCountingResults.size)
				listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
				for(CountingResultTree tre: listAllCountingResults){
					List<CountingSolution> listCountTerms = tre.getListCountingSolutions();
					if(listCountTerms.size() == listCountingResults.size()){
						//create new condition: sum of all possible counting values must equal to numberOfHighValues
						TermBuilder tb = services.getTermBuilder();
						Term sum = tb.zero();
						for(CountingSolution t: listCountTerms){
							Term frequency = tb.zTerm(sDistribution.getPartitions().get(t.getPartitionIdx()).getFrequency());
							sum = tb.add(sum, tb.mul(t.getValue(), frequency));
						}
						Term possCondition = tb.equals(sum, tb.zTerm(String.valueOf(sumAllFrequencies.longValue()))); //TODO: overflow might happen		
						Z3Solver z31 = new Z3Solver(possCondition, services);
						Term condition = tre.getConditionTerm();
						if(!z31.checkValid()){ //if possCondition is not valid then add it
							condition = tb.and(possCondition, condition);
						}
						Z3Solver z3 = new Z3Solver(condition, services);
						/*Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
						if(uniqueModel!=null)
							listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));*/
						Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
						if(uniqueModel!=null){
							if(uniqueModel.second==1) //there is only one model
							{
								System.out.println("unique model!!"+uniqueModel.first);
								listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,true));
							}
							else
								listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));
						}
					}		
				}		
				System.out.println("finish extracting! We found " + listMatchableSolutions.size() + " matchable solutions");
				
	}
	
	protected OptimalSolution findOptimalSolution4SingleCase(MatchableCountingSolution matchCountSolution, int metric) {		
		OptimizationSolver solver;
		if(optSolver.equals(KEGConstant.OPTSOLVER_ALL)){
			/*
			 * we try all solvers to find the best result
			 * pay attention: is might be very expensive
			 * at the moment we do not take into account couenne because it is usually very slow
			 * */
			List<OptimalSolution> listSolutions = new LinkedList<OptimalSolution>();
			solver = new OptLocalSolver(matchCountSolution, services, metric, sDistribution);
			OptimalSolution solution = solver.findOptimalSolution();
			if(solution!=null){
				System.out.println("solution found by local solver: "+ solution.getSolution() + "; optimal value: " +solution.getOptimizeValue());
				listSolutions.add(solution);
			}
			solver = new AMPLSolver(matchCountSolution, services, metric, KEGConstant.OPTSOLVER_BONMIN, sDistribution);
			solution = solver.findOptimalSolution();
			if(solution!=null){
				System.out.println("solution found by bonmin: "+ solution.getSolution() + "; optimal value: " + solution.getOptimizeValue());
				listSolutions.add(solution);
			}
			
			if(listSolutions.size()>0)
				return findGlobalOptimalSolution(listSolutions);
			else
				return null;
			
		}else{
			if(optSolver.equals(KEGConstant.OPTSOLVER_LOCALSOLVER))			
				solver = new OptLocalSolver(matchCountSolution, services, metric, sDistribution);
			else
				solver = new AMPLSolver(matchCountSolution, services, metric, optSolver, sDistribution);
			
			return solver.findOptimalSolution();
		}
	}

	//a CountingSolution item in PPCountingResult is assigned by corresponding outValue and partitionIdx
	private void assignInfo4AllCountingSolutionInPPCountingResult(){
		for(PPCountingResult ppCountResult: listCountingResults){
			for(CountingSolution cs: ppCountResult.getListResults()){
				cs.setPartitionIdx(ppCountResult.getPartitionIdx());
				cs.setOutputValue(ppCountResult.getOutputValue());
			}
		}
	}
	
}
