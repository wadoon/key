package de.tud.exploitgen.findsecret.strategy;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;

public class LowInputGenStrategy4RiskH extends LowInputGenStrategy{

	public LowInputGenStrategy4RiskH(SISupporter siSupporter) {
		super(siSupporter);
		// TODO Auto-generated constructor stub
	}

	@Override
	public Map<String, Long> findBestLowInput() throws IOException {
		//return findUsefulLowInput();
		/*
		 * if program contains path whose output depend only on H, try to guide the execution following that
		 * */
		BadMethod badMethod = siSupporter.getBadMethod();
		List<RiskyPath> listRiskyPaths = badMethod.getListRiskyPaths();
		for(RiskyPath rp: listRiskyPaths){
			if(rp.isReachable()){
				if(rp.outputDependsOnlyOnH()){
					if(!rp.isMatched()){
						System.out.println("reach here!");
						Map<String,Long> mapValues = findLowInputForcingExecutionFollowingPath(rp);
						if(mapValues!=null)
							return mapValues;
					}
				}
			}
		}
		
		//if we cannot find any low input forcing program along to a H-depend only path, then simply return an useful  low input
		return findUsefulLowInput();	
	}

}
