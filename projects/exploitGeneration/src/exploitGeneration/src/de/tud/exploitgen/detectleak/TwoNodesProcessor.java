/**
 * 
 */
package de.tud.exploitgen.detectleak;

import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.tud.exploitgen.detectleak.exploit.ExploitModel;
import de.tud.exploitgen.detectleak.exploit.ExploitModelCreator;
import de.tud.exploitgen.detectleak.node.NodeDetail;
import de.tud.exploitgen.detectleak.specification.declassification.DeclassificationCenter;
import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.solver.AbstractFormulaSolver;
import de.tud.exploitgen.solver.SMTLibSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.smt.IllegalFormulaException;

/**
 * @author Huy Do
 *
 */
public class TwoNodesProcessor {

   private final NodeDetail nodeD1,nodeD2; //two detail nodes representing two branches.   
   
   private KeYJavaMethod method;
   //private Services services;
   private VariableClassifier vc;
   
   private DeclassificationCenter declCenter;
   
   public TwoNodesProcessor(NodeDetail node1, NodeDetail node2,KeYJavaMethod method,VariableClassifier vc, DeclassificationCenter declCenter) {
      super();
      this.nodeD1 = node1;
      this.nodeD2 = node2;
      this.method=method;
      this.vc=vc;
      this.declCenter = declCenter;
   }
 
   /*synthesize arrays from declCenter, nodeD1, nodeD2 
   and return the result as a list of terms*/
   private List<Term> synthesizeArrays(){
      List<Term> result = new LinkedList<Term>();
      result = TermUtil.mergeListTerm(result, declCenter.getAllArrays());
      //System.out.println(" nodeD1.getListQuantifiedArrays():" +  nodeD1.getListArrays());
      result = TermUtil.mergeListTerm(result, nodeD1.getListArrays());
      result = TermUtil.mergeListTerm(result, nodeD2.getListArrays());     
      return result;
   }
   
   /*synthesize quantified arrays from declCenter, nodeD1, nodeD2
   and return the result as a list of terms*/
   private List<Term> synthesizeArtificialVars(){
      List<Term> result = new LinkedList<Term>();
      /*
       * omit artificial variables of nodeD1 and nodeD2 is an index term of an quantified array's elements
       * */
      
      List<Term> declQAElements = declCenter.getAllArrayElements();
      List<Term> nodeArtificialVars = new ExploitModelCreator(nodeD1, nodeD2).getSynthesisArtificialVar();
      for(Term t: nodeArtificialVars){
         if(!TermUtil.haveAncestorInList(t, declQAElements))
            result.add(t);
      }
      return result;
      
   }
   
   /*
    * Because of conditional value, one node can contain more than one model.
    * for each model at one node, we can consider it as a branch (fake branch)
    * For each pair of fake branches, we have unique ExploitModel object, and we can create from them several insecure formulas,
    * each insecure formula corresponds with a target ModelVariable.
    * this method gets all possible insecure formulas and parse them into a suitable map structure
    * */
   private Map<ExploitModel,Map<ModelVariable, Term>> getMapFormulas() throws ProofInputException{
      Map<ExploitModel,Map<ModelVariable, Term>> result = new HashMap<ExploitModel,Map<ModelVariable, Term>>();
      ExploitModelCreator eModelCreator = new ExploitModelCreator(nodeD1, nodeD2);
      //List<Term> listArtificialVars = eModelCreator.getSynthesisArtificialVar();
      List<Term> listArtificialVars = synthesizeArtificialVars();
      List<Term> listArrays = synthesizeArrays();
      //System.out.println("listQuantifiedArrays - tnp::\n" + listArrays);
      Term nodeConstraint1 = nodeD1.getConstraint();
      Term nodeConstraint2 = nodeD2.getConstraint();
      //System.out.println("nodeD1.size: " + nodeD1.getModels().size()+ " ; nodeD2.getIndex(): " + nodeD2.getIndex()); 
      if(nodeD1.getIndex()==nodeD2.getIndex()){
       //if nodeD1 and nodeD2 is the same, we eliminate redundant by enforcing idx2 start from idx1 not 0
         for(int idx1 =0; idx1 < nodeD1.getModels().size(); idx1++)
            for(int idx2 = idx1; idx2<nodeD2.getModels().size(); idx2++ ){
               ExploitModel eModel = eModelCreator.getMergedExploitModel(idx1, idx2);    
               //print the model
               //eModel.printModelInfo();
               //FormulaBuilder fb = new FormulaBuilder(eModel, method, vc, listArtificialVars, nodeConstraint1, nodeConstraint2);
               FormulaBuilder fb = new FormulaBuilder(eModel, method, vc, declCenter, 
                     listArtificialVars, listArrays,                     
                     nodeConstraint1, nodeConstraint2);
               Map<ModelVariable, Term> formulasOfVar = fb.getAllInterferenceFormula();
               result.put(eModel, formulasOfVar);
            }
      }else{
         for(int idx1 =0; idx1 < nodeD1.getModels().size(); idx1++)
            for(int idx2 = 0; idx2<nodeD2.getModels().size(); idx2++ ){
               ExploitModel eModel = eModelCreator.getMergedExploitModel(idx1, idx2);             
               FormulaBuilder fb = new FormulaBuilder(eModel, method, vc, declCenter, 
                     listArtificialVars, listArrays, 
                     nodeConstraint1, nodeConstraint2);
               Map<ModelVariable, Term> formulasOfVar = fb.getAllInterferenceFormula();
               result.put(eModel, formulasOfVar);
            }
      }
      return result;
   }
   
   /*
    * fresh version: using foundation variables to duplicate input memory state
    * Because of conditional value, one node can contain more than one model.
    * for each model at one node, we can consider it as a branch (fake branch)
    * For each pair of fake branches, we have unique ExploitModel object, and we can create from them several insecure formulas,
    * each insecure formula corresponds with a target ModelVariable.
    * this method gets all possible insecure formulas and parse them into a suitable map structure
    * */
   private Map<ExploitModel,Map<ModelVariable, Term>> getMapFreshFormulas() throws ProofInputException{
      Map<ExploitModel,Map<ModelVariable, Term>> result = new HashMap<ExploitModel,Map<ModelVariable, Term>>();
      ExploitModelCreator eModelCreator = new ExploitModelCreator(nodeD1, nodeD2);
      List<Term> listArtificialVars = eModelCreator.getSynthesisArtificialVar();
      listArtificialVars = TermUtil.mergeListTerm(listArtificialVars, declCenter.getAllQuantifiableVars());
      
      //use all node's constraints
      Term nodeConstraint1 = nodeD1.getAllConstraints(); 
      Term nodeConstraint2 = nodeD2.getAllConstraints();
      /*Term nodeConstraint1 = nodeD1.getConstraint(); 
      Term nodeConstraint2 = nodeD2.getConstraint();*/
      
      if(nodeD1.getIndex()==nodeD2.getIndex()){
       //if nodeD1 and nodeD2 is the same, we can eliminate redundant by enforcing idx2 start from idx1 not 0
         for(int idx1 =0; idx1 < nodeD1.getModels().size(); idx1++)
            for(int idx2 = idx1; idx2<nodeD2.getModels().size(); idx2++ ){
               ExploitModel eModel = eModelCreator.getMergedExploitModel(idx1, idx2);    
               //print the model
               //eModel.printModelInfo();
               //use FormulaBuilderS to build insecure formula
               FormulaBuilderS fb = new FormulaBuilderS(eModel, method, vc, declCenter, listArtificialVars, nodeConstraint1, nodeConstraint2);
               Map<ModelVariable, Term> formulasOfVar = fb.getAllInterferenceFormula();
               result.put(eModel, formulasOfVar);
            }
      }else{
         for(int idx1 =0; idx1 < nodeD1.getModels().size(); idx1++)
            for(int idx2 = 0; idx2<nodeD2.getModels().size(); idx2++ ){
               ExploitModel eModel = eModelCreator.getMergedExploitModel(idx1, idx2);             
               FormulaBuilderS fb = new FormulaBuilderS(eModel, method, vc,  declCenter, listArtificialVars, nodeConstraint1, nodeConstraint2);
               Map<ModelVariable, Term> formulasOfVar = fb.getAllInterferenceFormula();
               result.put(eModel, formulasOfVar);
            }
      }
      return result;
   }
   
   private List<ModelVariable> solveFormula(Term iTerm){
      AbstractFormulaSolver fs=new Z3Solver(iTerm, method.getServices());      //use Z3 solver
      List<ModelVariable> result = fs.solveFormula2GetListModelVariable();      
      return result;
   }
   
   /*
    * get all exploit models by instantiating them using concrete models taken from SMT Solver
    * */
   public List<ExploitModel> getAllExploitModels() throws ProofInputException, IllegalFormulaException{
      List<ExploitModel> result = new LinkedList<ExploitModel>();
      Map<ExploitModel,Map<ModelVariable, Term>> mapEModelFormulas = getMapFormulas();
      
      for(ExploitModel eModel: mapEModelFormulas.keySet()){
         Map<ModelVariable,Term> mapVarTerm = mapEModelFormulas.get(eModel);
         for(ModelVariable lowVar: mapVarTerm.keySet()){                  
            Term iTerm = mapVarTerm.get(lowVar);
            //System.out.println("Insecure formula: " + iTerm);          
            List<ModelVariable> concreteModel = solveFormula(iTerm);
            if(concreteModel!=null){      
               //assign values for variables
               ExploitModel eModelResult = new ExploitModel(eModel);               
               eModelResult.setLowVar(lowVar); //we are working with this low variable      
               eModelResult.resetPrimitiveValue();
               eModelResult.instantiateExploitModel(concreteModel);               
               System.out.println("A vulnerability detected: secret information could be leaked through variable " + eModelResult.getLowVar().getIdentifier() );
               result.add(eModelResult);
            }
         }         
      }
      return result;
   }
   
     
   
   /*use for testing SMTLibSolver over new style formula (just use foundation variables*/   
   public void testSMTLibSolverOverFreshFormula() throws IllegalFormulaException, ProofInputException, IOException{
      Map<ExploitModel,Map<ModelVariable, Term>> mapEModelFormulas = getMapFreshFormulas();
      //Map<ExploitModel,Map<ModelVariable, Term>> mapEModelFormulas = getMapFormulas();
      
      for(ExploitModel eModel: mapEModelFormulas.keySet()){
         Map<ModelVariable,Term> mapVarTerm = mapEModelFormulas.get(eModel);
         for(ModelVariable lowVar: mapVarTerm.keySet()){                  
            Term iTerm = mapVarTerm.get(lowVar);
            //System.out.println("fresh insecure formula: " + iTerm);
            
            /*******  test SMTLibSolver ********************/
            SMTLibSolver sls = new SMTLibSolver(new TermBuilder(new TermFactory(), method.getServices()).not(iTerm), method.getServices());           
            //sls.launch(); 
            //System.out.println("SOLVER OUTPUT OF EXTERNAL SMT SOLVER (Z3): \n" + sls.getSolverOutput());
            //sls.export2SMTLib2File("D:\\smtlib", lowVar.getIdentifier());
            sls.solveFormula();

         }         
      }
   }
   
   
   /*
    * get all synthezied formula to check whether there exists an information flow from high to low
    * */
   private Map<ExploitModel, Term> getSyntheziedFormulas2CheckIF() throws ProofInputException {
	   Map<ExploitModel, Term> result = new HashMap<ExploitModel, Term>();
      ExploitModelCreator eModelCreator = new ExploitModelCreator(nodeD1, nodeD2);
      //List<Term> listArtificialVars = eModelCreator.getSynthesisArtificialVar();
      List<Term> listArtificialVars = synthesizeArtificialVars();
      List<Term> listArrays = synthesizeArrays();
      //System.out.println("listQuantifiedArrays - tnp::\n" + listArrays);
      Term nodeConstraint1 = nodeD1.getConstraint();
      Term nodeConstraint2 = nodeD2.getConstraint();
      //System.out.println("nodeD1.size: " + nodeD1.getModels().size()+ " ; nodeD2.getIndex(): " + nodeD2.getIndex()); 
      if(nodeD1.getIndex()==nodeD2.getIndex()){
       //if nodeD1 and nodeD2 is the same, we can eliminate redundant by enforcing idx2 start from idx1 not 0
         for(int idx1 =0; idx1 < nodeD1.getModels().size(); idx1++)
            for(int idx2 = idx1; idx2<nodeD2.getModels().size(); idx2++ ){
               ExploitModel eModel = eModelCreator.getMergedExploitModel(idx1, idx2);    
               //print the model
               //eModel.printModelInfo();
               //FormulaBuilder fb = new FormulaBuilder(eModel, method, vc, listArtificialVars, nodeConstraint1, nodeConstraint2);
               FormulaBuilder fb = new FormulaBuilder(eModel, method, vc, declCenter, 
                     listArtificialVars, listArrays,                     
                     nodeConstraint1, nodeConstraint2);
               Term syntheziedFormula = fb.getSyntheziedFormula();
               result.put(eModel, syntheziedFormula);
            }
      }else{
         for(int idx1 =0; idx1 < nodeD1.getModels().size(); idx1++)
            for(int idx2 = 0; idx2<nodeD2.getModels().size(); idx2++ ){
               ExploitModel eModel = eModelCreator.getMergedExploitModel(idx1, idx2);             
               FormulaBuilder fb = new FormulaBuilder(eModel, method, vc, declCenter, 
                     listArtificialVars, listArrays, 
                     nodeConstraint1, nodeConstraint2);
               Term syntheziedFormula = fb.getSyntheziedFormula();
               result.put(eModel, syntheziedFormula);
            }
      }
      return result;
   }
   
   /**
    * check whether there is information flow from high variables to low variables (defined by VariableClassifier)
    * mainly used for secret finding
 * @throws ProofInputException 
    * */
   public boolean checkInformationFlow() throws ProofInputException{
	   Map<ExploitModel, Term> mapFormulaIF = getSyntheziedFormulas2CheckIF();
	   for(Term formula: mapFormulaIF.values()){
		   //System.out.println("formula: " + formula);
		   AbstractFormulaSolver fs=new Z3Solver(formula, method.getServices());      //use Z3 solver
		   if (fs.checkSatisfiable())
			   return true;
	   }
	   return false;
   }
}
