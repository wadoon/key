package de.tud.exploitgen.findsecret.optimizelowinput.convexoptimization;
/*
 * this class make use of commercial tool LocalSolver for optimization task
 * */

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import localsolver.*;//using free academic version of LocalSover

public class ConvexLocalSolver extends ConvexSolver {

	Map<String, LSExpression> mapVars;
	
	public ConvexLocalSolver(List<MatchableCountingSolution> listMatchCountSolutions, Services services) {
		super(listMatchCountSolutions, services);	
		// TODO Auto-generated constructor stub
	}

	@Override
	public Map<String, Long> findSolution() {
		List<OptimalSolution> listSolution = new LinkedList<OptimalSolution>();
		//for(CountingResultTree leaf: countTree.getAllLeaves()){
		for(MatchableCountingSolution countSolution: listMatchCountSolutions){
			countSolution.printInfo();
			if(countSolution.allCountTermsIsConstant()){
				OptimalSolution constSolution = findSolutionForAllConstantValues(countSolution);				
				listSolution.add(constSolution);
			}else{		
				if(countSolution.getUniqueSolution().size()>0){//there is only one satisfying model
					OptimalSolution uniqueSolution = resolve4UniqueSolution(countSolution);
					listSolution.add(uniqueSolution);
				}
				else{
					LocalSolver localSolver = new LocalSolver();
					
					LSModel model = localSolver.getModel();
					mapVars = new HashMap<String, LSExpression>();
					for(Term countTerm: countSolution.getListCountTerms())
						parseTerm2FindVar(countTerm, model);
					parseTerm2FindVar(countSolution.getConditionTerm(), model);
					
					System.out.println("map variable of LocalSolver: " + mapVars);
					LSExpression objective = getObjectiveFunction(countSolution.getListCountTerms(), model);
					//System.out.println("objective function: " + objective.toString());
					
					LSExpression constraint = transformTerm2LSExpression(countSolution.getConditionTerm(), model);				
					model.addConstraint(constraint);
					/*System.out.println("objective function: " + objective.getInfo());
					System.out.println("constraint: " + constraint.getInfo());*/
					//model.addObjective(objective, LSObjectiveDirection.Minimize);
					model.minimize(objective);
					model.close();
					LSPhase phase = localSolver.createPhase();
		            phase.setTimeLimit(1);       //TODO: time limit should be a parameter      
					localSolver.solve();			
					//LSSolution solution = localSolver.getSolution();				
					//System.out.println("solution found by LocalSover: \n");
					Map<String, Long> mapSolution = new HashMap<String, Long>();
					for(String var: mapVars.keySet()){
						//System.out.println(var + ": " + mapVars.get(var).getIntValue());
						try{
							mapSolution.put(var, mapVars.get(var).getIntValue());
						}catch(Exception e){
							
						}
					}
					try{
						OptimalSolution solution = new OptimalSolution(mapSolution, objective.getDoubleValue());
						solution.printInfo();
						listSolution.add(solution);
					}catch(Exception e){
						System.out.println("there is an error when finding optimal solution!");
					}
				}
				
				/*System.out.println("objective value: " + objective.getDoubleValue());
				System.out.println("solution: " + mapSolution);*/
			}				 
		}
		
		//find the best solution:
		if(listSolution.size()>0){
			System.out.println("\n following are found solutions: " + listSolution.size() + "\n");
			
			OptimalSolution bestSolution = listSolution.get(0);	
			bestSolution.printInfo();
			for(int i=1; i<listSolution.size(); i++){
				listSolution.get(i).printInfo();
				if(bestSolution.getOptimizeValue()>listSolution.get(i).getOptimizeValue())
					bestSolution = listSolution.get(i);
			}
			System.out.println("best solution found:");
			bestSolution.printInfo();
			return bestSolution.getSolution();
		}else{
			return null;
		}
	}	
	
	private void parseTerm2FindVar(Term term, LSModel model){
		if(KeYResourceHandler.isArtificialVariable(term)){ //we only work with integer type 
			mapVars.put(term.toString(), model.intVar(Long.MIN_VALUE, Long.MAX_VALUE)); 
		}else if(term.subs().size()>0){
			for(Term t: term.subs())
				parseTerm2FindVar(t, model);
		}
	}	
	
	/*
	 * objective function: maximizing Shanon entropy is equivalent to minimizing 
	 * g_1(x)log(g_1(x)) + g_2(x)log(g_2(x)) + ... + g_n(x)log(g_n(x))
	 * */
	private LSExpression getObjectiveFunction(List<Term> listCountTerms, LSModel model){
		LSExpression objective = model.sum();
		for(Term countTerm: listCountTerms){
			if(TermParser.isIntegerConst(countTerm)){
				if(TermParser.getIntegerValue(countTerm)==0)
					continue;
			}
			LSExpression gFunc = transformTerm2LSExpression(countTerm, model);
			LSExpression logGFunc = model.log(gFunc);
			objective.addOperand(model.prod(gFunc, logGFunc));
		}
		return objective;
	}	
	
	
	private LSExpression transformTerm2LSExpression(Term term, LSModel model){		
		if(TermParser.isIntegerConst(term)){
			return model.createConstant(TermParser.getIntegerValue(term));
		}
		else if(KeYResourceHandler.isArtificialVariable(term)){ //we only work with integer type 
			return mapVars.get(term.toString());
		}
		/* ********************************************************
		 * arithmetic expression
		 * ********************************************************/
		else if(TermParser.isAddition(term)){
			LSExpression sum = model.sum();
			sum.addOperand(transformTerm2LSExpression(term.sub(0), model));
			sum.addOperand(transformTerm2LSExpression(term.sub(1), model));
			return sum;
		}
		else if(TermParser.isSubtraction(term)){
			return model.sub(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isMultiplication(term)){
			LSExpression prod = model.prod();
			prod.addOperand(transformTerm2LSExpression(term.sub(0), model));
			prod.addOperand(transformTerm2LSExpression(term.sub(1), model));
			return prod;
		}
		else if(TermParser.isDivision(term)){
			return model.div(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isPowerFunction(term)){
			return model.pow(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		/* ********************************************************
		 * logic expression
		 * ********************************************************/
		else if(TermParser.isAnd(term)){
			return model.and(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isOr(term)){
			return model.or(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isNot(term)){
			return model.not(transformTerm2LSExpression(term.sub(0), model));
		}
		else if(TermParser.isGreaterOrEquals(term)){
			return model.geq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isGreaterThan(term)){
			return model.gt(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isLessOrEquals(term)){
			return model.leq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isLessThan(term)){
			return model.lt(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isEquals(term)){
			return model.eq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}		
		
		else
			return null;
		
	}
}

