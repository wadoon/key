
/* 
*  this class used to check the non-interference of a method
 * it gets all termination nodes of the symbolic execution tree of the method 
 * */


package de.tud.exploitgen.detectleak;
import de.tud.exploitgen.detectleak.exploit.ExploitModel;
import de.tud.exploitgen.detectleak.exploit.ExploitTestCases;
import de.tud.exploitgen.detectleak.node.ModelNode;
import de.tud.exploitgen.detectleak.node.NodeDetail;
import de.tud.exploitgen.detectleak.node.NodeInvestigator;
import de.tud.exploitgen.detectleak.node.NodeParser;
import de.tud.exploitgen.detectleak.specification.declassification.DeclassificationCenter;
import de.tud.exploitgen.detectleak.specification.noninterference.IFBarrier;
import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;

//import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.proof.init.ProofInputException;

import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.util.DelimitedRelease;
import de.uka.ilkd.key.util.Pair;

import java.io.IOException;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class MethodChecker {
   private KeYJavaMethod method; //contains information of method (maybe needed in variable checker)
   private List<IExecutionNode<?>> leafNodes; //contains leaf nodes of symbolic execution tree of method   
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   IExecutionStart root;  //the root node of symbolic execution tree
   private List<NodeDetail> nodeDetails;
   private int depth; //depth of sub-field's sequence being investigated
   //private List<CDRExtractor> listDRExtractor;
   private DeclassificationCenter declCenter;
   
   /**
    * @param method
    * @param ifSpecs
    * @param root
    * @throws ProofInputException 
    * @throws IllegalFormulaException 
    */
   public MethodChecker(KeYJavaMethod method, List<IFBarrier> ifSpecs,
         IExecutionStart root, int depth) throws ProofInputException, IllegalFormulaException {
      super();
      this.method = method;
      this.ifSpecs = ifSpecs;
      this.root = root;
      leafNodes = parseLeafNodes(root);      
      System.out.println("number of symbolic execution paths: " + leafNodes.size());
      this.depth = depth;      
      nodeDetails = createListNodeDetail();
      
      //initialize for listDRExtractor
      
      ImmutableList<DelimitedRelease> declassifies = method.getEscapeHatches();
      declCenter = new DeclassificationCenter(declassifies, method.getServices());
      //System.out.println("fresh escape hatches: " + declCenter.getListCDRExtractors().get(0).getDelimitedRelease().escapeHatches);
   }


       
   
   /**
    * check the input method to get list of exploit model if the method is insecure 
    * @throws IllegalFormulaException 
    * */
   private Pair<List<ExploitModel>, BadMethod> checkMethod2GetExploitModels(IFBarrier declar) throws IllegalFormulaException{
      List<ExploitModel> listEModels = Collections.synchronizedList(new LinkedList<ExploitModel>());
      VariableClassifier vc=new VariableClassifier(method,declar);    
      BadMethod badMethod = new BadMethod(method, declar);
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
           System.out.println("\n---------------------------------------------"); 
           System.out.print("Investigating symbolic execution path " + i);
            if (j!=i){
               System.out.print(" and path " + j);
            }
            System.out.println();
            try {
             //check branch i and branch j to get all exploit models if they exists               
               List<ExploitModel> eModels = getExploitModelsVia2Nodes(i, j,vc);
               //add models to the result
               
               if(eModels.size()>0){                  
                  listEModels.addAll(eModels);                  
                  /*//add risky path into BadMethod object
                  if(i==j){ //if i==j then there is an explicit information flow from H to L, it means that Risk_H =true
                	  badMethod.addRiskyPath(new RiskyPath(nodeDetails.get(i),i,true, method, vc));
                  }else{
	                  badMethod.addRiskyPath(new RiskyPath(nodeDetails.get(i),i,false,method, vc));
	                  badMethod.addRiskyPath(new RiskyPath(nodeDetails.get(j),j,false,method, vc));
                  }*/
                  for(ExploitModel eModel: eModels){
                	  ModelNode modelNode1 = eModel.getModelNode1();
                	  ModelNode modelNode2 = eModel.getModelNode2();
                	  if(modelNode1.sameIdxNumber(modelNode2))
                		  badMethod.addRiskyPath(new RiskyPath(modelNode1, method, vc, true));
                	  else{
                		  badMethod.addRiskyPath(new RiskyPath(modelNode1, method, vc, false));
                		  badMethod.addRiskyPath(new RiskyPath(modelNode2, method, vc, false));
                	  }
                  }
               }
            }
            catch (TermTransformerException e) {
               //eModels=null;
               e.printStackTrace();
            }
            catch (ProofInputException e) {
               //eModels=null;
               e.printStackTrace();
            }
            
         }
      }    
      return new Pair<List<ExploitModel>, BadMethod>(listEModels, badMethod);
   }
    
    
   /** return list of exploit model generated by solving two nodes 
    * @param node1, node2, vc
    * @throws ProofInputException 
    * @throws TermTransformerException 
    * @throws IllegalFormulaException */
   private List<ExploitModel> getExploitModelsVia2Nodes(int node1, int node2, VariableClassifier vc) throws ProofInputException, TermTransformerException, IllegalFormulaException{     

      //pass two nodes to TwoBranchesProcessor to solve and get interference formulas      
      NodeDetail nd1 = new NodeDetail(nodeDetails.get(node1));
      NodeDetail nd2 = new NodeDetail(nodeDetails.get(node2));     
      
      TwoNodesProcessor tnp = new TwoNodesProcessor(nd1, nd2, method, vc, declCenter);     
      /*try {
         tnp.testSMTLibSolverOverFreshFormula();
         
      }
      catch (IOException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }  */
      return tnp.getAllExploitModels();   
   }
   
   
   /**
    * get leaf nodes of symbolic execution tree from root
    */
   private List<IExecutionNode<?>> parseLeafNodes(IExecutionStart root){
      List<IExecutionNode<?>> leafNodes = new LinkedList<IExecutionNode<?>>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode<?> node = iterator.next();
         /*if(NodeParser.isTerminationNode(node))
            System.out.println("termination node detected: " + node.toString());*/
         if(NodeParser.isNormalTerminationNode(node) && !NodeParser.isExceptionalTerminationNode(node)
               &&!NodeParser.isLoopBodyTerminationNode(node)){            
            IExecutionNode<?> parentNode = node.getParent();
            if(parentNode instanceof IExecutionNode)
               leafNodes.add(parentNode);
            //leafNodes.add(node);
            /*try{
               System.out.println("path condition:: " + parentNode.getPathCondition());
            }catch(Exception e){}*/
         }
      } 
      return leafNodes;
   }
   
   /**
    * get resolved nodes of symbolic execution tree from root
    * @throws ProofInputException 
    * @throws IllegalFormulaException 
    * */
   private List<NodeDetail> createListNodeDetail() throws ProofInputException, IllegalFormulaException{
      List<NodeDetail> result = new LinkedList<NodeDetail>();
      for(int i=0; i<leafNodes.size();i++){
         IExecutionNode<?> node = leafNodes.get(i);
         NodeInvestigator ni = new NodeInvestigator(node, method, depth);
         NodeDetail nd = ni.extractNodeDetail();
         nd.setIndex(i);
         result.add(nd);
      }
      
      return result;
   }
 
   public Pair<List<ExploitTestCases>,List<BadMethod>> checkMethod2GetExploitTestCases() throws IllegalFormulaException{     
      List<ExploitTestCases> resultETestCases = Collections.synchronizedList(new LinkedList<ExploitTestCases>());
      List<BadMethod> resultBadMethods = new LinkedList<BadMethod>();
      for(IFBarrier declar: ifSpecs){
         System.out.println("\n==========================================================");
         System.out.println("Checking noninterference policy: " + declar.getDeclaration());
         //create variable checker via declaration
              
         
         //get list of exploit model by checking the method with current information flow security specification
         Pair<List<ExploitModel>,BadMethod> resultCheck1Declar = checkMethod2GetExploitModels(declar);
         //add list of exploit model into exploitTestSuite
         List<ExploitModel> listEM = resultCheck1Declar.first;
         if(!listEM.isEmpty()){            
               ExploitTestCases exploitTestCases=new ExploitTestCases(method, declar, declCenter, listEM);
               resultETestCases.add(exploitTestCases);  
               
               //add found BadMethod object into result (listEM is not empty means that the method is bad
               resultBadMethods.add(resultCheck1Declar.second);
         }         
         
      }
      return new Pair<List<ExploitTestCases>,List<BadMethod>>(resultETestCases, resultBadMethods);
   }
   
   
      
}



