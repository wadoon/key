/**
 * 
 */
package de.tud.exploitgen.detectleak.exploit;

import java.util.LinkedList;
import java.util.List;

import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;

import de.tud.exploitgen.detectleak.node.ModelNode;
import de.tud.exploitgen.detectleak.node.NodeDetail;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.logic.Term;


/**
 * @author Huy Do
 *
 */
public class ExploitModelCreator {
   private NodeDetail nodeD1, nodeD2;
   //private int idx1, idx2;
   
   /**
    * @param nodeD1
    * @param nodeD2
    */
   public ExploitModelCreator(NodeDetail nodeD1, NodeDetail nodeD2) {
      super();
      this.nodeD1 = nodeD1;
      this.nodeD2 = nodeD2;      
   }

   public ExploitModel getMergedExploitModel(int idx1, int idx2){
	   ModelNode modelNode1 = nodeD1.getModelNode(idx1);
	   ModelNode modelNode2 = nodeD2.getModelNode(idx2);
       KTGModel model1 = modelNode1.getModel();
       KTGModel model2 = modelNode2.getModel();
       //merge model2 to model1 and vice versa, to make sure that two model have the same number of ModelVariable
       KTGModel merModel1 = model1.merge(model2);
       KTGModel merModel2 = model2.merge(model1);
       String heapName = nodeD1.getHeapName();
       return new ExploitModel(merModel1, merModel2, heapName, modelNode1,modelNode2);
   }
   
   
   public ExploitModel getPureExploitModel(int idx1, int idx2){
      KTGModel model1 = KTGModel.constructModel(nodeD1.getModel(idx1));
      KTGModel model2 = KTGModel.constructModel(nodeD2.getModel(idx2));
      String heapName = nodeD1.getHeapName();
      return new ExploitModel(model1, model2, heapName, nodeD1.getModelNode(idx1), nodeD2.getModelNode(idx2));
  }
   
   /*
    * combine all artificial variables in two NodeDetail
    * */
   public List<Term> getSynthesisArtificialVar(){
      List<Term> result = new LinkedList<Term>();
      result = TermUtil.mergeListTerm(result, nodeD1.getArtificialVariables());
      result = TermUtil.mergeListTerm(result, nodeD2.getArtificialVariables());     
      return result;
   }
   
   /*
    * combine all foundation terms in two NodeDetail
    * */
   public List<Term> getSynthesisFoundationTerms(){
	   List<Term> result = new LinkedList<Term>();
      result = TermUtil.mergeListTerm(result, nodeD1.getListFoundationTerms());
      result = TermUtil.mergeListTerm(result, nodeD2.getListFoundationTerms());     
      return result;

   }
  
}
