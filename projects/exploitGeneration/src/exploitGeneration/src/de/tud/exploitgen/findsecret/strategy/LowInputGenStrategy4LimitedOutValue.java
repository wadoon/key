package de.tud.exploitgen.findsecret.strategy;

import java.io.IOException;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.PairTerm;
import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.distribution.Partition;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTProblem;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingMaxSMT;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShELMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KEGTermException;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.util.Pair;

public abstract class LowInputGenStrategy4LimitedOutValue extends LowInputGenStrategy {

	public LowInputGenStrategy4LimitedOutValue(SISupporter siSupporter) {
		super(siSupporter);
		// TODO Auto-generated constructor stub
	}

	@Override
	public Map<String, Long> findBestLowInput() throws IOException, KEGTermException {
		int metric = siSupporter.getMetric();
		SecretDistribution sDistrubution = siSupporter.getsDistribution();
		if(metric==KEGConstant.MIN_ENTROPY){
			if((sDistrubution==null)||(sDistrubution.isUniform())){
				//for uniform distribution, min-entropy-based leakage is logarithm base 2 of the number of possible output
				return findLowInputMaximizingNumberOfOutputValue();
			}else{
				return findLowInputMaximizingMinEntropyLeakage4NU();		
			}
		}else{
			//working with Shannon entropy or Guessing entropy
			List<PPCountingResult> listCountingResults = getListCountingResultForShannonAndGuessingEntropy();			
			//find "best" low input
			LeakageMaximizerUsingCounting inputProducer;
			BadMethod badMethod = siSupporter.getBadMethod();
			if((sDistrubution==null)||(sDistrubution.isUniform())){ 
				//uniform distribution
				BigInteger numOfHighValues = siSupporter.findNumberOfPossibleHighValue(siSupporter.getCurrentKnowledge());
				if(metric==KEGConstant.SHANNON_ENTROPY){				
					inputProducer = new ShELMaximizerUsingCounting4Uniform(listCountingResults, 
						badMethod.getMethod().getServices(), 
						badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(),numOfHighValues, siSupporter.getOptSolver());
				}	
				else{ // guessing entropy
					inputProducer = new GELMaximizerUsingCounting4Uniform(listCountingResults, 
							badMethod.getMethod().getServices(), 
							badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(),numOfHighValues,siSupporter.getOptSolver());
				}
			}else{ 
				//non-uniform distribution
				if(metric==KEGConstant.SHANNON_ENTROPY){
					inputProducer = new ShELMaximizerUsingCounting4NU(listCountingResults, badMethod.getMethod().getServices(), 
							badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(), 
							siSupporter.getOptSolver(),
							sDistrubution, siSupporter.findSumOfFrequencyOverAllPossibleHighValues());
					
				}	
				else{ //guessing entropy					
					inputProducer = new GELMaximizerUsingCounting4NU(listCountingResults, badMethod.getMethod().getServices(), 
							badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(), 
							siSupporter.getOptSolver(),
							sDistrubution, siSupporter.findSumOfFrequencyOverAllPossibleHighValues(),
							siSupporter.findListCardinalityOfPartitions());
				}
			}
			
			Pair<Map<String,Long>,Double> optimizedResult = inputProducer.findLowInputMaximizingLeakge();
			if(optimizedResult!=null){
				if(metric==KEGConstant.SHANNON_ENTROPY){
					System.out.println("Shannon-entropy-based leakage: " + optimizedResult.second);
				}else{
					System.out.println("Guessing-entropy-based leakage: " + optimizedResult.second);
				}
			}else
				System.out.println("leakage has not been computed!!");
			if((optimizedResult.second>KEGConstant.MINIMUM_LEAK) &&(optimizedResult.first.size()>0))
				return optimizedResult.first;
			else{
				return findUsefulLowInput();
			}
		}
	}

	protected PairTerm createPairTermFromMV(ModelVariable mv, int idx){      
	      String varName=mv.getIdentifier();  
	      Services services= siSupporter.getBadMethod().getMethod().getServices();
	      TermBuilder tb= services.getTermBuilder();
	     
	         LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_" + idx),mv.getType());
	         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_" + idx),mv.getType());
	         
	         //create two terms from two location variables
	         Term t1 = tb.var(lv1);
	         Term t2 = tb.var(lv2);
	         
	         return new PairTerm(t1,t2,services);  
	        
	   } 
	
	/*
	 * override the method in LowInputGenStrategy using Max-SMT approach for uniform distribution
	 * */
   @Override
	protected Map<String,Long> findLowInputMaximizingNumberOfOutputValue() throws IOException{
		return findLowInputMaximizingMinEntropyLeakage4NU();
	}
	
	protected abstract List<PPCountingResult> getListCountingResultForShannonAndGuessingEntropy() throws IOException, KEGTermException;
	protected abstract Map<String, Long> findLowInputMaximizingMinEntropyLeakage4NU();
}
