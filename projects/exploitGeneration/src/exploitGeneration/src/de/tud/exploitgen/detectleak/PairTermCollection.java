/**
 * 
 */
package de.tud.exploitgen.detectleak;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Map;




import org.key_project.util.collection.ImmutableArray;

import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
//import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;




/**
 * This class wraps a collection of PairTerm mapped by a name, 
 * which could be used to represent list of high variables, low variables in two branches...
 * @author Huy Do
 * 
 */
public class PairTermCollection {
   private Map<String, PairTerm> mapPairTerm;
   private final Services services;
   private final TermFactory tf = new TermFactory();
   private final TermBuilder termBuilder;
   private final Term tt = tf.createTerm(Junctor.TRUE);
   private final Term ff = tf.createTerm(Junctor.FALSE);
   /**
    * @param listPairTerm
    */
   public PairTermCollection(Map<String,PairTerm> listPairTerm, Services services) {
      super();
      this.mapPairTerm = listPairTerm;
      this.services=services;
      termBuilder=new TermBuilder(tf,services);
      
   }

   /**
    * @return the mapPairTerm
    */
   public Map<String,PairTerm> getMapPairTerm() {
      return mapPairTerm;
   }

   /**
    * @param mapPairTerm the listPairTerm to set
    */
   public void setMapPairTerm(Map<String,PairTerm> mapPairTerm) {
      this.mapPairTerm = mapPairTerm;
   }

   public PairTermCollection(Services services){
      this.mapPairTerm=new HashMap<String,PairTerm>();
      this.services=services;
      termBuilder=new TermBuilder(tf,services);
   }
   
   //constructor to clone another PairTermCollection
   public PairTermCollection(PairTermCollection ptc){
      mapPairTerm=new HashMap<String,PairTerm>();
      for(String key: ptc.getNameSet()){
         add(key,ptc.getPairTerm(key));
      }
      this.services=ptc.getServices();
      termBuilder=new TermBuilder(tf,services);
   }
   
   public void add(String name,PairTerm pt){
      mapPairTerm.put(name,pt);
   }
   
   /**
    * make total equal term from PairTermCollection. It looks like that:
    * t11=t21 and t21=t22 and t31=t32 and ....
    * */
   public Term totalEqualTerm(){      
      Term result = tt;
      int i=0;
      for(PairTerm pt : mapPairTerm.values()) {
          result = termBuilder.and(result,pt.equalTerm(i));
          i++;
      }
      return result;
   }
   
   /**
    * make total not equal term from PairTermCollection. It looks like that:
    * t11!=t21 and t21!=t22 and t31!=t32 and ...
    * */
   public Term totalNotEqualTerm(){
      Term result = tt;
      int i=0;
      for(PairTerm pt : mapPairTerm.values()) {         
          result = termBuilder.and(result,pt.notEqualTerm(i));
          i++;
      }
      return result;
   }
   
   /**
    * make partial equal term from PairTermCollection. It looks like that:
    * t11=t21 or t21=t22 or t31=t32 or ...
    * */
   public Term partialEqualTerm(){      
      Term result = ff;
      int i=0;
      for(PairTerm pt : mapPairTerm.values()) {
          result = termBuilder.or(result,pt.equalTerm(i));
          i++;
      }
      return result;
   }
   /**
    * make partial not equal term from PairTermCollection. It looks like that:
    * t11!= t21 or t21 != t22 or t31 != t32 ....
    * */
   public Term partialNotEqualTerm(){
      Term result = ff;
      int i=0;
      for(PairTerm pt : mapPairTerm.values()) {
          result = termBuilder.or(result,pt.notEqualTerm(i));
          i++;
      }
      return result;
   }
   
   
   /**
    * fresh version
    * make total equal term from PairTermCollection. It looks like that:
    * t11=t21 and t21=t22 and t31=t32 and ....
    * */
   public Term freshTotalEqualTerm(){      
      Term result = tt;
      for(PairTerm pt : mapPairTerm.values()) {
          result = termBuilder.and(result,pt.freshEqualTerm());
      }
      return result;
   }
   
   /**
    * fresh version
    * make total not equal term from PairTermCollection. It looks like that:
    * t11!=t21 and t21!=t22 and t31!=t32 and ...
    * */
   public Term freshTotalNotEqualTerm(){
      Term result = tt;
      for(PairTerm pt : mapPairTerm.values()) {
          result = termBuilder.and(result,pt.freshNotEqualTerm());
      }
      return result;
   }
   
   /**
    * make partial equal term from PairTermCollection. It looks like that:
    * t11=t21 or t21=t22 or t31=t32 or ...
    * */
   public Term freshPartialEqualTerm(){      
      Term result = ff;
      for(PairTerm pt : mapPairTerm.values()) {
          result = termBuilder.or(result,pt.freshEqualTerm());
      }
      return result;
   }
   /**
    * make partial not equal term from PairTermCollection. It looks like that:
    * t11!= t21 or t21 != t22 or t31 != t32 ....
    * */
   public Term freshPartialNotEqualTerm(){
      Term result = ff;
      for(PairTerm pt : mapPairTerm.values()) {
          result = termBuilder.or(result,pt.freshNotEqualTerm());
      }
      return result;
   }
   
   
   /*
    * get Term corresponding with the given name and the number of branch
    * if branch's number is 1, return term 1 in PairTerm, otherwise return term 2
    */
   public Term getTermByNameAndBranch(String name, int branch){
      if(mapPairTerm.containsKey(name)){
         if(branch==1)
            return mapPairTerm.get(name).getT1();
         else
            return mapPairTerm.get(name).getT2();
      }else
         return null;      
   }
   
   /*
    * create a new term from input term by: 
    * find all ProgramVariable subterms of input term which the name is the same with given name
    * replace it by the term  
    * */
   public Term replacePVByNameAndBranch(final Term term, int branch){
   //   OpReplacer replacer = new OpReplacer( msp from originsl prog  vsr to new prog vsr);
   //   Term newTerm = replacer.replace(term);
      
      
      if(term !=null){
         if(term.subs()==null || term.subs().size()==0){
            Term rt=getTermByNameAndBranch(term.toString(), branch);
            if(rt!=null)
               return rt;
            else return term;
         }else if (TermParser.isQuantifier(term)){
            return tf.createTerm(term.op(), replaceSubTermsByNameAndBranch(term.subs(), branch), 
                  replaceQuantifier(term.boundVars(),branch),term.javaBlock());
         }
         else{
            return tf.createTerm(term.op(), replaceSubTermsByNameAndBranch(term.subs(), branch), term.boundVars(),term.javaBlock());
            //return tf.createTerm(term.op(), replaceSubTermsByNameAndBranch(term.subs(), branch));
         }
      }else return null;
   }
   
   private ImmutableArray<QuantifiableVariable> replaceQuantifier(ImmutableArray<QuantifiableVariable> boundVars, int branch){
      List<QuantifiableVariable> listQV = new LinkedList<QuantifiableVariable>();
      //System.out.println("boundVars: " + boundVars.toString());
      for(int i = 0; i<boundVars.size(); i++){
         //System.out.println("quantifiable var: " + boundVars.get(i).name().toString());
         Term rt = getTermByNameAndBranch(boundVars.get(i).name().toString(), branch);        
         
         if(rt!=null){           
            
            LogicVariable lv = new LogicVariable(new Name(rt.toString()), rt.sort());         
            listQV.add(lv);
         }else{
            listQV.add(boundVars.get(i));
         }
      }
      
      return new ImmutableArray<QuantifiableVariable>(listQV);
   }
   
   private Term[] replaceSubTermsByNameAndBranch(final ImmutableArray<Term> subs, int branch){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replacePVByNameAndBranch(subs.get(i), branch);    
      return (result);
   }
   
   /*
    * print list pair term 
    * */
   public void printListPairTerm(){      
      Set<String> names=mapPairTerm.keySet();
      for(String name:names){
         System.out.println("name: " + name + "; term 1: " + mapPairTerm.get(name).getT1() + 
               "; type: " + mapPairTerm.get(name).getT1().sort().declarationString()+
               "; term 2: " + mapPairTerm.get(name).getT2() + "; type: "
               + mapPairTerm.get(name).getT2().sort().toString());        
         
      }
   }
   
   /*
    * check if the list of pairterm contains the variable varName 
    * */   
   public boolean contains(String varName){
      if(mapPairTerm.containsKey(varName))
         return true;
      else return false;
   }
   
   /*
    * combine with another PairTermCollection
    * */   
   public void combine(PairTermCollection ptc){
      //PairTermCollection result=new PairTermCollection(this);    //clone @this to the result
      
      for(String key:ptc.getNameSet()){
         if(!contains(key))
            add(key,ptc.getPairTerm(key));
      }
      //return result;
   }
   
   public Set<String> getNameSet(){
      return mapPairTerm.keySet();
   }
   
   public PairTerm getPairTerm(String name){
      if(contains(name)){
         return mapPairTerm.get(name);
      }else return null;
   }   
   
   //get all PairTerm of map listPairTerm
   public List<PairTerm> getPairTerms(){
      List<PairTerm> result=new LinkedList<PairTerm>();
      for(String key: mapPairTerm.keySet()){
         result.add(mapPairTerm.get(key));
      }
      return result;
   }
   
   public Services getServices(){
	   return services;
   }
   
   public String toString(){
	   String result = "";
	   for(String t: mapPairTerm.keySet())
		   result += t.toString() + " : " + mapPairTerm.get(t).toString() + "\n";
	   return result;
   }
 }
