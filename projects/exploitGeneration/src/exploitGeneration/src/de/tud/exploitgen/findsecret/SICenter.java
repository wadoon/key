package de.tud.exploitgen.findsecret;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.tud.exploitgen.solver.Z3Solver;
import de.uka.ilkd.key.proof.init.ProofInputException;

public class SICenter {
	private KeYJavaClass javaClass;
	private File javaFile;
	private List<BadMethod> listBadMethods;
	public SICenter(KeYJavaClass javaClass, File javaFile,
			List<BadMethod> listBadMethods) {
		super();
		this.javaClass = javaClass;
		this.javaFile = javaFile;
		this.listBadMethods = listBadMethods;
	}
	
	/*
	 * user interface
	 * */
	public void userInteraction() throws ProofInputException, IOException, InterruptedException{
		System.out.println("There are several vulnarable methods of class " + javaClass.getName() + ":");		
		for(int i=0;i<listBadMethods.size();i++)
			System.out.println((i+1) + ": " + listBadMethods.get(i).getMethod().getName());		
		Scanner keyboard = new Scanner(System.in);
		String input;
		int methodIdx=-1;
    	while(true){
    		System.out.println("Press corresponding index number to exploit the method! Press Q/q to halt");
    		input = keyboard.nextLine();
    		try{
    			methodIdx = Integer.parseInt(input);
    		}catch(NumberFormatException e){
    			if(input.equalsIgnoreCase("q")){
    				methodIdx=-1;
    				break;
    			}
    		}
    		if(methodIdx>0 && methodIdx<=listBadMethods.size())
    			break;
    	}
    	if(methodIdx>0 && methodIdx<=listBadMethods.size()){
    		secretInferSimulation(methodIdx);		
    	}  	    	
	}
	
	/*
	 * simulate hacking process
	 * first: exploit program is created and compiled
	 * second: create input data (both low and high)
	 * third: run exploit program several times and use SecretInferSupporter to create low inputs for the next experiment
	 * finally: halt after specific iterations and print out the information of high values
	 * */
	private void secretInferSimulation(int methodIdx) throws ProofInputException, IOException, InterruptedException{
		BadMethod badMethod = listBadMethods.get(methodIdx-1);	
		
		
		//badMethod.resolveRiskyPaths();
		badMethod.resolveRiskyPaths();
		badMethod.resolvePrecondition();
		System.out.println(badMethod.getStringRiskyPaths()); //check path condition
		
		//first: exploit program is created and compiled
		SIFactory sif = new SIFactory(javaFile,badMethod , javaClass);
		File hackFile = sif.createHackingProgram();		
		String hackClassName = sif.createHackingClassName();
		
		//second: create high input data 
		
		
		File hackFolder = sif.createHackFolder();
		File highInputFile= sif.makeHighInputFile();
		initiateHighInput(highInputFile, badMethod);		
		Scanner keyboard = new Scanner(System.in);
		String input="";
		while(true){
			System.out.println("high input data has been created at: " + highInputFile.getAbsolutePath());
			System.out.println("You can change high variable's values before continue!");
			while(true){
				System.out.println("Are you ready to continue? Yes: press Y; No: press N; Quit: press Q");
				input = keyboard.nextLine();
				if(input.equalsIgnoreCase("Y")||input.equalsIgnoreCase("Q"))
					break;			
			}
			
			if(input.equalsIgnoreCase("Y")){	
				/*
				 * here we must check the type of program to apply suitable strategy
				 * */	
				
				badMethod.resetMatchedPaths();
				File lowInputFile = sif.makeLowInputFile();	
				SISupporter sis = getSecretInferSupporter(badMethod);	
				//third: create low inputs using SecretInferSupporter and run exploit program several times
				System.out.println("initial knowledge of high variables: " + sis.getCurrentKnowledge());
				System.out.println("number of possible high values: " + sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge()));
				
				if(sis instanceof SISupporter4LowIndependent){
					System.out.println("because all risky paths are low-independent, we need one and only one experiment with arbitrary low input values to infer high values");
					Map<String, Long> lowInputs = sis.findBestLowInput();				
					writeLowInput(lowInputFile, badMethod, sis.replaceByOriginalNameOfVars(lowInputs));				
					Map<String,Long> observedOuputs = runNObserveLowOutput(hackFolder, hackClassName);
					Experiment experiment = new Experiment(lowInputs, sis.replaceByIndentifierOfVarInModel(observedOuputs));
					//experiment.printInfo();
					sis.updateKnowledge(experiment);				
					System.out.println("maximum knowledge can be achieved: " + sis.getCurrentKnowledge());
					long possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());				
					
					//finally, print out the information of high variable			
					if(possibleNumberOfHigh==1){
						Z3Solver z3= new Z3Solver(sis.getCurrentKnowledge(),javaClass.getEnvironment().getServices());
						Map<String,Long> mapHighValues = z3.solveFormula2GetMapValues();
						System.out.println("High value: " + mapHighValues);
					}else{
						System.out.println("number of possible high values after 1 experiment: "+ possibleNumberOfHigh);						
					}
					
				}else{
					int numIteration = 30; //number of iteration, TODO: it should be a parameter
					int i=0;
					sis.printInitialInformation();
					long possibleNumberOfHigh=Long.MAX_VALUE;
					while(i<numIteration){
						if(sis.matchLowIndependentPath()){
							System.out.println("BINGO! A low-independent path has been matched!!! Now we cannot do anything more!");
							break;
						}else{
							Map<String, Long> lowInputs = sis.findBestLowInput();
							if(lowInputs!=null){
								System.out.println("low input at step "+ i + ": " + lowInputs.toString());
								writeLowInput(lowInputFile, badMethod, sis.replaceByOriginalNameOfVars(lowInputs));				
								Map<String,Long> observedOuputs = runNObserveLowOutput(hackFolder, hackClassName);
								Experiment experiment = new Experiment(lowInputs, sis.replaceByIndentifierOfVarInModel(observedOuputs));
								//experiment.printInfo();
								sis.updateKnowledge(experiment);				
								System.out.println("attacker knowledge afer updating: " + sis.getCurrentKnowledge());
								i++;
								possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());				
								System.out.println("possible number of high values after " + i + " experiments: \n"+ possibleNumberOfHigh);
								if(possibleNumberOfHigh==1)
									break;
							}else{
								System.out.println("Cannot generate next low input values! It seems that we are not able to infer more about secret");							
								break;
							}
						}
					}			
					//finally, print out the information of high variable			
					if(possibleNumberOfHigh==1){
						Z3Solver z3= new Z3Solver(sis.getCurrentKnowledge(),javaClass.getEnvironment().getServices());
						Map<String,Long> mapHighValues = z3.solveFormula2GetMapValues();
						System.out.println("High value: " + mapHighValues);
					}else{
						System.out.println("attacker knowledge about high values: " + sis.getCurrentKnowledge());
						possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());				
						System.out.println("possible number of high values after " + i + " experiments: \n"+ possibleNumberOfHigh);
						//Z3Solver z3= new Z3Solver(sis.getCurrentKnowledge(),javaClass.getEnvironment().getServices());
						//System.out.println("Possible values of high variables: " );
						//List<Map<String,Long>> listPossibleValues = z3.findAllSatisfiableModels();
						
					}
				}
			}
			
			System.out.println("\n Would you like to try with another value of high variables? (Y/N)?");
			input = keyboard.nextLine();
			if(input.equalsIgnoreCase("N")||input.equalsIgnoreCase("Q"))
				break;			
		}
		
		
	}
	
	
	private Map<String, Long> runNObserveLowOutput(File hackFolder, String hackClassName) throws IOException, InterruptedException{
		Map<String, Long> result = new HashMap<String, Long>();
		List<String> command = new ArrayList<String>();
		
		command.add("java");
		command.add(hackFolder.getName()+"."+ hackClassName);
		   
	    
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.directory(hackFolder.getParentFile());
	    //Map<String, String> environ = builder.environment();		    		    
	    final Process process = builder.start();	    	    
	    InputStream is = process.getInputStream();
	    BufferedReader br = new BufferedReader(new InputStreamReader(is, Charset.defaultCharset()));
	      
	    int numVars = Integer.parseInt(br.readLine());
	    System.out.println("number of observable output: " + numVars);
	    for(int i=0;i<numVars;i++){
	    	String line = br.readLine();
	    	System.out.println(line);
	    	String[] varValue = line.split(":");
	    	result.put(varValue[0], Long.valueOf(varValue[1]));
	    }
		return result;
	}
	
	
	private void initiateHighInput(File highInputFile, BadMethod badMethod) throws IOException{
		List<String> highVars = badMethod.getIFBarrier().getSource();		
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(highInputFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "";
		//create high inputs
		highInputContent += highVars.size() + "\n";
		for(String highVar : highVars){
			highInputContent += highVar + " : 0\n" ; //default value is 0
		}
		writer.write(highInputContent);
		writer.close();
	}
	
	
	private void writeLowInput(File lowInputFile, BadMethod badMethod, Map<String, Long> mapValues) throws IOException{		
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(lowInputFile.getPath()), StandardCharsets.UTF_8);
		String lowInputContent ="";
		//create high inputs
		lowInputContent = mapValues.size() + "\n";
		for(String lowVar : mapValues.keySet()){
			lowInputContent += lowVar + " : " + mapValues.get(lowVar) +"\n"; //default value is 0
		}
		writer.write(lowInputContent);
		writer.close();
	}
	
	private SISupporter getSecretInferSupporter(BadMethod badMethod){
		if(badMethod.allPathsAreLowIndependent())
			return new SISupporter4LowIndependent(badMethod);
		else if(badMethod.allOutputsAreConst())
			return new SISupporter4RiskConst(badMethod);
		else
			return new SISupporter4General(badMethod);
	} 
}
