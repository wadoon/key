package de.tud.exploitgen.findsecret;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;
import java.math.BigInteger;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.commons.io.FileUtils;

//import javax.xml.parsers.*;
//import javax.xml.transform.*;
//import javax.xml.transform.dom.*;
//import javax.xml.transform.stream.*;
//import org.xml.sax.*;
import org.w3c.dom.*;


import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.distribution.DistributionTransformer;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4LowIndependent;

import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KEGTermException;
import de.tud.exploitgen.util.TermTransformer;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.util.Pair;



public class SICenter {
	private KeYJavaClass javaClass;
	private File javaFile;
	private List<BadMethod> listBadMethods;
	public SICenter(KeYJavaClass javaClass, File javaFile,
			List<BadMethod> listBadMethods) {
		super();
		this.javaClass = javaClass;
		this.javaFile = javaFile;
		this.listBadMethods = listBadMethods;
	}
	
	/*
	 * user interface
	 * */
	public void userInteraction() throws ProofInputException, IOException, InterruptedException, KEGTermException, ParserConfigurationException, TransformerException{
		System.out.println("There are several vulnarable methods of class " + javaClass.getName() + ":");		
		for(int i=0;i<listBadMethods.size();i++)
			System.out.println((i+1) + ": " + listBadMethods.get(i).getMethod().getName());		
		Scanner keyboard = new Scanner(System.in);
		String input;
		int methodIdx=-1;
    	while(true){
    		System.out.println("Press corresponding index number to exploit the method! Press Q/q to halt");
    		input = keyboard.nextLine();
    		try{
    			methodIdx = Integer.parseInt(input);
    		}catch(NumberFormatException e){
    			if(input.equalsIgnoreCase("q")){
    				methodIdx=-1;
    				break;
    			}
    		}
    		if(methodIdx>0 && methodIdx<=listBadMethods.size())
    			break;
    	}
    	if(methodIdx>0 && methodIdx<=listBadMethods.size()){
    		secretInferSimulation(methodIdx);	
    		//experimentSimulation(methodIdx);
    	}  	    	
    	keyboard.close();
	}
	
	/*
	 * simulate hacking process
	 * first: exploit program is created and compiled
	 * second: create input data (both low and high)
	 * third: run exploit program several times and use SecretInferSupporter to create low inputs for the next experiment
	 * finally: halt after specific iterations and print out the information of high values
	 * */
	private void secretInferSimulation(int methodIdx) throws ProofInputException, IOException, InterruptedException, KEGTermException{
		BadMethod badMethod = listBadMethods.get(methodIdx-1);	

		badMethod.extractMapFreshOutVar();	
		badMethod.extractListQuantifiedHighVar();
		System.out.println("Resolving all risky path: check if they are low-independent, OConst, ODependH, ODependL, ODependLH .....");
		badMethod.resolveRiskyPaths();
		System.out.println(badMethod.getStringRiskyPaths()); //check path condition
		System.out.println("Resolving precondition (is considered as initial knowledge)...... ");
		badMethod.resolvePrecondition();
		System.out.println("precondition:: "+ badMethod.getPrecondition());
		
		
		//first: exploit program is created and compiled
		SIFactory sif = new SIFactory(javaFile,badMethod , javaClass);
		File hackFile = sif.createHackingProgram();		
		String hackClassName = sif.createHackingClassName();
		
		//second: create high input data 
		
		
		File hackFolder = sif.createHackFolder();
		File highInputFile= sif.makeHighInputFile();
		File distributionFile = sif.createDistributionFile();
		//initiateHighInput(highInputFile, badMethod);
		Scanner keyboard = new Scanner(System.in);
		String input="";
		while(true){
			createRandomHighInputObj(highInputFile, badMethod);
			//initiateHighInput(highInputFile, badMethod);
			createUniformHighInputDistribution(distributionFile);
			System.out.println("High input data has been created randomly at: " + highInputFile.getAbsolutePath());
			System.out.println("Default distribution of high input data (UNIFORM DISTRIBUTION) has been created at: " + distributionFile.getAbsolutePath());
			System.out.println("You can change high values and its distribution before continue!");
			while(true){
				System.out.println("Are you ready to continue? Yes: press Y; No: press N; Quit: press Q");
				input = keyboard.nextLine();
				if(input.equalsIgnoreCase("Y")||input.equalsIgnoreCase("Q"))
					break;			
			}
			
			if(input.equalsIgnoreCase("Y")){
				/* get secret distribution*/
				 BufferedReader br = new BufferedReader(new FileReader(distributionFile));
				String distributionString = FileUtils.readFileToString(distributionFile);
				System.out.println("distributionString:: " + distributionString);
				DistributionTransformer distTransformer = new DistributionTransformer(distributionString, javaClass.getEnvironment().getServices());
				SecretDistribution sDistribution = distTransformer.translate2Distribution();
				sDistribution.printInfo();
				int numOfExprs=32; // default number
				while(true){
					System.out.println("Input the maximum number of experiments:");
					input = keyboard.nextLine();
					try{
						numOfExprs = Integer.parseInt(input);
					}catch(NumberFormatException e){
						continue;
					}
					if(numOfExprs > 0)
						break;
					else
						System.out.println("maximum number of experiments must be greater than 0!");
				}
				/*  create log file*/
				File logFile = sif.createLogFile();
				BufferedWriter logWriter = Files.newBufferedWriter(Paths.get(logFile.getPath()), StandardCharsets.UTF_8);
				logWriter.write("file name: " + javaFile.getName() + "; method : " + badMethod.getMethod().getName() + "\n");				
				/*
				 * here we must check the type of program to apply suitable strategy
				 * */				
				badMethod.resetPaths();
				File lowInputFile = sif.makeLowInputFile();				
				boolean randomLowInput = false;
				System.out.println("How to create low input? randomly (R/r)? or knowledge-guided optimized(O/o)?");
				input = keyboard.nextLine();
				if(input.equalsIgnoreCase("r")){
					logWriter.write("Randomly generating low input\n");
					randomLowInput = true;
				}
				int metric=KEGConstant.SHANNON_ENTROPY;
				String optSolver = KEGConstant.OPTSOLVER_ALL;
				if(!randomLowInput){
					logWriter.write("Choosing low input optimizing leakage\n");
					System.out.println("What metric would you like to use? Min-entropy-based(M/m)? Guessing-entropy-based(G/g)? Shannon-entropy-based(otherwise)?");				
					input = keyboard.nextLine();				
					if(input.equalsIgnoreCase("m")){
						metric = KEGConstant.MIN_ENTROPY;
						logWriter.write("Leakage metric: Min-entropy-based \n");
					}
					else if(input.equalsIgnoreCase("g")){
						metric = KEGConstant.GUESSING_ENTROPY;
						logWriter.write("Leakage metric: Guessing-entropy-based \n");
					}else
						logWriter.write("Leakage metric: Shannon-entropy-based \n");
					System.out.println("Choose optimization tool: couenne (C/c)? bonmin (B/b)? LocalSolver(L/l)? or combination of all solvers? (A/a)?");
					input = keyboard.nextLine();				
					if(input.equalsIgnoreCase("c")){
						optSolver = KEGConstant.OPTSOLVER_COUENNE;												
					}else if(input.equalsIgnoreCase("l"))
						optSolver = KEGConstant.OPTSOLVER_LOCALSOLVER;
					else if(input.equalsIgnoreCase("b"))
						optSolver = KEGConstant.OPTSOLVER_BONMIN;
					else 
					logWriter.write("Optimization solver: " + optSolver +  "\n");					
						
				}				
				SISupporter sis = new SISupporter(badMethod,metric,randomLowInput,optSolver, sDistribution); 
				System.out.println("low input generating strategy: " + sis.getLowInputGenStrategy().getClass().getName());
				//third: create low inputs using SecretInferSupporter and run exploit program several times
				System.out.println("initial knowledge of high variables: " + sis.getCurrentKnowledge());
				BigInteger numOfHighVars = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());
				logWriter.write("number of possible high values by initial knowledge: " + numOfHighVars + "\n");
				System.out.println("number of possible high values by initial knowledge: " + numOfHighVars);
				
				if(sis.getLowInputGenStrategy() instanceof LowInputGenStrategy4LowIndependent){
					System.out.println("because all risky paths are low-independent, we need one and only one experiment with arbitrary low input values to infer high values");
					logWriter.write("because all risky paths are low-independent, we need one and only one experiment with arbitrary low input values to infer high values\n");
					Map<String, Long> lowInputs = sis.findBestLowInput();		
			
					//writeLowInput(lowInputFile, badMethod, sis.replaceByOriginalNameOfVars(lowInputs));	
					writeLowInput(lowInputFile, lowInputs);
					
					Map<String,Long> observedOuputs = runNObserveLowOutput(hackFolder, hackClassName);
					System.out.println("observedOuputs: " + observedOuputs);
					//Experiment experiment = new Experiment(lowInputs, sis.replaceByIndentifierOfVarInModel(observedOuputs));
					Experiment experiment = new Experiment(lowInputs, observedOuputs);
					experiment.printInfo();
					sis.updateKnowledge(experiment,0);				
					System.out.println("maximum knowledge can be achieved: " + sis.getQuantifiedCurrentKnowledge());					
					BigInteger possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getQuantifiedCurrentKnowledge());				
					
					//finally, print out the information of high variable			
					if(possibleNumberOfHigh.equals(BigInteger.ONE)){
						
						Z3Solver z3= new Z3Solver(sis.getQuantifiedCurrentKnowledge(),javaClass.getEnvironment().getServices());
						Map<String,Long> mapHighValues = z3.solveFormula2GetMapValues();
						System.out.println("High value: " + mapHighValues);
						logWriter.write("High value: " + mapHighValues+ "\n");
					}else{
						System.out.println("number of possible high values after 1 experiment: "+ possibleNumberOfHigh);
						logWriter.write("number of possible high values after 1 experiment: "+ "\n");
					}					
				}else{
					//int numOfExprs = KEGConstant.NUM_EXPERIMENTS; 
					int i=0;
					sis.printInitialInformation();
					BigInteger possibleNumberOfHigh=BigInteger.valueOf(Long.MAX_VALUE);
					long startAttack = System.nanoTime();
					logWriter.write("===================================================\n");
					while(i<numOfExprs){
						if(sis.matchLowIndependentPath()){
							System.out.println("BINGO! A low-independent path has been matched!!! Now we cannot do anything more!");
							logWriter.write("BINGO! A low-independent path has been matched!!! Now we cannot do anything more!\n");
							break;
						}else{
							sis.reDetermineLowInputGenStrategy(); //maybe all high-depend-only paths have been matched already
							System.out.println("current LowInputGenStrategy:" + sis.getLowInputGenStrategy().getClass().getName());
							//logWriter.write("current LowInputGenStrategy:" + sis.getLowInputGenStrategy().getClass().getName()+ "\n");
							Map<String, Long> lowInputs = sis.findBestLowInput();
							if(lowInputs!=null){
								System.out.println("low input at step "+ i + ": " + lowInputs.toString());
								logWriter.write("low input at step "+ i + ": " + lowInputs.toString()+"\n");
								//writeLowInput(lowInputFile, badMethod, sis.replaceByOriginalNameOfVars(lowInputs));		
								writeLowInput(lowInputFile, lowInputs);
								
								Map<String,Long> observedOuputs = runNObserveLowOutput(hackFolder, hackClassName);
								
								//Experiment experiment = new Experiment(lowInputs, sis.replaceByIndentifierOfVarInModel(observedOuputs));
								Experiment experiment = new Experiment(lowInputs, observedOuputs);
								//experiment.printInfo();
								sis.updateKnowledge(experiment,i);				
								
								i++;
								possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());				
								System.out.println("possible number of high values after " + i + " experiments: \n"+ possibleNumberOfHigh);
								logWriter.write("possible number of high values after " + i + " experiments: "+ possibleNumberOfHigh + "\n");
								if(possibleNumberOfHigh.longValue()==1){
									System.out.println("hey, there is only one left!");
									break;
								}
							}else{
								System.out.println("Cannot generate useful low input values! It seems that we are not able to infer more about secret");
								logWriter.write("Cannot generate useful input values! It seems that we are not able to infer more about secret\n");
								break;
							}
						}
					}	
					logWriter.write("===================================================\n");
					//finally, print out the information of high variable			
					if(possibleNumberOfHigh.longValue()==1){
						TermTransformer termTransformer = new TermTransformer(javaClass.getEnvironment().getServices());
						Term knowledge = termTransformer.transformBWXORTerm(sis.getQuantifiedCurrentKnowledge(),4);
						
						knowledge = termTransformer.transformITE(sis.getQuantifiedCurrentKnowledge());
						Z3Solver z3= new Z3Solver(knowledge,javaClass.getEnvironment().getServices());
						List<Map<String,Long>> listValues = z3.findAllSatisfiableModels();
						System.out.println("High value: " );
						for(Map<String, Long> mapResult: listValues){
							for(String highVar: mapResult.keySet())
								System.out.println(highVar + " = " + mapResult.get(highVar));
						}
						Map<String,Long> mapHighValues = z3.solveFormula2GetMapValues();
						System.out.println("High value: " + mapHighValues);
						logWriter.write("High value: " + mapHighValues +"\n");
					}else{
						
						System.out.println("attacker knowledge about high values: " + sis.getQuantifiedCurrentKnowledge());
						logWriter.write("attacker knowledge about high values: " + sis.getQuantifiedCurrentKnowledge()+"\n");
						TermTransformer termTransformer = new TermTransformer(javaClass.getEnvironment().getServices());
						
						Term knowledge = termTransformer.transformBWXORTerm(sis.getQuantifiedCurrentKnowledge(),4);
						
						knowledge = termTransformer.transformITE(sis.getQuantifiedCurrentKnowledge());
						possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(knowledge);				
						System.out.println("possible number of high values after " + i + " experiments: \n"+ possibleNumberOfHigh);
						logWriter.write("possible number of high values after " + i + " experiments: "+ possibleNumberOfHigh+"\n");
						
						
						
						
						/*Z3Solver z3= new Z3Solver(knowledge,javaClass.getEnvironment().getServices());
						List<Map<String,Long>> listValues = z3.findAllSatisfiableModels();
						System.out.println("High value found using knowledge : " );
						for(Map<String, Long> mapResult: listValues){
							for(String highVar: mapResult.keySet())
								System.out.println(highVar + " = " + mapResult.get(highVar));
						}*/
						
						
						if(possibleNumberOfHigh.longValue()<10){ //<10						
							knowledge = termTransformer.transformBWXORTerm(sis.getQuantifiedCurrentKnowledge(),4);
							System.out.println("final knowledge:: " + knowledge);
							Z3Solver z3= new Z3Solver(knowledge,javaClass.getEnvironment().getServices());
							System.out.println("Possible values of high variables: " );
							logWriter.write("Possible values of high variables: \n");
							List<Map<String,Long>> listPossibleValues = z3.findAllSatisfiableModels();
							System.out.println(listPossibleValues);
							logWriter.write(listPossibleValues+"\n");
						}
						
					}
					long finishAttack = System.nanoTime();
					double attackTime =  (double)(finishAttack-startAttack)/1000000000;
					System.out.println("ATTACK TIME: " + attackTime + " seconds");
					logWriter.write("ATTACK TIME: " + attackTime + " seconds"+"\n");
					logWriter.close();
				}
			}
			
			System.out.println("\n Would you like to try with another value of high variables? (Y/N)?");
			input = keyboard.nextLine();
			if(input.equalsIgnoreCase("N")||input.equalsIgnoreCase("Q"))
				break;			
		}
		
		
	}
	
	
	private Map<String, Long> runNObserveLowOutput(File hackFolder, String hackClassName) throws IOException, InterruptedException{
		Map<String, Long> result = new HashMap<String, Long>();
		List<String> command = new ArrayList<String>();
		
		command.add("java");
		command.add(hackFolder.getName()+"."+ hackClassName);
		   
	    
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.directory(hackFolder.getParentFile());
	    //Map<String, String> environ = builder.environment();		    		    
	    final Process process = builder.start();	    	    
	    InputStream is = process.getInputStream();
	    BufferedReader br = new BufferedReader(new InputStreamReader(is, Charset.defaultCharset()));
	    int numVars = Integer.parseInt(br.readLine());
	    System.out.println("number of observable output: " + numVars);
	    for(int i=0;i<numVars;i++){
	    	String line = br.readLine();
	    	System.out.println(line);
	    	String[] varValue = line.split(":");
	    	result.put(varValue[0], Long.valueOf(varValue[1]));
	    }
		return result;
	}
	
	
	private void initiateHighInput(File highInputFile, BadMethod badMethod) throws IOException{
		List<String> highVars = badMethod.getIFBarrier().getSource();		
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(highInputFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "";
		//create high inputs
		highInputContent += highVars.size() + "\n";
		Z3Solver z3 = new Z3Solver(badMethod.getPrecondition(), badMethod.getMethod().getServices());		
		List<ModelVariable> resultL = z3.solveFormula2GetListModelVariable();
		KTGModel model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		if(resultL!=null){
			Map<String,Long> mapHighInput = new HashMap<String, Long>();
			VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();			
			//extract the value of high inputs
			for(ModelVariable mv: resultL){
				if(vc.isHigh(mv)){
					mapHighInput.put(model.getVariable(mv.getIdentifier()).getIdentifier(), (long)mv.getValue());
				}				
			}
			for(String highVar : mapHighInput.keySet()){
				highInputContent += highVar + " : 0\n" ; //default value is 0
			}			
		}
		
		writer.write(highInputContent);
		writer.close();
	}
	
	/*
	 * simply create random integer numbers
	 * */
	private void createRandomHighInput(File highInputFile, BadMethod badMethod) throws IOException{
		List<String> highVars = badMethod.getIFBarrier().getSource();		
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(highInputFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "";
		//create high inputs
		highInputContent += highVars.size() + "\n";	
		Map<String,Long> mapHighInput = new HashMap<String, Long>();		
		for(String varName: highVars){			
			long randValue = ThreadLocalRandom.current().nextLong(-2147483648,2147483647);
			mapHighInput.put(varName, randValue);							
		}
		for(String highVar : mapHighInput.keySet()){
			highInputContent += highVar + " : "+mapHighInput.get(highVar)+"\n" ; //default value is 0
		}			
		
		writer.write(highInputContent);
		writer.close();
	}
	
	/*
	 * simply create random integer numbers
	 * */
	private void createRandomHighInputObj(File highInputFile, BadMethod badMethod) throws IOException{
		//List<String> highVars = badMethod.getIFBarrier().getSource();		
		List<ModelVariable> listHighVars = badMethod.getListHighVars();
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(highInputFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "";
		//create high inputs
		highInputContent += listHighVars.size() + "\n";	
		Map<String,String> mapHighInput = new HashMap<String, String>();		
		for(ModelVariable var: listHighVars){
			if(var.isPrimitive()){//TODO: how about boolean?
				long randValue = ThreadLocalRandom.current().nextLong(-2147483648,2147483647);
				mapHighInput.put(var.getIdentifier(), String.valueOf(randValue));	
			}else if(!(var instanceof ModelArrayVariable)){
				ModelInstance instance = (ModelInstance)var.getValue();
				List<ModelVariable> fields = instance.getFields();
				for(ModelVariable field: fields)					
					mapHighInput.put(field.getIdentifier(),field.getVariableName());
			}	
		}
		for(String highVar : mapHighInput.keySet()){
			highInputContent += highVar + " : "+mapHighInput.get(highVar)+"\n" ; //default value is 0
		}			
		
		writer.write(highInputContent);
		writer.close();
	}
	
	
	/*
	 * simply create random integer numbers
	 * */
	private Map<String, String> createRandomHighInputObj(File highInputFile, BadMethod badMethod, Pair<Long,Long> boundary) throws IOException{
		//List<String> highVars = badMethod.getIFBarrier().getSource();		
		List<ModelVariable> listHighVars = badMethod.getListHighVars();
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(highInputFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "";
		//create high inputs
		highInputContent += listHighVars.size() + "\n";	
		Map<String,String> mapHighInput = new HashMap<String, String>();		
		for(ModelVariable var: listHighVars){
			if(var.isPrimitive()){//TODO: how about boolean?
				long randValue = ThreadLocalRandom.current().nextLong(boundary.first,boundary.second);
				mapHighInput.put(var.getIdentifier(), String.valueOf(randValue));	
			}else if(!(var instanceof ModelArrayVariable)){
				ModelInstance instance = (ModelInstance)var.getValue();
				List<ModelVariable> fields = instance.getFields();
				for(ModelVariable field: fields)					
					mapHighInput.put(field.getIdentifier(),field.getVariableName());
			}	
		}
		for(String highVar : mapHighInput.keySet()){
			highInputContent += highVar + " : "+mapHighInput.get(highVar)+"\n" ; //default value is 0
		}			
		
		writer.write(highInputContent);
		writer.close();
		return mapHighInput;
	}
	
	
	private void writeLowInput(File lowInputFile, Map<String, Long> mapValues) throws IOException{		
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(lowInputFile.getPath()), StandardCharsets.UTF_8);
		String lowInputContent ="";
		//create high inputs
		lowInputContent = mapValues.size() + "\n";
		for(String lowVar : mapValues.keySet()){
			lowInputContent += lowVar + " : " + mapValues.get(lowVar) +"\n"; //default value is 0
		}
		writer.write(lowInputContent);
		writer.close();
	}
	
		
	private void createUniformHighInputDistribution(File distributionFile) throws IOException{
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(distributionFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "true : 1"; //default is uniform distribution
		writer.write(highInputContent);
		writer.close();
	}
	
	/*
	 * carry out experiment simulation
	 * */
	private void experimentSimulation(int methodIdx) throws ProofInputException, IOException, KEGTermException, InterruptedException, ParserConfigurationException, TransformerException{
		BadMethod badMethod = listBadMethods.get(methodIdx-1);	
		badMethod.extractMapFreshOutVar();	
		badMethod.extractListQuantifiedHighVar();		
		badMethod.resolveRiskyPaths();
		badMethod.resolvePrecondition();
		
		

		
		//first: exploit program is created and compiled
		SIFactory sif = new SIFactory(javaFile,badMethod , javaClass);
		File hackFile = sif.createHackingProgram();		
		String hackClassName = sif.createHackingClassName();
		
		//second: create distribution input file
		File distributionFile = sif.createDistributionFile();
		createUniformHighInputDistribution(distributionFile);		
		File hackFolder = sif.createHackFolder();
		File highInputFile= sif.makeHighInputFile();
	
		Scanner keyboard = new Scanner(System.in);
		String input="";
		System.out.println("Default distribution of high input data (UNIFORM DISTRIBUTION) has been created at: " + distributionFile.getAbsolutePath());
		while(true){
			System.out.println("Are you ready to continue? Yes: press Y; No: press N; Quit: press Q");
			input = keyboard.nextLine();
			if(input.equalsIgnoreCase("Y")||input.equalsIgnoreCase("Q"))
				break;			
		}
		
		//third: parse distribution input file
		String distributionString = FileUtils.readFileToString(distributionFile);
		//System.out.println("distributionString:: " + distributionString);
		DistributionTransformer distTransformer = new DistributionTransformer(distributionString, javaClass.getEnvironment().getServices());
		SecretDistribution sDistribution = distTransformer.translate2Distribution();
		sDistribution.printInfo();
		
		while(true){
			/*Element experimentNode = doc.createElement("EXPERIMENT");
			rootElement.appendChild(experimentNode);*/
			
			/*export experimental result as XML file*/
			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
		    DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
		    Document doc = docBuilder.newDocument();
		    Element rootElement = doc.createElement("EXPERIMENTAL_RESULT");
		    doc.appendChild(rootElement);
			
			Pair<Long,Long> boundary = inputBoudaryOfHighInput(keyboard);
			
			String optSolver = KEGConstant.OPTSOLVER_ALL; //use all optimization solver
		
			int numOfHighInput= inputNuberOfHighInput(keyboard);
			int numOfExprs = inputMaxNumberOfExperiments(keyboard);			
			int metric = inputLeakageMetric(keyboard);

			Element boundHI = doc.createElement("BOUNDARY_HIGH_INPUT");
			boundHI.appendChild(doc.createTextNode(boundary.toString()));			
			rootElement.appendChild(boundHI);
		    
		    Element numHighInput = doc.createElement("NUM_HIGH_INPUT");
		    numHighInput.appendChild(doc.createTextNode(String.valueOf(numOfHighInput)));			
		    rootElement.appendChild(numHighInput);
		    Element numMaxExprs = doc.createElement("NUM_MAX_EXPERIMENTS");
		    numMaxExprs.appendChild(doc.createTextNode(String.valueOf(numOfExprs)));			
		    rootElement.appendChild(numMaxExprs);
		    Element metricName = doc.createElement("METRIC");
		    metricName.appendChild(doc.createTextNode(createMetricName(metric)));			
		    rootElement.appendChild(metricName);
		    
		   /* Element attack = doc.createElement("ATTACK");
		    experimentNode.appendChild(attack);*/
		    
			for(int j=0; j<numOfHighInput; j++){
				Element benchmark = doc.createElement("BENCHMARK");
				rootElement.appendChild(benchmark);
				
				Map<String,String> mapHighInput = createRandomHighInputObj(highInputFile, badMethod, boundary);
				System.out.println("high input: " + mapHighInput);
				Element highValue = doc.createElement("HIGH_INPUT");
				highValue.appendChild(doc.createTextNode(mapHighInput.toString()));
				benchmark.appendChild(highValue);
				 
				/*
				 * here we must check the type of program to apply suitable strategy
				 * */				
				badMethod.resetPaths();
				File lowInputFile = sif.makeLowInputFile();									
				SISupporter sis = new SISupporter(badMethod,metric,false,optSolver, sDistribution); //do not use random generator for low input
								
				
				//int numOfExprs = KEGConstant.NUM_EXPERIMENTS; 
				int i=0;

				BigInteger possibleNumberOfHigh=BigInteger.valueOf(Long.MAX_VALUE);
				long startAttack = System.nanoTime();
				
				while(i<numOfExprs){
					if(sis.matchLowIndependentPath()){
						break;
					}else{
						sis.reDetermineLowInputGenStrategy(); //maybe all high-depend-only paths have been matched already
						//logWriter.write("current LowInputGenStrategy:" + sis.getLowInputGenStrategy().getClass().getName()+ "\n");
						Map<String, Long> lowInputs = sis.findBestLowInput();
						if(lowInputs!=null){
							
							System.out.println("low input at step " + i + " : " + lowInputs);		
							writeLowInput(lowInputFile, lowInputs);
							
							Map<String,Long> observedOuputs = runNObserveLowOutput(hackFolder, hackClassName);
							
							//Experiment experiment = new Experiment(lowInputs, sis.replaceByIndentifierOfVarInModel(observedOuputs));
							Experiment experiment = new Experiment(lowInputs, observedOuputs);
							//experiment.printInfo();
							sis.updateKnowledge(experiment,i);				
							
							
							possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());
							System.out.println("number of possible high values: " + possibleNumberOfHigh);
							if(possibleNumberOfHigh.longValue()==1){
								break;
							}
							i++;
						}
					}
				}	
				
				long finishAttack = System.nanoTime();
				double attackTime =  (double)(finishAttack-startAttack)/1000000000;
				Element time = doc.createElement("TIME_SECONDS");
				time.appendChild(doc.createTextNode(String.valueOf(attackTime)));
				benchmark.appendChild(time);
				Element numExprs = doc.createElement("NUM_EXPERIMENTS");
				numExprs.appendChild(doc.createTextNode(String.valueOf(i)));
				benchmark.appendChild(numExprs);
				
				if(possibleNumberOfHigh.longValue()==1){
					
					Element unknownBits = doc.createElement("UNKNOWN_BITS");
					unknownBits.appendChild(doc.createTextNode("0"));
					benchmark.appendChild(unknownBits);
				}else{
					
					Element unknownBits = doc.createElement("UNKNOWN_BITS");
					unknownBits.appendChild(doc.createTextNode(String.valueOf(
							Math.log(possibleNumberOfHigh.doubleValue())/Math.log(2)
							)));
					benchmark.appendChild(unknownBits);
					
				}
				
				
							
			}
			
			/*save experimental results*/
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
		    Transformer transformer = transformerFactory.newTransformer();
		    DOMSource source = new DOMSource(doc);
		    StreamResult result = new StreamResult(createXMLFile(methodIdx));
		    transformer.transform(source, result);
		    System.out.println("File saved!");
			
			System.out.println("\n Would you like to try another experiment? (Y/N)?");
			input = keyboard.nextLine();
			if(input.equalsIgnoreCase("N")||input.equalsIgnoreCase("Q")){
				keyboard.close();
				break;	
				
			}
		}
		
		
		
	}
	
	private Pair<Long,Long> inputBoudaryOfHighInput(Scanner keyboard){
		long lower, upper;
		//Scanner keyboard = new Scanner(System.in);
		while(true){
			System.out.println("Choose the range [lower, upper] for high input value:");
			
			while(true){
				try{
					System.out.println("Lower bound:" );
					lower = Long.parseLong(keyboard.nextLine());
					break;
				}catch(Exception e)//NumberFormatException
				{
					continue;
				}
			}
			while(true){
				try{
					System.out.println("Upper bound:" );
					upper = Long.parseLong(keyboard.nextLine());
					break;
				}catch(Exception e)//NumberFormatException
				{
					continue;
				}
			}
			if(lower <upper){
				break;
			}
		}
		//keyboard.close();
		return new Pair<Long, Long>(lower, upper);
	}
	
	private int inputNuberOfHighInput(Scanner keyboard){
		//Scanner keyboard = new Scanner(System.in);
		int numOfHighInput=0;
		while(true){
			System.out.println("How many high input values need to be taken?");
			String input = keyboard.nextLine();
			try{
				numOfHighInput=Integer.parseInt(input);
				if(numOfHighInput<0){
					System.out.println("number of high input values must be greater than zero!");
				}else{
					
					break;
				}
			}catch(Exception exc){
				System.out.println("wrong number format!");
				continue;
			}
		}
		//keyboard.close();
		return numOfHighInput;
	}
	
	private int inputMaxNumberOfExperiments(Scanner keyboard){
		int numOfExprs=32; // default number
		//Scanner keyboard = new Scanner(System.in);
		while(true){
			System.out.println("Input the maximum number of experiments:");
			
			try{
				numOfExprs = Integer.parseInt(keyboard.nextLine());
			}catch(NumberFormatException exception){
				continue;
			}
			if(numOfExprs > 0)
				break;
			else
				System.out.println("maximum number of experiments must be greater than 0!");
		}
		//keyboard.close();
		return numOfExprs;
	}
	
	private int inputLeakageMetric(Scanner keyboard){
		int metric=KEGConstant.SHANNON_ENTROPY;
		System.out.println("What metric would you like to use? Min-entropy-based(M/m)? Guessing-entropy-based(G/g)? Shannon-entropy-based(otherwise)?");
		//Scanner keyboard = new Scanner(System.in);
		String input = keyboard.nextLine();				
		if(input.equalsIgnoreCase("m")){
			metric = KEGConstant.MIN_ENTROPY;
		}
		else if(input.equalsIgnoreCase("g")){
			metric = KEGConstant.GUESSING_ENTROPY;
		}
		//keyboard.close();
		return metric;
	}
	
	
	
	private String createMetricName(int metric){
		if(metric==KEGConstant.GUESSING_ENTROPY)
			return "GUESSING_ENTROPY";
		else if(metric==KEGConstant.MIN_ENTROPY)
			return "MIN_ENTROPY";
		else
			return "SHANNON_ENTROPY";
	}
	
	private File createXMLFile(int methodIdx){
		Path currentFolder = Paths.get("");
		String path = currentFolder.toAbsolutePath() + File.separator +"nu_experiments";
		
		File folder=new File(path);
	      if(!folder.exists())
	         folder.mkdir();
	      
	      
		String fileName = javaClass.getName()+ KEGConstant.SEPARATOR + listBadMethods.get(methodIdx-1).getMethod().getName();
		File xmlFile;
		while(true){
	         xmlFile=new File(folder, fileName+".xml");
	         if(xmlFile.exists() && !xmlFile.isDirectory()){
	            fileName = fileName+"1";
	            xmlFile=new File(folder,fileName+".xml");                 
	         }else
	            break;
	      }
		return xmlFile;
				
	}
}
