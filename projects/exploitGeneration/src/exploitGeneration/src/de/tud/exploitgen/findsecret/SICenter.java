package de.tud.exploitgen.findsecret;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;
import java.math.BigInteger;

import org.apache.commons.io.FileUtils;

import sun.font.CreatedFontTracker;

import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.distribution.DistributionTransformer;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4LowIndependent;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskConst;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskH;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskL;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskLH;
import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.uka.ilkd.key.proof.init.ProofInputException;


public class SICenter {
	private KeYJavaClass javaClass;
	private File javaFile;
	private List<BadMethod> listBadMethods;
	public SICenter(KeYJavaClass javaClass, File javaFile,
			List<BadMethod> listBadMethods) {
		super();
		this.javaClass = javaClass;
		this.javaFile = javaFile;
		this.listBadMethods = listBadMethods;
	}
	
	/*
	 * user interface
	 * */
	public void userInteraction() throws ProofInputException, IOException, InterruptedException{
		System.out.println("There are several vulnarable methods of class " + javaClass.getName() + ":");		
		for(int i=0;i<listBadMethods.size();i++)
			System.out.println((i+1) + ": " + listBadMethods.get(i).getMethod().getName());		
		Scanner keyboard = new Scanner(System.in);
		String input;
		int methodIdx=-1;
    	while(true){
    		System.out.println("Press corresponding index number to exploit the method! Press Q/q to halt");
    		input = keyboard.nextLine();
    		try{
    			methodIdx = Integer.parseInt(input);
    		}catch(NumberFormatException e){
    			if(input.equalsIgnoreCase("q")){
    				methodIdx=-1;
    				break;
    			}
    		}
    		if(methodIdx>0 && methodIdx<=listBadMethods.size())
    			break;
    	}
    	if(methodIdx>0 && methodIdx<=listBadMethods.size()){
    		secretInferSimulation(methodIdx);		
    	}  	    	
	}
	
	/*
	 * simulate hacking process
	 * first: exploit program is created and compiled
	 * second: create input data (both low and high)
	 * third: run exploit program several times and use SecretInferSupporter to create low inputs for the next experiment
	 * finally: halt after specific iterations and print out the information of high values
	 * */
	private void secretInferSimulation(int methodIdx) throws ProofInputException, IOException, InterruptedException{
		BadMethod badMethod = listBadMethods.get(methodIdx-1);	
		
		
		badMethod.extractMapFreshOutVar();	
		badMethod.extractListQuantifiedHighVar();
		badMethod.resolveRiskyPaths();
		badMethod.resolvePrecondition();
		System.out.println("precondition:: "+ badMethod.getPrecondition());
		System.out.println(badMethod.getStringRiskyPaths()); //check path condition
		
		//first: exploit program is created and compiled
		SIFactory sif = new SIFactory(javaFile,badMethod , javaClass);
		File hackFile = sif.createHackingProgram();		
		String hackClassName = sif.createHackingClassName();
		
		//second: create high input data 
		
		
		File hackFolder = sif.createHackFolder();
		File highInputFile= sif.makeHighInputFile();
		File distributionFile = sif.createDistributionFile();
		//initiateHighInput(highInputFile, badMethod);
		Scanner keyboard = new Scanner(System.in);
		String input="";
		while(true){
			createRandomHighInputObj(highInputFile, badMethod);
			createHighInputDistribution(distributionFile);
			System.out.println("High input data has been created randomly at: " + highInputFile.getAbsolutePath());
			System.out.println("Default distribution of high input data (UNIFORM DISTRIBUTION) has been created at: " + distributionFile.getAbsolutePath());
			System.out.println("You can change high values and its distribution before continue!");
			while(true){
				System.out.println("Are you ready to continue? Yes: press Y; No: press N; Quit: press Q");
				input = keyboard.nextLine();
				if(input.equalsIgnoreCase("Y")||input.equalsIgnoreCase("Q"))
					break;			
			}
			
			if(input.equalsIgnoreCase("Y")){
				/* get secret distribution*/
				 BufferedReader br = new BufferedReader(new FileReader(distributionFile));
				String distributionString = FileUtils.readFileToString(distributionFile);
				System.out.println("distributionString:: " + distributionString);
				DistributionTransformer distTransformer = new DistributionTransformer(distributionString, javaClass.getEnvironment().getServices());
				SecretDistribution sDistribution = distTransformer.translate2Distribution();
				sDistribution.printInfo();
				int numOfExprs=32; // default number
				while(true){
					System.out.println("Input the maximum number of experiments:");
					input = keyboard.nextLine();
					try{
						numOfExprs = Integer.parseInt(input);
					}catch(NumberFormatException e){
						continue;
					}
					if(numOfExprs > 0)
						break;
					else
						System.out.println("maximum number of experiments must be greater than 0!");
				}
				/*  create log file*/
				File logFile = sif.createLogFile();
				BufferedWriter logWriter = Files.newBufferedWriter(Paths.get(logFile.getPath()), StandardCharsets.UTF_8);
				logWriter.write("file name: " + javaFile.getName() + "; method : " + badMethod.getMethod().getName() + "\n");				
				/*
				 * here we must check the type of program to apply suitable strategy
				 * */				
				badMethod.resetPaths();
				File lowInputFile = sif.makeLowInputFile();				
				boolean randomLowInput = false;
				System.out.println("How to create low input? randomly (R/r)? or knowledge-guided optimized(O/o)?");
				input = keyboard.nextLine();
				if(input.equalsIgnoreCase("r")){
					logWriter.write("Randomly generating low input\n");
					randomLowInput = true;
				}
				int metric=KEGConstant.SHANNON_ENTROPY;
				String optSolver = KEGConstant.OPTSOLVER_ALL;
				if(!randomLowInput){
					logWriter.write("Choosing low input optimizing leakage\n");
					System.out.println("What metric would you like to use? Min-entropy-based(M/m)? Guessing-entropy-based(G/g)? Shannon-entropy-based(otherwise)?");				
					input = keyboard.nextLine();				
					if(input.equalsIgnoreCase("m")){
						metric = KEGConstant.MIN_ENTROPY;
						logWriter.write("Leakage metric: Min-entropy-based \n");
					}
					else if(input.equalsIgnoreCase("g")){
						metric = KEGConstant.GUESSING_ENTROPY;
						logWriter.write("Leakage metric: Guessing-entropy-based \n");
					}else
						logWriter.write("Leakage metric: Shannon-entropy-based \n");
					System.out.println("Choose optimization tool: couenne (C/c)? bonmin (B/b)? LocalSolver(L/l)? or combination of all solvers? (A/a)?");
					input = keyboard.nextLine();				
					if(input.equalsIgnoreCase("c")){
						optSolver = KEGConstant.OPTSOLVER_COUENNE;												
					}else if(input.equalsIgnoreCase("l"))
						optSolver = KEGConstant.OPTSOLVER_LOCALSOLVER;
					else if(input.equalsIgnoreCase("b"))
						optSolver = KEGConstant.OPTSOLVER_BONMIN;
					else 
					logWriter.write("Optimization solver: " + optSolver +  "\n");					
						
				}				
				SISupporter sis = new SISupporter(badMethod,metric,randomLowInput,optSolver, sDistribution); 
				System.out.println("low input generating strategy: " + sis.getLowInputGenStrategy().getClass().getName());
				//third: create low inputs using SecretInferSupporter and run exploit program several times
				System.out.println("initial knowledge of high variables: " + sis.getCurrentKnowledge());
				BigInteger numOfHighVars = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());
				logWriter.write("number of possible high values by initial knowledge: " + numOfHighVars + "\n");
				System.out.println("number of possible high values by initial knowledge: " + numOfHighVars);
				
				if(sis.getLowInputGenStrategy() instanceof LowInputGenStrategy4LowIndependent){
					System.out.println("because all risky paths are low-independent, we need one and only one experiment with arbitrary low input values to infer high values");
					logWriter.write("because all risky paths are low-independent, we need one and only one experiment with arbitrary low input values to infer high values\n");
					Map<String, Long> lowInputs = sis.findBestLowInput();		
			
					//writeLowInput(lowInputFile, badMethod, sis.replaceByOriginalNameOfVars(lowInputs));	
					writeLowInput(lowInputFile, lowInputs);
					
					Map<String,Long> observedOuputs = runNObserveLowOutput(hackFolder, hackClassName);
					System.out.println("observedOuputs: " + observedOuputs);
					//Experiment experiment = new Experiment(lowInputs, sis.replaceByIndentifierOfVarInModel(observedOuputs));
					Experiment experiment = new Experiment(lowInputs, observedOuputs);
					experiment.printInfo();
					sis.updateKnowledge(experiment,0);				
					System.out.println("maximum knowledge can be achieved: " + sis.getCurrentKnowledge());					
					BigInteger possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());				
					
					//finally, print out the information of high variable			
					if(possibleNumberOfHigh.equals(BigInteger.ONE)){
						Z3Solver z3= new Z3Solver(sis.getCurrentKnowledge(),javaClass.getEnvironment().getServices());
						Map<String,Long> mapHighValues = z3.solveFormula2GetMapValues();
						System.out.println("High value: " + mapHighValues);
						logWriter.write("High value: " + mapHighValues+ "\n");
					}else{
						System.out.println("number of possible high values after 1 experiment: "+ possibleNumberOfHigh);
						logWriter.write("number of possible high values after 1 experiment: "+ "\n");
					}					
				}else{
					//int numOfExprs = KEGConstant.NUM_EXPERIMENTS; 
					int i=0;
					sis.printInitialInformation();
					BigInteger possibleNumberOfHigh=BigInteger.valueOf(Long.MAX_VALUE);
					long startAttack = System.nanoTime();
					logWriter.write("===================================================\n");
					while(i<numOfExprs){
						if(sis.matchLowIndependentPath()){
							System.out.println("BINGO! A low-independent path has been matched!!! Now we cannot do anything more!");
							logWriter.write("BINGO! A low-independent path has been matched!!! Now we cannot do anything more!\n");
							break;
						}else{
							sis.reDetermineLowInputGenStrategy(); //maybe all high-depend-only paths have been matched already
							System.out.println("current LowInputGenStrategy:" + sis.getLowInputGenStrategy().getClass().getName());
							//logWriter.write("current LowInputGenStrategy:" + sis.getLowInputGenStrategy().getClass().getName()+ "\n");
							Map<String, Long> lowInputs = sis.findBestLowInput();
							if(lowInputs!=null){
								System.out.println("low input at step "+ i + ": " + lowInputs.toString());
								logWriter.write("low input at step "+ i + ": " + lowInputs.toString()+"\n");
								//writeLowInput(lowInputFile, badMethod, sis.replaceByOriginalNameOfVars(lowInputs));		
								writeLowInput(lowInputFile, lowInputs);
								
								Map<String,Long> observedOuputs = runNObserveLowOutput(hackFolder, hackClassName);
								
								//Experiment experiment = new Experiment(lowInputs, sis.replaceByIndentifierOfVarInModel(observedOuputs));
								Experiment experiment = new Experiment(lowInputs, observedOuputs);
								//experiment.printInfo();
								sis.updateKnowledge(experiment,i);				
								
								i++;
								possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());				
								System.out.println("possible number of high values after " + i + " experiments: \n"+ possibleNumberOfHigh);
								logWriter.write("possible number of high values after " + i + " experiments: "+ possibleNumberOfHigh + "\n");
								if(possibleNumberOfHigh.longValue()==1){
									System.out.println("hey, there is only one left!");
									break;
								}
							}else{
								System.out.println("Cannot generate useful low input values! It seems that we are not able to infer more about secret");
								logWriter.write("Cannot generate useful input values! It seems that we are not able to infer more about secret\n");
								break;
							}
						}
					}	
					logWriter.write("===================================================\n");
					//finally, print out the information of high variable			
					if(possibleNumberOfHigh.longValue()==1){
						Z3Solver z3= new Z3Solver(sis.getCurrentKnowledge(),javaClass.getEnvironment().getServices());
						Map<String,Long> mapHighValues = z3.solveFormula2GetMapValues();
						System.out.println("High value: " + mapHighValues);
						logWriter.write("High value: " + mapHighValues +"\n");
					}else{
						System.out.println("attacker knowledge about high values: " + sis.getCurrentKnowledge());
						logWriter.write("attacker knowledge about high values: " + sis.getCurrentKnowledge()+"\n");
						possibleNumberOfHigh = sis.findNumberOfPossibleHighValue(sis.getCurrentKnowledge());				
						System.out.println("possible number of high values after " + i + " experiments: \n"+ possibleNumberOfHigh);
						logWriter.write("possible number of high values after " + i + " experiments: "+ possibleNumberOfHigh+"\n");
						
						if(possibleNumberOfHigh.longValue()<10){ //<10
							Z3Solver z3= new Z3Solver(sis.getCurrentKnowledge(),javaClass.getEnvironment().getServices());
							System.out.println("Possible values of high variables: " );
							logWriter.write("Possible values of high variables: \n");
							List<Map<String,Long>> listPossibleValues = z3.findAllSatisfiableModels();
							System.out.println(listPossibleValues);
							logWriter.write(listPossibleValues+"\n");
						}
						
					}
					long finishAttack = System.nanoTime();
					double attackTime =  (double)(finishAttack-startAttack)/1000000000;
					System.out.println("ATTACK TIME: " + attackTime + " seconds");
					logWriter.write("ATTACK TIME: " + attackTime + " seconds"+"\n");
					logWriter.close();
				}
			}
			
			System.out.println("\n Would you like to try with another value of high variables? (Y/N)?");
			input = keyboard.nextLine();
			if(input.equalsIgnoreCase("N")||input.equalsIgnoreCase("Q"))
				break;			
		}
		
		
	}
	
	
	private Map<String, Long> runNObserveLowOutput(File hackFolder, String hackClassName) throws IOException, InterruptedException{
		Map<String, Long> result = new HashMap<String, Long>();
		List<String> command = new ArrayList<String>();
		
		command.add("java");
		command.add(hackFolder.getName()+"."+ hackClassName);
		   
	    
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.directory(hackFolder.getParentFile());
	    //Map<String, String> environ = builder.environment();		    		    
	    final Process process = builder.start();	    	    
	    InputStream is = process.getInputStream();
	    BufferedReader br = new BufferedReader(new InputStreamReader(is, Charset.defaultCharset()));
	    int numVars = Integer.parseInt(br.readLine());
	    System.out.println("number of observable output: " + numVars);
	    for(int i=0;i<numVars;i++){
	    	String line = br.readLine();
	    	System.out.println(line);
	    	String[] varValue = line.split(":");
	    	result.put(varValue[0], Long.valueOf(varValue[1]));
	    }
		return result;
	}
	
	
	private void initiateHighInput(File highInputFile, BadMethod badMethod) throws IOException{
		List<String> highVars = badMethod.getIFBarrier().getSource();		
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(highInputFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "";
		//create high inputs
		highInputContent += highVars.size() + "\n";
		Z3Solver z3 = new Z3Solver(badMethod.getPrecondition(), badMethod.getMethod().getServices());		
		List<ModelVariable> resultL = z3.solveFormula2GetListModelVariable();
		KTGModel model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		if(resultL!=null){
			Map<String,Long> mapHighInput = new HashMap<String, Long>();
			VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();			
			//extract the value of high inputs
			for(ModelVariable mv: resultL){
				if(vc.isHigh(mv)){
					mapHighInput.put(model.getVariable(mv.getIdentifier()).getVariableName(), (long)mv.getValue());
				}				
			}
			for(String highVar : mapHighInput.keySet()){
				highInputContent += highVar + " : 0\n" ; //default value is 0
			}			
		}
		
		writer.write(highInputContent);
		writer.close();
	}
	
	/*
	 * simply create random integer numbers
	 * */
	private void createRandomHighInput(File highInputFile, BadMethod badMethod) throws IOException{
		List<String> highVars = badMethod.getIFBarrier().getSource();		
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(highInputFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "";
		//create high inputs
		highInputContent += highVars.size() + "\n";	
		Map<String,Long> mapHighInput = new HashMap<String, Long>();		
		for(String varName: highVars){			
			long randValue = ThreadLocalRandom.current().nextLong(-2147483648,2147483647);
			mapHighInput.put(varName, randValue);							
		}
		for(String highVar : mapHighInput.keySet()){
			highInputContent += highVar + " : "+mapHighInput.get(highVar)+"\n" ; //default value is 0
		}			
		
		writer.write(highInputContent);
		writer.close();
	}
	
	/*
	 * simply create random integer numbers
	 * */
	private void createRandomHighInputObj(File highInputFile, BadMethod badMethod) throws IOException{
		//List<String> highVars = badMethod.getIFBarrier().getSource();		
		List<ModelVariable> listHighVars = badMethod.getListHighVars();
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(highInputFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "";
		//create high inputs
		highInputContent += listHighVars.size() + "\n";	
		Map<String,String> mapHighInput = new HashMap<String, String>();		
		for(ModelVariable var: listHighVars){
			if(var.isPrimitive()){//TODO: how about boolean?
				long randValue = ThreadLocalRandom.current().nextLong(-2147483648,2147483647);
				mapHighInput.put(var.getIdentifier(), String.valueOf(randValue));	
			}else if(!(var instanceof ModelArrayVariable)){
				ModelInstance instance = (ModelInstance)var.getValue();
				List<ModelVariable> fields = instance.getFields();
				for(ModelVariable field: fields)					
					mapHighInput.put(field.getIdentifier(),field.getVariableName());
			}	
		}
		for(String highVar : mapHighInput.keySet()){
			highInputContent += highVar + " : "+mapHighInput.get(highVar)+"\n" ; //default value is 0
		}			
		
		writer.write(highInputContent);
		writer.close();
	}
	
	
	
	
	private void writeLowInput(File lowInputFile, Map<String, Long> mapValues) throws IOException{		
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(lowInputFile.getPath()), StandardCharsets.UTF_8);
		String lowInputContent ="";
		//create high inputs
		lowInputContent = mapValues.size() + "\n";
		for(String lowVar : mapValues.keySet()){
			lowInputContent += lowVar + " : " + mapValues.get(lowVar) +"\n"; //default value is 0
		}
		writer.write(lowInputContent);
		writer.close();
	}
	
		
	private void createHighInputDistribution(File distributionFile) throws IOException{
		BufferedWriter writer = Files.newBufferedWriter(Paths.get(distributionFile.getPath()), StandardCharsets.UTF_8);
		String highInputContent = "true : 1"; //default is uniform distribution
		
		
		writer.write(highInputContent);
		writer.close();
	}
	
}
