/**
 * 
 */
package de.tud.exploitgen.processing.node;

import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.ModelBuilderVisitor;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstanceFactory;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariableFactory;

import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionConstraint;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * supply methods investigating node to get information of:
 *    - node contract
 *    - model variables (used in checking noninterference and building exploit model)
 *    - artificial variable (just used in checking noninterference)
 * @author Huy Do
 *
 */
public class NodeInvestigator {   
   
   private final Services services;
   private final TermBuilder termBuilder;
   private final HeapHandler heapHandler;
   private final Term tt = new TermFactory().createTerm(Junctor.TRUE);
   
   private Model model; //contains all of ModelVariable and relations between them
   private List<Term> artificialVars; //contains  artificial variable detected while investigate node
   
   private String HEAP_NAME=""; //contain HEAP_NAME (mostly it is self)
   private Stack<String> sHeapName; //contains name of object in heap, served for creating name of heap variables during recursively investigating heap
   
  
   /**
    * @param services
    */
   public NodeInvestigator(Services services) {      
      super();
      this.services = services;
      heapHandler = new HeapHandler(services);
      termBuilder=new TermBuilder(new TermFactory(), services);
      model = Model.constructModel();
      sHeapName=new Stack<String>();
      artificialVars = new LinkedList<Term>();
   }

   
   public Term getUsefulConstraint(final IExecutionNode<?> node){
      IExecutionConstraint[] constraints = node.getConstraints();  
      Term result = tt;
      for(IExecutionConstraint ec: constraints){ 
         Term t = ec.getTerm();
         if(KeYResourceHandler.isUsefulConstraint(t)){ 
            //System.out.println(t);
            t = KeYResourceHandler.removeUnnecessaryTerm(t);
            t = heapHandler.replaceSelectFunctionByItsField(t);
            t = heapHandler.replaceLengthFunctionByVar(t);                                 
            result = termBuilder.and(result,t);                
         }            
      }
      return result;      
   }
   
   public void constructModel(final IExecutionNode<?> node) throws ProofInputException{
      /*
       * Create the initial Model, without any concrete values assigned to
       * primitive integer values in it.
       */
            
       //investigate heap to add all fields, static variables and method parameters into model
       
       IExecutionVariable[] vars = node.getVariables(); 
       
       for(IExecutionVariable var: vars){
          //System.out.println("variables: " + var.getName());          
          if(HeapHandler.isSelf(var)){             
             HEAP_NAME=var.getName();   
             addSelfToModel(var);                                           
             investigateProgramVariable(var);
             
          }else if(HeapHandler.isStatic(var) || HeapHandler.isParameter(var)){ //solve static variables and method's parameters
             investigateProgramVariable(var);     
          }
          /*else if(!HeapHandler.isExc(var)){             
             for(IExecutionValue iev: var.getValues()){
                Term value = iev.getValue();
                value = KeYResourceHandler.removeUnnecessaryTerm(value);
                value = heapHandler.replaceSelectFunctionByItsField(value);
                value = heapHandler.replaceLengthFunctionByVar(value);
                investigateArtificialVars(value);
             }
          }*/          
       }       
       
       //manipulate exploit model to indicate the container for static variables
       maniputlateModel2SolveStaticVar();
       
       List<Term> listValue = new LinkedList<Term>();
       for(ModelVariable mv: model.getVariables()){          
          Term sv = mv.getSymbolicValue();
          //System.out.println("value: ---> " + sv + " : " + HeapHandler.isLengthFunction(sv));
          
          listValue.add(sv);
          mv.setSymbolicValue(refineTerm(sv));
          //System.out.println("refined value: ---> " + mv.getSymbolicValue());
       }
       
       for(Term t: listValue){
          investigateArtificialVars(t);
       }
       
       //solveModel();
       //investigate path condition to find out artificial variables
       Term pathCond = node.getPathCondition();       
       investigateArtificialVars(pathCond);
   }
   
   /**
    * called if var is heap (started by "self")
    * @throws ProofInputException 
    * */
   private void addSelfToModel(IExecutionVariable var) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
      final ModelInstance selfInstance = ModelInstanceFactory.constructModelInstance(container);      
      final ModelVariable self = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), var.getName());      
      model.add(self, selfInstance);      
   }
   
   /**
    * investigate self object to retrieve information of all fields and add it into exploit model
    * */
   private void investigateProgramVariable(IExecutionVariable var) throws ProofInputException{
      if (var.getProgramVariable() instanceof IProgramVariable){   
         
         String identifier = KeYResourceHandler.getVarName(var);
         if(!model.inModel(identifier)){
            addVarToModel(var);
         } 
         
         sHeapName.push(KeYResourceHandler.getVarName(var));
         //recursively work with child variable of this variable
         IExecutionValue[] values =var.getValues();
         
         for(IExecutionValue value:values){                  
            IExecutionVariable[] vchilds=value.getChildVariables();           
            for(IExecutionVariable vchild:vchilds){               
               investigateProgramVariable(vchild) ;               
            }
         }
         sHeapName.pop();      
      }      
   }
   
   /**
    * adds a field of the class to model, links to container object
    * */
   private void addVarToModel(IExecutionVariable var) throws ProofInputException{
      
      
      
      String identifier = KeYResourceHandler.getVarName(var);
      
      if(!HeapHandler.isParameter(var)){
         if(!sHeapName.isEmpty())
            identifier=getReferenceName()+"_"+identifier;
      }
      final ModelVariable variable;
      if(HeapHandler.isArray(var)){
         //System.out.println(var + " is array!");
         variable = new ModelArrayVariable(var.getProgramVariable(),identifier);
      }else{
         variable=new ModelVariable(var.getProgramVariable(),identifier);
      }     
      
      
      Object instance;
      if (HeapHandler.isPrimitive(var)) {
          //The term is a static variable. Identify and connect it with its parent class.
          instance = ModelBuilderVisitor.resolvePrimitiveType(var.getProgramVariable());
      } else {
          instance = ModelInstanceFactory.constructModelInstance(var.getProgramVariable().getKeYJavaType());
      }
      
      //resolve symbolic value
      IExecutionValue[] values =var.getValues();
      Term symbolicValue = values[0].getValue();
      //System.out.println("value of " + variable.getIdentifier() + " : " + symbolicValue + " ; type: " + variable.getType());
     
      
      //symbolicValue = refineTerm(symbolicValue);
      variable.setSymbolicValue(symbolicValue);

      //resolve all constraints of var, the constraints is retrieved from value
      List<Term> constraints = new LinkedList<Term>();
      for(IExecutionValue value:values){  
         for(IExecutionConstraint ec: value.getConstraints()){
            //System.out.println(ec.getTerm());
            Term constraint = ec.getTerm();
            if(KeYResourceHandler.isUsefulConstraint(constraint)){
               //System.out.println("useful constraint: " + constraint);               
               symbolicValue = KeYResourceHandler.removeUnnecessaryTerm(symbolicValue);
               constraint = heapHandler.replaceSelectFunctionByItsField(constraint);
               constraint = heapHandler.replaceLengthFunctionByVar(constraint);
               constraints.add(constraint);
               //investigateArtificialVars(constraint); //investigate all artificial variables
            }
         }        
      }
      variable.setConstraints(constraints);
      
      if(HeapHandler.isParameter(var))  //assign true flag for method's parameter
         variable.setParameter(true);
      
      if(HeapHandler.isStatic(var)){
         variable.setStatic(true);
         variable.setDeclareClassName(KeYResourceHandler.getAccessClassNameOfStaticVar(var));
      }else
         variable.setStatic(false);         
      
         
      /*
       * Add the variable and its instance to the Model. This might seem
       * premature, but must be done to preserve referential integrity and
       * avoiding extra work.
       */
      model.add(variable, instance);
      if(!sHeapName.isEmpty()){
         String referenceName = getReferenceName();
         model.assignField(variable, model.getVariable(referenceName));
      }
        
   }  
   
   /*
    * when resolving loop by using loop invariant, SED (Symbolic Execution Debugger) may create fake variables
    * to represent the value of fields, we have to detect them and add them into model
    * */
   private void investigateArtificialVars(final Term term){
      if(term!=null){       
         if(HeapHandler.isHeapSelectFunction(term) && !HeapHandler.isLoopHeap(term)){
            processSelect2GetModelVars(term);
         }else if(KeYResourceHandler.isArtificialVariable(term) ){
            //System.out.println("artificial detected!::: " + term);
            //we have to check if term has been added into model or not
            //if true, it is parameter and we do not add it into list of artificial variables
            if(!model.inModel(term.toString())){                  
               Term addTerm;                  
               if(HeapHandler.isLoopHeap(term))
                  addTerm = new HeapHandler(services).getReplacedTermForSelect(term);
               else
                  addTerm = term;
               
               if(!HeapHandler.inListTerm(addTerm, artificialVars)){
                  //System.out.println("add term: " + addTerm);
                  artificialVars.add(addTerm);
               }  
            }            
         }else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               investigateArtificialVars(st);
            }
         }         
      }      
   }
   
   
   /*
    * constructs reference name from stack, if object obj is a field of heap self, then the heap name is self_obj
    * */
   private String getReferenceName() {  
      String heapName="";
      if(sHeapName.size()>0){
         heapName=sHeapName.get(0);
         for(int i=1;i<sHeapName.size();i++){
            heapName +="_" + sHeapName.get(i);
         }
      }
      return heapName;
   }
   
   
   /*
    * basically, all static variable are listed when we look into the array of program variables, not in heap
    * however, we would like to match static variable with some specific variables that their class is the real container of it.
    * so we have to manipulate the model
    * */
   
   private void maniputlateModel2SolveStaticVar(){     
      List<ModelVariable> lMV = model.getVariables();
          
      /*
       * now we resolve lMV in the following way:
       * take all ModelVariable mv in lMV
       * if mv is static then
       * find a ModelVariable container in lMV that its type is same with the type of container class of mv
       * set mv as a field of container
       * */
      //System.out.println("+++ BEGIN static resolving");
      for(ModelVariable mv: lMV){ 
         
         if(mv.isStatic()){
          //System.out.println(mv.getIdentifier() + " : " + mv.getVariableName());
            String containerName = mv.getDeclareClassName();
            for(ModelVariable mvc: lMV){
               if(containerName.equals(mvc.getTypeName())){
                  model.assignField(mv, mvc);
                  
               }
            }
         }        
      }
      //System.out.println("+++ END static resolving");
   }
  
   
   


   /**
    * @return the model
    */
   public Model getModel() {
      return model;
   }


   /**
    * @return the artificialVars
    */
   public List<Term> getArtificialVars() {
      return artificialVars;
   }
   
   
   
   /**
    * @return the hEAP_NAME
    */
   public String getHEAP_NAME() {
      return HEAP_NAME;
   }


   /**
    * solve select function to add all of detected fields and array elements into model
    * */
   private void processSelect2GetModelVars(final Term term){      
      Stack<ModelVariable> sVar = new Stack<ModelVariable>();
      Term t = term;   
      /*
       * create location variable from select function, continue with its sub fields
       * push generated variables into stack to maintain the order
       * */
      while(HeapHandler.isHeapSelectFunction(t) && !HeapHandler.isLoopHeap(t)){
         String identifier = HeapHandler.getSynthesisNameOfHeapSelectFunction(t);
         String varName = HeapHandler.getFieldNameOfSelect(t);
               
         ProgramVariable pv = new LocationVariable(new ProgramElementName(varName), KeYResourceHandler.createType(t));         
         ModelVariable mv = new ModelVariable(pv, identifier);
         mv.setArrayIdx(KeYResourceHandler.getArrayIndex(t.sub(2)));
         sVar.push(mv);
         t = t.sub(1);
      }
      String fatherName = t.toString(); //use baseName to track the container object exists in model
      /*
       * now we have a stack containing all model variable extracted from select function
       * one element in the stack is the field of its next element
       * so we do assign element
       */
      //take the top one of stact, add it into model, find the container variable and assign field
      while(!sVar.empty()){
         ModelVariable mv = sVar.pop();
         //System.out.println("is working on:  " + mv.getIdentifier() + " :: " + mv.getSort().toString());
         if(!model.inModel(mv.getIdentifier())){            
            Object instance;
            if (TermParser.isPrimitiveType(mv.getSort().name().toString())) {               
                instance = ModelBuilderVisitor.resolvePrimitiveType(mv.getProgramVariable());
            } else {
                instance = ModelInstanceFactory.constructModelInstance(mv.getProgramVariable().getKeYJavaType());
            }
            model.add(mv, instance);
            model.assignField(mv, model.getVariable(fatherName));       
            
         }
         fatherName = mv.getIdentifier(); //save current identifier to fatherName, so next elements can find it
      }      
   }
   
   
   
   private Term refineTerm(final Term t){
      Term result = KeYResourceHandler.removeUnnecessaryTerm(t);
      result = heapHandler.replaceLengthFunctionByVar(result);
      result = heapHandler.replaceSelectFunctionByItsField(result);
      return result;
   }
   
   
}
