/**
 * 
 */
package de.tud.exploitgen.processing.node;


import java.util.LinkedList;
import java.util.List;
import java.util.Stack;


import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.ModelBuilderVisitor;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstanceFactory;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariableFactory;

import de.tud.exploitgen.util.KEGConfig;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.ModelTree;
import de.tud.exploitgen.util.ModelVariableGenerator;
import de.tud.exploitgen.util.TermParser;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.Junctor;

import de.uka.ilkd.key.proof.init.ProofInputException;



import de.uka.ilkd.key.symbolic_execution.model.IExecutionConstraint;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionUtil;

/**
 * supply methods investigating node to get information of:
 *    - node contract
 *    - model variables (used in checking noninterference and building exploit model)
 *    - artificial variable (just used in checking noninterference)
 * @author Huy Do
 *
 */
public class NodeInvestigator {   
   private final IExecutionNode<?> node;
   private final Services services;
   private final TermBuilder termBuilder;
   private final HeapHandler heapHandler;
   private final Term tt = new TermFactory().createTerm(Junctor.TRUE);
   
   //private Model model; //contains all of ModelVariable and relations between them
   private List<Term> artificialVars; //contains  artificial variable detected while investigate node
   
   private String HEAP_NAME=""; //contain HEAP_NAME (mostly it is self)
   private Stack<String> sHeapName; //contains name of object in heap, served for creating name of heap variables during recursively investigating heap
   private int depth; //depth of sub-field's sequence being investigated
   
   private List<Model> listModel; //contains list of Model created from the node
   private ModelTree selfModelTree; //store all models created during investigating heap (start from self object)
   private Term nodeConstraints; //store all node constrains created by using conjunction
   
   //private int counter; //use to count the layer of investigating relevant to sub-field sequence
   /**
    * @param services
    */
   public NodeInvestigator(IExecutionNode<?> node, int depth) {      
      super();
      this.node = node;
      this.services = node.getServices();
      heapHandler = new HeapHandler(services);
      termBuilder=new TermBuilder(new TermFactory(), services);
      //model = Model.constructModel();
      sHeapName=new Stack<String>();
      artificialVars = new LinkedList<Term>();
      this.depth = depth; //default          
      //listModel = new ArrayList<Model>();
      this.selfModelTree = new ModelTree();
   }  
   
  
   
   private Term getUsefulConstraint() {
      IExecutionConstraint[] constraints = node.getConstraints();  
      Term result = tt;
      System.out.println(" -- node constraint: -- ");
      for(IExecutionConstraint ec: constraints){ 
         Term t = ec.getTerm();   
         System.out.println(t);      
        
         if(!KeYResourceHandler.containUselessConstraint(t)){            
            /*if(TermParser.isForAllQuantifier(t)){
               SMTWorker st = new SMTWorker(services, new Configuration(false,false));
               StringBuffer sb = st.translateTerm(t, new Vector<QuantifiableVariable>(), services);
               System.out.println("forall quantifier:  " + sb.toString());               
            }*/
              
           
            //t = KeYResourceHandler.removeUnnecessaryTerm(t);
            //t = heapHandler.replaceSelectFunctionByItsField(t, KEGConfig.SEPARATOR);
            //t = heapHandler.replaceLengthFunctionByVar(t, KEGConfig.SEPARATOR);     
            //System.out.println(t);
            result = termBuilder.and(result,t);                
         }            
      }
      System.out.println("---------");
      return result;      
   }
   
   private void constructModels() throws ProofInputException{
      /*
       * Create the initial Model, without any concrete values assigned to
       * primitive integer values in it.
       */
            
       //investigate heap to add all fields, static variables and method parameters into model     
       IExecutionVariable[] vars = node.getVariables();
       
       /*recursively investigate program variable. 
        * Because the sub-field sequence might be infinite, we have to set up the depth on investigating*/
       
       for(IExecutionVariable var: vars){
          //System.out.println("variables: " + var.getName());          
          if(HeapHandler.isSelf(var)){   
             HEAP_NAME=var.getName();   
             addSelfToModel(var);                                           
             investigateProgramVariable(var,0,selfModelTree);             
          }       
       }       
       
       for(IExecutionVariable var: vars){
          if(HeapHandler.isStatic(var) || HeapHandler.isParameter(var)){ //solve static variables and method's parameters
             for(ModelTree mt: selfModelTree.getAllLeafModelTrees())
                investigateProgramVariable(var,0, mt);     
          }      
       }
       
       //manipulate exploit model to indicate the container for static variables
       listModel = selfModelTree.getAllLeafModels();
       System.out.println("NUMBER OF MODELS: " + listModel.size());
       for(Model model: listModel){
          maniputlateModel2SolveStaticVar(model);
          System.out.println("model created:::::: \n" + model.toString());
       }
       
       //List<Term> listTerm = new LinkedList<Term>();
       for(Model model: listModel){
          for(ModelVariable mv: model.getVariables()){          
             //Term sv = mv.getSymbolicValue();
             //System.out.println("value of " + mv.getIdentifier() + " : ---> "  + sv + " : " + HeapHandler.isLengthFunction(sv));             
             //listTerm.add(mv.getValueCondition());             
             //mv.setSymbolicValue(refineTerm(sv));
             //System.out.println("refined value: ---> " + mv.getSymbolicValue());
             investigateArtificialVars(mv.getSymbolicValue());
             investigateArtificialVars(mv.getValueCondition());
             
          }       
       }
              
       /*find artificial variables from node constraint
       node constraint usually contains path condition*/
       nodeConstraints = getUsefulConstraint();
       investigateArtificialVars(nodeConstraints);
       
   }
   
   /**
    * called if var is heap (started by "self")
    * @throws ProofInputException 
    * */
   private void addSelfToModel(IExecutionVariable var) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
      final ModelInstance selfInstance = ModelInstanceFactory.constructModelInstance(container);      
      final ModelVariable self = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), var.getName());
      self.setParentIdentifier(null);
      //model.add(self, selfInstance);   
      Model m = Model.constructModel();
      m.add(self, selfInstance);
      selfModelTree.setModel(m);
      
      //listModel.add(model);
   }
   
   /**
    * investigate self object to retrieve information of all fields and add it into exploit model
    * counter represents precisely the depth of investigating
    * */
   private void investigateProgramVariable(IExecutionVariable var, int level, ModelTree modelTree) throws ProofInputException{
      /*System.out.println("detected var: " + var.getName()+ " array index: " + var.getArrayIndex() + 
            " program variable: " + var.getProgramVariable() + " type: " + var.getValues()[0].getValue().sort());   */
      //if (var.getProgramVariable() instanceof IProgramVariable){            
          
         String identifier = KeYResourceHandler.getVarName(var);
         if(!HeapHandler.isParameter(var)){
            if(!sHeapName.isEmpty())
               identifier=getReferenceName()+"_"+identifier;
         }
         //System.out.println("detected var: " + identifier);
         
        /* if(!model.inModel(identifier)){            
            addVarToModel(var, modelTree.getModel());
         } */
         //Model model = modelTree.getModel();         
         
         if(level<depth){             
            //recursively work with child variable of this variable
            if(var.getValues()!=null){
               IExecutionValue[] values =var.getValues();
               if(values.length>1){
                  List<ModelTree> leafs = modelTree.getAllLeafModelTrees();       
                  System.out.println(" variable + " + identifier + " has condition value, its value detail is: ");
                  for(IExecutionValue value: values){
                     System.out.println("value: " + value.getValue() + " condition: " + value.getCondition());
                  }
                  System.out.println("\n\nnumber of current leaf model trees: " + leafs.size());                  
                  for(ModelTree leaf: leafs){
                     Model model = leaf.getModel();
                     for(IExecutionValue value:values){                  
                       //for each value, we create a new child for current ModelTree    
                        ModelTree subTree = new ModelTree(Model.constructModel(model));
                        if(!subTree.getModel().hasVar(identifier)){
                           addVarToModel(var, value.getValue(), value.getCondition(), subTree);
                        }
                        sHeapName.push(KeYResourceHandler.getVarName(var));
                        if(leaf.getSmallestChild()!=null)
                           subTree.setClosestSibling(leaf.getSmallestChild());
                        leaf.addChild(subTree);                        
                        IExecutionVariable[] vchilds=value.getChildVariables();   
                        //System.out.println("number of children of " + identifier + ": " + vchilds.length); 
                        for(IExecutionVariable vchild:vchilds){                      
                           investigateProgramVariable(vchild, level++, subTree);                      
                        }                        
                        //System.out.println("ModelTree created: \n" + modelTree.getModel().toString());
                        sHeapName.pop(); 
                     }
                  }
               }else{
                //if there is only one value, the condition is true
                  //TODO: ask Martin to fix this bug
                  Model model = modelTree.getModel();
                  if(!model.hasVar(identifier)){                        
                     addVarToModel(var, values[0].getValue(), termBuilder.tt(), modelTree);
                  }
                  sHeapName.push(KeYResourceHandler.getVarName(var));
                  IExecutionVariable[] vchilds=values[0].getChildVariables();   
                  //System.out.println("number of children of " + identifier + ": " + vchilds.length); 
                  for(IExecutionVariable vchild:vchilds){                      
                     investigateProgramVariable(vchild, level++, modelTree);                      
                  }
                  sHeapName.pop(); 
               }
            }
         }
      //}
   }
   
   /**
    * adds a field of the class to model, links to container object
    * */
   private void addVarToModel(final IExecutionVariable var, Term symbolicValue, Term valueCondition, ModelTree modelTree) throws ProofInputException{     
      String identifier = KeYResourceHandler.getVarName(var);
      
      if(!HeapHandler.isParameter(var)){
         if(!sHeapName.isEmpty())
            identifier=getReferenceName()+"_"+identifier;
      }
      //System.out.println("detected: " + identifier);
      
      ModelVariable variable;
      if(var.getProgramVariable() instanceof IProgramVariable){ //normal program variable
         if(HeapHandler.isArray(var)){
            //System.out.println(var + " is array!");
            variable = new ModelArrayVariable(var.getProgramVariable(),identifier);
         }else{
            variable=new ModelVariable(var.getProgramVariable(),identifier);
         }     
      }else{ //array's element is not treated as program variable, so we have to solve it separately
         variable = new ModelVariable(ModelVariableGenerator.createProgramVariable(var),identifier);
      }
   
      //System.out.println("adding "+ identifier);
      //resolve symbolic value
      /*IExecutionValue[] values =var.getValues();
      Term symbolicValue = values[0].getValue();*/
      //System.out.println("value of " + variable.getIdentifier() + " : " + symbolicValue + " ; condition: " + valueCondition);      
      
      //symbolicValue = refineTerm(symbolicValue);
      variable.setSymbolicValue(symbolicValue);
      variable.setValueCondition(valueCondition);
      //variable.setArrayIdx(var.getgetArrayIndex());
      Term idxTerm = var.getArrayIndex();
      if(idxTerm!=null){
         variable.setArrayIdxTerm(idxTerm);
         if(TermParser.isInteger(idxTerm))
            variable.setArrayIdx(TermParser.getIntegerValue(idxTerm));
      }
      
      //assign select form
      variable.setSelectForm(var.createSelectTerm());
      //System.out.println("select form: " + variable.getSelectForm());
      
      
      if(HeapHandler.isParameter(var))  //assign true flag for method's parameter
         variable.setParameter(true);
      
      if(HeapHandler.isStatic(var)){
         variable.setStatic(true);
         variable.setDeclareClassName(KeYResourceHandler.getAccessClassNameOfStaticVar(var));
      }else
         variable.setStatic(false);         
      
      Object instance;
      if (HeapHandler.isPrimitive(var)) {
          //The term is a static variable. Identify and connect it with its parent class.
          instance = ModelBuilderVisitor.resolvePrimitiveType(variable.getProgramVariable());
      } else {
          instance = ModelInstanceFactory.constructModelInstance(variable.getProgramVariable().getKeYJavaType());
      }
      /*
       * Add the variable and its instance to the Model. This might seem
       * premature, but must be done to preserve referential integrity and
       * avoiding extra work.
       */
      modelTree.getModel().add(variable, instance);
      if(!sHeapName.isEmpty()){
         String referenceName = getReferenceName();
         variable.setParentIdentifier(referenceName);
         modelTree.getModel().assignField(variable, modelTree.getModel().getVariable(referenceName));
      }
      
      //add var to all sub ModelTree of this current modelTree
      for(ModelTree subtree: modelTree.getChildren())
         addVarToModel(var, symbolicValue, valueCondition, subtree);
      //add var to the closest sibling of current modelTree
      if(modelTree.getClosestSibling()!=null)
         addVarToModel(var, symbolicValue, valueCondition, modelTree.getClosestSibling());
   }  
   
   /*
    * when resolving loop by using loop invariant, SED (Symbolic Execution Debugger) may create fake variables
    * to represent the value of fields, we have to detect them and add them into model
    * */
   private void investigateArtificialVars(final Term t){
      if(t!=null){       
         if(HeapHandler.isHeapSelectFunction(t) && !HeapHandler.isAnonHeapSelectFunction(t)){
            //processSelectFunction(t);            
         }else if(HeapHandler.isLengthFunction(t)){
            //processLengthFunction(t);          
            
         }else if(KeYResourceHandler.isArtificialVariable(t) ){
            //System.out.println("artificial detected!::: " + term);
            //we have to check if term has been added into model or not
            //if true, it is parameter and we do not add it into list of artificial variables       
            Term addTerm = refineTerm(t);
            //Term addTerm = t;
            //if(!model.hasVar(addTerm.toString())){                  
               add2ArtificialVars(addTerm);
            //}           
         }else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=t.subs();
            for(Term st:subterms){
               investigateArtificialVars(st);
            }
         }         
      }      
   }
   
   private void add2ArtificialVars(Term t){          
      if(!HeapHandler.inListTerm(t, artificialVars)){         
         artificialVars.add(t);
      }
   }
   
   
   /*
    * constructs reference name from stack, if object obj is a field of heap self, then the heap name is self_obj
    * */
   private String getReferenceName() {  
      String heapName="";
      if(sHeapName.size()>0){
         heapName=sHeapName.get(0);
         for(int i=1;i<sHeapName.size();i++){
            heapName +="_" + sHeapName.get(i);
         }
      }
      return heapName;
   }
   
   
   /*
    * basically, all static variable are listed when we look into the array of program variables, not in heap
    * however, we would like to match static variable with some specific variables that their class is the real container of it.
    * so we have to manipulate the model
    * */
   
   private void maniputlateModel2SolveStaticVar(Model model){
      List<ModelVariable> lMV = model.getVariables();
          
      /*
       * now we resolve lMV in the following way:
       * take all ModelVariable mv in lMV
       * if mv is static then
       * find a ModelVariable container in lMV that its type is same with the type of container class of mv
       * set mv as a field of container
       * */
      //System.out.println("+++ BEGIN static resolving");
      for(ModelVariable mv: lMV){ 
         
         if(mv.isStatic()){
          //System.out.println(mv.getIdentifier() + " : " + mv.getVariableName());
            String containerName = mv.getDeclareClassName();
            for(ModelVariable mvc: lMV){
               if(containerName.equals(mvc.getTypeName())){
                  model.assignField(mv, mvc);                  
               }
            }
         }        
      }
      //System.out.println("+++ END static resolving");
   }
  
   /*
    * process length function to detect and add unknown model variable into model
    * */   
   private void processLengthFunction(final Term t){
      /*String rootName = HeapHandler.getRootNameOfSelectAndLength(t);
      if(model.hasVar(rootName)){ //this is legal model variable, add it into model 
         ModelVariable length = ModelVariableGenerator.createModelVariable(t);      
         //if length is not in model, we process it
         if(!model.hasVar(length.getIdentifier())){
            model.add(length,ModelVariableGenerator.createInstance(length));
            Term sub0 = t.sub(0);
            if(HeapHandler.isHeapSelectFunction(sub0) && !HeapHandler.isAnonHeapSelectFunction(sub0)){
               processSelectFunction(sub0);
            }else{
               ModelVariable array = ModelVariableGenerator.createModelVariable(sub0);
               if(!model.hasVar(array.getIdentifier())){
                  model.add(array, ModelVariableGenerator.createInstance(array));                  
               }   
            }
            ModelVariable array = ModelVariableGenerator.createModelVariable(sub0);
            length.setParentIdentifier(array.getIdentifier());
            model.assignField(length, model.getVariable(array.getIdentifier()));
         }
      }else{
         add2ArtificialVars(refineTerm(t));
         investigateArtificialVars(t.sub(0));         
      }*/
   }
   
   /*
    * process select function to detect and add unknown model variable into model
    * */   
   private void processSelectFunction(final Term t){  
      /*String rootName = HeapHandler.getRootNameOfSelectAndLength(t);
      if(model.hasVar(rootName)){  //this is legal model variable, add it into model   
         ModelVariable mv = ModelVariableGenerator.createModelVariable(t); //create Model variable
         if(!model.hasVar(mv.getIdentifier())){ 
            //if mv is not in model, add it and resolve it
             model.add(mv,ModelVariableGenerator.createInstance(mv));
             Term sub2 = t.sub(2);
             if(HeapHandler.isArrayIdxFunction(sub2)){ //if mv is an element of array 
                if(HeapHandler.isArrayElementNumber(sub2)){ 
                   //if the index is number, then assign the index number
                   mv.setArrayIdx(HeapHandler.getArrayIndexNumber(sub2));
                   //if the index is length function, then call process length function                   
                }else if(HeapHandler.isLengthFunction(sub2)){                                      
                   processLengthFunction(sub2);
                   after processing length function, length variable is added to the model
                   assign index object as length function 
                   ModelVariable length = ModelVariableGenerator.createModelVariable(sub2);
                   mv.setArrayIdxValue(model.getVariable(length.getIdentifier()));                   
                } else{
                   //if the index is variable or select function, then assign array index object
                   ModelVariable idxMv = ModelVariableGenerator.createModelVariable(sub2.sub(0));
                   if(!model.hasVar(idxMv.getIdentifier())){
                      //if index object is not in the model, add it into model
                      if(HeapHandler.isHeapSelectFunction(sub2.sub(0)) && !HeapHandler.isAnonHeapSelectFunction(sub2.sub(0)))
                         processSelectFunction(sub2.sub(0));
                      else                         
                         model.add(idxMv, ModelVariableGenerator.createInstance(idxMv));
                   }
                   //assign index object
                   mv.setArrayIdxValue(model.getVariable(idxMv.getIdentifier()));
                }
             }else {
                //if sub2 is an variable, basically do nothing
             }             
             //check if mv has been assigned as a field of referee object
             Term sub1 = t.sub(1);
             ModelVariable referMv = ModelVariableGenerator.createModelVariable(sub1);
             if(!model.hasVar(referMv.getIdentifier())){
                //if refer object has not been added into model, add it and process it
                if(HeapHandler.isHeapSelectFunction(t) && !HeapHandler.isAnonHeapSelectFunction(t))
                   processSelectFunction(sub1);
                else
                   model.add(referMv, ModelVariableGenerator.createInstance(referMv));
                
             }
             //assign field: mv is a field of referMv
             mv.setParentIdentifier(referMv.getIdentifier());
             model.assignField(mv, model.getVariable(referMv.getIdentifier()));
             
         }else{
            if mv is already in the model, we do nothing because basically
             * Term t is resolved already        
             
         }       
      }else{//add this select function to artificial variables collection
         add2ArtificialVars(refineTerm(t));
         investigateArtificialVars(t.sub(1));
         investigateArtificialVars(t.sub(2));
      }*/
   }
   
  
   private Term refineTerm(final Term t){
      //Term result = KeYResourceHandler.removeUnnecessaryTerm(t);
      Term result = heapHandler.replaceLengthFunctionByVar(t, KEGConfig.SEPARATOR);
      result = heapHandler.replaceSelectFunctionByItsField(result, KEGConfig.SEPARATOR);
      return result;
   }
   
   
   
   public NodeDetail extractNodeDetail() throws ProofInputException{
      //Term constraint = getUsefulConstraint();
      constructModels(); //construct Model of ModelVariable and artificial variables    
      return new NodeDetail(node, listModel, artificialVars, nodeConstraints, HEAP_NAME);      
   }
   
}
