package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;


import java.math.BigInteger;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.swing.text.html.ListView;



import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

/*
 * this class generate the best low input for next experiment in the sense that it maximizes the leakage (measured by Shannon Entropy or other metric) 
 * 
 * */
public class ShannonLeakageMaximizer extends LeakageMaximizer{	
	
	
	
	public ShannonLeakageMaximizer(List<PPCountingResult> listCountingResults, Services services, List<String> listLowVars,  BigInteger numOfHighValues, String optSolver) {
		super(listCountingResults, services, listLowVars, optSolver,numOfHighValues);		
		//this.numberOfHighValues = numOfHighValues;
		//System.out.println("numberOfHighValues (ShannonLeakageMaximizer):" + numberOfHighValues);
		extract2ListMatchableSolutions();
		printInfoOfListMatchableCountingSolutions();
	}
	
		
	
	
	
		
		
	protected OptimalSolution findGlobalOptimalSolution(List<OptimalSolution> listSolution){
		return findMimimumSolution(listSolution);
	}
	
	/*
	 * compute Shannon-entropy-leakage for the case all counting term is constant
	 * */
	protected OptimalSolution resolveConstantSolution(MatchableCountingSolution matchCountSolution){
		/*
		 * calculate scaled shannon entropy leakage
		 * */
		double optimizeValue = 0;
		for(Term value: matchCountSolution.getListCountTerms()){
			long cG = TermParser.getIntegerValue(value, services);
			if(cG>0)
				optimizeValue += cG * Math.log(cG);			
		}
		
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		return new OptimalSolution(solution, optimizeValue);
	}
	
	protected OptimalSolution resolve4UniqueSolution(MatchableCountingSolution matchCountSolution){
		Map<String,Long> solution = matchCountSolution.getUniqueSolution();
		double optimizeValue = 0;
		for(Term countTerm: matchCountSolution.getListCountTerms()){
			double cG = TermUtil.computeDouble(countTerm, solution, services);
			if(cG>0){
				optimizeValue += cG * Math.log(cG);	
			}			
		}
		return new OptimalSolution(solution, optimizeValue);
	}

	@Override
	protected OptimalSolution findOptimalSolution4SingleCase(
			MatchableCountingSolution matchCountSolution) {
		OptimizationSolver solver;
		return findOptimalSolution4SingleCase(matchCountSolution, KEGConstant.SHANNON_ENTROPY);
	}

	
	/*
	 * shannon-entropy-based leakage = ((ln(S_{j-1}) - (1/S_{j-1})*bestSolution.optimalValue))/ln2
	 * */
	@Override
	protected double computeLeakage(OptimalSolution bestSolution) {
		double S = numberOfHighValues.doubleValue();
		return (Math.log(S) - bestSolution.getOptimizeValue()/S)/Math.log(2);
	}
	
	
}
