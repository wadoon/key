package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;


import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.swing.text.html.ListView;



import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

/*
 * this class generate the best low input for next experiment in the sense that it maximizes the leakage (measured by Shannon Entropy or other metric) 
 * 
 * */
public class ShannonLeakageMaximizer extends LeakageMaximizer{	
	
	private final long numberOfHighValues; //number of possible high values calculated via currentKnowlegde
	
	public ShannonLeakageMaximizer(List<PPCountingResult> listCountingResults, Services services, List<String> listLowVars,  long numOfHighValues) {
		super(listCountingResults, services, listLowVars);
		
		this.numberOfHighValues = numOfHighValues;
		extract2ListMatchableCountingSolution();
	}
	
		
	protected void extract2ListMatchableCountingSolution(){
		//System.out.println("start extracting to list of matchable counting solution!");
		CountingResultTree countTree = new CountingResultTree();
		for(PPCountingResult countResult: listCountingResults){			
			for(CountingResultTree leaf: countTree.getAllLeaves()){
				List<CountingResultTree> leaves = new LinkedList<CountingResultTree>();				
				for(CountingSolution condResult: countResult.getListResults()){
					if(!TermParser.isBooleanFalse(condResult.getCondition()))
						leaves.add(new CountingResultTree(condResult));
				}		
				leaf.addChildren(leaves, services);
			}
		}
		//System.out.println("all leaves have been added!");
		//remove all leaf that don't have enough childs (=listCountingResults.size)
		listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
		for(CountingResultTree tre: countTree.getAllLeaves()){
			List<Term> listCountTerms = tre.getListCountTerms();
			if(listCountTerms.size() == listCountingResults.size()){
				//create new condition: sum of all possible counting values must equal to numberOfHighValues
				TermBuilder tb = services.getTermBuilder();
				Term sum = tb.zero();
				for(Term t: listCountTerms){
					sum = tb.add(sum, t);
				}
				Term possCondition = tb.equals(sum, tb.zTerm((int)numberOfHighValues));
				Z3Solver z31 = new Z3Solver(possCondition, services);
				Term condition = tre.getConditionTerm();
				if(!z31.checkValid()){ //if possCondition is not valid then add it
					condition = tb.and(possCondition, condition);
				}
				Z3Solver z3 = new Z3Solver(condition, services);
				Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
				if(uniqueModel!=null){
					if(uniqueModel.second==1) //there is only one model
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,true));
					else
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));
				}
			}		
		}
		System.out.println("finish extracting! We found " + listMatchableSolutions.size() + " matchable solutions");
		
	}
	
	
		
		
	public void printInfoOfListCountingResults(){
		System.out.println("information about list counting result:");
		for(int i=0;i<listCountingResults.size();i++){
			System.out.println("number of count result " + i + " : " + listCountingResults.get(i).getListResults().size());
			for(CountingSolution result: listCountingResults.get(i).getListResults()){
				System.out.println("  value: "+ result.getValue() + "; condition: " + result.getCondition());
			}
		}
		System.out.println("----");
	}	
	
	protected OptimalSolution findGlobalOptimalSolution(List<OptimalSolution> listSolution){
		return findMimimumSolution(listSolution);
	}
	
	/*
	 * compute Shannon-entropy-leakage for the case all counting term is constant
	 * */
	protected OptimalSolution resolveConstantSolution(MatchableCountingSolution matchCountSolution){
		/*
		 * calculate scaled shannon entropy leakage
		 * */
		double optimizeValue = 0;
		for(Term value: matchCountSolution.getListCountTerms()){
			long cG = TermParser.getIntegerValue(value);
			if(cG>0)
				optimizeValue += cG * Math.log(cG);			
		}
		
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		return new OptimalSolution(solution, optimizeValue);
	}
	
	protected OptimalSolution resolve4UniqueSolution(MatchableCountingSolution matchCountSolution){
		Map<String,Long> solution = matchCountSolution.getUniqueSolution();
		double optimizeValue = 0;
		for(Term countTerm: matchCountSolution.getListCountTerms()){
			long cG = TermUtil.computeLong(countTerm, solution);
			if(cG>0){
				optimizeValue += cG * Math.log(cG);	
			}			
		}
		return new OptimalSolution(solution, optimizeValue);
	}

	@Override
	protected OptimalSolution findOptimalSolution4SingleCase(
			MatchableCountingSolution matchCountSolution) {
		OptimizationSolver solver = new AMPLSolver(matchCountSolution, services, KEGConstant.SHANNON_ENTROPY);
		return solver.findOptimalSolution();
	}

	
	/*
	 * shannon-entropy-based leakage = ((ln(S_{j-1}) - (1/S_{j-1})*bestSolution.optimalValue))/ln2
	 * */
	@Override
	protected double computeLeakage(OptimalSolution bestSolution) {
		return (Math.log(numberOfHighValues) - bestSolution.getOptimizeValue()/numberOfHighValues)/Math.log(2);
	}
	
}
