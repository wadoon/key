grammar DistributionInput;

@header {
package de.tud.exploitgen.findsecret.distribution.gensrc;

import de.uka.ilkd.key.logic.Term;
}

/***********************************
LEXER RULES
************************************/
WS: [ \t\r\n]+ ;
Neg_num: MINUS Pos_num;
Pos_num: NONZERODIGIT (ZERO|NONZERODIGIT)* ;
FLOOR: 'floor' ; //floor function
OR : 'or';
AND: 'and' ;	
INFINITY: 'infty';
EXISTS: 'exists' ;
TRUE: 'true' | 'TRUE' ;
ZERO: '0';
POWER: '^' ;
NONZERODIGIT: '1'..'9';

Param: LETTER (NONZERODIGIT | ZERO |LETTER)* ;

LETTER: 'a'..'z'|'A'..'Z'|'_' ;



GE: '>=' ;
GT: '>' ;
LE: '<=' ;
LT: '<' ;
EQ:	'=' ;

MULT: '*' ;
DIV: '/' ;
PLUS: '+';
MINUS: '-';

/********************************* 
PARSER RULES 
********************************/

distribution: partition ((WS)*';' (WS)* distribution)* ;

partition: 
	formula (WS)* ':' (WS)* frequency
	; 

formula: logic_expr
		| TRUE /*if formula = true and we have uniform distribution*/
		;
	
frequency: Pos_num #frequency_postNum
	| ZERO #frequency_ZERO
	;


arith_expr: 	
	arith_expr WS MINUS WS arith_expr #Arith_expr_Minus
	|arith_expr WS PLUS WS arith_expr #Arith_expr_Plus
	|arith_term #Arith_expr_Arith_term
	|MINUS arith_expr #Minus_Arith_expr
	;

arith_term: 
	arith_term WS MULT WS arith_term #Arith_term_Mult
	|arith_term WS DIV WS arith_term #Arith_term_Div
	|factor #Arith_term_factor;

factor: int_num #INT
		| factor DIV factor #Factor_Fraction
		| '[' factor ']' #Factor_Round //round operator
		| factor POWER factor		 #Factor_Power
		| Param #Factor_param
		| int_num Param #Factor_num_mul_param
		| '(' arith_expr ')' #Factor_Parentheses_Arith_Expr
		| FLOOR '(' factor ')' #Factor_floor
		;  


int_num /*returns[String output]*/: Pos_num //{$output=$Pos_num.text} 
	| Neg_num //{$output=$Neg_num.text} 
	| ZERO //{$output=$ZERO.text} 
	;

logic_expr: 
	logic_expr (WS)* OR (WS)* logic_expr #Logic_expr_OR
	| exists_expr #Logic_expr_Exist
	|logic_term #Logic_expr_logic_term
	; 

exists_expr: EXISTS (WS)* '(' qvar_expr ':' (WS)* logic_expr ')';

qvar_expr:  Param  #Qvar_expr_param
			| Param (WS)* '=' (WS)* arith_expr #Qvar_expr_param_equals_expr
			; 

logic_term: 
	logic_term WS AND WS logic_term #Logic_term_AND
	|logic_factor #Logic_term_logic_factor;


logic_factor: compare_term #Logic_factor_compare
			| '(' (WS)* logic_expr (WS)* ')' #Logic_factor_Parentheses_Logic_Expr 
			;
compare_operator: 
	GE  #Greater_or_equal
	| GT #Greater
	| LE #Less_or_equal
	| LT #Less 
	| EQ #Equal 
	;
compare_term: 
	arith_expr (WS)* compare_operator (WS)* arith_expr (WS)* compare_operator (WS)* arith_expr #compare_term_trio
	|arith_expr (WS)* GT (WS)* arith_expr #Compare_term_Greater
	|arith_expr (WS)* GE (WS)* arith_expr #Compare_term_Greater_or_equal
	|arith_expr (WS)* LT (WS)* arith_expr #Compare_term_Less
	|arith_expr (WS)* LE (WS)* arith_expr #Compare_term_Less_or_equal
	|arith_expr (WS)* EQ (WS)* arith_expr #Compare_term_Equal
	;