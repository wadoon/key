/**
 * 
 */
package de.tud.exploitgen.util;

import com.csvanefalk.keytestgen.StringConstants;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;

/**
 * this class has several methods to transform different format of input materials
 * into the format suitable for generating test file 
 * @author Huy Do
 *
 */
public class TestTransformer {
   
	//adding Services object, serving for calling HeapHandler
   private final Services services;
   
   public TestTransformer(Services services){
	   this.services=services;
   }
   
   /**
    * return wrapper class of the input term, based on KeYJavaType
    * */
   public static String getWrapperClass(Term expression){
      
      final String sortName = expression.sort().name().toString();
      if(sortName.equals(StringConstants.INTEGER)){
         return "Integer";
      }
      if(sortName.equals(StringConstants.LONG)){
         return "Long";
      }
      if(sortName.equals(StringConstants.BYTE)){
         return "Byte";
      }
      if(sortName.equals(StringConstants.BOOLEAN)){
         return "Boolean";
      }
      return "";      
      
      
   }
   
   /**
    * transform an arithmetic expression in prefix notation format( returned by toString() method of Term) 
    * into  infix notation that could be used in normal Java source code,
    * also add the suffix branch at the end of variable names
    * for example, if we have an arithmetic expression 'term' like that: JavaAddInt(a,b)
    * so transformArithmeticExpression(term,1) will return (a_1 + b_1)
    * to do that, we traverse the Term by inOder method (Term has tree structure)
    * */
   public String transformExpression2String(Term expression,int branch){     
      
      if(TermParser.isInteger(expression)){
         return TermParser.resolveNumber(expression);
      }
      else if(TermParser.isLocationVariable(expression)){
         return TermParser.getVariableNameForTerm(expression)+getSuffix(branch);
      }
      else if(HeapHandler.isHeapSelectFunction(expression)){
         return new HeapHandler(services).getFieldName(expression)+getSuffix(branch);                     
      }      
      else if(TermParser.isBinaryFunction(expression)){
         return "(" + 
               transformExpression2String(expression.sub(0), branch) +
               getBinaryOperatorString(expression) +
               transformExpression2String(expression.sub(1), branch) +
               ")";         
      }
      else if(TermParser.isUnaryFunction(expression)){
         return "(" + 
               getUnaryOperatorString(expression) +
               transformExpression2String(expression, branch) + 
               ")";
         
      }else
         return "";
   }   
   
   /**
    * similar to above method
    * use parameter heapName to contribute name of variables representing for field,
    * while resolving the heap
    * */
   public String transformExpression2String(Term expression,int branch, String heapName){     
      
      if(TermParser.isInteger(expression)){
         return TermParser.resolveNumber(expression);
      }
      else if(TermParser.isLocationVariable(expression)){
         return TermParser.getVariableNameForTerm(expression)+getSuffix(branch);
      }
      else if(TermParser.isBooleanTrue(expression)){
         return "true";
      }
      else if(TermParser.isBooleanFalse(expression)){
         return "false";
      }
      else if(HeapHandler.isHeapSelectFunction(expression)){
         return new HeapHandler(services).getFieldName(expression,heapName)+getSuffix(branch);                     
      }  
      
      else if(TermParser.isBinaryFunction(expression)){         
         return "(" + 
               transformExpression2String(expression.sub(0), branch, heapName) +
               getBinaryOperatorString(expression) +
               transformExpression2String(expression.sub(1), branch, heapName) +
               ")";         
      }
      
      else if(TermParser.isAnd(expression)){
         if(TermParser.isBooleanTrue(expression.sub(0)))
            return transformExpression2String(expression.sub(1), branch, heapName);
         else if(TermParser.isBooleanTrue(expression.sub(1)))
            return transformExpression2String(expression.sub(0), branch, heapName);
         else
            return "(" + 
            transformExpression2String(expression.sub(0), branch, heapName) +
            getLogicalOperatorString(expression) +
            transformExpression2String(expression.sub(1), branch, heapName) +
            ")";        
      }
      
      else if(TermParser.isOr(expression)){
         if(TermParser.isBooleanFalse(expression.sub(0)))
            return transformExpression2String(expression.sub(1), branch, heapName);
         else if(TermParser.isBooleanFalse(expression.sub(1)))
            return transformExpression2String(expression.sub(0), branch, heapName);
         else
            return "(" + 
            transformExpression2String(expression.sub(0), branch, heapName) +
            getLogicalOperatorString(expression) +
            transformExpression2String(expression.sub(1), branch, heapName) +
            ")";        
      }
      else if(TermParser.isUnaryFunction(expression)){
         return "(" + 
               getUnaryOperatorString(expression) +
               transformExpression2String(expression.sub(0), branch, heapName) + 
               ")";      
      }else
         return "";
   }   
   
   /*get operation string of binary operator (+, -, *, / , >, <, <=,>=, == )*/
   public static String getBinaryOperatorString(Term expression){
      //arithmetic operators
      if(TermParser.isAddition(expression))
         return " + ";
      else if(TermParser.isSubtraction(expression))
         return " - ";
      else if(TermParser.isMultiplication(expression))
         return " * ";
      else if(TermParser.isDivision(expression))
         return " / ";
      
      //Comparison operators
      else if(TermParser.isGreaterThan(expression))
         return " > ";
      else if(TermParser.isGreaterOrEquals(expression))
         return " >= " ;
      else if(TermParser.isLessThan(expression))
         return " < ";
      else if(TermParser.isLessOrEquals(expression))
         return " <= ";
      else if(TermParser.isEquals(expression))
         return " == ";
     
      //binary logical operators
      if(TermParser.isAnd(expression))
         return " && ";
      else if(TermParser.isOr(expression))
         return " || ";      
      else   
         return "";
   } 
   
   /*get logical operator*/
   public static String getLogicalOperatorString(Term expression){
      
      //binary logical operators
      if(TermParser.isAnd(expression))
         return " && ";
      else if(TermParser.isOr(expression))
         return " || ";
      else   
         return "";
   }
   
   
   /* get operation string of unary operator (-)*/
   public static String getUnaryOperatorString(Term expression){
      if(TermParser.isIntegerNegation(expression))
         return "-";
      else if(TermParser.isUnaryMinusFunction(expression))
         return "-";
      else if (TermParser.isNot(expression))
         return "!";
      else
         return "";
   }   
 
   
   private static String getSuffix(int branch){
      return "_" + branch;
   }
}
