package de.tud.exploitgen.findsecret;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.util.Pair;

public class ObservableOutput {
	private class TreeMapTerm{
		Map<String,Term> mapTerm;
		List<TreeMapTerm> children;
		public TreeMapTerm(){
			this.mapTerm = new HashMap<String,Term>();
			children = new LinkedList<TreeMapTerm>();			
		}		
		public TreeMapTerm(Map<String,Term> mapTerm){
			this.mapTerm = new HashMap<String,Term>();			
			children = new LinkedList<TreeMapTerm>();
			this.mapTerm.putAll(mapTerm);
		}
		
		
		public List<TreeMapTerm> getAllLeaves(){
		    //performing tree traversal to get all leaf nodes      
		      if(isLeaf()){
		         List<TreeMapTerm> result = new LinkedList<TreeMapTerm>();
		         result.add(this);
		         return result;
		      }else{
		         List<TreeMapTerm> result = new LinkedList<TreeMapTerm>();
		         for(TreeMapTerm mt: children)
		            result.addAll(mt.getAllLeaves());
		         return result;
		      }    
		 }
		
		public boolean isLeaf(){
		   return (children.size()==0);	   
		}
		
		public void addChildren(List<TreeMapTerm> children) {			
			for(TreeMapTerm child: children)
				addChild(child);			
		}
		
		public void addChild(TreeMapTerm child){
			TreeMapTerm newChild = new TreeMapTerm(child.getMapTerm()); //avoid aliasing
			newChild.mapTerm.putAll(this.mapTerm);
			children.add(newChild);
		}
		public Map<String, Term> getMapTerm() {
			return mapTerm;
		}
		
		
		
	}
	
	private final Map<String, Term> mapValues;	
	private List<String> constantOutputVars; //list of all observable variable that have symbolic output value is constant 
	private List<String> lowDependOutputVars; //list of all observable variable that the output depends only on low variables
	private Map<String,Long> mapHighDependOutputVars; //list of all observable variable whose symbolic output depends on high variable 
	private List<String> dependLHOutputVars; //depends on both low, high or/and artificial variables
	//private List<Map<String, Term>> listMapSymbolicValues; //list of all map symbolic values representing for all possible concrete values  
	private final RiskyPath riskyPath;
	
	private List<Map<String, Term>> listMapHybridValues;
	private List<String> listSymbols;
	
	public ObservableOutput(Map<String, Term> mapValues, RiskyPath riskyPath) {
		super();
		this.mapValues = mapValues;
		this.riskyPath = riskyPath;
		extractListOutVars();
		System.out.println("mapValues: " + mapValues);
		constructElement4HybridDomain();
	}

	public List<String> getConstantOutputVars() {
		return constantOutputVars;
	}

	public List<String> getLowDependOutputVars() {
		return lowDependOutputVars;
	}

	public Map<String, Term> getMapValues() {
		return mapValues;
	}
	
	private void extractListOutVars(){
		constantOutputVars = new LinkedList<String>();
		mapHighDependOutputVars = new HashMap<String,Long>();
		lowDependOutputVars = new LinkedList<String>();
		dependLHOutputVars = new LinkedList<String>();
		for(String varName: mapValues.keySet()){
			Term symbolicValue = mapValues.get(varName);
			if(TermParser.isIntegerConst(symbolicValue)|| TermParser.isBooleanConstant(symbolicValue))
				constantOutputVars.add(varName);
			else if(containsOnlyLowVar(symbolicValue)){
				//System.out.println("containsOnlyLowVar: "+ symbolicValue);
					lowDependOutputVars.add(varName);
			}else if(containsOnlyHighVar(symbolicValue)){
				mapHighDependOutputVars.put(varName,null); //when we havent observed the value of varName, it is assigned as null
			}
			/*else if(uncontainLowVar(symbolicValue)){
				mapHighDependOutputVars.put(varName,null);
			}
			else if(uncontainHighVar(symbolicValue)){
				lowDependOutputVars.add(varName);
			}*/
			else{
				dependLHOutputVars.add(varName);
			}
		}
	}
	/*check if Term t contains only low varibles or not
	 * */
	private boolean containsOnlyLowVar(Term t){		
		List<String> listLowVars = riskyPath.getVc().getListLowVars();
		return TermUtil.containOnlyVarInListString(listLowVars, t);
			
	}
	
	/*check if Term t contains only high variables or not
	 * */
	private boolean containsOnlyHighVar(Term t){
		List<String> listHighVars = riskyPath.getVc().getListHighVars();
		return TermUtil.containOnlyVarInListString(listHighVars, t);			
	}
	
	private boolean uncontainLowVar(Term t){
		List<String> listLowVars = riskyPath.getVc().getListLowVars();
		return TermUtil.uncontainVarInListString(listLowVars, t);
	}
	
	private boolean uncontainHighVar(Term t){
		List<String> listHighVars = riskyPath.getVc().getListHighVars();
		return TermUtil.uncontainVarInListString(listHighVars, t);
	}
	
	public Term getCompareOutputTerm(Experiment experiment){		
		Services services = riskyPath.getMethod().getServices();
		PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
		TermBuilder termBuilder = services.getTermBuilder();	
		
		if(matchByConstantAndLowDenpendOnly(experiment)){		
			Term compareOutputTerm = termBuilder.tt();
			Map<String, Long> observedOutputs = experiment.getObservableOutputs();
			for(String notConstVarName: mapHighDependOutputVars.keySet()){
				if(mapHighDependOutputVars.get(notConstVarName)==null){
					Term symbolicValue = mapValues.get(notConstVarName);
					Term comparison = termBuilder.equals(termBuilder.zTerm(observedOutputs.get(notConstVarName).toString()), symbolicValue);
					compareOutputTerm = termBuilder.and(compareOutputTerm, comparison);
				}
			}	
			
			for(String notConstVarName: dependLHOutputVars){
				Term symbolicValue = mapValues.get(notConstVarName);
				Term comparison = termBuilder.equals(termBuilder.zTerm(observedOutputs.get(notConstVarName).toString()), symbolicValue);
				compareOutputTerm = termBuilder.and(compareOutputTerm, comparison);
			}	
			compareOutputTerm = ptcLowInput.replacePVByNameAndBranch(compareOutputTerm, 1);
			return compareOutputTerm;
		}else{			
			return termBuilder.ff();
		}				
	}
	
	/*
	 * browse all observable variables whose symbolic output value is constant or depends only on L
	 * and compare their output values with corresponding values observed in experiment
	 * */
	private boolean matchByConstantAndLowDenpendOnly(Experiment experiment){
		boolean match = true;
		
		Map<String, Long> observedOutputs = experiment.getObservableOutputs();	
		for(String varName: constantOutputVars){
			Term symbolicValue = mapValues.get(varName);
			if(TermParser.getIntegerValue(symbolicValue)!= observedOutputs.get(varName).longValue()){
				//not match, get rid of this path
				match = false;
				break;
			}
		}
		//System.out.println("match1: " + match);
		if(match){
			Map<String,Long> lowInputs = experiment.getLowInputs();
			for(String varName: lowDependOutputVars){
				//System.out.println("low-depend-only var name: " + varName);
				Term symbolicValue = mapValues.get(varName);
				if(TermUtil.computeLong(symbolicValue, lowInputs)!= observedOutputs.get(varName).longValue()){
					//not match, get rid of this path
					match = false;
					break;
				}
			}
		}
		//System.out.println("match2: " + match);
		/*
		 * check observable output depending only on H and has been matched before
		 * */		
		if(match){
			for(String varName: mapHighDependOutputVars.keySet()){
				if(mapHighDependOutputVars.get(varName)!=null){
					if(observedOutputs.get(varName).longValue()!= mapHighDependOutputVars.get(varName)){
						//not match, get rid of this path
						match = false;
						break;
					}
				}
			}
		}
		//System.out.println("match3: " + match);
		return match;
	} 
	
	private void constructElement4HybridDomain(){
		listMapHybridValues = new LinkedList<Map<String,Term>>();
		listSymbols = new LinkedList<String>();
		if(constantOutputVars.size()==mapValues.size()){ //all values are constant
			listMapHybridValues.add(mapValues);
		}
		else if(dependLHOutputVars.size()==0){ //there is no symbolic output values depending on both L and H
			Map<String,Term> newMapValues= new HashMap<String,Term>();
			for(String varName: constantOutputVars){
				newMapValues.put(varName, mapValues.get(varName));
			}
			/*
			 * for each symbolic output value containing low vars or high vars, we create a corresponding new fresh symbolic value
			 * */
			int id = 0;
			for(String varName: lowDependOutputVars){
				Term sTerm = getSymbolicTerm(mapValues.get(varName), id);
				newMapValues.put(varName, sTerm);
				listSymbols.add(sTerm.toString());
				id++;
			}
			for(String varName: mapHighDependOutputVars.keySet()){
				Term sTerm = getSymbolicTerm(mapValues.get(varName), id);
				newMapValues.put(varName, sTerm);
				listSymbols.add(sTerm.toString());
				id++;
			}
			System.out.println("newMapValues: " + newMapValues);
			listMapHybridValues.add(newMapValues);
		}else{
			/*
			 * for the case that there exists a symbolic output depends on both L and H, we create a number of symbolic value representing for all possible concrete values
			 * number of symbolic value should depend on specific program and is decided by attacker 
			*/
			Map<String,Term> newMapValues= new HashMap<String,Term>();
			for(String varName: constantOutputVars){
				newMapValues.put(varName, mapValues.get(varName));
			}
			/*
			 * for each symbolic output value containing low vars or high vars, we create a corresponding new fresh symbolic value
			 * */
			int id = 0;
			for(String varName: lowDependOutputVars){
				Term sTerm = getSymbolicTerm(mapValues.get(varName), id);
				newMapValues.put(varName, sTerm);
				listSymbols.add(sTerm.toString());
				id++;
			}
			for(String varName: mapHighDependOutputVars.keySet()){
				Term sTerm = getSymbolicTerm(mapValues.get(varName), id);
				newMapValues.put(varName, sTerm);
				listSymbols.add(sTerm.toString());
				id++;
			}
			/*
			 * add 3 symbolic values (should be a parameter)
			 * */
			int numSymbValue = 2;// should be a parameter
			Map<String, List<Term>> mapSymbolicValues = new HashMap<String, List<Term>>(); //each variable is mapped by 3 symbolic values
			for(String varName: dependLHOutputVars){		
				List<Term> listSTerm = new LinkedList<Term>();
				for(int j=0;j<numSymbValue;j++){										
					Term sTerm = getSymbolicTerm(mapValues.get(varName), id,j);
					listSTerm.add(sTerm);					
					id++;
				}
				mapSymbolicValues.put(varName, listSTerm);
			}
			
			/*now, we create all possible combinations of symbolic values
			 using tree structure
			*/
			TreeMapTerm treeMapTerm = new TreeMapTerm();			
			for(String varName: mapSymbolicValues.keySet()){
				List<Term> listSymbolicValue = mapSymbolicValues.get(varName);
				List<TreeMapTerm> children = new LinkedList<TreeMapTerm>();
				for(Term value: listSymbolicValue){
					Map<String,Term> newMap = new HashMap<String,Term>();
					newMap.put(varName, value);
					TreeMapTerm child = new TreeMapTerm(newMap);
					children.add(child);
				}
				List<TreeMapTerm> leaves = treeMapTerm.getAllLeaves();
				for(TreeMapTerm leaf: leaves){
					leaf.addChildren(children);
				}
			}
			
			for(TreeMapTerm leaf: treeMapTerm.getAllLeaves()){
				Map<String,Term> mapSValues = leaf.getMapTerm();
				mapSValues.putAll(newMapValues);
				listMapHybridValues.add(mapSValues);
			}			
		}
		
	}
	
	/*
	 * construct string used as name of symbolic value
	 * */
	private String getNameForSymbolicValue(int i){
		String result = "_s_";
		result += riskyPath.getModelNode().getIdx();
		result +=riskyPath.getModelNode().getNodeDetail().getIndex();
		result +=i;
		return result;
	}
	
	private Term getSymbolicTerm(Term valueTerm, int id){
		String sName = getNameForSymbolicValue(id);
		TermBuilder tb = riskyPath.getMethod().getServices().getTermBuilder();
		return tb.var(new LocationVariable(new ProgramElementName(sName),valueTerm.sort()));
		 
	}
	
	/*
	 * construct string used as name of symbolic value
	 * */
	private String getNameForSymbolicValue(int i, int j){
		String result = "_s_";
		result += riskyPath.getModelNode().getIdx();
		result +=riskyPath.getModelNode().getNodeDetail().getIndex();
		result +="_"+i;
		result +="_"+j;
		return result;
	}
	
	private Term getSymbolicTerm(Term valueTerm, int id1, int id2){
		String sName = getNameForSymbolicValue(id1,id2);
		TermBuilder tb = riskyPath.getMethod().getServices().getTermBuilder();
		return tb.var(new LocationVariable(new ProgramElementName(sName),valueTerm.sort()));
		 
	}
	
	public List<String> getDependLHOutputVars() {
		return dependLHOutputVars;
	}

	public RiskyPath getRiskyPath() {
		return riskyPath;
	}

	public List<Map<String, Term>> getListMapHybridValues() {
		return listMapHybridValues;
	}

	public List<String> getListSymbols() {
		return listSymbols;
	}

	public Map<String, Long> getMapHighDependOutputVars() {
		return mapHighDependOutputVars;
	}

	public void resetMapHighDependOutputVars(){
		Set<String> vars = mapHighDependOutputVars.keySet();
		for(String var: vars){
			mapHighDependOutputVars.put(var, null);
		}
	}
	
	/*
	 * because of the assumption that H is unchanged
	 * if experiment matches to riskyPath, then we know exactly the value of observable outputs that depend only on H 
	 * */
	public void updateMapHighDependOutputVars(Experiment experiment){
		Map<String,Long> outValues = experiment.getObservableOutputs();
		Set<String> setHighDependVars = mapHighDependOutputVars.keySet();
		for(String var: setHighDependVars){
			mapHighDependOutputVars.put(var, outValues.get(var));
		}
	}
	
}




