package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

public class MinLeakageMaximizer extends LeakageMaximizer{

	public MinLeakageMaximizer(List<PPCountingResult> listCountingResults,
			Services services, List<String> listLowVars,String optSolver) {
		super(listCountingResults, services, listLowVars, optSolver,null); //we dont need the number of possible high values
		/*
		 * print list of all counting solutions
		 * */
		
		extract2ListMatchableCountingSolution();
	}

	
	/*
	 * compute Min-entropy-leakage for the case all counting term is constant
	 * */
	protected OptimalSolution resolveConstantSolution(MatchableCountingSolution matchCountSolution){
		/*
		 * calculate scaled min-entropy-leakage
		 * because MELeak = log|O_Lj|, we have only one counting term fo each matchable counting solution
		 * */
		double optimizeValue = TermParser.getBigIntegerValue(matchCountSolution.getListCountTerms().get(0)).doubleValue();
		
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		return new OptimalSolution(solution, optimizeValue);
	}
	
	protected OptimalSolution resolve4UniqueSolution(MatchableCountingSolution matchCountSolution){
		Map<String,Long> solution = matchCountSolution.getUniqueSolution();		 
		Term countTerm= matchCountSolution.getListCountTerms().get(0);		
		double optimizeValue = (double)TermUtil.computeLong(countTerm, solution);		
		return new OptimalSolution(solution, optimizeValue);
	}
	
	protected OptimalSolution findGlobalOptimalSolution(List<OptimalSolution> listSolution){
		return findMaximumSolution(listSolution);
	}

	@Override
	protected void extract2ListMatchableCountingSolution() {
	/*	System.out.println("start extracting " + listCountingResults.size() + " solutions to list of matchable counting solution!");
		CountingResultTree countTree = new CountingResultTree();
		for(PPCountingResult countResult: listCountingResults){			
			for(CountingResultTree leaf: countTree.getAllLeaves()){
				List<CountingResultTree> leaves = new LinkedList<CountingResultTree>();				
				for(CountingSolution condResult: countResult.getListResults()){
					if(!TermParser.isBooleanFalse(condResult.getCondition()))
						leaves.add(new CountingResultTree(condResult));
				}		
				leaf.addChildren(leaves, services);
			}
		}
		//System.out.println("all leaves have been added!");
		//remove all leaf that don't have enough children (=listCountingResults.size)
		List<CountingResultTree> allLeaves = countTree.getAllLeaves();
		System.out.println("all leaves have been added! number of leaves: " + allLeaves.size());
		listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
		for(CountingResultTree tre: allLeaves){
			List<Term> listCountTerms = tre.getListCountTerms();
			if(listCountTerms.size() == listCountingResults.size()){
				Term condition = tre.getConditionTerm();						
				Z3Solver z3 = new Z3Solver(condition, services);
				Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
				if(uniqueModel!=null){
					if(uniqueModel.second==1) //there is only one model
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,true));
					else
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));
				}
			}		
		}
		System.out.println("finish extracting! We found " + listMatchableSolutions.size() + " matchable solutions");*/			
		listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
		for(CountingSolution cSolution: listCountingResults.get(0).getListResults()){
			Term condition = cSolution.getCondition();
			Z3Solver z3 = new Z3Solver(condition, services);
			Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
			if(uniqueModel!=null){
				List<Term> countTerm = new LinkedList<Term>();
				countTerm.add(cSolution.getValue());
				if(uniqueModel.second==1) //there is only one model
					listMatchableSolutions.add(new MatchableCountingSolution(countTerm, condition,uniqueModel.first,true));
				else
					listMatchableSolutions.add(new MatchableCountingSolution(countTerm, condition,uniqueModel.first,false));
			}
		}		
		System.out.println("finish extracting! We found " + listMatchableSolutions.size() + " matchable solutions");		
	}


	@Override
	protected OptimalSolution findOptimalSolution4SingleCase(
			MatchableCountingSolution matchCountSolution) {
		
		return findOptimalSolution4SingleCase(matchCountSolution, KEGConstant.MIN_ENTROPY);

	}


	/*
	 * min-entropy-based leakage = ln(bestSolution.optimalValue)/ln(2)
	 * */
	@Override
	protected double computeLeakage(OptimalSolution bestSolution) {
		return Math.log(bestSolution.getOptimizeValue())/Math.log(2);
	}
	
	/*
	 * add zero result into each PPCountingResult 
	 * */
	protected void resolvePPCountingResult(){		
		for(PPCountingResult countResult: listCountingResults){
			countResult.setListResults(countResult.replaceOrCondition());			
		}		
	}
}

