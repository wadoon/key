/**
 * 
 */
package de.tud.exploitgen.detectleak.exploit.codegenerator;


import java.util.*;

import org.key_project.util.collection.ImmutableList;

import com.csvanefalk.keytestgen.backend.AbstractJavaSourceGenerator;
import com.csvanefalk.keytestgen.backend.junit.JUnitConverterException;
import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelArrayInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ConcreteArrInterp;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.exploit.ExploitModel;
import de.tud.exploitgen.detectleak.exploit.ExploitTestCases;
import de.tud.exploitgen.detectleak.exploit.ExploitTestSuite;
import de.tud.exploitgen.detectleak.exploit.ExploitTestTransformer;
import de.tud.exploitgen.detectleak.specification.declassification.CDRExtractor;
import de.tud.exploitgen.detectleak.specification.declassification.DeclassificationCenter;
import de.tud.exploitgen.detectleak.specification.noninterference.IFBarrier;
import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
//import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.smt.model.Heap;
import de.uka.ilkd.key.smt.model.Model;
import de.uka.ilkd.key.smt.model.ObjectVal;
import de.uka.ilkd.key.testgen.Assignment;
import de.uka.ilkd.key.testgen.RefEx;
/**
 * this class generates JUnit test for checking non-interference property of program 
 * @author Huy Do
 *
 */
public class JUnitExploitGenerator extends AbstractJavaSourceGenerator{
   private final ExploitTestSuite exploitTestSuite;
   
   /**
    * Imports to be included in this test class
    */
   private final HashSet<String> imports = new HashSet<String>();
   
   /**
    * The name of the class for which the test suite is being generated.
    * Kept for the purpose of naming and type declaration.
    */
   private String className = "X";
   
   /**
    * Used to differentiate between the names of test cases.
    */
   private int ID_METHOD = 0;
  
     
   /**
    * The name of the container for the result value (if any) resulting
    * from the invocation of a method being tested. This value is used in
    * the assertion process, and must not conflict with the names of any
    * parameter values.
    */
   private static final String EXECUTION_RESULT = "result";

   /**
    * The name of the root variable (i.e. the variable pointing to the
    * instance of the object that has the methods to be tested).
    */
   private String SELF = "self";
   
   /**
    * @param exploitTestSuite
 * @param services TODO
    */
   public JUnitExploitGenerator(ExploitTestSuite exploitTestSuite) {
      super();
      this.exploitTestSuite = exploitTestSuite; 
   }
   
   /**
    * Writes the getField method.
    * @source: Christopher
    */
   private void writeGetFieldMethod() {

       writeComment("Gets the field of a given object", true);
       writeMethodHeader(null,
                         "private",
                         new String[]{"<T>"},
                         "T",
                         "getFieldValue",
                         new String[]{"Object instance", "String fieldName"},
                         new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});

       writeIndentedLine("Field field = instance.getClass().getDeclaredField(fieldName);");
       writeNewLine();

       writeIndentedLine("field.setAccessible(true);");
       writeNewLine();

       writeIndentedLine("return (T)field.get(instance);");
       writeNewLine();

       writeClosingBrace();
   }
  
   /**
    * Writes the setField method.
    * @source: Christopher
    */
   private void writeSetFieldMethod() {

       writeComment("Sets a field of some object to a given value", true);
       writeMethodHeader(null,
                         "private",
                         null,
                         "void",
                         "setFieldValue",
                         new String[]{"Object instance", "String fieldName", "Object value"},
                         new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});

       writeIndentedLine("Field field = instance.getClass().getDeclaredField(fieldName);");
       writeNewLine();

       writeIndentedLine("field.setAccessible(true);");
       writeNewLine();

       writeIndentedLine("field.set(instance, value );");
       writeNewLine();

       writeClosingBrace();
              
   }
   
    
   /**
    * Given a {@link KTGModel}, this method will extract all instances of
    * {@link ModelInstance} from it.
    * @source: Christopher
    * @param model
    * @return
    */
   private List<ModelInstance> extractInstancesFromModel(final KTGModel model) {

       final List<ModelInstance> instances = new LinkedList<ModelInstance>();
       for (final ModelVariable variable : model.getVariables()) {
           if ((variable.getValue() instanceof ModelInstance) && !(variable.getValue() instanceof ModelArrayInstance)) {
               instances.add((ModelInstance) variable.getValue());
           }
       }
       return instances;
   }
   
   /**
    * Given a set of {@link ExploitTestCases} instances, this method will extract
    * put all {@link ModelInstance} declared in the model of each test case
    * into a single list.
    *
    * @param List<ExploitTestCases> the test cases
    * @return a list of all instances declared in all test cases models
    */
   private List<ModelInstance> collectInstances(final List<ExploitTestCases> testCases) {

       final List<ModelInstance> instances = new LinkedList<ModelInstance>();       
       for (final ExploitTestCases testCase : testCases) {
          for(final ExploitModel eModel: testCase.getExploitModel()){
              final List<ModelInstance> collectedInstances = extractInstancesFromModel(eModel.getModel1());
              instances.addAll(collectedInstances);
              break;
          }
       }
       return instances;
   }
   
    
   //create the content of JUnit file to check non-interference
   private void createExploitContent(){
      
      final List<ExploitTestCases> listExploitTestCases = exploitTestSuite.getListETC();      

      final KeYJavaClass klass = exploitTestSuite.getKeYJavaClass();
      

      /*
       * Collect the import assertions.
       */
      
      final List<ModelInstance> instances = collectInstances(listExploitTestCases);
      for (final ModelInstance instance : instances) {
          final String toImport = instance.getType();
          if(toImport!=null)
             imports.add(toImport);
      }
      
      writeImportClauses();
      
      /*
       * Get the name of the class being tested.
       */
      className = klass.getName();
      /*
       * Print the new class header
       */
      className = "Test" + className;
      
      writeClassHeader(null, "public", "", className, "TestCase");
      
      //check all ExploitTestCase
      for(ExploitTestCases exploitTestCases : listExploitTestCases){
         String methodName = exploitTestCases.getMethod().getName();
         /*
          * Create one test method for each tuple of test cases.
          */
         //create comment for the method and the specification
         IFBarrier spec=exploitTestCases.getSpec();
         writeComment("check method "+ methodName + " with noninterference specification: " + spec.getDeclaration(), true);
         //write the content of method
         writeTestMethods(exploitTestCases,spec);
      }

      /*
       * Create the fixture repository for this class
       */
      createFixtureRepository(listExploitTestCases);

      /*
       * Close the class body.
       */
      writeClosingBrace();

      //return new JUnitTestSuite(exploitTestSuite, name, getCurrentOutput());
   }
   
   /**
    * write all import clauses for the test class
    * */
   private void writeImportClauses(){
      /*
       * write the popular imports
       * */
      appendToOutput("import org.junit.*;\n");
      appendToOutput("import junit.framework.TestCase;\n");
      appendToOutput("import java.lang.reflect.*;\n");
      appendToOutput("import java.util.*;\n");

      /*
       * Write the specific imports.
       */
      for (final String importt : imports) {
          appendToOutput("import ");
          appendToOutput(importt);
          appendToOutput(";\n");
      }
      writeNewLine();
   }
   /**
    * Sets up the fixture repository for a given test class. This
    * repository will contain the object instances needed for the test
    * cases to run.
    *
    * @param testCases the test cases for the test class.
    */
   private void createFixtureRepository(final List<ExploitTestCases> testCases) {

       /*
        * Safeguard from first invocation errors.
        */
       if (testCases.isEmpty()) {
           return;
       }
       /*
        * Write the method for setting fields of objects.
        */
       writeSetFieldMethod();

       /*
        * Write the method for getting fields of objects.
        */
       writeGetFieldMethod();
   }
   
   /**
    * overload method writeClassHeader of parent class
    * Supplement information of parent class (should be a subclass of TestCase)
    * */
   private void writeClassHeader(final String[] annotations,
         final String visibility,
         final String modifier,
         final String name,
         final String parentClass) {

            if (annotations != null) {
            for (final String annotation : annotations) {
            writeIndentedLine(annotation + AbstractJavaSourceGenerator.NEWLINE);
            }
            }
            
            indent();           
            appendToOutput(visibility + " ");
            appendToOutput(modifier + " ");
            appendToOutput("class" + " ");
            appendToOutput(name);
            if((parentClass!=null)&&(!parentClass.trim().isEmpty())){
               appendToOutput(" extends " + parentClass);
            }
            appendToOutput(" {\n");
            
            increaseIndentation();
}
   
   
   /**
    * write test methods for a tuple of test cases, for each test case we creat a method
    * @param exploitTestCases, IFBarrier
    * @throws JUnitConverterException
    */
   private void writeTestMethods(final ExploitTestCases exploitTestCases,IFBarrier spec){       
           
       //write separated test case for each model  
       final KeYJavaMethod method=exploitTestCases.getMethod();
       final String methodName = "test_" + method.getProgramMethod().getName();
       for(ExploitModel eModel:exploitTestCases.getExploitModel()){
          //eModel.printModelInfo();
          writeNewLine();      
          /*
           * Write the method header.
           */          
          writeMethodHeader(new String[]{"@Test"},
                            "public",
                            null,
                            "void",
                            methodName + "_" + eModel.getLowVar().getIdentifier()+"_" + ID_METHOD++,
                            null,
                            new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});
          //write the content of method
          writeTestMethodContent(eModel,spec,method, exploitTestCases.getDeclCenter());
          
          writeClosingBrace();
       }  
      
   }
   
   /**
    * return suffix via branch 
    * */
   private String getSuffix(int branch){
     return "_" + branch;
   }
   
   
   
   /*
    * write declaration statement for each variable at each branch
    * */   
   private void writeVariableDeclaration(ModelVariable variable, int branch){
      String varName = variable.getIdentifier() + getSuffix(branch);      
      if((variable instanceof ModelArrayVariable)&&(variable.getValue() instanceof ModelArrayInstance)){         
          //if(((ModelArrayInstance)variable.getValue()).length()>0){
             String arrayType = variable.getTypeName();
             String baseType = arrayType.substring(0, arrayType.indexOf("[]"));
             String declaration = arrayType + " " + varName + " = " + "new" + " " + baseType +"[" 
                   + ((ModelArrayInstance)variable.getValue()).length() + "]";
             for(int i=1;i<((ModelArrayVariable)variable).dimension();i++){
                declaration +="[]";
             }
             declaration += ";" ;
             writeIndentedLine(declaration); 
          //}
      }else if (!variable.isPrimitive()){       
         /*
          * Declares and instantiates a reference typed instance.
          */   
         String runtimeType = variable.getRuntimeType();         
   	 
         writeIndentedLine(runtimeType + " " + varName + " = " + "new" + " " + runtimeType + "();");
      }else {
         /*
          * Declares and instantiates a primitive typed instance, but
          * only if they are parameters (other primitive values will[
          * be configured as part of the classes they are fields of).
          */
    	  //System.out.println(variable.getTypeName() + " " + varName + " = " + variable.getValue() + ";");
          writeIndentedLine(variable.getTypeName() + " " + varName + " = " + variable.getValue() + ";");
      }
   }
   
   /*
    * write assignment to set fields for reference variable
    * */
   private void writeSetFieldsForReference(ModelVariable variable, int branch){      
      final Object value = variable.getValue();
      if(value instanceof ModelArrayInstance && variable instanceof ModelArrayVariable){
         long length = ((ModelArrayInstance)value).length();
         if(length>0){
            final String variableIdentifier = variable.getIdentifier()+ getSuffix(branch);

            writeComment("Configure variable: " + variableIdentifier, false);
            /*using ConcreteArrayInterpretation*/
            ConcreteArrInterp arrInterp = ((ModelArrayVariable)variable).getArrInterp();
            if(arrInterp!=null){
               //assign all elements by else value
            	if(arrInterp.getElseValue()!=null){
	               writeIndentedLine("for (int i=0; i<" + variableIdentifier + ".length; i++)");
	               writeNewLine();
	               increaseIndentation();
	               writeIndentedLine(variableIdentifier + "[i] = " + arrInterp.getElseValue().toString() + ";" );               
	               decreaseIndentation();
	               writeNewLine();
            	}
                              
               //assign each element in Entries by corresponding value
               Map<int[],Object> entries = arrInterp.getEntries();
               if(!entries.isEmpty()){
                  for(int[] key: entries.keySet()){
                     Object entryValue = entries.get(key);
                     for(int i=0;i<key.length;i++){
                        if(0<=key[i] && key[i]<key.length){
                           writeIndentedLine(variableIdentifier + "[" + key[i] + "] = " + entryValue.toString() + ";");
                           writeNewLine();                           
                        }                        
                     }
                  }
               }
            }else{
            	/*
            	 * if ConcreteArrInterp field is not found, we simply instantiate array's elements from KTGModel
            	 * */
	            for(ModelVariable elements: ((ModelArrayInstance)value).getArrayElements()){               
	               if(elements.getArrayIdx()>=0)
	                  writeIndentedLine(variableIdentifier + "[" + elements.getArrayIdx() + "] = " + elements.getIdentifier() + getSuffix(branch) + ";");
	               else
	                  writeIndentedLine(variableIdentifier + "[" + 
	                        ExploitTestTransformer.transformExpression2String(elements.getArrayIdxTerm(), branch, SELF,exploitTestSuite.getKeYJavaClass().getEnvironment().getServices()) +
	                        "] = " + elements.getIdentifier() + getSuffix(branch) + ";");
	               writeNewLine();
	            }
            }
         }
      }else if (!variable.isPrimitive()) {
         //System.out.println(variable.getIdentifier() + " is object");
          final ModelInstance instance = (ModelInstance) value;

          if (!instance.getFields().isEmpty()) {
              final String variableIdentifier = variable.getIdentifier()+ getSuffix(branch);

              writeComment("Configure variable: " + variableIdentifier, false);

              for (final ModelVariable field : instance.getFields()) {

                  String fieldValueIdentifier = "";
                  /*if (field.getValue() instanceof ModelInstance) { 
                      fieldValueIdentifier = field.getIdentifier();
                  } else {
                      final Object fieldValue = field.getValue();
                      fieldValueIdentifier = fieldValue.toString();
                  }*/
                  fieldValueIdentifier = field.getIdentifier()+getSuffix(branch);
                  writeIndentedLine("setFieldValue(" + variableIdentifier + "," + "\"" + field.getVariableName() + "\"" + "," + fieldValueIdentifier + ");");
                  writeNewLine();
              }
          }
      }      
   }
   
   /**
    * write test fixture for a branch
    * */
   private void writeTestFixtureForBranch(ExploitModel eModel,int branch){
      /*
       * First, declare and assign values for necessary variables
       * */
      writeComment("Prepare for execution " + branch, false);
      KTGModel model=eModel.getModel(branch);    
      
      for (final ModelVariable variable : model.getVariables()) {
        // if(!variable.isParameter()){            
            writeVariableDeclaration(variable, branch);   
            writeNewLine();            
         //}         
      }        
      
      /*
       * Next, configure the needed instances properly.
       */
      for (final ModelVariable variable : model.getVariables()) {
          /*
           * Again, deal only with those variables which are not primitives.
           */
          if (!variable.isPrimitive()) {
             writeSetFieldsForReference(variable, branch);             
          }
      }      
     
   }
   
   
   
   /**
    * write the method invocation for each branch
    *
    * @param testCase
    */
   private void writeMethodInvocation(ExploitModel eModel, KeYJavaMethod method, int branch) {
       //SELF=getSelfName(eModel);
       SELF = eModel.getSELF_NAME();
       writeComment("Perform execution " + branch,false);      
       
       final String returnType = method.getReturnTypeAsString();
       String methodInvocation = "";
       if (!returnType.equals("void")) {
           methodInvocation += returnType + " " + EXECUTION_RESULT + getSuffix(branch)+ " = ";
       }

       methodInvocation += SELF + getSuffix(branch)+ "." + method.getProgramMethod().getName() + "(";
       final List<IProgramVariable> parameters = method.getParameters();

       for (int i = 0; i < parameters.size(); i++) {
           final String parameterName = parameters.get(i).name().toString();
           methodInvocation += parameterName +getSuffix(branch);
           if (i != (parameters.size() - 1)) {
               methodInvocation += ",";
           }
       }
       methodInvocation += ");";
       writeIndentedLine(methodInvocation);
       writeNewLine();
   }
   
     
   /**
    * write instruction to get and store the value of low variable when an execution finish
    * to avoid side-effect of self-composition (relating static variable)
    * revised: instead of getting directly field's value from object, we make a chain of getFieldValue
    * For example: to get self_1.f1.ff with self_1.f1= fo, we do not get ff directly from fo but we trace it from self_1  
    * the reason is self_1.f1 might be changed during the execution of self_1 to refer to another object
 * @param services TODO
    * */  
   
   private void writeAccessToLowVarOutput(ExploitModel eModel, int branch, Services services){
      ModelVariable lowVar = eModel.getLowVar();
	  String lowVarName = lowVar.getIdentifier();
      KTGModel model = eModel.getModel(branch);
      writeComment("Get the value of low variable " + lowVarName + " after execution " + branch, false);
     /* if(lowVar.isStatic()){
         
          * TODO: change to use the REAL Class name (for reference type)
          * 
         String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
         String typeName = lowVar.getTypeName();  
         //String className = exploitTestSuite.getKeYJavaClass().getName();
         String className = lowVar.getDeclareClassName();
         writeIndentedLine(typeName + " " + low_out + " = " + 
                           className+"." + lowVar.getVariableName()+";");
         writeNewLine();
      }else{*/
      
      if(model.hasVar(lowVarName)){ 
    	 
    	 lowVar = model.getVariable(lowVarName);
         //System.out.println("output low var " + lowVar.getIdentifier() +" type: " + lowVar.getTypeName());
         Stack<String> s = new Stack<String>();         
         if(lowVar.isArrayLength()){
            String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
            //String typeName = lowVar.getTypeName(); 
            String typeName = lowVar.getRuntimeType();
            //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
            String parentName = lowVar.getParentIdentifier();
            String valueRetrieval = typeName + " " + low_out + " = " + parentName + getSuffix(branch) + ".length;" ;
            s.push(valueRetrieval);
         }else if(lowVar.isArrayElement()){
            String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
            //String typeName = lowVar.getTypeName();
            String typeName = lowVar.getRuntimeType();
            //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
            String parentName = lowVar.getParentIdentifier();
            //TODO: revise to get array's element whose index value is a variable
            String valueRetrieval;
            if(lowVar.getArrayIdx()>=0){
               valueRetrieval = typeName + " " + low_out + " = " + parentName + getSuffix(branch) + "[" + 
                     lowVar.getArrayIdx() + "];" ;               
            }else{
               valueRetrieval = typeName + " " + low_out + " = " + parentName + getSuffix(branch) + "[" + 
                     ExploitTestTransformer.transformExpression2String(lowVar.getArrayIdxTerm(), branch,eModel.getSELF_NAME(), services) + "];" ;
            }
            s.push(valueRetrieval);
         }else if(lowVar.isPrimitive()){        
            String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
            //String typeName = lowVar.getTypeName();
            String typeName = lowVar.getRuntimeType();
            //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
            String parentName = lowVar.getParentIdentifier();
            String valueRetrieval = typeName + " " + low_out + " = ((" + ClassWrapper.wrapperClassName.get(typeName) + 
                  ")getFieldValue(" + parentName + getSuffix(branch) + "," + "\"" + lowVar.getVariableName() + "\"))." 
                  + ClassWrapper.getValueMethodName.get(typeName) + ";\n" ;
            s.push(valueRetrieval);
            /*writeIndentedLine(valueRetrieval);            
            writeNewLine();*/
         }else if(lowVar instanceof ModelArrayVariable){         
            //if(((ModelArrayInstance)variable.getValue()).length()>0){
            String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
            String parentName = lowVar.getParentIdentifier();         
            String typeName = lowVar.getRuntimeType();
            String valueRetrieval =typeName + " " + low_out + " = (" + typeName + 
                  ")getFieldValue(" + parentName + getSuffix(branch) + "," + "\"" + lowVar.getVariableName() + "\"); \n"  ;
            s.push(valueRetrieval);
         //}
         }else{
            String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
            //String typeName = lowVar.getTypeName();         
            String typeName = lowVar.getRuntimeType();
            //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
            String parentName = lowVar.getParentIdentifier();
            String valueRetrieval =typeName + " " + low_out + " = (" + typeName + 
                  ")getFieldValue(" + parentName + getSuffix(branch) + "," + "\"" + lowVar.getVariableName() + "\"); \n"  ;
            s.push(valueRetrieval);
         }
         
         lowVar = model.getVariable(lowVar.getParentIdentifier());
         if(lowVar!=null){
            while(lowVar.getParentIdentifier()!=null){         
                  String low_out = lowVar.getIdentifier() +getSuffix(branch);
                  //String typeName = lowVar.getTypeName();
                  String typeName = lowVar.getRuntimeType();
                  //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
                  String parentName = lowVar.getParentIdentifier();
                  String valueRetrieval = typeName + " " + low_out + " = (" + typeName + 
                        ")getFieldValue(" + parentName + getSuffix(branch) + "," + "\"" + lowVar.getVariableName() + "\"); \n"  ;
                  s.push(valueRetrieval);  
                  lowVar = model.getVariable(lowVar.getParentIdentifier());
            }
         }
         while(!s.empty()){
            writeIndentedLine(s.pop());
         }
      }else{
         /*if lowVar does not exist in model, we assign it as null value*/
         String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
         //String typeName = lowVar.getTypeName();         
         String typeName = lowVar.getRuntimeType();                 
         if(lowVar.isPrimitive())
            typeName = ClassWrapper.wrapperClassName.get(typeName);            
         String valueRetrieval =typeName + " " + low_out + " = null;"  ;
         writeIndentedLine(valueRetrieval);
      }
      
      //}
   }
   
   /**
    * write assert clause to check non-interference by comparing the output value of low variable in ExploitModel
    * it has the template: assertFalse(l1==l2)
    * */
   private void writeAssert2CompareLowOutput(ExploitModel eModel){
      ModelVariable lowVar = eModel.getLowVar();
      String low_out_1 = lowVar.getIdentifier()+"_out" + getSuffix(1);
      String low_out_2 = lowVar.getIdentifier()+"_out" + getSuffix(2);
      writeNewLine();
      writeIndentedLine("assertNotNull(" + low_out_1+");");
      writeNewLine();
      writeIndentedLine("assertNotNull(" + low_out_2+");");
      
      String assertClause="";
      if(lowVar.isPrimitive()){
         assertClause = low_out_1 + " == " + low_out_2; 
         assertClause = "assertTrue(" + assertClause + ");";
      }else if(lowVar instanceof ModelArrayVariable){
         assertClause = low_out_1 + " , " + low_out_2; 
         assertClause = "Assert.assertArrayEquals(" + assertClause + ");";
         
      }
      else{
         assertClause = low_out_1 + ".getClass().getName().equals(" + low_out_2 + ".getClass().getName())";
         assertClause = "assertTrue(" + assertClause + ");";
      }
      
      writeComment("assert that the value of low variable " + lowVar.getIdentifier() + " is not changed after performing two executions", false);
      writeIndentedLine(assertClause);
      writeNewLine();
   }
   
     
     
   /**
    * write assert clause to test declassification (conditional delimited release)
    * the concrete model should satisfy condition:
    * \forall escapes expression e: e(l1,h1) == e(l2,h2) \if c(cl1,h1) and c(l2,h2)
    * the logical clause has the format: 
    * (!(c1(cl1,h1) and c1(l2,h2)) || e1(l1,h1) == e1(l2,h2)) && (!(c2(cl1,h1) and c2(l2,h2)) || e2(l1,h1) == e2(l2,h2))
    * */
   private void writeAssert2DeclassificationByCompareEscapeClause(ExploitModel eModel, KeYJavaMethod method, DeclassificationCenter declCenter){
      if(method.hasEscapeHatches()){
          Services services = method.getServices();
         SELF=eModel.getSELF_NAME();
         ModelVariable lowVar=eModel.getLowVar();
         writeComment("Assert that the declassification (conditional delimited release) : \n" +
               " If the values of all escapes expression calculated by input values of both executions are the same, accordingly" +
               " or the conditions are not satisfied by both two executions, then the output value of low variable  " + lowVar + " is independent of all escapes expression", false);     
            
         //get all of declassification clause
         //List<Term> escapeHatchTerms = method.getDeclassificationTerms();
         //ImmutableList<DelimitedRelease> declassification = method.getEscapeHatches();
         for(CDRExtractor drExtractor: declCenter.getListCDRExtractors() ){              
            if (drExtractor.affect2Var(SELF, lowVar.getIdentifier())){
               /*
                * create equation of two escape hatches expressions interpreted in two paths
                * */ 
               
               ImmutableList<Term> escapeHatchTerms = drExtractor.getDelimitedRelease().escapeHatches;            
               //TestTransformer testTransformer = new TestTransformer(method.getServices());
               String compareClause="";         
               for(Term escapeTerm: escapeHatchTerms){
                    
                  Term declass1=escapeTerm;
                  Term declass2=escapeTerm;            
                              
                  compareClause += "(" + ExploitTestTransformer.transformExpression2String(declass1, 1, SELF, services) +
                                    " == " +
                                    ExploitTestTransformer.transformExpression2String(declass2, 2, SELF, services)+")";             
                  
                  compareClause += "&&";               
                 
               }        
               //eliminate the last "&&" in compareClause
               compareClause = compareClause.substring(0, compareClause.length()-2);
               
               /*
                * create contents for escape hatches conditions 
                * */
                           
               ImmutableList<Term> conditions = drExtractor.getDelimitedRelease().conditions; 
               String conditionClause1 = "";
               String conditionClause2 = "";
               if(conditions.size()>0){               
                  Term conditionTerm = drExtractor.getEscCondition();  
                                 
                  conditionClause1 += ExploitTestTransformer.transformExpression2String(conditionTerm, 1 , SELF, services);
                  conditionClause2 += ExploitTestTransformer.transformExpression2String(conditionTerm, 2 , SELF, services);
                  
               }
               String assertClause = "";
               if(conditions.size()>0){    
                  assertClause = "assertTrue(" + compareClause + 
                                 " || \n " + AbstractJavaSourceGenerator.TAB +
                                 "(!(" + conditionClause1 + " && " + conditionClause2 + ")));" ;
                  
               }else
                  assertClause = "assertTrue(" + compareClause + ");" ;
               writeIndentedLine(assertClause);
               writeNewLine();
            }
         }
      }                 
   }
   
   /**
    * write assert clause to check if the preconditions are satisfied with input values of two running
    * */
   private void writeAssert2CheckPrecondition(ExploitModel eModel,KeYJavaMethod method, int branch){
     
      String heapName=eModel.getSELF_NAME();
      List<Term> preconds = method.getPreconditions();
      String assertClause ="";
      //TestTransformer testTransformer =new TestTransformer(method.getServices());
    		  
      for(int i=0;i<preconds.size();i++){
         Term precond = KeYResourceHandler.removeDefaultPrecondition(preconds.get(i));
         precond = KeYResourceHandler.removeNonnullDefaultCondition(precond);
         //System.out.println(preconds.get(i));
         assertClause += ExploitTestTransformer.transformExpression2String(precond, branch , heapName, method.getServices());
         if(i<preconds.size()-1)
            assertClause += " && ";  
         
      }
      //System.out.println("check precondition:" + assertClause);
      if(!assertClause.equals("true")){
         writeComment("assert that the input values of execution " + branch +" satisfies all preconditions of method " + method.getName(), false);
         assertClause = "assertTrue(" + assertClause + ");" ;
         writeIndentedLine(assertClause);
         writeNewLine();
      }
   }
   
   /**
    * write test case for an exploit model
    * @param ExploitModel, IFBarrier, KeyJavaMethod
    * */
   private void writeTestMethodContent(ExploitModel eModel, IFBarrier spec, KeYJavaMethod method, DeclassificationCenter declCenter){
	  /*if(eModel.getSmtModel()!=null)
		  System.out.println("SMT Model used to generate exploit: \n" + eModel.getSmtModel().toString());*/
      //write test fixture for running 1
      //writeTestFixtureForBranch(eModel, 1);    
        writeTestFixtureForBranchUsingSMTModel(eModel, 1); 
      //write assert to check if the input values of running 1 satisfy the precondition or not
      //writeAssert2CheckPrecondition(eModel, method, 1);
      
      //write method invocations
      writeMethodInvocation(eModel, method, 1);
      writeAccessToLowVarOutput(eModel, 1, method.getServices());
      
      //write test fixture for running 2
      //writeTestFixtureForBranch(eModel, 2);      
      writeTestFixtureForBranchUsingSMTModel(eModel, 2); 
      //write assert to check if the input values of running 2 satisfy the precondition or not
      //writeAssert2CheckPrecondition(eModel, method, 2);
      
      writeMethodInvocation(eModel, method, 2); 
      writeAccessToLowVarOutput(eModel, 2, method.getServices());
      
      
     //write Assert clauses to check declassification (conditional delimited release)
      //writeAssert2DeclassificationByCompareEscapeClause(eModel, method, declCenter );     
                 
      
      //write assert clauses
      //writeAssert2CompareLowValueOutput(eModel);
      writeAssert2CompareLowOutput(eModel);     
   }
   
   public String getExploitTestContent(){
      try {
         createExploitContent();
      }
      catch (Exception e) {

         e.printStackTrace();
      }
      return getCurrentOutput();
   }

   
   public String getClassName(){
      return className;
   }
   
   private void writeTestFixtureForBranchUsingSMTModel(ExploitModel eModel,int branch){
	   Model smtModel= eModel.getSmtModel();
	   if(smtModel!=null){
		   //find the right heap
		   writeComment("Prepare for execution " + branch, false);
		   Heap branchHeap=null;
		   for(Heap heap:smtModel.getHeaps()){
			   if(heap.getName().equals(eModel.getModelNode1().getNodeDetail().getNode().getServices().getTypeConverter().getHeapLDT().getHeap().name().toString()+getSuffix(branch))){
				   branchHeap = heap;
				   break;
			   }
				   
		   }
		   if(branchHeap!=null){
			   KTGModel ktgModel = eModel.getModel(branch);
			   /*
			    * declare all object variables (TODO: some of them is redundant)
			    * */
			   for(ObjectVal o: branchHeap.getObjects()){
				   if (o.getName().equals("#o0") || o.getSort().name().toString().endsWith("Exception")) {
						continue;
					}
				   if (o.getSort() != null){
					   String sort = o.getSort().toString();
					   if(sort.endsWith("[]") ) {							
						   int length = o.getLength();
						   //declare array
						   writeIndentedLine(o.getSort() + " " + createObjectName(o,branch) + " = new " + sort.substring(0, sort.length()-2) +"[" + length +"];\n");
					   }else{
						   writeIndentedLine(o.getSort() + " " + createObjectName(o,branch) + " = new " + sort +"();\n");
					   }
				   }	
			   }
			   
			   /*
			    * assign value for the object (TODO: some of them is redundant)
			    * */
			   for(ObjectVal o: branchHeap.getObjects()){
				   if (o.getName().equals("#o0") || o.getSort().name().toString().endsWith("Exception")) {
						continue;
					}
				   if (o.getSort() != null){
					   String sort = o.getSort().toString();
					   if(sort.endsWith("[]") ) {							
						   int length = o.getLength();
						   //assign value for array's elements
						   
						   for(int i=0;i<length;i++){
							   writeIndentedLine(createObjectName(o, branch)+"["+i+"] = " + 
									   translateValueExpression(o.getArrayValue(i), branch) + ";\n");
							   
						   }
						   
					   }else{
						   //assign value for object's fields
						   for (final String f : o.getFieldvalues().keySet()) {
								
								if (f.contains("<") || f.contains(">")) {
									continue;
								}
								
								String fieldName = f.substring(f.lastIndexOf(":") + 1);
								fieldName = fieldName.replace("|", "");
								String val = o.getFieldvalues().get(f);
								
								writeIndentedLine("setFieldValue(" + createObjectName(o, branch) + "," + "\"" + fieldName + "\"" + "," + translateValueExpression(val, branch) + ");\n");

							}
					   }
				   }	
			   }

			   /*
			    * assign value for constants
			    * */	   
			   
			   for (final String c : smtModel.getConstants().keySet()){
				   if ( !c.equals("null")) {
						if(c.endsWith(getSuffix(branch))){
							String origName = getNameWithoutSuffix(c);
							//System.out.println("origName: " + origName);
							if(TermUtil.inListTerm(origName, eModel.getListFoundations())){
								String val = smtModel.getConstants().get(c);
								ModelVariable mv = ktgModel.getVariable(origName);
								if(mv!=null){
									writeIndentedLine(mv.getRuntimeType() + " " + c + " = " + translateValueExpression(val, branch) + ";\n");
								}
														
							}
						}
					}		
			   }
		   }
	   }else{
		   writeTestFixtureForBranch(eModel, branch);
	   }
   }
   
  /* private void writeVarDeclaration(Heap heap,int branch, String type, String varName, String value){
	   if(value.startsWith("#o")){
		   //resolve for object and array
		   ObjectVal o = null;
		   for(ObjectVal obj: heap.getObjects()){
			   if(obj.getName().equals(value)){
				   o = obj;
				   break;
			   }
		   }
		   if(o!=null){
			   if (o.getSort() != null){
				   String sort = o.getSort().toString();
				   if(sort.endsWith("[]") ) {	
					
					int length = o.getLength();
					//declare array
					writeIndentedLine(o.getSort() + " " + createObjectName(o) + " = new " + sort.substring(0, sort.length()-2) +"[" + length +"];");
					
					
					
					 * assign value for array's elements
					 * we also create a ConcreteArrInterp object for the array
					 * 
					
					for (int i = 0; i < length; i++) {
						String val = o.getArrayValue(i);
						val = translateValueExpression(val);
						ModelVariable element = ((ModelArrayVariable)object).searchArrayElement(i);
						if(element!=null){								
							element.setValueByString(val);
							if(element.isReferenceType()){
								instantiateObject(val, h, ktgModel);
							}
						}else{
							ModelVariable elementI = new ModelVariable(object.getIdentifier() + KEGConstant.SEPARATOR + "I"+i);
							elementI.setArrayIdx(i);
							elementI.setParentIdentifier(object.getIdentifier());
							//ModelInstance instance = ModelInstanceFactory.constructModelInstance(object.)
						}
						
						
					}
				}
			   }
												
		   }
	   }
	   //declare and assign value for variable
	   writeIndentedLine(type + " " + varName + " = " + translateValueExpression(value));
   }*/
   
 
   private String translateValueExpression(String val, int branch) {
	   
		if (val.contains("/")) {
			val = val.substring(0, val.indexOf("/"));
		}
		if (val.equals("#o0")) {
			return "null";
		}
		if(val.startsWith("#o"))
			val = val + getSuffix(branch);
		val = val.replace("|", "");
		val = val.replace("#", "_");
		return val;
	}
	
   
   private String getNameWithoutSuffix(String varName){
	   if(varName.endsWith("_1")||varName.endsWith("_2"))
		   return varName.substring(0, varName.length()-2);
	   else
		   return varName;
   }

   private String createObjectName(final ObjectVal o, int branch) {
		return o.getName().replace("#", "_")+getSuffix(branch);
	}

   
	   
}

