/**
 * 
 */
package de.tud.exploitgen.processing;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.processing.exploit.ExploitModelCreator;
import de.tud.exploitgen.processing.node.NodeDetail;
import de.tud.exploitgen.processing.specification.VariableClassifier;
import de.tud.exploitgen.solver.AbstractFormulaSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;

/**
 * @author Huy Do
 *
 */
public class TwoNodesProcessor {

   private final NodeDetail nodeD1,nodeD2; //two detail nodes representing two branches.   
   
   private KeYJavaMethod method;
   //private Services services;
   private VariableClassifier vc;
   
   public TwoNodesProcessor(NodeDetail node1, NodeDetail node2,KeYJavaMethod method,VariableClassifier vc) throws TermTransformerException, ProofInputException {
      super();
      this.nodeD1 = node1;
      this.nodeD2 = node2;
      this.method=method;
      this.vc=vc;      
   }
 
   /*
    * Because of conditional value, one node can contain more than one model.
    * for each model at one node, we can consider it as a branch (fake branch)
    * For each pair of fake branches, we have unique ExploitModel object, and we can create from them several insecure formulas,
    * each insecure formula corresponds with a target ModelVariable.
    * this method gets all possible insecure formulas and parse them into a suitable map structure
    * */
   private Map<ExploitModel,Map<ModelVariable, Term>> getMapFormulas() throws ProofInputException{
      Map<ExploitModel,Map<ModelVariable, Term>> result = new HashMap<ExploitModel,Map<ModelVariable, Term>>();
      ExploitModelCreator eModelCreator = new ExploitModelCreator(nodeD1, nodeD2);
      List<Term> listArtificialVars = eModelCreator.getSynthesisArtificialVar();
      Term nodeConstraint1 = nodeD1.getConstraint();
      Term nodeConstraint2 = nodeD2.getConstraint();
      System.out.println("nodeD1.size: " + nodeD1.getModels().size()+ " ; nodeD2.getIndex(): " + nodeD2.getIndex()); 
      if(nodeD1.getIndex()==nodeD2.getIndex()){
       //if nodeD1 and nodeD2 is the same, we can eliminate redundant by enforcing idx2 start from idx1 not 0
         for(int idx1 =0; idx1 < nodeD1.getModels().size(); idx1++)
            for(int idx2 = idx1; idx2<nodeD2.getModels().size(); idx2++ ){
               ExploitModel eModel = eModelCreator.getMergedExploitModel(idx1, idx2);             
               FormulaBuilder fb = new FormulaBuilder(eModel, method, vc, listArtificialVars, nodeConstraint1, nodeConstraint2);
               Map<ModelVariable, Term> formulasOfVar = fb.getAllInterferenceFormula();
               result.put(eModel, formulasOfVar);
            }
      }else{
         for(int idx1 =0; idx1 < nodeD1.getModels().size(); idx1++)
            for(int idx2 = 0; idx2<nodeD2.getModels().size(); idx2++ ){
               ExploitModel eModel = eModelCreator.getMergedExploitModel(idx1, idx2);             
               FormulaBuilder fb = new FormulaBuilder(eModel, method, vc, listArtificialVars, nodeConstraint1, nodeConstraint2);
               Map<ModelVariable, Term> formulasOfVar = fb.getAllInterferenceFormula();
               result.put(eModel, formulasOfVar);
            }
      }
      return result;
   }
   
   private List<ModelVariable> solveFormula(Term iTerm){
      AbstractFormulaSolver fs=new Z3Solver(iTerm);      //use Z3 solver
      List<ModelVariable> result = fs.solveFormula();      
      return result;
   }
   
   /*
    * get all exploit models by instantiating them using concrete models taken from SMT Solver
    * */
   public List<ExploitModel> getAllExploitModels() throws ProofInputException{
      List<ExploitModel> result = new LinkedList<ExploitModel>();
      Map<ExploitModel,Map<ModelVariable, Term>> mapEModelFormulas = getMapFormulas();
      
      for(ExploitModel eModel: mapEModelFormulas.keySet()){
         Map<ModelVariable,Term> mapVarTerm = mapEModelFormulas.get(eModel);
         for(ModelVariable lowVar: mapVarTerm.keySet()){                  
            Term iTerm = mapVarTerm.get(lowVar);
            System.out.println(iTerm);
            List<ModelVariable> concreteModel = solveFormula(iTerm);
            if(concreteModel!=null){      
               //assign values for variables
               ExploitModel eModelResult = new ExploitModel(eModel);               
               eModelResult.setLowVar(lowVar); //we are working with this low variable      
               eModelResult.resetPrimitiveValue();
               eModelResult.instantiateExploitModel(concreteModel);
               //exploitModel.printModelInfo();
               System.out.println("A vulnerability detected: secret information could be leaked through variable " + eModelResult.getLowVar().getIdentifier() );
               result.add(eModelResult);
            }
         }         
      }
     
      return result;
   }
}
