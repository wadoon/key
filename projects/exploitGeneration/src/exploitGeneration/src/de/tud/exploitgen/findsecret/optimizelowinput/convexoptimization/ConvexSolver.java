package de.tud.exploitgen.findsecret.optimizelowinput.convexoptimization;

import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;

public abstract class ConvexSolver {
	//protected CountingResultTree countTree;
	protected List<MatchableCountingSolution> listMatchCountSolutions;
	protected Services services; //contain necessary stuffs for handling Term
	public abstract Map<String, Long> findSolution();
	public ConvexSolver(List<MatchableCountingSolution> listMatchCountSolutions, Services services) {
		super();
		this.listMatchCountSolutions = listMatchCountSolutions;
		this.services = services;
	}	
	
	protected OptimalSolution findSolutionForAllConstantValues(MatchableCountingSolution matchCountSolution){
		/*
		 * calculate scaled shannon entropy
		 * */
		double optimizeValue = 0;
		for(Term value: matchCountSolution.getListCountTerms()){
			long cG = TermParser.getIntegerValue(value);
			if(cG>0)
				optimizeValue += cG * Math.log(cG);			
		}
		
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		return new OptimalSolution(solution, optimizeValue);
	}
	
	protected OptimalSolution resolve4UniqueSolution(MatchableCountingSolution matchCountSolution){
		Map<String,Long> solution = matchCountSolution.getUniqueSolution();
		double optimizeValue = 0;
		for(Term countTerm: matchCountSolution.getListCountTerms()){
			long cG = TermUtil.computeLong(countTerm, solution);
			if(cG>0){
				optimizeValue += cG * Math.log(cG);	
			}			
		}
		return new OptimalSolution(solution, optimizeValue);
	}
	
}
