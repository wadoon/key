/**
 * 
 */
package de.tud.exploitgen.processing.node;

import java.util.LinkedList;
import java.util.List;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;

/**
 * this class contains all information that is relevant to a node of symbolic execution tree 
 * all information is collected while parsing symbolic execution tree
 * this information is useful for checking noninterference and creating exploit model
 * @author Huy Do
 *
 */
public class NodeDetail {
   private final IExecutionNode<?> node; //the node that is resolved
   /*
    * model of model variables and artificial variables extracted from node
    * use to check noninterference and create exploit model 
    * */
   private final List<Model> models; //due to conditional values, there might be more than one models corresponding to a node
   private final List<Term> artificialVariables;  
   private final Term constraint; //useful constraint of node, it also contains path condition 
   private final String selfName;
   private final Term allConstraints; //all available constraints of node
   private List<Term> listArrays; //list of all arrays terms detected
   private List<Term> listArrayElements; //list of array's elements
   

   private int index; //index of node in list node
    /**
    * @param node
    * @param models
    * @param artificialVariable
    * @param constraint
    * @param selfName
    */
   public NodeDetail(IExecutionNode<?> node, List<Model> models,
         List<Term> listArrays, List<Term> listArrayElements,     
         List<Term> artificialVariable, Term constraint, Term allConstraints, String selfName) {
      super();
      this.node = node;
      this.models = models;
      this.listArrays = listArrays;
      this.listArrayElements = listArrayElements;
      this.artificialVariables = artificialVariable;
      this.constraint = constraint;
      this.allConstraints = allConstraints;
      this.selfName = selfName;
      index = -1;
   }

   



   /**clone constructor*/
   public NodeDetail(NodeDetail nd){
      //System.out.println("original model::: \n" + nd.toString());
      this.node = nd.node;
      this.constraint = nd.constraint;
      this.artificialVariables = nd.artificialVariables;
      this.listArrays = nd.listArrays;
      this.listArrayElements = nd.listArrayElements;
      this.selfName = nd.selfName;
      this.allConstraints = nd.allConstraints;
      //model must be deeply cloned
      this.models = new LinkedList<Model>();
      for(Model model: nd.models)
         this.models.add(Model.constructModel(model));
      //System.out.println("cloned model::: \n" + this.model.toString());
      this.index = nd.index;
      //this.model.resetPrimitiveValue();
   }
   
   /**
    * @return the node
    */
   public IExecutionNode<?> getNode() {
      return node;
   }

   /**
    * @return the list of model
    */
   public List<Model> getModels() {
      return models;
   }
   
   public Model getModel(int i){
      return models.get(i);
   }

   /**
    * @return the artificialVariable
    */
   public List<Term> getArtificialVariable() {
      return artificialVariables;
   }

   /**
    * @return the constraint
    */
   public Term getConstraint() {
      return constraint;
   }

   
   
   /**
    * @return the heapName
    */
   public String getHeapName() {
      return selfName;
   }

   public boolean isDescendantOfMC(){
      return NodeParser.isDescendantOfMethodContract(node);
   }
   
   public boolean isDescendantOfLI(){
      return NodeParser.isDescendantOfLoopInvariant(node);
   }   
   
   public boolean wellLoopInvariantAncestor(){
      if(isDescendantOfLI()){
         return NodeParser.getLoopInvariantAncestor(node).isInitiallyValid();
      }
      return false;
   }   
   
   public Term getPathCondition() throws ProofInputException{
      return node.getPathCondition();
   }

   public int getIndex() {
      return index;
   }

   public void setIndex(int index) {
      this.index = index;
   }
  
   public Term getAllConstraints() {
      return allConstraints;
   }


   public List<Term> getListArrays() {
      return listArrays;
   }


   public List<Term> getListArrayElements() {
      return listArrayElements;
   }
   
   
   
}
