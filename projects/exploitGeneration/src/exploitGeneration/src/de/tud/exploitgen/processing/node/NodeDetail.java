/**
 * 
 */
package de.tud.exploitgen.processing.node;

import java.util.List;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;

/**
 * this class contains all information that is relevant to a node of symbolic execution tree 
 * all information is collected while parsing symbolic execution tree
 * this information is useful for checking noninterference and creating exploit model
 * @author Huy Do
 *
 */
public class NodeDetail {
   private final IExecutionNode<?> node; //the node that is resolved
   /*
    * model of model variables and artificial variables extracted from node
    * use to check noninterference and create exploit model 
    * */
   private final Model model;
   private final List<Term> artificialVariable;
   
   private final Term constraint; //useful constraint of node, it also contains path condition 
   private final String heapName;
   /**
    * @param node
    * @param descendantMC
    * @param descendantLI
    * @throws ProofInputException 
    * @throws IllegalFormulaException 
    */
   public NodeDetail(IExecutionNode<?> node) throws ProofInputException, IllegalFormulaException {
      super();
      this.node = node;   
      
      //extract information
      NodeInvestigator ni = new NodeInvestigator(node.getServices());
      constraint = ni.getUsefulConstraint(node);
      ni.constructModel(node); //construct Model of ModelVariable and artificial variables
      artificialVariable = ni.getArtificialVars();
      model = ni.getModel();
      heapName = ni.getHEAP_NAME();
   }
   
   /**clone constructor*/
   public NodeDetail(NodeDetail nd){
      //System.out.println("original model::: \n" + nd.toString());
      this.node = nd.node;
      this.constraint = nd.constraint;
      this.artificialVariable = nd.artificialVariable;
      this.heapName = nd.heapName;
      //model must be deeply cloned
      this.model = Model.constructModel(nd.model);
      //System.out.println("cloned model::: \n" + this.model.toString());
      
      //this.model.resetPrimitiveValue();
   }
   
   /**
    * @return the node
    */
   public IExecutionNode<?> getNode() {
      return node;
   }

   /**
    * @return the model
    */
   public Model getModel() {
      return model;
   }

   /**
    * @return the artificialVariable
    */
   public List<Term> getArtificialVariable() {
      return artificialVariable;
   }

   /**
    * @return the constraint
    */
   public Term getConstraint() {
      return constraint;
   }

   
   
   /**
    * @return the heapName
    */
   public String getHeapName() {
      return heapName;
   }

   public boolean isDescendantOfMC(){
      return NodeParser.isDescendantOfMethodContract(node);
   }
   
   public boolean isDescendantOfLI(){
      return NodeParser.isDescendantOfLoopInvariant(node);
   }   
   
   public boolean wellLoopInvariantAncestor(){
      if(isDescendantOfLI()){
         return NodeParser.getLoopInvariantAncestor(node).isInitiallyValid();
      }
      return false;
   }   
   
   public Term getPathCondition() throws ProofInputException{
      return node.getPathCondition();
   }
   
}
