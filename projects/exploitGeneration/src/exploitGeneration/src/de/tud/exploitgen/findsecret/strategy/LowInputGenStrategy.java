package de.tud.exploitgen.findsecret.strategy;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.Experiment;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.MinLeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

public abstract class LowInputGenStrategy {
	protected SISupporter siSupporter;

	public LowInputGenStrategy(SISupporter siSupporter) {
		super();
		this.siSupporter = siSupporter;
	}
	
	public abstract Map<String, Long> findBestLowInput() throws IOException;
	
	protected Map<String,Long> findUsefulLowInput(){
		BadMethod badMethod = siSupporter.getBadMethod();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term conditionL = tb.and(avoidUsedInput(), avoidAlwayMatchUselessPathsByInput(),inputMatchRiskyPaths());
		Z3Solver z3 = new Z3Solver(conditionL,badMethod.getMethod().getServices());
		List<ModelVariable> resultL = z3.solveFormula2GetListModelVariable();
		if(resultL!=null){
			Map<String,Long> mapLowInput = new HashMap<String, Long>();
			VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
			//initiate the value for low inputs to make sure that all low inputs are assigned by default value (0)
			for(String lowVar: vc.getListLowVars())				
				mapLowInput.put(lowVar, (long)0);	
			
			//extract the value of low inputs
			for(ModelVariable mv: resultL){
				if(vc.isLow(mv)){
					mapLowInput.put(mv.getIdentifier(), (long)mv.getValue());
				}				
			}
			return mapLowInput;
		}
		return null;
	}
	
	/*
	 * simple idea: we should not conduct the same experiment again (one is too enough :D)
	 * return formula: \forall 0<=k<j: L_j \neq L_k 
	 * */
	protected Term avoidUsedInput(){
		BadMethod badMethod = siSupporter.getBadMethod();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term result = tb.tt();
		for(Experiment experiment: siSupporter.getUsedExperiments()){
			Map<String,Long> mapLowInputs = experiment.getLowInputs();
			Term aggDiffTerm = tb.ff();
			for(Term lowVar: siSupporter.getListLowVarTerms()){
				Term diffTerm = tb.not(tb.equals(lowVar, tb.zTerm(mapLowInputs.get(lowVar.toString()).intValue())));
				aggDiffTerm = tb.or(aggDiffTerm,diffTerm);
			}
			result = tb.and(result, aggDiffTerm);
		}
		return result;
	}
	
	/*
	 * if the low input always match experiment to a risky path whose outputs are constant or depend only on L, then it is bad low input
	 *  if the low input always match experiment to a matched risky path whose outputs depend only on H, then it is bad low input
	 * return formula: \forall i \in Risk_L \cup Risk_Const: (\exists H: currentKnowledge(H) && !(pc_i(L_j,H) )  &&
	 * \forall i \in Risk_H and matched(i): (\exists H: currentKnowledge(H) && !(pc_i(L_j,H) )  
	 * */
	protected Term avoidAlwayMatchUselessPathsByInput(){
		BadMethod badMethod = siSupporter.getBadMethod();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term result = tb.tt();
		//Term result = currentKnowledge;
		List<RiskyPath> listAvoidPaths = badMethod.getRiskConst_RiskL_MatchedRiskH();
		for(RiskyPath rp: listAvoidPaths){
			Term existH = tb.and(siSupporter.getCurrentKnowledge(), tb.not(rp.getPathCondition()));
			existH = tb.ex(siSupporter.getListQuantifiedHighVar(), existH);
			result = tb.and(result,existH);
			
			//Term forallH = tb.and(currentKnowledge, tb.not(rp.getPathCondition()));
			//Term forallH = tb.not(rp.getPathCondition());
			//Term forallH = tb.not(tb.ex(listQuantifiedHighVar, rp.getPathCondition()));
			//result = tb.and(result,forallH);
		}
		return result;		
	}


	/*
	 * low input L_j must satisfy that p(L_j,H) can be ascribed to path i \in Risk
	 * exists H: pc_i(L_j,H) true
	 * */
	protected Term inputMatchRiskyPaths(){
		BadMethod badMethod = siSupporter.getBadMethod();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term result = tb.tt();
		for(RiskyPath rp: badMethod.getListRiskyPaths()){
			result = tb.and(rp.getPathCondition());
		}
		return result;
	}
	
	/*
	 * sometimes we want to find a low input that guide program following a specific path
	 * then it must satisfies following formula
	 * \forall H: currentKnowledge(H) ==> pc(L,H)
	 * */
	protected Map<String, Long> findLowInputForcingExecutionFollowingPath(RiskyPath rp){
		BadMethod badMethod = siSupporter.getBadMethod();
		Services services = badMethod.getMethod().getServices();
		TermBuilder tb = services.getTermBuilder();
		Term formula = tb.imp(siSupporter.getCurrentKnowledge(), rp.getExistPathCondition());
		formula = tb.all(siSupporter.getListQuantifiedHighVar(), formula);
		
		Z3Solver z3 = new Z3Solver(formula, services);
		return z3.solveFormula2GetMapValues();
	}
	
	/*
	 * compute leakage using min-entropy-based metric
	 * usually used for Risk_LH program
	 * */
	protected Map<String,Long> findLowInputMaximizingNumberOfOutputValue() throws IOException{
		Term countTerm = siSupporter.getBadMethod().getOutputNumberCountingTerm(siSupporter.getCurrentKnowledge());
		VariableClassifier vc = siSupporter.getBadMethod().getRiskyPath(0, 0).getVc();
				
		List<String> listParameters = new LinkedList<String>();
		listParameters.addAll(vc.getListLowVars());
		//list of variables is list of fresh output var (O_out)
		List<String> listVariables = new LinkedList<String>();
		Map<String,Term> mapFreshOutputVar = siSupporter.getBadMethod().getMapFreshOutputVar();
		for(String outVar: mapFreshOutputVar.keySet()){
			listVariables.add(mapFreshOutputVar.get(outVar).toString());
		}

		ParametricPolytope pp = new ParametricPolytope(countTerm, listParameters, listVariables);	
		
		List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
		listCountingResults.add(barvinokCount(pp)); 
		
		LeakageMaximizer inputProducer = new MinLeakageMaximizer(listCountingResults, 
				siSupporter.getBadMethod().getMethod().getServices(), 
				vc.getListLowVars());
		Pair<Map<String,Long>,Double> optimizedResult = inputProducer.findLowInputMaximizingLeakge();
		System.out.println("min-entropy-based leakage: " + optimizedResult.second);
		return optimizedResult.first;
	}
	
	protected PPCountingResult barvinokCount(ParametricPolytope pp) throws IOException{
		PrintStream outFile = new PrintStream(new FileOutputStream("/home/huy/formula.txt"));
		String paraPolytope = Term2IsccTransformer.transformParaPolytope2Iscc(pp);
		System.out.println("parametric polytope: " + paraPolytope);
		outFile.print("card " + paraPolytope );
		outFile.close();
		
		List<String> command = new ArrayList<String>();
	    command.add("iscc");
	    
	    ProcessBuilder builder = new ProcessBuilder(command);
	    //Map<String, String> environ = builder.environment();
	    builder.redirectInput(ProcessBuilder.Redirect.from(new File("/home/huy/formula.txt")));		    
	    final Process process = builder.start();
	    /*   InputStream is = process.getInputStream();
	    InputStreamReader isr = new InputStreamReader(is);*/
	    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
	    String line = br.readLine();
	    System.out.println("iscc result returned: " + line);
    	Iscc2TermTransformer transformer = new Iscc2TermTransformer(line, siSupporter.getBadMethod().getMethod().getServices());
    	transformer.translateIsccResult2MapTerm();			   
    	return new PPCountingResult(transformer.getListCountingResult());	
	}
}
