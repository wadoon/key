package de.tud.exploitgen.findsecret.strategy;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.Experiment;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.MELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KEGTermException;
import de.tud.exploitgen.util.TermSimplifier;
import de.tud.exploitgen.util.TermTransformer;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

public abstract class LowInputGenStrategy {
	protected SISupporter siSupporter;

	public LowInputGenStrategy(SISupporter siSupporter) {
		super();
		this.siSupporter = siSupporter;
	}
	
	public abstract Map<String, Long> findBestLowInput() throws IOException, KEGTermException;
	
	protected Map<String,Long> findUsefulLowInput(){
		BadMethod badMethod = siSupporter.getBadMethod();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term conditionL = tb.and(avoidUsedInput(), avoidAlwaysMatchUselessPathsByInput(),inputMatchRiskyPaths());
		conditionL = new TermTransformer(siSupporter.getBadMethod().getMethod().getServices()).transformBWXORTerm(conditionL, 4);
		//System.out.println("formula to find useful low input: \n" + conditionL);
		Z3Solver z3 = new Z3Solver(conditionL,badMethod.getMethod().getServices());
		

		List<ModelVariable> resultL = z3.solveFormula2GetListModelVariable();
		if(resultL!=null){
			Map<String,Long> mapLowInput = new HashMap<String, Long>();
			VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
			//initiate the value for low inputs to make sure that all low inputs are assigned by default value (0)
			for(String lowVar: vc.getListLowVars())				
				mapLowInput.put(lowVar, (long)0);	
			
			//extract the value of low inputs
			for(ModelVariable mv: resultL){
				if(vc.isLow(mv)){
					mapLowInput.put(mv.getIdentifier(), (long)mv.getValue());
				}				
			}
			return mapLowInput;
		}
		return null;
	}
	
	/*
	 * for experiment purpose
	 * */
	public Map<String,Long> findRandomLowInput(){
		BadMethod badMethod = siSupporter.getBadMethod();
		Map<String,Long> mapLowInput = new HashMap<String, Long>();
			VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
			//initiate the value for low inputs to make sure that all low inputs are assigned by default value (0)
					
			//extract the value of low inputs
			for(String lowVar: vc.getListLowVars())	{
				mapLowInput.put(lowVar, ThreadLocalRandom.current().nextLong(-2147483648,2147483647));			
			}
			return mapLowInput;
	}
	
	/*
	 * simple idea: we should not conduct the same experiment again (one is too enough :D)
	 * return formula: \forall 0<=k<j: L_j \neq L_k 
	 * */
	protected Term avoidUsedInput(){
		BadMethod badMethod = siSupporter.getBadMethod();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term result = tb.tt();
		for(Experiment experiment: siSupporter.getUsedExperiments()){
			Map<String,Long> mapLowInputs = experiment.getLowInputs();
			Term aggDiffTerm = tb.ff();
			for(Term lowVar: siSupporter.getListLowVarTerms()){
				Term diffTerm = tb.not(tb.equals(lowVar, tb.zTerm(mapLowInputs.get(lowVar.toString()).intValue())));
				aggDiffTerm = tb.or(aggDiffTerm,diffTerm);
			}
			result = tb.and(result, aggDiffTerm);
		}
		return result;
	}
	
	/*
	 * if the low input always match experiment to a risky path whose outputs are constant or depend only on L, then it is bad low input
	 *  if the low input always match experiment to a matched risky path whose outputs depend only on H, then it is bad low input
	 * return formula: \forall i \in Risk_L \cup Risk_Const: (\exists H: currentKnowledge(H) && !(pc_i(L_j,H) )  &&
	 * \forall i \in Risk_H and matched(i): (\exists H: currentKnowledge(H) && !(pc_i(L_j,H) )  
	 * */
	protected Term avoidAlwaysMatchUselessPathsByInput(){
		BadMethod badMethod = siSupporter.getBadMethod();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term result = tb.tt();
		//Term result = currentKnowledge;
		List<RiskyPath> listAvoidPaths = badMethod.getRiskConst_RiskL_MatchedRiskH();
		for(RiskyPath rp: listAvoidPaths){
			Term existH = tb.and(siSupporter.getCurrentKnowledge(), tb.not(rp.getPathCondition()));
			existH = tb.ex(siSupporter.getListQuantifiedHighVar(), existH);
			result = tb.and(result,existH);
			
			//Term forallH = tb.and(currentKnowledge, tb.not(rp.getPathCondition()));
			//Term forallH = tb.not(rp.getPathCondition());
			//Term forallH = tb.not(tb.ex(listQuantifiedHighVar, rp.getPathCondition()));
			//result = tb.and(result,forallH);
		}
		return result;		
	}


	/*
	 * low input L_j must satisfy that p(L_j,H) can be ascribed to path i \in Risk
	 * exists H: pc_i(L_j,H) true
	 * */
	protected Term inputMatchRiskyPaths(){
		BadMethod badMethod = siSupporter.getBadMethod();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term result = tb.tt();
		for(RiskyPath rp: badMethod.getListRiskyPaths()){
			result = tb.and(rp.getPathCondition());
		}
		return result;
	}
	
	/*
	 * sometimes we want to find a low input that guide program following a specific path
	 * then it must satisfies following formula
	 * \forall H: currentKnowledge(H) ==> pc(L,H)
	 * */
	protected Map<String, Long> findLowInputForcingExecutionFollowingPath(RiskyPath rp){
		BadMethod badMethod = siSupporter.getBadMethod();
		Services services = badMethod.getMethod().getServices();
		TermBuilder tb = services.getTermBuilder();
		Term formula = tb.imp(siSupporter.getCurrentKnowledge(), rp.getPathCondition());
		formula = tb.all(siSupporter.getListQuantifiedHighVar(), formula);
		
		Z3Solver z3 = new Z3Solver(formula, services);
		return z3.solveFormula2GetMapValues();
	}
	
	/*
	 * compute leakage using min-entropy-based metric
	 * usually used for Risk_LH program
	 * */
	protected Map<String,Long> findLowInputMaximizingNumberOfOutputValue() throws IOException, KEGTermException{		
			Term countTerm = siSupporter.getBadMethod().getOutputNumberCountingTerm(siSupporter.getCurrentKnowledge());
			System.out.println("countTerm of min entropy: " + countTerm);
			
			Services services = siSupporter.getBadMethod().getMethod().getServices();
			TermTransformer termTransform = new TermTransformer(services);
			countTerm = termTransform.transformBWXORTerm(countTerm, 4);
			//simplify term before counting
			countTerm = termTransform.transformITE(countTerm);
			countTerm = TermSimplifier.simplifyITE(countTerm, services.getTermBuilder());
			countTerm = TermSimplifier.simplifyConstant(countTerm, services);
			
			
			VariableClassifier vc = siSupporter.getBadMethod().getListRiskyPaths().get(0).getVc();
					
			List<String> listParameters = new LinkedList<String>();
			listParameters.addAll(vc.getListLowVars());
			//list of variables is list of fresh output var (O_out)
			List<String> listVariables = new LinkedList<String>();
			Map<String,Term> mapFreshOutputVar = siSupporter.getBadMethod().getMapFreshOutputVar();
			for(String outVar: mapFreshOutputVar.keySet()){
				listVariables.add(mapFreshOutputVar.get(outVar).toString());
			}
			
			
			ParametricPolytope pp = new ParametricPolytope(countTerm, listParameters, listVariables);	
			
			List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
			listCountingResults.add(barvinokCount(pp)); 
			
			LeakageMaximizerUsingCounting4Uniform inputProducer = new MELMaximizerUsingCounting4Uniform(listCountingResults, 
					siSupporter.getBadMethod().getMethod().getServices(), 
					vc.getListLowVars(),siSupporter.getOptSolver());
			Pair<Map<String,Long>,Double> optimizedResult = inputProducer.findLowInputMaximizingLeakge();
			System.out.println("min-entropy-based leakage: " + optimizedResult.second);
	
			//FIX THE MIMIMUM VALUE OF LEAKAGE
			if((optimizedResult.second>KEGConstant.MINIMUM_LEAK) &&(optimizedResult.first.size()>0))
				return optimizedResult.first;
			else{
				return findUsefulLowInput();
			}
		
		
	}
	
	protected PPCountingResult barvinokCount(ParametricPolytope pp) throws IOException, KEGTermException{
		PrintStream outFile = new PrintStream(new FileOutputStream("formula.txt"));
		String paraPolytope = new Term2IsccTransformer(siSupporter.getBadMethod().getMethod().getServices()).transformParaPolytope2Iscc(pp);
		System.out.println("parametric polytope: " + paraPolytope);
		outFile.print("card " + paraPolytope );
		outFile.close();
		
		List<String> command = new ArrayList<String>();
	    command.add("iscc");
	    
	    ProcessBuilder builder = new ProcessBuilder(command);
	    //Map<String, String> environ = builder.environment();
	    builder.redirectInput(ProcessBuilder.Redirect.from(new File("formula.txt")));		    
	    final Process process = builder.start();
	    /*   InputStream is = process.getInputStream();
	    InputStreamReader isr = new InputStreamReader(is);*/
	    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
	    String line = br.readLine();
	    System.out.println("iscc result returned: " + line);
    	Iscc2TermTransformer transformer = new Iscc2TermTransformer(line, siSupporter.getBadMethod().getMethod().getServices());
    	transformer.translateIsccResult2MapTerm();			   
    	return new PPCountingResult(transformer.getListCountingResult());	
	}
}
