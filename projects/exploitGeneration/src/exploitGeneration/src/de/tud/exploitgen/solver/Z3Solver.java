/**
 * 
 */
package de.tud.exploitgen.solver;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.util.Pair;

import com.csvanefalk.keytestgen.StringConstants;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ConcreteArrInterp;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.parsers.TermParserException;
//import com.csvanefalk.keytestgen.core.model.implementation.Model;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.QuantifiedFunctionResolver;
import de.tud.exploitgen.util.TermParser;
import com.microsoft.z3.*;
import com.microsoft.z3.FuncInterp.Entry;
/**
 * this class integrates Z3 SMT Solver directly using Z3 for Java API  
 * @author Huy Do
 *
 */
public class Z3Solver extends AbstractFormulaSolver {
   
   private class QuantifiedFunction{
      /*
       * to optimize the solving, reduce the workload of SMT Solver, all identical quantified functions in the formula must be translated to the same FuncDecl object
       * this class represents a quantified function, allows to check if two quantified functions are identical, which have:
       *    - same name (bsum, max, min, ...)
       *    - same calculation function.
       * */
      public FuncDecl qfunc; //quantified function (bsum, max, min...)
      public FuncDecl calc;  //calculation function corresponding to qfunc
      public String name; //name could be bsum, max, min
      public IntExpr idx;  //quantifiable variable
      public ArithExpr calcExpr; //calculation expression
      /**
       * @param qfuncm
       * @param calc
       * @param name
       * @param idx
       * @param calcExpr
       */
      public QuantifiedFunction(FuncDecl qfunc, FuncDecl calc, String name,
            IntExpr idx, ArithExpr calcExpr) {
         super();
         this.qfunc = qfunc;
         this.calc = calc;
         this.name = name;
         this.idx = idx;
         this.calcExpr = calcExpr;
      }
      
      /*check if this quantified function and qf are identical  */
      public boolean identical(QuantifiedFunction qf) throws Z3Exception{
         if(qf.name.toString().equals(name)){
            /*
             * replace all idx in qf.calcExpr by this.idx and afterwards, compare qf.calcExpr and this.calcExpr 
             * */
            ArithExpr qfCalcExpr = (ArithExpr)qf.calcExpr.Substitute(this.idx, qf.idx);            
            //firstly, try to compare two string
            if(this.calcExpr.toString().equals(qfCalcExpr.toString())){               
               return true;
            }else{
               /*
                * user SMT Solver to check the equality
                * NOTE: it might be very expensive
                * */
               BoolExpr notEqual = ctx.MkNot(ctx.MkEq(this.calcExpr, qfCalcExpr));  
               //System.out.println("compare two calculation function: \n" + notEqual);
               Solver solver = ctx.MkSolver();
               solver.Assert(notEqual);
               if(solver.Check()==Status.SATISFIABLE)
                  return false;
               else
                  return true;
            }               
         }else            
            return false;
      }      
      
      /*search for an indentical function in listFuncs,
       * if it exists, return the identical function
       * else return null */
      public QuantifiedFunction searchIdentical(List<QuantifiedFunction> listFuncs) throws Z3Exception{
         for(QuantifiedFunction qf: listFuncs){
            if(identical(qf))
               return qf;
         }
         return null;
      }
      
      public String toString(){
         String result = "Name: " + name;
         result += "\nidx: "+ idx;
         result += "\ncalExpr: "+ calcExpr;      
         return result;
      }
   }   
   
   private Map<String,Expr> vars=new HashMap<String,Expr>(); //list of program variables in the term.

   List<BoolExpr> axioms;//contains all axioms of all functions in formula
   List<QuantifiedFunction> listQFuncs; //list of all quantified function embedded in formula
   
   Context ctx; //ctx contains methods to create expressions
   private int funcIdx;//index for calculate functions represented for third elements of bsum, max, min function
   
   @Override   
   public Map<String, Integer> solveFormulaInt() {         
      try {
         //get all variables in the formula
         parseVariables(formula);
         //parseVariablesBV(formula);
         //
         printVariables();
         
         //translate formula into Z3 expression format 
         BoolExpr expr=(BoolExpr)translateTerm(formula);
         //BoolExpr expr=(BoolExpr)parseTermBV(formula);
         
        /* System.out.println("\n-----------\nInterference formula: ");
         System.out.println(expr);*/
         
         Model model=check(ctx,expr,Status.SATISFIABLE);
         int value;
         if(model!=null){//there is a concrete model, then return the model as a HashMap<String,Integer> object
            //System.out.println("*********Parsing value into model**********");
            Map<String,Integer> result=new HashMap<String,Integer>();
            
            for(String var: vars.keySet()){       
               Expr a = vars.get(var);
               /*if(a instanceof ArrayExpr){
                  System.out.println("Interpretation of " + var + ":\n"
                        + model.FuncInterp(a.FuncDecl()));
               }               
               System.out.println(var + " : " + model.Evaluate(a, false).toString());*/
               try{
                  value = Integer.parseInt(model.Evaluate(a, false).toString());                  
               } catch(Exception e){
                  value = 0;
               }               
               result.put(var, value);
               //print array
               
            }
            return result;
         }else
            return null; //the formula is unsatisfiable, non-interference is guaranteed.
      }
      
      catch (Z3Exception e) {

         e.printStackTrace();
      }
      catch (TermParserException e) {         
         e.printStackTrace();
      }
      return null;
   }

   
   /**
    * @param formula
    */
   public Z3Solver(Term formula, Services services) {
      super(formula,services);     
      System.out.println("insecurity formula: \n"+formula);
      HashMap<String, String> cfg = new HashMap<String, String>();
      cfg.put("proof", "true");      
      try {
         ctx = new Context(cfg);
         //build all quantifier function that could appear: bsum, max, min, ..
         //get all variables in the formula
         parseVariables(formula);
         funcIdx = 0;
         axioms = new LinkedList<BoolExpr>();
         listQFuncs = new LinkedList<QuantifiedFunction>();
         //buildFuncs();
      }
      catch (Z3Exception e) {
         e.printStackTrace();
      }  
      
   }
   
   /*
    * parse all program variables in Term into @vars
    * */
   private void parseVariables(final Term term) throws Z3Exception{
      if(term!=null){
         if(TermParser.isLocationVariable(term) || KeYResourceHandler.isArtificialVariable(term)){           
            String name =term.op().name().toString();
            //System.out.println("z3 - variable detected: " + name);
            if(!vars.containsKey(name)){ 
               Expr var;
              /*
               * check variable's type
               * at the moment we just support Integer and Boolean
               * */
               if(TermParser.isIntegerType(term)){
                  var=(IntExpr)ctx.MkIntConst(name);                   
               }else if(TermParser.isBoolean(term)){
                  var=ctx.MkBoolConst(name);                  
               }
               else if(TermParser.isArray(term)){                 
                  Sort arraySort = createSort(term);
                  //var = (ArrayExpr) ctx.MkArrayConst(name, arraySort, ctx.IntSort());
                  var = (ArrayExpr)ctx.MkConst(name, arraySort);
               }
               else{ 
                  //FIXME: using another type for term                  
                  var=(IntExpr)ctx.MkIntConst(name); //Integer is default type
               }               
               vars.put(name, var); //add this variable into collection of program varibales
            }            
         }      
         /*else if(TermParser.isBSumFunction(term)){
            //create bsum function
            ctx.MkFu
         }*/
         else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               parseVariables(st);
            }
            if(term.boundVars()!=null){
               if(term.boundVars().size()>0){
                  for(QuantifiableVariable qv: term.boundVars())
                     parseQuantifiableVariable(qv);
               }
            }
         }
      }
   }
   
   /**
    * create array sort corresponding to term
    * @throws Z3Exception 
    * */
   private Sort createSort(Term term) throws Z3Exception{
      if(TermParser.isArray(term)){         
            int n = HeapHandler.getArrayDimension(term);
            
            Sort base_type;
            Sort I = ctx.MkIntSort();
            //System.out.println("array: " + HeapHandler.getTypeOfArray(term));
            if(HeapHandler.isBoolArray(term)){
               base_type = ctx.MkBoolSort();
            }else{
               base_type = I;
            }
            Sort arraySort;
            arraySort = ctx.MkArraySort(I, base_type);           
            while(n>1){//resolve multi-dimensional array
               n--;
               //child = ctx.MkArraySort(father, base_type);
               arraySort = ctx.MkArraySort(I, arraySort);              
            }
            return arraySort;         
      }else
         return ctx.MkIntSort();
   }
   
   private void parseQuantifiableVariable(QuantifiableVariable qv) throws Z3Exception{
      String name = qv.name().toString();
      if(!vars.containsKey(name)){
         Expr var;
         if(qv.sort().toString().equals("int")){
            var = (IntExpr)ctx.MkIntConst(name);
         }
         else if(qv.sort().toString().equals(StringConstants.BOOLEAN)){
            var = (BoolExpr)ctx.MkBoolConst(name);
         }
         //FIXME: resolve more general array
         else if(qv.sort() instanceof ArraySort){
            var = (ArrayExpr) ctx.MkArrayConst(name,ctx.IntSort(), ctx.MkBitVecSort(32));
         }
         else{ 
            //FIXME: using another type for term                  
            var=(IntExpr)ctx.MkIntConst(name); //Integer is default type
         }
         vars.put(name, var);   
      }
   }
   
    
   //try printing all variables expression after parsing from Formula 
   public void printVariables() throws Z3Exception{
      System.out.println("variables collection:");
      parseVariables(formula);
      for(String name: vars.keySet()){
         System.out.println(name + " --- " + vars.get(name).Sort());
      }
   }
   
   
   /*
    * parse Term into Z3 Expression, mainly focus on parsing formula
    * */
   private Expr translateTerm(final Term term) throws Z3Exception, TermParserException{
      //try{
      if(term!=null){         
         //if term is variables, simply return corresponding variable expression
         if(TermParser.isLocationVariable(term)|| KeYResourceHandler.isArtificialVariable(term)){
            return vars.get(term.op().name().toString());
         }else         
         //if is heap select function, we have to translate into array
         if(HeapHandler.isHeapSelectFunction(term)){
            //System.out.println("select term: " + term);
            return ctx.MkSelect((ArrayExpr)translateTerm(term.sub(1)), translateTerm(term.sub(2).sub(0)));
         }else
         /*
          * check if term is a logical operation 
          * */
         //if term is not a function
         if(TermParser.isNot(term)){
            return ctx.MkNot((BoolExpr)translateTerm(term.sub(0)));
         }else
         //if term is and function
         if(TermParser.isAnd(term)){
            BoolExpr[] subs={(BoolExpr)translateTerm(term.sub(0)),(BoolExpr)translateTerm(term.sub(1))};
            return ctx.MkAnd(subs);
         }else
        //if term is or function
         if(TermParser.isOr(term)){
            BoolExpr[] subs={(BoolExpr)translateTerm(term.sub(0)),(BoolExpr)translateTerm(term.sub(1))};
            return ctx.MkOr(subs);
         }else
         
         //if term is implication
         if(TermParser.isImplication(term)){
            BoolExpr[] subs={(BoolExpr)translateTerm(term.sub(0)),(BoolExpr)translateTerm(term.sub(1))};            
            return ctx.MkImplies(subs[0], subs[1]);
         }else 
         
         /*
          * check if term is a arithmetic operation 
          * */
         //if term is addition
         if(TermParser.isAddition(term)){
            ArithExpr[] subs={(ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1))};
            return ctx.MkAdd(subs);
         }else
         //if term is subtraction
         if(TermParser.isSubtraction(term)){
            ArithExpr[] subs={(ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1))};
            return ctx.MkSub(subs);
         }else
         //if term is multiplication
         if(TermParser.isMultiplication(term)){
            ArithExpr[] subs={(ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1))};
            return ctx.MkMul(subs);
         }else
       //if term is division
         if(TermParser.isDivision(term)){
            ArithExpr[] subs={(ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1))};
            return ctx.MkDiv(subs[0], subs[1]);
         }else
         //if term is minus function, transform -(expression) to expression * (-1)
         if(TermParser.isUnaryMinusFunction(term)){
            //ArithExpr[] subs = {(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)ctx.MkInt(-1)};
            //return ctx.MkMul(subs);
            return ctx.MkUnaryMinus((ArithExpr)translateTerm(term.sub(0)));
         }else
         
         /*
          * check if term is a comparison operation 
          * */
        //if term is greater
         if(TermParser.isGreaterThan(term)){
            return ctx.MkGt((ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1)));
         }else
       //if term is greater or equal
         if(TermParser.isGreaterOrEquals(term)){
            return ctx.MkGe((ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1)));
         }else
         
       // if term is less than
         if(TermParser.isLessThan(term)){
            return ctx.MkLt((ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1)));
         }else
      // if term is less or equal
         if(TermParser.isLessOrEquals(term)){
            return ctx.MkLe((ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1)));
         }else
       // if term is equal
         if(TermParser.isEquals(term)){
            //System.out.println(term);
            return ctx.MkEq((Expr)translateTerm(term.sub(0)),(Expr)translateTerm(term.sub(1)));
         }else                 
            
         /*
          * check if term is a quantifier: forall, exists
          * */
         if(TermParser.isForAllQuantifier(term)){
            
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            //System.out.println("^^^^^^^ bounded variable: " + boundVars.get(0).name().toString());
            Expr[] boundExprs = new Expr[]{vars.get(boundVars.get(0).name().toString())};        
            //System.out.println(term.sub(0));
            return ctx.MkForall(boundExprs, translateTerm(term.sub(0)), 0, null, null, null, null);
              
         }else if(TermParser.isExistsQuantifier(term)){
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            //System.out.println("^^^^^^^ bounded variable: " + boundVars.get(0).name().toString());
            Expr[] boundExprs = new Expr[]{vars.get(boundVars.get(0).name().toString())};
            //System.out.println(term.sub(0));
            return ctx.MkExists(boundExprs, translateTerm(term.sub(0)), 0, null, null, null, null);
         }else
                     
          //if term is if-then-else
         if(TermParser.isIfThenElse(term)){
            return ctx.MkITE((BoolExpr)translateTerm(term.sub(0)), 
                  (ArithExpr)translateTerm(term.sub(1)), (ArithExpr)translateTerm(term.sub(2)));
         }else
         
         /*
          * check if term is bsum function
          * */
         if(TermParser.isBSumFunction(term)){
            //System.out.println("bsum detected!");
            Pair<IntExpr, BoolExpr> result = resolveBsumFunction(term, funcIdx);
            //System.out.println("bsum function: " + result.first);
            //System.out.println("axioms: " + result.second);
            funcIdx++;
            axioms.add(result.second);
            return result.first;
         }else
         /*check if term is max function*/
         if(TermParser.isMaxFunction(term)){
          //System.out.println("max detected!");
            Pair<IntExpr, BoolExpr> result = resolveMaxFunction(term, funcIdx);
            //System.out.println("max function: " + result.first);
            //System.out.println("axioms: " + result.second);
            funcIdx++;
            axioms.add(result.second);
            return result.first;
         }else
         /*check if term is max function*/
         if(TermParser.isMinFunction(term)){
          //System.out.println("max detected!");
            Pair<IntExpr, BoolExpr> result = resolveMinFunction(term, funcIdx);
            //System.out.println("max function: " + result.first);
            //System.out.println("axioms: " + result.second);
            funcIdx++;
            axioms.add(result.second);
            return result.first;
         }else    
            
         /*
          * check if Term is a constant                  * 
          */            
         //if term is boolean constant
         if(TermParser.isBooleanConstant(term)){
            return ctx.MkBool(TermParser.translateToJavaBoolean(term));
         }else   
          
           //if term is a integer constant
           if(TermParser.isInteger(term)){
              //return ctx.MkInt(TermParser.getIntegerValue(term));
              return ctx.MkInt(TermParser.getIntegerValue(term));
           }else{           
              return ctx.MkTrue();
           }
      }
         return ctx.MkTrue();
     /* }catch(Exception e){
         return ctx.MkFalse();
      }*/
      
   }
   
   Model check(Context ctx, BoolExpr f, Status sat) throws Z3Exception{
      Solver s = ctx.MkSolver();
      s.Assert(f);
      if (s.Check() != sat){
         //System.out.println("unsatisfiable!");      
         return null;
      }else return s.Model();
    }

  
   public List<ModelVariable> solveFormula(){
      
      try {                             
         parseVariables(formula);
         //printVariables();
         
         //transform formula into Z3 expression format 
         BoolExpr expr=(BoolExpr)translateTerm(formula);
         //BoolExpr expr=(BoolExpr)parseTermBV(formula);
         axioms.add(expr);
         BoolExpr[] allExprs = axioms.toArray(new BoolExpr[axioms.size()]);
         
         BoolExpr translatedFormula = ctx.MkAnd(allExprs);
         System.out.println("\n-----------\nInterference formula: ");
         System.out.println(translatedFormula);
         
         Model model=check(ctx,translatedFormula,Status.SATISFIABLE);
         //int value;
         if(model!=null){//there is a concrete model, then return the model as a HashMap<String,Integer> object
            LinkedList<ModelVariable> result = new LinkedList<ModelVariable>();
            for(String varName: vars.keySet()){      
               Expr a = vars.get(varName);
               ModelVariable mv;
               Expr value = model.Evaluate(vars.get(varName), false);
               System.out.println(varName + " : " + value.toString());
               if(a instanceof ArrayExpr){
                  //parseArrExpr((ArrayExpr)a, model);
                  System.out.println("\nInterpretation of " + varName + ":\n");    
                  ConcreteArrInterp arrInterp = getConcreteArrInterp((ArrayExpr)a, model);
                  System.out.println(arrInterp.toString());
                  mv = new ModelArrayVariable(varName,arrInterp)    ; 
               }else{                           
                  mv  = new ModelVariable(varName);               
                  if(value.IsIntNum()){
                     mv.setValue(Integer.parseInt(value.toString()));                  
                  }else if(value.IsTrue()){
                     mv.setValue(true);
                  }else if(value.IsFalse()){
                     mv.setValue(false);
                  }
               }
               if(mv!=null)
                  result.add(mv);               
            }
            return result;
         }else
            return null; //the formula is unsatisfiable, non-interference is guaranteed.
      }
      
      catch (Z3Exception e) {
         e.printStackTrace();
      }
      catch (TermParserException e) {
         e.printStackTrace();
      }
      return null;
      
   }
    
   private ConcreteArrInterp getConcreteArrInterp(ArrayExpr expr, Model model) throws Z3Exception{
      Map<int[],Object> entries = new HashMap<int[], Object>();
      
      Object elseValue;
      FuncInterp fi = model.FuncInterp(expr.FuncDecl());      
      while(true){    
         for(Entry e: fi.Entries()){
           
            Expr[] args = e.Args();
            int[] arguments = new int[args.length];
            for(int i=0; i<args.length; i++){               
               arguments[i] = Integer.parseInt(args[i].toString());
            }
            Object value;
            Expr valueExpr = e.Value();
            if(valueExpr.IsIntNum()){
               value = new Integer(valueExpr.toString());              
            }else if(valueExpr.IsTrue()||valueExpr.IsFalse()){
               value = new Boolean(valueExpr.toString());
            }else{
               value = new Object();
            }
            entries.put(arguments, value);
         }
        
         Expr elseExpr = fi.Else();   
         
         if(elseExpr.Args().length>0){
            fi = model.FuncInterp(elseExpr.FuncDecl());             
         }else{
            if(elseExpr.IsIntNum()){
               elseValue = new Integer(elseExpr.toString());              
            }else if(elseExpr.IsTrue()||elseExpr.IsFalse()){
               elseValue = new Boolean(elseExpr.toString());
            }else{
               elseValue = new Object();
            }
            break;
         }
         
      }      
      return new ConcreteArrInterp(entries, elseValue);
   }

   
   /*create function with corresponding axiom for quantifier function BSUM*/
   private Pair<IntExpr, BoolExpr> resolveBsumFunction(Term term, int i) throws Z3Exception, TermParserException{
      if(TermParser.isBSumFunction(term)){
         if(term.boundVars()==null){
            return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
         }else{
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            if(boundVars.size()>1)               
               return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
            else{              
               //Expr[] boundExprs = new Expr[]{vars.get(boundVars.get(0).name().toString())};         
                  
               IntExpr lowerBound = (IntExpr)translateTerm(term.sub(0));
               IntExpr upperBound = (IntExpr)translateTerm(term.sub(1));
               Sort I = ctx.MkIntSort();
               
               /*
                * create bsum function, calculation function, idx and calcTermExpr to build up QuantifiedFunction
                * */
               FuncDecl bsum = ctx.MkFuncDecl(StringConstants.BSUM +i, new Sort[]{I,I}, I); 
               FuncDecl calc = ctx.MkFuncDecl("calc"+i, I, I);
               Term calcTerm = term.sub(2);
               IntExpr calcTermExpr = (IntExpr)translateTerm(calcTerm);
               IntExpr idx = (IntExpr)vars.get(boundVars.get(0).name().toString()); //bounded variables has been parsed
               QuantifiedFunction function = new QuantifiedFunction(bsum,calc,StringConstants.BSUM,idx,calcTermExpr);
               System.out.println("bsum function: " + bsum.Name().toString());
               System.out.println("calc function of " + bsum.Name().toString() + " : " + calcTermExpr);
               //System.out.println("information: \n"+ function.toString());
               //looking for the identical function in listQFuncsE               
               QuantifiedFunction idenFunc = function.searchIdentical(listQFuncs);
               if(idenFunc!=null){
                  //if there is an identical function available in listFuncs, then use it     
                  System.out.println("found identical bsum function of " + bsum.Name().toString() + " : " + idenFunc.qfunc.Name().toString());
                  bsum = idenFunc.qfunc;
                  calc = idenFunc.calc;
                  
               }else{//otherwise, add function into listFuncs
                  listQFuncs.add(function);
               }
               /*
                * create axiom for calc
                * basically calc's axiom is computational constraint of calc
                * \forall idx: lowerBound <= idx < upperBound; calc(idx)=calcTerm(idx)
                * */               
               IntExpr calcApp = (IntExpr) ctx.MkApp(calc, idx);               
               BoolExpr equalExpr = ctx.MkEq(calcApp, calcTermExpr);
               BoolExpr boundedEqualExpr = ctx.MkImplies(
                     ctx.MkAnd(new BoolExpr[]{
                           ctx.MkGe(idx, lowerBound),
                           ctx.MkLt(idx, upperBound)
                     }), 
                     equalExpr);
               BoolExpr calcAxiom = ctx.MkForall(new Expr[]{idx}, boundedEqualExpr, 0, null, null, null, null);
               //BoolExpr calcAxiom = ctx.MkForall(new Expr[]{idx}, equalExpr, 0, null, null, null, null);

               
               /*
                * create axiom for bsum(x,y), includes:
                *  - axiom 1: (x>y)=> bsum = 0 &&
                *   - axiom 2: (x==y)=> bsum = calc(x)
                *   - axiom 3: (x<y)=> bsum = bsum(y,y) + bsum(x,y-1)
                *   - axiom 4: (x<=k<=y)=> bsum(x,y) = bsum(x,k) + bsum(k+1,y)
                *   - axiom 5: (x<y)=> bsum = bsum(x,x) + bsum(x+1,y)
                * */
               
               //FuncDecl bsum = funcs.get(term.op().name().toString());              
               IntExpr x = ctx.MkIntConst("x");
               IntExpr y = ctx.MkIntConst("y");
               IntExpr calcBsum = (IntExpr)bsum.Apply(new IntExpr[]{x,y});
               
               BoolExpr axiom1 = ctx.MkImplies(ctx.MkGt(x, y), 
                                                ctx.MkEq(calcBsum, /*(IntExpr)bsum.Apply(new IntExpr[]{y,x})*/ctx.MkInt(0)));
               
               //x=y => bsum(x,y) = calc(x)  
               BoolExpr axiom2 = ctx.MkImplies(ctx.MkEq(x, y), 
                     ctx.MkEq(calcBsum, calc.Apply(x)));
               
               //x<y=>bsum(x,y)=bsum(y,y)+bsum(x,y-1)
               BoolExpr axiom3 = ctx.MkImplies(ctx.MkLt(x, y), 
                     ctx.MkEq(calcBsum,
                           ctx.MkAdd(new IntExpr[]{
                                 (IntExpr)calc.Apply(y),
                                 (IntExpr)bsum.Apply(new IntExpr[]{
                                       x,
                                       (IntExpr)ctx.MkSub(new IntExpr[]{y,ctx.MkInt(1)})                                       
                                       }
                                 )
                                 })));
               
               //x<=k<=y => bsum(x,y)= bsum(x,k) + bsum(k+1,y)
               IntExpr k = ctx.MkIntConst("k");
               BoolExpr middleExpr = ctx.MkImplies(
                     ctx.MkAnd(new BoolExpr[]{
                           ctx.MkGe(k, x),
                           ctx.MkLe(k, y)
                     }), 
                     ctx.MkEq(
                           calcBsum, 
                           ctx.MkAdd(new IntExpr[]{
                                 (IntExpr)bsum.Apply(new IntExpr[]{x,k}),
                                 (IntExpr)bsum.Apply(new IntExpr[]{
                                       (IntExpr)ctx.MkAdd(new IntExpr[]{k,ctx.MkInt(1)}),
                                       y})
                           })
                           )
                     );
               BoolExpr axiom4 = ctx.MkForall(new IntExpr[]{k}, middleExpr, 0, null, null, null, null);
               
               //axiom5: x<y=>bsum(x,y)=bsum(x,x)+bsum(x+1,y)
               BoolExpr axiom5 = ctx.MkImplies(ctx.MkLt(x, y), 
                     ctx.MkEq(calcBsum,
                           ctx.MkAdd(new IntExpr[]{
                                 (IntExpr)calc.Apply(x),
                                 (IntExpr)bsum.Apply(new IntExpr[]{
                                       (IntExpr)ctx.MkAdd(new IntExpr[]{x,ctx.MkInt(1)}), 
                                       y                                                                             
                                       }
                                 )
                                 })));
               
               //bound quantifiable variable x, y by arg0, arg1
               BoolExpr boundedQV = ctx.MkAnd(new BoolExpr[]{
                     ctx.MkGe(x, lowerBound),
                     ctx.MkLt(x, upperBound),
                     ctx.MkGe(y, lowerBound),
                     ctx.MkLt(y, upperBound)
               });
              BoolExpr bsumAxiom = ctx.MkForall(
                     new IntExpr[]{x,y}, 
                     ctx.MkImplies(
                           boundedQV, 
                           ctx.MkAnd(new BoolExpr[]{axiom1,axiom2,axiom3,axiom4,axiom5})
                           ), 
                     0, null, null, null, null
                     );
               /*BoolExpr bsumAxiom = ctx.MkForall(
                     new IntExpr[]{x,y},
                     ctx.MkAnd(new BoolExpr[]{axiom1,axiom2,axiom3,axiom4,axiom5}),                           
                     0, null, null, null, null
                     );*/
                  
               BoolExpr axiom = ctx.MkAnd(new BoolExpr[]{calcAxiom, bsumAxiom});
               IntExpr applyBsum = (IntExpr)bsum.Apply(new IntExpr[]{lowerBound,(IntExpr)ctx.MkSub(new IntExpr[]{upperBound,ctx.MkInt(1)})});
               //IntExpr applyBsum = (IntExpr)bsum.Apply(new IntExpr[]{lowerBound,upperBound});
               return new Pair<IntExpr, BoolExpr>(applyBsum,axiom);
            }
         }         
      }else         
         return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
   }

   /*
    * create function with corresponding axiom for quantifier function MAX
    * we only deal with max function has the form: max(lowerBound, upperBound, compValue)
    * */
   private Pair<IntExpr, BoolExpr> resolveMaxFunction(Term term, int i) throws Z3Exception, TermParserException{
      if(TermParser.isMaxFunction(term)){
         if(term.boundVars()==null){
            return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
         }else{
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            if(boundVars.size()>1)               
               return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
            else{              
               QuantifiedFunctionResolver maxResolver = new QuantifiedFunctionResolver(term, services);         
               IntExpr idx = (IntExpr)vars.get(boundVars.get(0).name().toString()); //bounded variables has been parsed     
               IntExpr lowerBound = (IntExpr)translateTerm(maxResolver.getLowerVal());
               IntExpr upperBound = (IntExpr)translateTerm(maxResolver.getUpperVal());
               Sort I = ctx.MkIntSort();
            
               /*
                * create max function, calculation function, idx and calcTermExpr to build up QuantifiedFunction
                * */
               FuncDecl max = ctx.MkFuncDecl(StringConstants.MAX+i, new Sort[]{I,I}, I);      
               FuncDecl calc = ctx.MkFuncDecl("calc"+i, I, I);
               Term calcTerm = maxResolver.getCalcTerm();
               IntExpr calcTermExpr = (IntExpr)translateTerm(calcTerm);
               QuantifiedFunction function = new QuantifiedFunction(max, calc, StringConstants.MAX, idx, calcTermExpr);
               //looking for the identical function in listQFuncsE
               QuantifiedFunction idenFunc = function.searchIdentical(listQFuncs);
               if(idenFunc!=null){
                  //if there is an indentical function available in listFuncs, then use it
                  max = idenFunc.qfunc;
                  calc = idenFunc.calc;                  
               }else{//otherwise, add function into listFuncs
                  listQFuncs.add(function);
               }                      
               
               /*
                * create axiom for calc
                * basically calc's axiom is computational constraint of calc
                * \forall idx: lowerBound <= idx < upperBound; calc(idx)=calcTerm(idx)
                * */
              
               IntExpr calcApp = (IntExpr) ctx.MkApp(calc, idx);              
               BoolExpr equalExpr = ctx.MkEq(calcApp, calcTermExpr);
               BoolExpr boundedEqualExpr = ctx.MkImplies(
                     ctx.MkAnd(new BoolExpr[]{
                           ctx.MkGe(idx, lowerBound),
                           ctx.MkLt(idx, upperBound)
                     }), 
                     equalExpr);
               BoolExpr calcAxiom = ctx.MkForall(new Expr[]{idx}, boundedEqualExpr, 0, null, null, null, null);
               //BoolExpr calcAxiom = ctx.MkForall(new Expr[]{idx}, equalExpr, 0, null, null, null, null);
                     
               
               
               /*
                * create axiom for max(x,y), includes:
                *   - axiom 1: (x>y)=> max(x,y) = Integer.MIN_VALUE
                *   - axiom 2: (x==y)=> max(x,y) = calc(x)
                *   - axiom 3: (x<y)=> max(x,y) = ite(calc(y)>max(x,y-1)?calc(y);max(x,y-1))
                *   - axiom 4: (x<=k<=y)=> max(x,y) = ite(max(x,k) > max(k+1,y)?max(x,k);max(k+1,y))
                *   - axiom 5: (x<y)=> max(x,y) = ite(calc(x)>max(x+1,y)?calc(x);max(x+1,y))
                * */
               
               //FuncDecl bsum = funcs.get(term.op().name().toString());                
               IntExpr x = ctx.MkIntConst("x");
               IntExpr y = ctx.MkIntConst("y");
               IntExpr maxXY = (IntExpr)max.Apply(new IntExpr[]{x,y});
               
               //axiom 1: (x>y)=> max(x,y) = Integer.MIN_VALUE
               BoolExpr axiom1 = ctx.MkImplies(ctx.MkGt(x, y), 
                                                ctx.MkEq(maxXY, ctx.MkInt(-1000000)));
               
               //axiom 2: (x==y)=> max(x,y) = calc(x) 
               IntExpr calcX = (IntExpr)calc.Apply(x);
               BoolExpr axiom2 = ctx.MkImplies(
                     ctx.MkEq(x, y), 
                     ctx.MkEq(maxXY, calcX)
                     );
               
               // axiom 3: (x<y)=> max(x,y) = ite(calc(y)>max(x,y-1)?calc(y);max(x,y-1))
               IntExpr calcY = (IntExpr)calc.Apply(y);
               IntExpr maxXY_1 = (IntExpr)max.Apply(
                     new IntExpr[]{
                           x,
                           (IntExpr)ctx.MkSub(new IntExpr[]{y,ctx.MkInt(1)})
                     });
               BoolExpr axiom3 = ctx.MkImplies(
                     ctx.MkLt(x, y), 
                     ctx.MkEq(
                           maxXY,
                           ctx.MkITE(
                                 ctx.MkGt(
                                       calcY, 
                                       maxXY_1
                                       ), 
                                 calcY, 
                                 maxXY_1
                                 )
                           )
                     );
               
               //axiom 4: (x<=k<=y)=> max(x,y) = ite(max(x,k) > max(k+1,y)?max(x,k);max(k+1,y))
               IntExpr k = ctx.MkIntConst("k");
               IntExpr maxXK = (IntExpr)max.Apply(new IntExpr[]{x,k});
               IntExpr maxKp1Y = (IntExpr)max.Apply(
                     new IntExpr[]{
                           (IntExpr)ctx.MkAdd(new IntExpr[]{k,ctx.MkInt(1)}),
                           y
                     });
               BoolExpr middleExpr = ctx.MkImplies(
                     ctx.MkAnd(new BoolExpr[]{
                           ctx.MkGe(k, x),
                           ctx.MkLe(k, y)
                     }), 
                     ctx.MkEq(
                           maxXY,
                           ctx.MkITE(
                                 ctx.MkGt(
                                       maxXK, 
                                       maxKp1Y
                                       ), 
                                 maxXK, 
                                 maxKp1Y
                                 )
                           )
                     );
               BoolExpr axiom4 = ctx.MkForall(new IntExpr[]{k}, middleExpr, 0, null, null, null, null);
               
               //axiom 5: (x<y)=> max(x,y) = ite(calc(x)>max(x+1,y)?calc(x);max(x+1,y))               
               IntExpr maxXp1Y = (IntExpr)max.Apply(
                     new IntExpr[]{
                           (IntExpr)ctx.MkAdd(new IntExpr[]{x,ctx.MkInt(1)}),
                           y
                     });
               BoolExpr axiom5 = ctx.MkImplies(
                     ctx.MkLt(x, y), 
                     ctx.MkEq(
                           maxXY,
                           ctx.MkITE(
                                 ctx.MkGt(
                                       calcX, 
                                       maxXp1Y
                                       ), 
                                 calcX, 
                                 maxXp1Y
                                 )
                           )
                      );
               
               //bound quantifiable variable x, y by arg0, arg1
               BoolExpr boundedQV = ctx.MkAnd(new BoolExpr[]{
                     ctx.MkGe(x, lowerBound),
                     ctx.MkLt(x, upperBound),
                     ctx.MkGe(y, lowerBound),
                     ctx.MkLt(y, upperBound)
               });
              BoolExpr maxAxiom = ctx.MkForall(
                     new IntExpr[]{x,y}, 
                     ctx.MkImplies(
                           boundedQV, 
                           ctx.MkAnd(new BoolExpr[]{axiom1,axiom2,axiom3,axiom4,axiom5})
                           ), 
                     0, null, null, null, null
                     );
                                 
               BoolExpr axiom = ctx.MkAnd(new BoolExpr[]{calcAxiom, maxAxiom});
               IntExpr applyMax = (IntExpr)max.Apply(new IntExpr[]{lowerBound,(IntExpr)ctx.MkSub(new IntExpr[]{upperBound,ctx.MkInt(1)})});
               //IntExpr applyMax = (IntExpr)bsum.Apply(new IntExpr[]{lowerBound,upperBound});
               return new Pair<IntExpr, BoolExpr>(applyMax,axiom);
            }
         }         
      }else         
         return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
   }
   
   /*
    * create function with corresponding axiom for quantifier function MIN
    * we only deal with min function has the form: min(lowerBound, upperBound, compValue)
    * */
   private Pair<IntExpr, BoolExpr> resolveMinFunction(Term term, int i) throws Z3Exception, TermParserException{
      if(TermParser.isMinFunction(term)){
         if(term.boundVars()==null){
            return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
         }else{
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            if(boundVars.size()>1)               
               return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
            else{              
               QuantifiedFunctionResolver minResolver = new QuantifiedFunctionResolver(term, services);         
               IntExpr idx = (IntExpr)vars.get(boundVars.get(0).name().toString()); //bounded variables has been parsed     
               IntExpr lowerBound = (IntExpr)translateTerm(minResolver.getLowerVal());
               IntExpr upperBound = (IntExpr)translateTerm(minResolver.getUpperVal());
               Sort I = ctx.MkIntSort();
               /*
                * create min function, calculation function, idx and calcTermExpr to build up QuantifiedFunction
                * */
               FuncDecl min = ctx.MkFuncDecl(StringConstants.MIN+i, new Sort[]{I,I}, I);          
               FuncDecl calc = ctx.MkFuncDecl("calc"+i, I, I);
               Term calcTerm = minResolver.getCalcTerm();
               IntExpr calcTermExpr = (IntExpr)translateTerm(calcTerm);
               QuantifiedFunction function = new QuantifiedFunction(min, calc, StringConstants.MIN, idx, calcTermExpr);
               //looking for the identical function in listQFuncsE
               QuantifiedFunction idenFunc = function.searchIdentical(listQFuncs);
               if(idenFunc!=null){
                  //if there is an indentical function available in listFuncs, then use it
                  min = idenFunc.qfunc;
                  calc = idenFunc.calc;                  
               }else{//otherwise, add function into listFuncs
                  listQFuncs.add(function);
               }      
               /*
                * create axiom for calc
                * basically calc's axiom is computational constraint of calc
                * \forall idx: lowerBound <= idx < upperBound; calc(idx)=calcTerm(idx)
                * */
               
               IntExpr calcApp = (IntExpr) ctx.MkApp(calc, idx);               
               BoolExpr equalExpr = ctx.MkEq(calcApp, calcTermExpr);
               BoolExpr boundedEqualExpr = ctx.MkImplies(
                     ctx.MkAnd(new BoolExpr[]{
                           ctx.MkGe(idx, lowerBound),
                           ctx.MkLt(idx, upperBound)
                     }), 
                     equalExpr);
               BoolExpr calcAxiom = ctx.MkForall(new Expr[]{idx}, boundedEqualExpr, 0, null, null, null, null);
               //BoolExpr calcAxiom = ctx.MkForall(new Expr[]{idx}, equalExpr, 0, null, null, null, null);
                                   
               
               /*
                * create axiom for min(x,y), includes:
                *   - axiom 1: (x>y)=> min(x,y) = Integer.MAX_VALUE
                *   - axiom 2: (x==y)=> min(x,y) = calc(x)
                *   - axiom 3: (x<y)=> min(x,y) = ite(calc(y)<min(x,y-1)?calc(y);min(x,y-1))
                *   - axiom 4: (x<=k<=y)=> min(x,y) = ite(min(x,k) < min(k+1,y)?min(x,k);min(k+1,y))
                *   - axiom 5: (x<y)=> min(x,y) = ite(calc(x)<min(x+1,y)?calc(x);min(x+1,y))
                * */
                         
               IntExpr x = ctx.MkIntConst("x");
               IntExpr y = ctx.MkIntConst("y");
               IntExpr minXY = (IntExpr)min.Apply(new IntExpr[]{x,y});
               
               //axiom 1: (x>y)=> min(x,y) = Integer.MAX_VALUE
               BoolExpr axiom1 = ctx.MkImplies(ctx.MkGt(x, y), 
                                                ctx.MkEq(minXY, ctx.MkInt(10000000)));
               
               //axiom 2: (x==y)=> min(x,y) = calc(x)
               IntExpr calcX = (IntExpr)calc.Apply(x);
               BoolExpr axiom2 = ctx.MkImplies(
                     ctx.MkEq(x, y), 
                     ctx.MkEq(minXY, calcX)
                     );
               
               // axiom 3: (x<y)=> min(x,y) = ite(calc(y)<min(x,y-1)?calc(y);min(x,y-1))
               IntExpr calcY = (IntExpr)calc.Apply(y);
               IntExpr minXY_1 = (IntExpr)min.Apply(
                     new IntExpr[]{
                           x,
                           (IntExpr)ctx.MkSub(new IntExpr[]{y,ctx.MkInt(1)})
                     });
               BoolExpr axiom3 = ctx.MkImplies(
                     ctx.MkLt(x, y), 
                     ctx.MkEq(
                           minXY,
                           ctx.MkITE(
                                 ctx.MkLt(
                                       calcY, 
                                       minXY_1
                                       ), 
                                 calcY, 
                                 minXY_1
                                 )
                           )
                     );
               
               //axiom 4: (x<=k<=y)=> min(x,y) = ite(min(x,k) < min(k+1,y)?min(x,k);min(k+1,y))
               IntExpr k = ctx.MkIntConst("k");
               IntExpr minXK = (IntExpr)min.Apply(new IntExpr[]{x,k});
               IntExpr minKp1Y = (IntExpr)min.Apply(
                     new IntExpr[]{
                           (IntExpr)ctx.MkAdd(new IntExpr[]{k,ctx.MkInt(1)}),
                           y
                     });
               BoolExpr middleExpr = ctx.MkImplies(
                     ctx.MkAnd(new BoolExpr[]{
                           ctx.MkGe(k, x),
                           ctx.MkLe(k, y)
                     }), 
                     ctx.MkEq(
                           minXY,
                           ctx.MkITE(
                                 ctx.MkLt(
                                       minXK, 
                                       minKp1Y
                                       ), 
                                 minXK, 
                                 minKp1Y
                                 )
                           )
                     );
               BoolExpr axiom4 = ctx.MkForall(new IntExpr[]{k}, middleExpr, 0, null, null, null, null);
               
               //axiom 5: (x<y)=> min(x,y) = ite(calc(x)<min(x+1,y)?calc(x);min(x+1,y))               
               IntExpr minXp1Y = (IntExpr)min.Apply(
                     new IntExpr[]{
                           (IntExpr)ctx.MkAdd(new IntExpr[]{x,ctx.MkInt(1)}),
                           y
                     });
               BoolExpr axiom5 = ctx.MkImplies(
                     ctx.MkLt(x, y), 
                     ctx.MkEq(
                           minXY,
                           ctx.MkITE(
                                 ctx.MkLt(
                                       calcX, 
                                       minXp1Y
                                       ), 
                                 calcX, 
                                 minXp1Y
                                 )
                           )
                      );
               
               //bound quantifiable variable x, y by arg0, arg1
               BoolExpr boundedQV = ctx.MkAnd(new BoolExpr[]{
                     ctx.MkGe(x, lowerBound),
                     ctx.MkLt(x, upperBound),
                     ctx.MkGe(y, lowerBound),
                     ctx.MkLt(y, upperBound)
               });
              BoolExpr maxAxiom = ctx.MkForall(
                     new IntExpr[]{x,y}, 
                     ctx.MkImplies(
                           boundedQV, 
                           ctx.MkAnd(new BoolExpr[]{axiom1,axiom2,axiom3,axiom4,axiom5})
                           ), 
                     0, null, null, null, null
                     );
                                 
               BoolExpr axiom = ctx.MkAnd(new BoolExpr[]{calcAxiom, maxAxiom});
               IntExpr applyMin = (IntExpr)min.Apply(new IntExpr[]{lowerBound,(IntExpr)ctx.MkSub(new IntExpr[]{upperBound,ctx.MkInt(1)})});
               //IntExpr applyMax = (IntExpr)bsum.Apply(new IntExpr[]{lowerBound,upperBound});
               return new Pair<IntExpr, BoolExpr>(applyMin,axiom);
            }
         }         
      }else         
         return new Pair<IntExpr, BoolExpr>(null,ctx.MkTrue());
   }  
 }

