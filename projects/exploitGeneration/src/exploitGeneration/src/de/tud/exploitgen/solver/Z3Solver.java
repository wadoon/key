/**
 * 
 */
package de.tud.exploitgen.solver;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.key_project.util.collection.ImmutableArray;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.util.Pair;

import com.csvanefalk.keytestgen.StringConstants;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ConcreteArrInterp;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.parsers.TermParserException;

import de.tud.exploitgen.detectleak.exploit.ExploitModel;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.QuantifiedFunctionResolver;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;

import com.microsoft.z3.*;
import com.microsoft.z3.enumerations.*;
import com.microsoft.z3.FuncInterp.Entry;
/**
 * this class integrates Z3 SMT Solver directly using Z3 for Java API  
 * @author Huy Do
 *
 */
public class Z3Solver {
   
   private class ComprehensionFunction{
      /*
       * to optimize the solving, reduce the workload of SMT Solver, all identical comprehension functions in the formula must be translated to the same FuncDecl object
       * this class represents a quantified function, allows to check if two quantified functions are identical, which have:
       *    - same name (bsum, max, min, ...)
       *    - same calculation function.
       * */
      public FuncDecl qfunc; //comprehension function (bsum, max, min...)
      public FuncDecl calc;  //calculation function corresponding to qfunc
      public String name; //name could be bsum, max, min
      public IntExpr idx;  //quantifiable variable //TODO: maybe there are more than one quantifiable variable?
      public List<IntExpr> paraExprs; //parameter expression
      public ArithExpr calcExpr; //calculation expression
            
      /**
       * @param qfuncm
       * @param calc
       * @param name
       * @param idx
       * @param calcExpr
       * @param paraExpr
       */
      public ComprehensionFunction(FuncDecl qfunc, FuncDecl calc, String name,
            IntExpr idx, ArithExpr calcExpr, List<IntExpr> paraExprs) {
         super();
         this.qfunc = qfunc;
         this.calc = calc;
         this.name = name;
         this.idx = idx;
         this.calcExpr = calcExpr;
         this.paraExprs = paraExprs;
      }
      
      /*check if this comprehension function and qf are identical  */
      public boolean identical(ComprehensionFunction qf) throws Z3Exception{
         if(qf.name.toString().equals(name)){
            /*
             * replace all idx in qf.calcExpr by this.idx and afterwards, compare qf.calcExpr and this.calcExpr 
             * */
            if(qf.qfunc.getNumParameters()!=qfunc.getNumParameters())
               return false;
            if(qf.calc.getNumParameters()!=calc.getNumParameters())
               return false;
            ArithExpr qfCalcExpr = (ArithExpr)qf.calcExpr.substitute(this.idx, qf.idx);            
            //firstly, try to compare two string
            if((this.paraExprs!=null) && (qf.paraExprs!=null) && this.paraExprs.size()>0 && qf.paraExprs.size()>0 && 
            		this.paraExprs.size()==qf.paraExprs.size()){
            	for(int i=0;i<this.paraExprs.size();i++)
            		qfCalcExpr.substitute(this.paraExprs.get(i), qf.paraExprs.get(i));            }
            if(this.calcExpr.toString().equals(qfCalcExpr.toString())){               
               return true;
            }else{
               /*
                * use SMT Solver to check the equality
                * NOTE: it might be very expensive
                * */
               BoolExpr notEqual = ctx.mkNot(ctx.mkEq(this.calcExpr, qfCalcExpr));  
               //System.out.println("compare two calculation function: \n" + notEqual);
               Solver solver = ctx.mkSolver();
               solver.add(notEqual);
               
               if(solver.check(notEqual)==Status.SATISFIABLE)
                  return false;
               else
                  return true;
            }               
         }else            
            return false;
      }      
      
      /*search for an indentical function in listFuncs,
       * if it exists, return the identical function
       * else return null */
      public ComprehensionFunction searchIdentical(List<ComprehensionFunction> listFuncs) throws Z3Exception{
         for(ComprehensionFunction qf: listFuncs){
            if(identical(qf))
               return qf;
         }
         return null;
      }
      
      
      public String toString(){
         String result = "Name: " + name;
         result += "\nidx: "+ idx;
         result += "\ncalExpr: "+ calcExpr;      
         return result;
      }
   }   
   
   protected Term formula;
   protected Services services;
   protected ExploitModel eModel;
   private Map<String,Expr> vars=new HashMap<String,Expr>(); //list of program variables in the term.

   List<BoolExpr> axioms;//contains all axioms of all functions in formula
   List<ComprehensionFunction> listQFuncs; //list of all quantified function embedded in formula
   
   List<Term> listQVars; // list of all quantifiable variables
   
   Context ctx; //ctx contains methods to create expressions
   private int funcIdx;//index for calculate functions represented for third elements of bsum, max, min function
   
   //private FuncDecl evSum; //sum function, only for e-voting case study
   //private FuncDecl evCount; //counting function, only for e-voting case study
   //private BoolExpr evAxioms; //only for e-voting
   //private boolean addedEVAxioms;
   /**
    * @param formula
    */
   public Z3Solver(Term formula, Services services) {
      this.formula = formula;
      this.services = services;
      //System.out.println("insecurity formula: \n"+formula);
      HashMap<String, String> cfg = new HashMap<String, String>();
      cfg.put("model", "true");      
      try {
         ctx = new Context(cfg);
         //ctx = new Context();
         //build all quantifier function that could appear: bsum, max, min, ..
         //get all variables in the formula
         vars = new HashMap<String, Expr>();
         listQVars = new LinkedList<Term>();
         parseVariables(formula);
         //System.out.println("variables:: "+vars);
         //printVariables();
         funcIdx = 0;
         axioms = new LinkedList<BoolExpr>();
         listQFuncs = new LinkedList<ComprehensionFunction>();
         //createEVotingStuff();
         //buildFuncs();
      }
      catch (Z3Exception e) {
         e.printStackTrace();
      }      
   }
   
   /*
    * parse all program variables in Term into @vars
    * */
   private void parseVariables(final Term term) throws Z3Exception{
      if(term!=null){
         if(TermParser.isLocationVariable(term) || KeYResourceHandler.isArtificialVariable(term, services)){           
            String name =term.op().name().toString();
            //System.out.println("z3 - variable detected: " + name);
            if(!vars.containsKey(name)){ 
               Expr var;
              /*
               * check variable's type
               * at the moment we just support Integer and Boolean
               * */
               if(TermParser.isIntegerType(term, services)){
                  var=(IntExpr)ctx.mkIntConst(name);                   
               }else if(TermParser.isBoolean(term, services)){
                  var=ctx.mkBoolConst(name);                  
               }
               else if(TermParser.isArray(term)){                 
                  Sort arraySort = createSort(term);
                  //var = (ArrayExpr) ctx.MkArrayConst(name, arraySort, ctx.IntSort());
                  var = (ArrayExpr)ctx.mkConst(name, arraySort);
               }
               else{ 
                  //FIXME: using another type for term                  
                  var=(IntExpr)ctx.mkIntConst(name); //Integer is default type
               }               
               vars.put(name, var); //add this variable into collection of program varibales
            }            
         }      
         /*else if(TermParser.isBSumFunction(term)){
            //create bsum function
            ctx.MkFu
         }*/
         else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               parseVariables(st);
            }
            if(term.boundVars()!=null){
               if(term.boundVars().size()>0){
                  for(QuantifiableVariable qv: term.boundVars())
                     parseQuantifiableVariable(qv);
                  if(!TermParser.isComprehension(term, services)){
                	  for(QuantifiableVariable qv: term.boundVars())
                		  add2ListQVars(qv);
                  }
               }
            }
         }
      }
   }
   
   /**
    * create array sort corresponding to term
    * @throws Z3Exception 
    * */
   private Sort createSort(Term term) throws Z3Exception{
      if(TermParser.isArray(term)){         
            int n = HeapHandler.getArrayDimension(term);
            
            Sort base_type;
            Sort I = ctx.mkIntSort();
            //System.out.println("array: " + HeapHandler.getTypeOfArray(term));
            if(HeapHandler.isBoolArray(term)){
               base_type = ctx.mkBoolSort();
            }else{
               base_type = I;
            }
            Sort arraySort;
            arraySort = ctx.mkArraySort(I, base_type);           
            while(n>1){//resolve multi-dimensional array
               n--;
               //child = ctx.mkArraySort(father, base_type);
               arraySort = ctx.mkArraySort(I, arraySort);              
            }
            return arraySort;         
      }else
         return ctx.mkIntSort();
   }
   
   private void parseQuantifiableVariable(QuantifiableVariable qv) throws Z3Exception{
      String name = qv.name().toString();
      
      if(!vars.containsKey(name)){
         Expr var;
         if(qv.sort().toString().equals("int")){
            var = (IntExpr)ctx.mkIntConst(name);
         }
         else if(qv.sort().toString().equals(StringConstants.BOOLEAN)){
            var = (BoolExpr)ctx.mkBoolConst(name);
         }
         //FIXME: resolve more general array
         else if(qv.sort() instanceof ArraySort){
            var = (ArrayExpr) ctx.mkArrayConst(name,ctx.getIntSort(), ctx.mkBitVecSort(32));
         }
         else{ 
            //FIXME: using another type for term                  
            var=(IntExpr)ctx.mkIntConst(name); //Integer is default type
         }
         vars.put(name, var);   
      }
   }
   
   private void add2ListQVars(QuantifiableVariable qv){
	 //add quantifiable variable into listQVars
	   Term qvTerm = services.getTermBuilder().var(qv);
	      if(!TermUtil.inListTerm(qvTerm, listQVars)){
	    	  listQVars.add(qvTerm);
	      }
   }
   
   
    
   //try printing all variables expression after parsing from Formula 
   public void printVariables() throws Z3Exception{
      System.out.println("variables collection:");
      //parseVariables(formula);
      for(String name: vars.keySet()){
         System.out.println(name + " --- " + vars.get(name).getSort());
      }
   }
   
   
   /*
    * parse Term into Z3 Expression, mainly focus on parsing formula
    * */
   private Expr translateTerm(final Term term) throws Z3Exception, TermParserException{
      //try{
      if(term!=null){         
         //if term is variables, simply return corresponding variable expression
         if(TermParser.isLocationVariable(term)|| KeYResourceHandler.isArtificialVariable(term, services)){
            return vars.get(term.op().name().toString());
         }else         
         //if is heap select function, we have to translate into array
         if(HeapHandler.isHeapSelectFunction(term)){
            //System.out.println("select term: " + term);
            return ctx.mkSelect((ArrayExpr)translateTerm(term.sub(1)), translateTerm(term.sub(2).sub(0)));
         }else
         /*
          * check if term is a logical operation 
          * */
         //if term is not a function
         if(TermParser.isNot(term)){
            return ctx.mkNot((BoolExpr)translateTerm(term.sub(0)));
         }else
         //if term is and function
         if(TermParser.isAnd(term)){
            BoolExpr[] subs={(BoolExpr)translateTerm(term.sub(0)),(BoolExpr)translateTerm(term.sub(1))};
            return ctx.mkAnd(subs);
         }else
        //if term is or function
         if(TermParser.isOr(term)){
            BoolExpr[] subs={(BoolExpr)translateTerm(term.sub(0)),(BoolExpr)translateTerm(term.sub(1))};
            return ctx.mkOr(subs);
         }else
         
         //if term is implication
         if(TermParser.isImplication(term)){
            BoolExpr[] subs={(BoolExpr)translateTerm(term.sub(0)),(BoolExpr)translateTerm(term.sub(1))};            
            return ctx.mkImplies(subs[0], subs[1]);
         }else 
         
         /*
          * check if term is a arithmetic operation 
          * */
         //if term is addition
         if(TermParser.isAddition(term)){
            ArithExpr[] subs={(ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1))};
            return ctx.mkAdd(subs);
         }else
         //if term is subtraction
         if(TermParser.isSubtraction(term)){
            ArithExpr[] subs={(ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1))};
            return ctx.mkSub(subs);
         }else
         //if term is multiplication
         if(TermParser.isMultiplication(term)){
            ArithExpr[] subs={(ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1))};
            return ctx.mkMul(subs);
         }else
       //if term is division
         if(TermParser.isDivision(term)){
            ArithExpr[] subs={(ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1))};
            return ctx.mkDiv(subs[0], subs[1]);
         }else
         if(TermParser.isModulo(term)){        	 
        	 return ctx.mkMod((IntExpr)translateTerm(term.sub(0)), (IntExpr)translateTerm(term.sub(1)));
         }
         
         else
         //if term is minus function, transform -(expression) to expression * (-1)
         if(TermParser.isUnaryMinusFunction(term, services)){
            //ArithExpr[] subs = {(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)ctx.mkInt(-1)};
            //return ctx.mkMul(subs);
            return ctx.mkUnaryMinus((ArithExpr)translateTerm(term.sub(0)));
         }else
    	 if(TermParser.isFloor(term)){
             
             //TODO: need implementation supporting floor and ceiling and round
    		 return translateTerm(term.sub(0));
          }else
         /*
          * check if term is a comparison operation 
          * */
        //if term is greater
         if(TermParser.isGreaterThan(term, services)){        	
            return ctx.mkGt((ArithExpr)translateTerm(term.sub(0)),
            		(ArithExpr)translateTerm(term.sub(1)));
         }else
       //if term is greater or equal
         if(TermParser.isGreaterOrEquals(term, services)){
            return ctx.mkGe((ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1)));
         }else
         
       // if term is less than
         if(TermParser.isLessThan(term, services)){
            return ctx.mkLt((ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1)));
         }else
      // if term is less or equal
         if(TermParser.isLessOrEquals(term, services)){
        	 //System.out.println(term);
            return ctx.mkLe((ArithExpr)translateTerm(term.sub(0)),(ArithExpr)translateTerm(term.sub(1)));
         }else
       // if term is equal
         if(TermParser.isEquals(term)){
            //System.out.println(term);
            return ctx.mkEq((Expr)translateTerm(term.sub(0)),(Expr)translateTerm(term.sub(1)));
         }else                 
            
         /*
          * check if term is a quantifier: forall, exists
          * */
         if(TermParser.isForAllQuantifier(term)){
            
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            //System.out.println("^^^^^^^ bounded variable: " + boundVars.get(0).name().toString());
            Expr[] boundExprs = new Expr[]{vars.get(boundVars.get(0).name().toString())};        
            //System.out.println(term.sub(0));
            return ctx.mkForall(boundExprs, translateTerm(term.sub(0)), 0, null, null, null, null);
              
         }else if(TermParser.isExistsQuantifier(term)){
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            //System.out.println("^^^^^^^ bounded variable: " + boundVars.get(0).name().toString());
            Expr[] boundExprs = new Expr[]{vars.get(boundVars.get(0).name().toString())};
            //System.out.println(term.sub(0));
            return ctx.mkExists(boundExprs, translateTerm(term.sub(0)), 0, null, null, null, null);
         }else
                     
          //if term is if-then-else
         if(TermParser.isIfThenElse(term)){
            return ctx.mkITE((BoolExpr)translateTerm(term.sub(0)), 
                  translateTerm(term.sub(1)), translateTerm(term.sub(2)));
         }else
         
        
         /*
          * check if term is bsum function
          * */
         if(TermParser.isBSumFunction(term, services)){                                        
             List<Term> listQVarsInside = extractListQVarInComprehension(term);
        	 System.out.println("listQVarsInSum:: " + listQVarsInside);
        	 Pair<IntExpr, BoolExpr> result = resolveComprehensionFunction(term, funcIdx, listQVarsInside, KEGConstant.BSUM);
        	 System.out.println("bsum function: " + result.first);
             funcIdx++;
             axioms.add(result.second);
             return result.first;
         }else
         /*check if term is max function*/
         if(TermParser.isMaxFunction(term)){                
             List<Term> listQVarsInside = extractListQVarInComprehension(term);
        	 Pair<IntExpr, BoolExpr> result = resolveComprehensionFunction(term, funcIdx, listQVarsInside, KEGConstant.MAX);
             funcIdx++;
             axioms.add(result.second);
             return result.first;
         }else
         /*check if term is min function*/
         if(TermParser.isMinFunction(term)){
        	 List<Term> listQVarsInside = extractListQVarInComprehension(term);
        	 Pair<IntExpr, BoolExpr> result = resolveComprehensionFunction(term, funcIdx, listQVarsInside, KEGConstant.MIN);
             funcIdx++;
             axioms.add(result.second);
             return result.first;
         }else    
            
         /*
          * check if Term is a constant                  * 
          */            
         //if term is boolean constant
         if(TermParser.isBooleanConstant(term)){
            return ctx.mkBool(TermParser.translateToJavaBoolean(term));
         }else   
          
           //if term is a integer constant
           if(TermParser.isIntegerConst(term, services)){              
              //return ctx.mkInt(TermParser.getIntegerValue(term));
        	   return ctx.mkInt(TermParser.getBigIntegerValue(term, services).toString());
              
           }else{           
              return ctx.mkTrue();
           }
      }
         return ctx.mkTrue();
     /* }catch(Exception e){
         return ctx.mkFalse();
      }*/
      
   }
   
   Model check(Context ctx, BoolExpr f, Status sat) throws Z3Exception{
      Solver s = ctx.mkSolver();
     s.add(f);
      if (s.check() != sat){
         //System.out.println("unsatisfiable!");      
         return null;
      }else return s.getModel();
    }

  
   public List<ModelVariable> solveFormula2GetListModelVariable(){
	   //System.out.println("insecurity formula: \n"+formula);
      try {                             
         //parseVariables(formula);
         //printVariables();
         
         //transform formula into Z3 expression format 
         BoolExpr expr=(BoolExpr)translateTerm(formula);
         //BoolExpr expr=(BoolExpr)parseTermBV(formula);
         axioms.add(expr);
         BoolExpr[] allExprs = axioms.toArray(new BoolExpr[axioms.size()]);
         
         BoolExpr translatedFormula = ctx.mkAnd(allExprs);
         System.out.println("\n-----------\nInsecurity formula: ");
         System.out.println(translatedFormula);
         
         Model model=check(ctx,translatedFormula,Status.SATISFIABLE);
         //int value;
         if(model!=null){//there is a concrete model, then return the model as a HashMap<String,Integer> object
            LinkedList<ModelVariable> result = new LinkedList<ModelVariable>();
            for(String varName: vars.keySet()){      
               Expr var = vars.get(varName);
               ModelVariable mv;
               Expr value = model.evaluate(vars.get(varName), false);
               System.out.println(varName + " : " + value.toString());
               if(var instanceof ArrayExpr){
                  //parseArrExpr((ArrayExpr)a, model);
                  System.out.println("\nInterpretation of " + varName + ":\n");    
                  ConcreteArrInterp arrInterp = getConcreteArrInterp((ArrayExpr)var, model);
                  if(arrInterp!=null)
                	  System.out.println(arrInterp.toString());
                  mv = new ModelArrayVariable(varName,arrInterp)    ; 
               }else{                           
                  mv  = new ModelVariable(varName);               
                  if(value.isIntNum()){
                     mv.setValue(Long.parseLong(value.toString()));                  
                  }else if(value.isTrue()){
                     mv.setValue(true);
                  }else if(value.isFalse()){
                     mv.setValue(false);
                  }else if(value.toString().equals(varName)){ //in case value has the same name with varName, we assign default value
                	  if(var instanceof IntExpr){
                		  mv.setValue(new Long(1));
                	  }else if(var instanceof BoolExpr)
                		  mv.setValue(true);
                	  //TODO: how about array?
                  }
               }
               if(mv!=null)
                  result.add(mv);               
            }
            
            for(ComprehensionFunction qf: listQFuncs){
               System.out.println("\nInterpretation of " + qf.qfunc.getName().toString() + ":\n");    
               FuncInterp fi = model.getFuncInterp(qf.qfunc);
               System.out.println(fi);
            }
            
            return result;
         }else{
            System.out.println("\nInsecurity formula is unsatisfiable");
            return null; //the formula is unsatisfiable, non-interference is guaranteed.
         }
      }
      
      catch (Z3Exception e) {
         e.printStackTrace();
      }
      catch (TermParserException e) {
         e.printStackTrace();
      }
      return null;
      
   }
  
   public boolean checkSatisfiable(){
	   //System.out.println("formula to check satisfiability: \n"+formula);
	   if(TermParser.isBooleanFalse(formula))
		   return false;
	   try {                             
         //parseVariables(formula);
         //printVariables();
         
         //transform formula into Z3 expression format 
         BoolExpr expr=(BoolExpr)translateTerm(formula);
         //BoolExpr expr=(BoolExpr)parseTermBV(formula);
         axioms.add(expr);
         BoolExpr[] allExprs = axioms.toArray(new BoolExpr[axioms.size()]);
         
         BoolExpr translatedFormula = ctx.mkAnd(allExprs);
         
         //System.out.println("\n-----------\n formula to check satisfiability:: ");
         //System.out.println(translatedFormula);
         
         Model model=check(ctx,translatedFormula,Status.SATISFIABLE);
         //int value;
         if(model!=null){//there is a concrete model, then return true
        	 //System.out.println("SATISFIABLE!");
           return true;
         }else{
        	 //System.out.println("UNSATISFIABLE!!!");
            return false; //the formula is unsatisfiable, then return false
         }
      }
      
      catch (Z3Exception e) {
         e.printStackTrace();
      }
      catch (TermParserException e) {
         e.printStackTrace();
      }
	   
      return false;
   }
   
   private ConcreteArrInterp getConcreteArrInterp(ArrayExpr expr, Model model) {
      Map<int[],Object> entries = new HashMap<int[], Object>();
      
      Object elseValue;
      FuncInterp fi;
      try{
    	  fi = model.getFuncInterp(expr.getFuncDecl());    
      
	      while(true){    
	         for(Entry e: fi.getEntries()){         
	            Expr[] args = e.getArgs();
	            int[] arguments = new int[args.length];
	            for(int i=0; i<args.length; i++){               
	               arguments[i] = Integer.parseInt(args[i].toString());
	            }
	            Object value;
	            Expr valueExpr = e.getValue();
	            if(valueExpr.isIntNum()){
	               value = new Integer(valueExpr.toString());              
	            }else if(valueExpr.isTrue()||valueExpr.isFalse()){
	               value = new Boolean(valueExpr.toString());
	            }else{
	               value = new Object();
	            }
	            entries.put(arguments, value);
	         }
	        
	         Expr elseExpr = fi.getElse();   
	         
	         if(elseExpr.getArgs().length>0){
	            fi = model.getFuncInterp(elseExpr.getFuncDecl());             
	         }else{
	            if(elseExpr.isIntNum()){
	               elseValue = new Integer(elseExpr.toString());              
	            }else if(elseExpr.isTrue()||elseExpr.isFalse()){
	               elseValue = new Boolean(elseExpr.toString());
	            }else{
	               elseValue = new Object();
	            }
	            break;
	         }
	         
	      }      
	      return new ConcreteArrInterp(entries, elseValue);
      }catch(Z3Exception e){
    	  return null;
      }
   }
   
   /*
    * each comprehension operator (bsum, max, min) can be translated using two function in Z3: 
    *  - a function describing it
    *  - a function describing how to calculate it
    * */
   
   private Pair<FuncDecl, FuncDecl> createPairFuncOfComprehension(int fIdx, int numParams, String comprehensionName) throws Z3Exception{
	   Sort I = ctx.mkIntSort();
	   if(numParams==0){
		   FuncDecl bsum = ctx.mkFuncDecl(comprehensionName +"_" + fIdx, new Sort[]{I,I}, I); 
           FuncDecl calc = ctx.mkFuncDecl(comprehensionName +"_calc_"+fIdx, I, I);
           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }else 
	   if(numParams==1){
		   FuncDecl bsum = ctx.mkFuncDecl("tri_" + comprehensionName +"_" + fIdx, new Sort[]{I,I,I}, I); 
           FuncDecl calc = ctx.mkFuncDecl("tri_"+comprehensionName +"_calc_" +fIdx, new Sort[]{I,I}, I);
           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }else
	   if(numParams==2){
		   FuncDecl bsum = ctx.mkFuncDecl("quadri_" + comprehensionName +"_" + fIdx, new Sort[]{I,I,I,I}, I); 
           FuncDecl calc = ctx.mkFuncDecl("quadri_"+comprehensionName +"_calc_" +fIdx, new Sort[]{I,I,I}, I);
           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }
	   else if(numParams==3){
			   FuncDecl bsum = ctx.mkFuncDecl("penta_" + comprehensionName +"_" + fIdx, new Sort[]{I,I,I,I,I}, I); 
	           FuncDecl calc = ctx.mkFuncDecl("penta_"+comprehensionName +"_calc_" +fIdx, new Sort[]{I,I,I,I}, I);
	           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }
	   else if(numParams==4){
		   FuncDecl bsum = ctx.mkFuncDecl("hexa_" + comprehensionName +"_" + fIdx, new Sort[]{I,I,I,I,I,I}, I); 
           FuncDecl calc = ctx.mkFuncDecl("hexa_"+comprehensionName +"_calc_" +fIdx, new Sort[]{I,I,I,I,I}, I);
           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }	   
	   else if(numParams==5){
		   FuncDecl bsum = ctx.mkFuncDecl("septa_" + comprehensionName +"_" + fIdx, new Sort[]{I,I,I,I,I,I,I}, I); 
           FuncDecl calc = ctx.mkFuncDecl("septa_"+ comprehensionName +"_calc_" +fIdx, new Sort[]{I,I,I,I,I,I}, I);
           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }
	   else if(numParams==6){
		   FuncDecl bsum = ctx.mkFuncDecl("octa_" + comprehensionName +"_" + fIdx, new Sort[]{I,I,I,I,I,I,I,I}, I); 
           FuncDecl calc = ctx.mkFuncDecl("octa_"+ comprehensionName +"_calc_" +fIdx, new Sort[]{I,I,I,I,I,I,I}, I);
           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }
	   
	   else if(numParams==7){
		   FuncDecl bsum = ctx.mkFuncDecl("nona_" + comprehensionName +"_" + fIdx, new Sort[]{I,I,I,I,I,I,I,I,I}, I); 
           FuncDecl calc = ctx.mkFuncDecl("nona_"+comprehensionName +"_calc_" +fIdx, new Sort[]{I,I,I,I,I,I,I,I}, I);
           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }
	   else if(numParams==8){
		   FuncDecl bsum = ctx.mkFuncDecl("deca_" + comprehensionName +"_" + fIdx, new Sort[]{I,I,I,I,I,I,I,I,I,I}, I); 
           FuncDecl calc = ctx.mkFuncDecl("deca_"+comprehensionName +"_calc_" +fIdx, new Sort[]{I,I,I,I,I,I,I,I,I}, I);
           return new Pair<FuncDecl, FuncDecl>(bsum, calc);
	   }else
		   return createPairFuncOfComprehension(fIdx, 0, comprehensionName);
   }
   
   private BoolExpr buildAxioms4Comprehension(FuncDecl comprehension, FuncDecl calc, IntExpr lowerBound, IntExpr upperBound, int numParams, String comprehensionName) throws Z3Exception{
	   /*
        * create axiom for bsum(x,y,p), includes:
        *  - axiom 1: (x>y)=> bsum(x,y,p) = 0 
        *   - axiom 2: (x==y)=> bsum = calc(y,p)
        *   - axiom 3: (x<y)=> bsum = calc(y,p) + bsum(x,y-1,p)
        *   - axiom 4: (x<=k<=y)=> bsum(x,y,p) = bsum(x,k,p) + bsum(k+1,y,p)
        *   - axiom 5: (x<y)=> bsum = calc(x,p) + bsum(x+1,y,p)
        * */

	   /*
        * create axiom for max(x,y,p), includes:
        *   - axiom 1: (x>y)=> max(x,y,p) = Long.MIN_VALUE
        *   - axiom 2: (x==y)=> max(x,y,p) = calc(x,p)
        *   - axiom 3: (x<y)=> max(x,y,p) = ite(calc(y,p)>max(x,y-1,p)?calc(y,p);max(x,y-1,p))
        *   - axiom 4: (x<=k<=y)=> max(x,y,p) = ite(max(x,k,p) > max(k+1,y,p)?max(x,k,p);max(k+1,y,p))
        *   - axiom 5: (x<y)=> max(x,y,p) = ite(calc(x,p)>max(x+1,y,p)?calc(x,p);max(x+1,y,p))
        * */
	   
	   /*
        * create axiom for min(x,y,p), includes:
        *   - axiom 1: (x>y)=> min(x,y,p) = Long.MAX_VALUE
        *   - axiom 2: (x==y)=> min(x,y,p) = calc(y,p)
        *   - axiom 3: (x<y)=> min(x,y,p) = ite(calc(y,p)<min(x,y-1,p)?calc(y,p);min(x,y-1,p))
        *   - axiom 4: (x<=k<=y)=> min(x,y,p) = ite(min(x,k,p) < min(k+1,y,p)?min(x,k,p);min(k+1,y,p))
        *   - axiom 5: (x<y)=> min(x,y,p) = ite(calc(x,p)<max(x+1,y,p)?calc(x,p);min(x+1,y,p))
        * */
	          
       IntExpr x = ctx.mkIntConst("x");
       IntExpr y = ctx.mkIntConst("y");      
       List<IntExpr> params = createListIntExpr(numParams);
       
       
       List<IntExpr> xyp = new LinkedList<IntExpr>();
       xyp.add(x);
       xyp.add(y);
       xyp.addAll(params);
       IntExpr calc_xyp = (IntExpr)comprehension.apply(xyp.toArray(new IntExpr[xyp.size()]));
       
       /*  axiom 1:
        * (x>y)=> bsum(x,y,p) = 0 
        * (x>y)=> max(x,y,p) = Long.MIN_VALUE
        * (x>y)=> min(x,y,p) = Long.MAX_VALUE 
        * 
        * */
       BoolExpr axiom1 = ctx.mkImplies(ctx.mkGt(x, y), 
                                        ctx.mkEq(calc_xyp, createValue4EmptyRange(comprehensionName)));
       
       /* - axiom 2:  
        * 	(x==y)=> bsum = calc(y,p)
			(x==y)=> max(x,y,p) = calc(y,p) 
			(x==y)=> min(x,y,p) = calc(y,p)
        * */      
       List<IntExpr> yp = new LinkedList<IntExpr>();
       yp.add(y);
       yp.addAll(params);
       IntExpr calc_yp = (IntExpr)calc.apply(yp.toArray(new IntExpr[yp.size()]));
       BoolExpr axiom2 = ctx.mkImplies(ctx.mkEq(x, y), 
             ctx.mkEq(calc_xyp, calc_yp));
       
       /*- axiom 3: 
        * (x<y)=> bsum = calc(y,p) + bsum(x,y-1,p)
        * (x<y)=> max(x,y,p) = ite(calc(y,p)>max(x,y-1,p)?calc(y,p);max(x,y-1,p)) 
        * (x<y)=> min(x,y,p) = ite(calc(y,p)<min(x,y-1,p)?calc(y,p);min(x,y-1,p))
        * */
       List<IntExpr> xyminus1p = new LinkedList<IntExpr>();
       xyminus1p.add(x);
       xyminus1p.add((IntExpr)ctx.mkSub(new IntExpr[]{y,ctx.mkInt(1)}));
       xyminus1p.addAll(params);
       IntExpr calc_xyminus1p = (IntExpr)comprehension.apply(xyminus1p.toArray(new IntExpr[xyminus1p.size()]));
       BoolExpr axiom3 = ctx.mkImplies(
    		   ctx.mkLt(x, y), 
    		   ctx.mkEq(
    				   calc_xyp,
    				   createComparingExpr4ComprehensionAxiom(calc_yp, calc_xyminus1p, comprehensionName)
    				   )
    		   );
 
       
       /* - axiom 4: 
        * (x<=k<=y)=> bsum(x,y,p) = bsum(x,k,p) + bsum(k+1,y,p)
        * (x<=k<=y)=> max(x,y,p) = ite(max(x,k,p) > max(k+1,y,p)?max(x,k,p);max(k+1,y,p)) 
        * (x<=k<=y)=> min(x,y,p) = ite(min(x,k,p) < min(k+1,y,p)?min(x,k,p);min(k+1,y,p))
        * */
       IntExpr k = ctx.mkIntConst("k");
       List<IntExpr> xkp = new LinkedList<IntExpr>();
       xkp.add(x);
       xkp.add(k);
       xkp.addAll(params);
       IntExpr calc_xkp = (IntExpr)comprehension.apply(xkp.toArray(new IntExpr[xkp.size()]));       
       List<IntExpr> kplus1yp = new LinkedList<IntExpr>();
       kplus1yp.add((IntExpr)ctx.mkAdd(new IntExpr[]{k,ctx.mkInt(1)}));
       kplus1yp.add(y);
       kplus1yp.addAll(params);
       IntExpr calc_kplus1yp = (IntExpr)comprehension.apply(kplus1yp.toArray(new IntExpr[kplus1yp.size()]));
       BoolExpr middleExpr = ctx.mkImplies(
             ctx.mkAnd(new BoolExpr[]{
                   ctx.mkGe(k, x),
                   ctx.mkLe(k, y)
             }), 
             ctx.mkEq(
                   calc_xyp, 
                   createComparingExpr4ComprehensionAxiom(calc_xkp, calc_kplus1yp, comprehensionName)
                   ) 
             );
       BoolExpr axiom4 = ctx.mkForall(new IntExpr[]{k}, middleExpr, 0, null, null, null, null);
       
       /*- axiom 5:
        * (x<y)=> bsum = calc(x,p) + bsum(x+1,y,p) 
        * (x<y)=> max(x,y,p) = ite(calc(x,p)>max(x+1,y,p)?calc(x,p);max(x+1,y,p)) 
        * (x<y)=> min(x,y,p) = ite(calc(x,p)<max(x+1,y,p)?calc(x,p);min(x+1,y,p))
        * */
       List<IntExpr> xp = new LinkedList<IntExpr>();
       xp.add(x);
       xp.addAll(params);
       IntExpr calc_xp = (IntExpr)calc.apply(xp.toArray(new IntExpr[xp.size()]));
       List<IntExpr> xplus1yp = new LinkedList<IntExpr>();
       xplus1yp.add((IntExpr)ctx.mkAdd(new IntExpr[]{x,ctx.mkInt(1)}));
       xplus1yp.add(y);
       xplus1yp.addAll(params);
       IntExpr calc_xplus1yp = (IntExpr)comprehension.apply(xplus1yp.toArray(new IntExpr[xplus1yp.size()]));
       BoolExpr axiom5 = ctx.mkImplies(
    		   ctx.mkLt(x, y), 
    		   ctx.mkEq(
    				   calc_xyp,
    				   createComparingExpr4ComprehensionAxiom(calc_xp, calc_xplus1yp, comprehensionName)
    				   ) 
    			);
             
       
       //bound quantifiable variable x, y by arg0, arg1
       BoolExpr boundedQV = ctx.mkAnd(new BoolExpr[]{
             ctx.mkGe(x, lowerBound),
             ctx.mkLt(x, upperBound),
             ctx.mkGe(y, lowerBound),
             ctx.mkLt(y, upperBound)
       });
      BoolExpr comprehensionAxiom = ctx.mkForall(
    		  xyp.toArray(new IntExpr[xyp.size()]), 
             //ctx.mkAnd(new BoolExpr[]{axiom1,axiom2,axiom3,axiom4,axiom5}),
             ctx.mkImplies(
                   boundedQV, 
                   ctx.mkAnd(new BoolExpr[]{axiom1,axiom2,axiom3,axiom4,axiom5})
                   ), 
             0, null, null, null, null
             );
      return comprehensionAxiom;
   }
   
   private IntExpr createComparingExpr4ComprehensionAxiom(IntExpr p1, IntExpr p2, String comprehensionName) throws Z3Exception{
	   if(comprehensionName.equals(KEGConstant.BSUM))
		   return (IntExpr)ctx.mkAdd(new IntExpr[]{p1,p2});
	   else if (comprehensionName.equals(KEGConstant.MAX))
		   return (IntExpr)ctx.mkITE(
                   ctx.mkGt(
                         p1, 
                         p2
                         ), 
                         p1, 
                         p2
                   );
	   else if (comprehensionName.equals(KEGConstant.MIN))
		   return (IntExpr)ctx.mkITE(
                   ctx.mkLt(
                         p1, 
                         p2
                         ), 
                         p1, 
                         p2
                   );
	   else // how about count?
		   return null;
   }
   
   private IntExpr createValue4EmptyRange(String comprehensionName) throws Z3Exception{
	   if(comprehensionName.equals(KEGConstant.BSUM))
		   return ctx.mkInt(0);
	   else if (comprehensionName.equals(KEGConstant.MAX))
		   return ctx.mkInt(Long.MIN_VALUE);
	   else if (comprehensionName.equals(KEGConstant.MIN))
		   return ctx.mkInt(Long.MAX_VALUE);
	   else // how about count?
		   return null;
   }
   
  private Pair<IntExpr, BoolExpr> resolveComprehensionFunction(Term term, int i, List<Term> listQVarsInComprehension, String comprehensionName) throws Z3Exception, TermParserException{
	     if(term.boundVars()==null){
            return new Pair<IntExpr, BoolExpr>(null,ctx.mkTrue());
         }else{
        	System.out.println("comprehension term: "+ term);
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            if(boundVars.size()>1)      //at the moment we only deal with comprehension that has only one index variable         
               return new Pair<IntExpr, BoolExpr>(null,ctx.mkTrue());
            else{              
            	Pair<Pair<Term,Term>, Pair<QuantifiableVariable,Term>> basicInfo = extractBoundNCaclInfo(term, comprehensionName)   ;
               Term lowerBoundTerm = basicInfo.first.first;
               Term upperBoundTerm = basicInfo.first.second;
               QuantifiableVariable idxVar = basicInfo.second.first;
               Term calcTerm = basicInfo.second.second;
               
               IntExpr lowerBound = (IntExpr)translateTerm(lowerBoundTerm);
               IntExpr upperBound = (IntExpr)translateTerm(upperBoundTerm);
               IntExpr calcTermExpr = (IntExpr)translateTerm(calcTerm);
               IntExpr idx = (IntExpr)vars.get(idxVar.name().toString()); //bounded variables has been parsed
               
               /*
                * create comprehension function, calculation function to build up QuantifiedFunction
                * */
               Pair<FuncDecl,FuncDecl> pairFunc = createPairFuncOfComprehension(i, listQVarsInComprehension.size(), comprehensionName);               
               FuncDecl comprehension = pairFunc.first;	              
               FuncDecl calc = pairFunc.second;
               System.out.println("comprehension:" +comprehension);
               System.out.println("calc:" +calc);
               
               //translate list of qvar term in comprehension term to list of IntExpr
               List<IntExpr> qvarExprs = new LinkedList<IntExpr>();
               for(Term t: listQVarsInComprehension)
            	   qvarExprs.add((IntExpr)translateTerm(t));                             
                              
               ComprehensionFunction function = new ComprehensionFunction(comprehension,calc,comprehensionName,idx,calcTermExpr,qvarExprs);
               
               //looking for the identical function in listQFuncsE               
               ComprehensionFunction idenFunc = function.searchIdentical(listQFuncs);
               if(idenFunc!=null){
                  //if there is an identical function available in listFuncs, then use it     
                  comprehension = idenFunc.qfunc;
                  calc = idenFunc.calc;
                  //we do not need to add axiom for available tri_bsum function
                  List<IntExpr> paramsOfComprehension = new LinkedList<IntExpr>();
                  paramsOfComprehension.add(lowerBound);
                  paramsOfComprehension.add((IntExpr)ctx.mkSub(new IntExpr[]{upperBound,ctx.mkInt(1)}));
                  paramsOfComprehension.addAll(qvarExprs);
                  
                  IntExpr applyComprehension = (IntExpr)comprehension.apply(paramsOfComprehension.toArray(new IntExpr[paramsOfComprehension.size()]));	     
                  BoolExpr axiom = ctx.mkBool(true);
                  return new Pair<IntExpr, BoolExpr>(applyComprehension,axiom);
               }else{//otherwise, add function into listFuncs
                  listQFuncs.add(function);
               }
               /*
                * create axiom for calc
                * basically calc's axiom is computational constraint of calc
                * \forall idx,p: lowerBound <= idx < upperBound; calc(idx,p)=calcTerm(idx,p)
                * */
               BoolExpr calcAxiom = buildCalcAxiom(calc, calcTermExpr, idx, lowerBound, upperBound, qvarExprs);
               System.out.println("calcAxiom:: "+calcAxiom);

               //create axioms for comprehension
              BoolExpr bsumAxiom = buildAxioms4Comprehension(comprehension, calc, lowerBound, upperBound, listQVarsInComprehension.size(), comprehensionName);
              
              //make aggrigated axiom
              BoolExpr axiom = ctx.mkAnd(new BoolExpr[]{calcAxiom, bsumAxiom});
              List<IntExpr> paramsOfComprehension = new LinkedList<IntExpr>();
              paramsOfComprehension.add(lowerBound);
              paramsOfComprehension.add((IntExpr)ctx.mkSub(new IntExpr[]{upperBound,ctx.mkInt(1)}));
              paramsOfComprehension.addAll(qvarExprs);
              IntExpr applyComprehension = (IntExpr)comprehension.apply(paramsOfComprehension.toArray(new IntExpr[paramsOfComprehension.size()]));	     
              return new Pair<IntExpr, BoolExpr>(applyComprehension,axiom);
            }
         }         
	      
   }
   
   /*
    * extract necessary information from comprehension:
    * @return ((lowerBoundTerm,upperBoundTerm),(idx, calcTerm)) 
    * */
   private Pair<Pair<Term,Term>, Pair<QuantifiableVariable,Term>> extractBoundNCaclInfo(Term term, String comprehensionName){
	   Term lowerBoundTerm, upperBoundTerm, calcTerm;
	   QuantifiableVariable idx;
	   if(comprehensionName.equals(KEGConstant.BSUM)){
		   lowerBoundTerm = term.sub(0);
		   upperBoundTerm = term.sub(1);
		   calcTerm = term.sub(2);
		   idx = term.boundVars().get(0); //asume that there is only one quantifiable variable
	   }else{
		   QuantifiedFunctionResolver qfr = new QuantifiedFunctionResolver(term, services);
		   lowerBoundTerm = qfr.getLowerVal();
		   upperBoundTerm = qfr.getUpperVal();
		   calcTerm = qfr.getCalcTerm();
		   idx = qfr.getQuantifiableVariable();
	   }
	   return new Pair<Pair<Term,Term>, Pair<QuantifiableVariable,Term>>(new Pair<Term,Term>(lowerBoundTerm,upperBoundTerm), new Pair<QuantifiableVariable,Term>(idx, calcTerm));
   } 
   
   private BoolExpr buildCalcAxiom(FuncDecl calc, IntExpr calcTermExpr, IntExpr idx, IntExpr lowerBound, IntExpr upperBound, List<IntExpr> qvarExprs) throws Z3Exception{
	   /*
        * create axiom for calc
        * basically calc's axiom is computational constraint of calc
        * \forall idx,p: lowerBound <= idx < upperBound; calc(idx,p)=calcTerm(idx,p)
        * */
       List<IntExpr> paramsOfCalc = new LinkedList<IntExpr>();
       paramsOfCalc.add(idx);
       paramsOfCalc.addAll(qvarExprs);
       System.out.println("paramsOfCalc:" + paramsOfCalc);
       IntExpr calcApp = (IntExpr)calc.apply(paramsOfCalc.toArray(new IntExpr[paramsOfCalc.size()]));   
       System.out.println("calcApp:: "+ calcApp);
       BoolExpr equalExpr = ctx.mkEq(calcApp, calcTermExpr);
       BoolExpr boundedEqualExpr = ctx.mkImplies(
             ctx.mkAnd(new BoolExpr[]{
                   ctx.mkGe(idx, lowerBound),
                   ctx.mkLt(idx, upperBound)
             }), 
             equalExpr);
       BoolExpr calcAxiom = ctx.mkForall(paramsOfCalc.toArray(new IntExpr[paramsOfCalc.size()]), boundedEqualExpr /*equalExpr*/, 0, null, null, null, null);
       return calcAxiom;
   }
   
   private List<IntExpr> createListIntExpr(int n) throws Z3Exception{
	   List<IntExpr> result = new LinkedList<IntExpr>();
	   for(int i=0;i<n;i++){
		   IntExpr p = ctx.mkIntConst("p_"+i);
		   result.add(p);
	   }
	   return result;
   }
 
   /*
    * return true if sum function contains quantifiable variables
    * */
   private List<Term> extractListQVarInComprehension(Term comprehensionTerm){
	   List<Term> result = new LinkedList<Term>();
	   List<Term> listQuans = new LinkedList<Term>();
	   for(QuantifiableVariable qv: comprehensionTerm.boundVars()){
		   listQuans.add(services.getTermBuilder().var(qv));
	   }
	   for(Term qvar: listQVars){
		   if(!TermUtil.inListTerm(qvar, listQuans)){
			   if(TermUtil.haveDescendantInList(comprehensionTerm, listQVars)){
				   result.add(qvar);
			   }
		   }
	   }	   
	   return result;
   }

   /*
    * use for find best low input
    * TODO: should use List<ModelVariable> as the return value so we can deal with more complicated program     
    * */
   public Map<String, Long> solveFormula2GetMapValues(){
	   System.out.println("solveFormula2GetMapValues: \n"+formula);
	   try {                             
	         
	         //transform formula into Z3 expression format 
	         BoolExpr expr=(BoolExpr)translateTerm(formula);
	         //BoolExpr expr=(BoolExpr)parseTermBV(formula);
	         axioms.add(expr);
	         BoolExpr[] allExprs = axioms.toArray(new BoolExpr[axioms.size()]);
	         
	         BoolExpr translatedFormula = ctx.mkAnd(allExprs);
	        System.out.println("\n-----------\n solveFormula2GetMapValues:: ");
	         System.out.println(translatedFormula);
	         
	         Model model=check(ctx,translatedFormula,Status.SATISFIABLE);
	         //int value;
	         if(model!=null){//there is a concrete model, then return the model as a HashMap<String,Integer> object
	            Map<String, Long> result = new HashMap<String, Long>();
	            for(String varName: vars.keySet()){     
	               Expr value = model.evaluate(vars.get(varName), false);
	               try{
	            	   result.put(varName, Long.valueOf(value.toString()));
	               }catch(Exception e){
	            	   
	               }
	            }	            
	            //System.out.println("best low input: " + result);
	            return result;
	         }else{
	            //System.out.println("\nCannot find best low input");
	            return null; //the formula is unsatisfiable, non-interference is guaranteed.
	         }
	      }
	      
	      catch (Z3Exception e) {
	         e.printStackTrace();
	      }
	      catch (TermParserException e) {
	         e.printStackTrace();
	      }
	      return null;
   }
   
   /*
    * find all models satisfying given formula
    * */
   public List<Map<String,Long>> findAllSatisfiableModels(){
	   try {                             
	        
	         
	         //transform formula into Z3 expression format 
	         BoolExpr expr=(BoolExpr)translateTerm(formula);
	         //BoolExpr expr=(BoolExpr)parseTermBV(formula);
	         axioms.add(expr);
	         BoolExpr[] allExprs = axioms.toArray(new BoolExpr[axioms.size()]);
	         
	         BoolExpr translatedFormula = ctx.mkAnd(allExprs);
	         System.out.println("\n-----------\n formula to find all satisfying models:: ");
	         System.out.println(translatedFormula);
	         List<Map<String,Long>> result = new LinkedList<Map<String,Long>>();
	         while(true){
		         Model model=check(ctx,translatedFormula,Status.SATISFIABLE);
		         //int value;
		         if(model!=null){//there is a concrete model, then return the model as a HashMap<String,Integer> object
		            Map<String, Long> solution = new HashMap<String, Long>();
		            BoolExpr aggNewCondition = ctx.mkFalse();
		            for(String varName: vars.keySet()){     
		               Expr value = model.evaluate(vars.get(varName), false);
		               try{
		               solution.put(varName, Long.valueOf(value.toString()));		         
		               BoolExpr newCondition = ctx.mkNot(ctx.mkEq(vars.get(varName), value));
		               aggNewCondition = ctx.mkOr(new BoolExpr[]{aggNewCondition,newCondition});
		               }catch(NumberFormatException e){
		            	   continue;
		               }
		            }
		            
		               /*
			            * add new constraints to translatedFormula
			            * so that we can avoid previous value
			            */
		            translatedFormula = ctx.mkAnd(new BoolExpr[]{translatedFormula,aggNewCondition});
		           //System.out.println("translatedFormula: " + translatedFormula);
		           result.add(solution);	
		           if(result.size()>10){
		        	   System.out.println("there are more than 10 solutions");
		        	   return result;
		           }
		         }else{
		            return result;
		         }
	         }
	      }
	      
	      catch (Z3Exception e) {
	         e.printStackTrace();
	      }
	      catch (TermParserException e) {
	         e.printStackTrace();
	      }
	      return null;
   }
   
   public boolean checkValid(){	   
	 try {
		//parseVariables(formula);

		 //printVariables();
	       
	       //transform formula into Z3 expression format 
	       BoolExpr expr=(BoolExpr)translateTerm(formula);
	       //BoolExpr expr=(BoolExpr)parseTermBV(formula);
	       axioms.add(expr);
	       BoolExpr[] allExprs = axioms.toArray(new BoolExpr[axioms.size()]);
	       
	       BoolExpr translatedFormula = ctx.mkNot(ctx.mkAnd(allExprs));
	       //System.out.println("translatedFormula to checkValid: " + translatedFormula);
	       Model model=check(ctx,translatedFormula,Status.SATISFIABLE);
	       //int value;
	       if(model!=null){//negation is satisfiable, then return false
	    	   
	         return false;
	       }else{            
	          return true; //otherwise, return true
	       }       
	} catch (Z3Exception e) {
		
	} catch (TermParserException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
     return false;       
   }
   
   /*
    * check if there is one and only one model satisfying formula w.r.t. list of variable name
    * if YES: return this model and the number 1
    * if there is more than one model: return the first model and the number 2
    * if there is no model or exception: return null
    * */
   public Pair<Map<String, Long>,Integer> onlyOneSatisfiableModel(List<String> varNames) {
	   try{
		   
		   //parseVariables(formula);
	       //printVariables();	       
	       //transform formula into Z3 expression format 
	       BoolExpr expr=(BoolExpr)translateTerm(formula);
	       //BoolExpr expr=(BoolExpr)parseTermBV(formula);
	       axioms.add(expr);
	       BoolExpr[] allExprs = axioms.toArray(new BoolExpr[axioms.size()]);
	       
	       BoolExpr translatedFormula = ctx.mkAnd(allExprs);      
	        //System.out.println("translatedFormula of onlyOneSatisfiableModel:" + translatedFormula);
		     Model model=check(ctx,translatedFormula,Status.SATISFIABLE);
		     //int value;
		     
		     if(model!=null){//there is a concrete model, then add new constraint into 
		    	//System.out.println("satisfiable!!!");
		        Map<String, Long> solution = new HashMap<String, Long>();
		        BoolExpr aggNewCondition = ctx.mkFalse();
		        for(String varName: varNames){     
		           Expr value = model.evaluate(vars.get(varName), false);
		           solution.put(varName, Long.valueOf(value.toString()));		           		         
		           BoolExpr newCondition = ctx.mkNot(ctx.mkEq(vars.get(varName), value));
		           if(varNames.contains(varName))
		        	   aggNewCondition = ctx.mkOr(new BoolExpr[]{aggNewCondition,newCondition});		          
		        }
		        /*
		            * add new constraints to translatedFormula
		            * so that we can avoid previous value
		            */
		        translatedFormula = ctx.mkAnd(new BoolExpr[]{translatedFormula,aggNewCondition});
		        //System.out.println("translatedFormula: " + translatedFormula);
		        Model newModel=check(ctx,translatedFormula,Status.SATISFIABLE);
		        if(newModel!=null){//there is more than one solutions
		        	return new Pair<Map<String,Long>,Integer>(solution,2);
		        }else{
		        	return new Pair<Map<String,Long>,Integer>(solution,1);
		        }		                		           
		     }else{
		    	 //System.out.println("unsatisfiable!!!");
		        return null; //the formula is unsatisfiable
		     }
	   }catch(Exception e){
		   //System.out.println(e);
		   return null;
	   }
   } 
 }

