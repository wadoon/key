/**
 * 
 */
package de.tud.exploitgen.solver;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.parsers.TermParserException;
//import com.csvanefalk.keytestgen.core.model.implementation.Model;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.ModelVariableGenerator;
import de.tud.exploitgen.util.TermParser;
import com.microsoft.z3.*;
/**
 * this class integrates Z3 SMT Solver directly using Z3 for Java API  
 * @author Huy Do
 *
 */
public class Z3Solver extends AbstractFormulaSolver {

   /* (non-Javadoc)
    * @see com.huydo.exploitgen.FormulaSolver#solveFormula()
    */
   
   private Map<String,Expr> vars=new HashMap<String,Expr>(); //list of program variables in the term. 
  
   Context ctx; //ctx contains methods to create expressions
   @Override   
   public Map<String, Integer> solveFormulaInt() {         
      try {
         //get all variables in the formula
         parseVariables(formula);
         //parseVariablesBV(formula);
         //printVariables();
         
         //transform formula into Z3 expression format 
         BoolExpr expr=(BoolExpr)parseTerm(formula);
         //BoolExpr expr=(BoolExpr)parseTermBV(formula);
         
         System.out.println("\n-----------\nInterference formula: ");
         System.out.println(expr);
         
         Model model=check(ctx,expr,Status.SATISFIABLE);
         int value;
         if(model!=null){//there is a concrete model, then return the model as a HashMap<String,Integer> object
            //System.out.println("*********Parsing value into model**********");
            Map<String,Integer> result=new HashMap<String,Integer>();
            for(String var: vars.keySet()){              
               System.out.println(var + " : " + model.Evaluate(vars.get(var), false).toString());
               try{
                  value = Integer.parseInt(model.Evaluate(vars.get(var), false).toString());                  
               } catch(Exception e){
                  value = 0;
               }
               
               result.put(var, value);
            }
            return result;
         }else
            return null; //the formula is unsatisfiable, non-interference is guaranteed.
      }
      catch (TermParserException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
      catch (Z3Exception e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
      return null;
   }

   
   /**
    * @param formula
    */
   public Z3Solver(Term formula) {
      super(formula);
      // TODO Auto-generated constructor stub
      HashMap<String, String> cfg = new HashMap<String, String>();
      cfg.put("proof", "true");      
      try {
         ctx = new Context(cfg);
      }
      catch (Z3Exception e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }      
   }
   
   /*
    * parse all program variables in Term into @vars
    * */
   private void parseVariables(final Term term) throws Z3Exception{
      if(term!=null){
         if(TermParser.isLocationVariable(term) || KeYResourceHandler.isArtificialVariable(term)){           
            String name =term.op().name().toString();
            //check if vars does not contain this variable then add it
            if(!vars.containsKey(name)){ 
               Expr var;
              /*
               * check variable's type
               * at the moment we just support Integer and Boolean
               * */
               if(TermParser.isIntegerType(term)){
                  var=(IntExpr)ctx.MkIntConst(name); 
                  
               }else if(TermParser.isBoolean(term)){
                  var=ctx.MkBoolConst(name);                  
               }else var=(IntExpr)ctx.MkIntConst(name); //Integer is default type
               
               vars.put(name, var); //add this variable into collection of program varibales
            }            
         }        
        	 
         
         else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               parseVariables(st);
            }
         }
      }
   }
   
   /*parse all program variables in term into vars, uses BVSExpr*/
   private void parseVariablesBV(final Term term) throws Z3Exception{
      if(term!=null){
         if(TermParser.isLocationVariable(term)){           
            String name =term.op().name().toString();
            //check if vars does not contain this variable then add it
            if(!vars.containsKey(name)){ 
               Expr var;
               //use Bit vector type for all variables
               var = (BitVecExpr)ctx.MkBVConst(name, 64);
               vars.put(name, var); //add this variable into collection of program varibales
            }
         }else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               parseVariables(st);
            }
         }
      }
   }
   
   //try printing all variables expression after parsing from Formula 
   public void printVariables() throws Z3Exception{
      System.out.println("variables collection:");
      parseVariables(formula);
      for(String name: vars.keySet()){
         System.out.println(name + " --- parsed by Z3 Solver");
      }
   }
   
   
   /*
    * parse Term into Z3 Expression, mainly focus on parsing formula
    * */
   private Expr parseTerm(final Term term) throws Z3Exception, TermParserException{
      if(term!=null){
         //if term is variables, simply return corresponding variable expression
         if(TermParser.isLocationVariable(term)|| KeYResourceHandler.isArtificialVariable(term)){
            return vars.get(term.op().name().toString());
         }else
         
         /*
          * check if term is a logical operation 
          * */
         //if term is not a function
         if(TermParser.isNot(term)){
            return ctx.MkNot((BoolExpr)parseTerm(term.sub(0)));
         }else
         //if term is and function
         if(TermParser.isAnd(term)){
            BoolExpr[] subs={(BoolExpr)parseTerm(term.sub(0)),(BoolExpr)parseTerm(term.sub(1))};
            return ctx.MkAnd(subs);
         }else
        //if term is or function
         if(TermParser.isOr(term)){
            BoolExpr[] subs={(BoolExpr)parseTerm(term.sub(0)),(BoolExpr)parseTerm(term.sub(1))};
            return ctx.MkOr(subs);
         }else
         
         //if term is implication
         if(TermParser.isImplication(term)){
            BoolExpr[] subs={(BoolExpr)parseTerm(term.sub(0)),(BoolExpr)parseTerm(term.sub(1))};            
            return ctx.MkImplies(subs[0], subs[1]);
         }else 
         
         /*
          * check if term is a arithmetic operation 
          * */
         //if term is addition
         if(TermParser.isAddition(term)){
            ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkAdd(subs);
         }else
         //if term is subtraction
         if(TermParser.isSubtraction(term)){
            ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkSub(subs);
         }else
         //if term is multiplication
         if(TermParser.isMultiplication(term)){
            ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkMul(subs);
         }else
       //if term is division
         if(TermParser.isDivision(term)){
            ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkDiv(subs[0], subs[1]);
         }else
         //if term is minus function, transform -(expression) to expression * (-1)
         if(TermParser.isUnaryMinusFunction(term)){
            //ArithExpr[] subs = {(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)ctx.MkInt(-1)};
            //return ctx.MkMul(subs);
            return ctx.MkUnaryMinus((ArithExpr)parseTerm(term.sub(0)));
         }else
         
         /*
          * check if term is a comparison operation 
          * */
        //if term is greater
         if(TermParser.isGreaterThan(term)){
            return ctx.MkGt((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
       //if term is greater or equal
         if(TermParser.isGreaterOrEquals(term)){
            return ctx.MkGe((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
         
       // if term is less than
         if(TermParser.isLessThan(term)){
            return ctx.MkLt((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
      // if term is less or equal
         if(TermParser.isLessOrEquals(term)){
            return ctx.MkLe((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
       // if term is equal
         if(TermParser.isEquals(term)){
            return ctx.MkEq((Expr)parseTerm(term.sub(0)),(Expr)parseTerm(term.sub(1)));
         }else                 
            
         /*
          * check if term is a quantifier: forall, exists
          * */
         if(TermParser.isForAllQuantifier(term)){
            
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            //System.out.println("^^^^^^^ bounded variable: " + boundVars.get(0).name().toString());
            Expr[] boundExprs = new Expr[]{vars.get(boundVars.get(0).name().toString())};
            //System.out.println(term.sub(0));
            return ctx.MkForall(boundExprs, parseTerm(term.sub(0)), 0, null, null, null, null);
              
         }else
                     
          //if term is if-then-else
         if(TermParser.isIfThenElse(term)){
            return ctx.MkITE((BoolExpr)parseTerm(term.sub(0)), 
                  (ArithExpr)parseTerm(term.sub(1)), (ArithExpr)parseTerm(term.sub(2)));
         }
         /*
          * check if Term is a constant                  * 
          */            
         //if term is boolean constant
         if(TermParser.isBooleanConstant(term)){
            return ctx.MkBool(TermParser.translateToJavaBoolean(term));
         }else   
         
        //if term is a integer constant
        if(TermParser.isInteger(term)){
           //return ctx.MkInt(TermParser.getIntegerValue(term));
           return ctx.MkInt(TermParser.getIntegerValue(term));
        }else
           return ctx.MkTrue();            
      
      }
      return ctx.MkTrue();
   }
   
   //parse term, use Bit vector type
   private Expr parseTermBV(final Term term) throws Z3Exception, TermParserException{
      if(term!=null){
         //if term is variables, simply return corresponding variable expression
         if(TermParser.isLocationVariable(term)){
            return vars.get(term.op().name().toString());
         }else
         
         /*
          * check if term is a logical operation 
          * */
         //if term is not a function
         if(TermParser.isNot(term)){
            return ctx.MkNot((BoolExpr)parseTerm(term.sub(0)));
         }else
         //if term is and function
         if(TermParser.isAnd(term)){
            BoolExpr[] subs={(BoolExpr)parseTerm(term.sub(0)),(BoolExpr)parseTerm(term.sub(1))};
            return ctx.MkAnd(subs);
         }else
        //if term is or function
         if(TermParser.isOr(term)){
            BoolExpr[] subs={(BoolExpr)parseTerm(term.sub(0)),(BoolExpr)parseTerm(term.sub(1))};
            return ctx.MkOr(subs);
         }else
         
         
         /*
          * check if term is a arithmetic operation 
          * */
         //if term is addition
         if(TermParser.isAddition(term)){
            
            /*ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkAdd(subs);*/
            return ctx.MkBVAdd((BitVecExpr)parseTerm(term.sub(0)), (BitVecExpr)parseTerm(term.sub(0)));
         }else
         //if term is subtraction
         if(TermParser.isSubtraction(term)){
            /*ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkSub(subs);*/
            return ctx.MkBVSub((BitVecExpr)parseTerm(term.sub(0)), (BitVecExpr)parseTerm(term.sub(0)));
         }else
         //if term is multiplication
         if(TermParser.isMultiplication(term)){
            /*ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkMul(subs);*/
            return ctx.MkBVMul((BitVecExpr)parseTerm(term.sub(0)), (BitVecExpr)parseTerm(term.sub(0)));
         }else
       //if term is division
         if(TermParser.isDivision(term)){
           /* ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkDiv(subs[0], subs[1]);*/
            return ctx.MkBVSDiv((BitVecExpr)parseTerm(term.sub(0)), (BitVecExpr)parseTerm(term.sub(0)));
         }else
         //if term is minus function, transform -(expression) to expression * (-1)
         if(TermParser.isUnaryMinusFunction(term)){
            /*ArithExpr[] subs = {(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)ctx.MkInt(-1)};
            return ctx.MkMul(subs);*/
            return ctx.MkBVNeg((BitVecExpr)parseTerm(term.sub(0)));
         }else
         
         /*
          * check if term is a comparison operation 
          * */
        //if term is greater
         if(TermParser.isGreaterThan(term)){
            return ctx.MkBVSGT((BitVecExpr)parseTerm(term.sub(0)), (BitVecExpr)parseTerm(term.sub(1)));
         }else
       //if term is greater or equal
         if(TermParser.isGreaterOrEquals(term)){
            return ctx.MkBVSGE((BitVecExpr)parseTerm(term.sub(0)),(BitVecExpr)parseTerm(term.sub(1)));
         }else
         
       // if term is less than
         if(TermParser.isLessThan(term)){
            return ctx.MkBVSLT((BitVecExpr)parseTerm(term.sub(0)),(BitVecExpr)parseTerm(term.sub(1)));
         }else
      // if term is less or equal
         if(TermParser.isLessOrEquals(term)){
            return ctx.MkBVSLE((BitVecExpr)parseTerm(term.sub(0)),(BitVecExpr)parseTerm(term.sub(1)));
         }else
       // if term is equal
         if(TermParser.isEquals(term)){
            return ctx.MkEq((Expr)parseTerm(term.sub(0)),(Expr)parseTerm(term.sub(1)));
         }else
         
         
         /*
          * check if Term is a constant                  * 
          */            
         //if term is boolean constant
         if(TermParser.isBooleanConstant(term)){
            return ctx.MkBool(TermParser.translateToJavaBoolean(term));
            
         }else     
         
        //if term is a integer constant
        if(TermParser.isInteger(term)){
           //return ctx.MkInt(TermParser.getIntegerValue(term));
           return ctx.MkBV(TermParser.getIntegerValue(term),64);
        }else
           return ctx.MkTrue();            
      
      }
      return ctx.MkTrue();
   }
   
   Model check(Context ctx, BoolExpr f, Status sat) throws Z3Exception{
      Solver s = ctx.MkSolver();
      s.Assert(f);
      if (s.Check() != sat){
         //System.out.println("unsatisfiable!");      
         return null;
      }else return s.Model();
    }

  
   public List<ModelVariable> solveFormula(){
      
      try {                    
         //get all variables in the formula
         parseVariables(formula);
         //parseVariablesBV(formula);
         //printVariables();
         
         //transform formula into Z3 expression format 
         BoolExpr expr=(BoolExpr)parseTerm(formula);
         //BoolExpr expr=(BoolExpr)parseTermBV(formula);
         
         System.out.println("\n-----------\nInterference formula: ");
         System.out.println(expr);
         
         Model model=check(ctx,expr,Status.SATISFIABLE);
         //int value;
         if(model!=null){//there is a concrete model, then return the model as a HashMap<String,Integer> object
            LinkedList<ModelVariable> result = new LinkedList<ModelVariable>();
            for(String var: vars.keySet()){         
               System.out.println(var + " : " + model.Evaluate(vars.get(var), false).toString());
               ModelVariable mv = new ModelVariable(var);
               Expr value = model.Evaluate(vars.get(var), false);
               if(value.IsIntNum()){
                  mv.setValue(Integer.parseInt(value.toString()));                  
               }else if(value.IsTrue()){
                  mv.setValue(true);
               }else if(value.IsFalse()){
                  mv.setValue(false);
               }
               result.add(mv);               
            }
            return result;
         }else
            return null; //the formula is unsatisfiable, non-interference is guaranteed.
      }
      catch (TermParserException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
      catch (Z3Exception e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
      return null;
      
   }

  
   
   
}
