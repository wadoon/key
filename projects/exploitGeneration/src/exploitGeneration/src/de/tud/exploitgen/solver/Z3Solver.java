/**
 * 
 */
package de.tud.exploitgen.solver;

import java.util.HashMap;
import java.util.Map;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.Term;

import com.csvanefalk.keytestgen.util.parsers.TermParserException;
import com.csvanefalk.keytestgen.util.parsers.TermParserTools;
import com.microsoft.z3.*;
/**
 * this class integrates Z3 SMT Solver directly using Z3 for Java API  
 * @author Huy Do
 *
 */
public class Z3Solver extends FormulaSolver {

   /* (non-Javadoc)
    * @see com.huydo.exploitgen.FormulaSolver#solveFormula()
    */
   
   private Map<String,Expr> vars=new HashMap<String,Expr>(); //list of program variables in the term. 
  
   Context ctx; //ctx contains methods to create expressions
   @Override   
   public Map<String, Integer> solveFormula() {         
      try {
         //get all variables in the formula
         parseVariables(formula);
         
         //transform formula into Z3 expression format 
         BoolExpr expr=(BoolExpr)parseTerm(formula);
         
         System.out.println("expression created from formula is:");
         System.out.println(expr.toString());
         
         Model model=check(ctx,expr,Status.SATISFIABLE);
         
         if(model!=null){//there is a concrete model, then return the model as a HashMap<String,Integer> object
            Map<String,Integer> result=new HashMap<String,Integer>();
            for(String var: vars.keySet()){              
               result.put(var,Integer.parseInt(model.Evaluate(vars.get(var), false).toString()) );
            }
            return result;
         }else
            return null; //the formula is unsatisfiable, non-interference is guaranteed.
      }
      catch (TermParserException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
      catch (Z3Exception e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
      return null;
   }

   /**
    * @param formula
    */
   public Z3Solver(Term formula) {
      super(formula);
      // TODO Auto-generated constructor stub
      HashMap<String, String> cfg = new HashMap<String, String>();
      cfg.put("proof", "true");      
      try {
         ctx = new Context(cfg);
      }
      catch (Z3Exception e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }      
   }
   
   /*
    * parse all program variables in Term into @vars
    * */
   private void parseVariables(final Term term) throws Z3Exception{
      if(term!=null){
         if(TermParserTools.isLocationVariable(term)){           
            String name =term.op().name().toString();
            //check if vars does not contain this variable then add it
            if(!vars.containsKey(name)){ 
               Expr var;
              /*
               * check variable's type
               * at the moment we just support Integer and Boolean
               * */
               if(TermParserTools.isIntegerType(term)){
                  var=(IntExpr)ctx.MkIntConst(name);                  
               }else if(TermParserTools.isBoolean(term)){
                  var=ctx.MkBoolConst(name);
               }else var=(IntExpr)ctx.MkIntConst(name); //Integer is default type
               
               vars.put(name, var); //add this variable into collection of program varibales
            }
         }else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               parseVariables(st);
            }
         }
      }
   }
   
   //try printing all variables expression after parsing from Formula 
   public void printVariables() throws Z3Exception{
      System.out.println("variables collection:");
      parseVariables(formula);
      for(String name: vars.keySet()){
         System.out.println(name + " --- parsed by Z3 Solver");
      }
   }
   
   
   /*
    * parse Term into Z3 Expression, mainly focus on parsing formula
    * */
   private Expr parseTerm(final Term term) throws Z3Exception, TermParserException{
      if(term!=null){
         //if term is variables, simply return corresponding variable expression
         if(TermParserTools.isLocationVariable(term)){
            return vars.get(term.op().name().toString());
         }else
         
         /*
          * check if term is a logical operation 
          * */
         //if term is not a function
         if(TermParserTools.isNot(term)){
            return ctx.MkNot((BoolExpr)parseTerm(term.sub(0)));
         }else
         //if term is and function
         if(TermParserTools.isAnd(term)){
            BoolExpr[] subs={(BoolExpr)parseTerm(term.sub(0)),(BoolExpr)parseTerm(term.sub(1))};
            return ctx.MkAnd(subs);
         }else
        //if term is or function
         if(TermParserTools.isOr(term)){
            BoolExpr[] subs={(BoolExpr)parseTerm(term.sub(0)),(BoolExpr)parseTerm(term.sub(1))};
            return ctx.MkOr(subs);
         }else
         
         
         /*
          * check if term is a arithmetic operation 
          * */
         //if term is addition
         if(TermParserTools.isAddition(term)){
            ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkAdd(subs);
         }else
         //if term is subtraction
         if(TermParserTools.isSubtraction(term)){
            ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkSub(subs);
         }else
         //if term is multiplication
         if(TermParserTools.isMultiplication(term)){
            ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkMul(subs);
         }else
       //if term is division
         if(TermParserTools.isDivision(term)){
            ArithExpr[] subs={(ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1))};
            return ctx.MkDiv(subs[0], subs[1]);
         }else
         
         /*
          * check if term is a comparison operation 
          * */
        //if term is greater
         if(TermParserTools.isGreaterThan(term)){
            return ctx.MkGt((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
       //if term is greater or equal
         if(TermParserTools.isGreaterOrEquals(term)){
            return ctx.MkGe((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
         
       // if term is less than
         if(TermParserTools.isLessThan(term)){
            return ctx.MkLt((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
      // if term is less or equal
         if(TermParserTools.isLessOrEquals(term)){
            return ctx.MkLe((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
       // if term is equal
         if(TermParserTools.isEquals(term)){
            return ctx.MkEq((ArithExpr)parseTerm(term.sub(0)),(ArithExpr)parseTerm(term.sub(1)));
         }else
            
         /*
          * check if Term is a constant                  * 
          */            
         //if term is boolean constant
         /*if(TermParserTools.isBooleanConstant(term)){
            return ctx.MkBool(TermParserTools.translateToJavaBoolean(term));
         }else */    
         
        //if term is a integer constant
        if(TermParserTools.isInteger(term)){
           return ctx.MkInt(TermParserTools.getIntegerValue(term));
        }else
           return ctx.MkTrue();            
      
      }
      return ctx.MkTrue();
   }
    
   Model check(Context ctx, BoolExpr f, Status sat) throws Z3Exception{
      Solver s = ctx.MkSolver();
      s.Assert(f);
      if (s.Check() != sat){
         System.out.println("unsatisfiable!");      
         return null;
      }else return s.Model();
    }
  
   
   
}
