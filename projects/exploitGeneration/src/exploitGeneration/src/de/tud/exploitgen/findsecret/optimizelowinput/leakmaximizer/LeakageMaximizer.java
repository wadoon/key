package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.smt.lang.SMTTermBinOp.Op;
import de.uka.ilkd.key.util.Pair;


public abstract class LeakageMaximizer {
	protected List<PPCountingResult> listCountingResults;	
	//private CountingResultTree countTree; //is created from listCountingResult	
	protected Services services;
	protected List<String> listLowVars;
	protected List<MatchableCountingSolution> listMatchableSolutions;	

	
	protected abstract void extract2ListMatchableCountingSolution();
	
	protected abstract OptimalSolution findOptimalSolution4SingleCase(MatchableCountingSolution matchCountSolution);
	protected abstract OptimalSolution findGlobalOptimalSolution(List<OptimalSolution> listOptimalSolutions);
	protected abstract double computeLeakage(OptimalSolution bestSolution);
	/*
	 * compute Shannon-entropy-leakage for the case all counting term is constant
	 * */
	protected abstract OptimalSolution resolveConstantSolution(MatchableCountingSolution matchCountSolution);
	
	protected abstract OptimalSolution resolve4UniqueSolution(MatchableCountingSolution matchCountSolution);
	
	
	
	public LeakageMaximizer(List<PPCountingResult> listCountingResults, Services services, List<String> listLowVars) {
		super();
		this.listCountingResults = listCountingResults;		 
		this.services = services;
		this.listLowVars = listLowVars;
		//printInfoOfListCountingResults();
		resolvePPCountingResult();

	}	
	
	public Pair<Map<String,Long>, Double> findLowInputMaximizingLeakge(){
		List<OptimalSolution> listOptimalSolutions = new LinkedList<OptimalSolution>();
		for(MatchableCountingSolution countingSolution: listMatchableSolutions){
			//countingSolution.printInfo();
			OptimalSolution solution = findOptimalSolution(countingSolution);
			//solution.printInfo();
			listOptimalSolutions.add(solution);
		}
		
		OptimalSolution bestSolution = findGlobalOptimalSolution(listOptimalSolutions);
		
		double maximumLeakage = computeLeakage(bestSolution);
		return new Pair<Map<String,Long>, Double>(bestSolution.getSolution(),maximumLeakage);
	}
	
	public void printInfoOfListCountingResults(){
		System.out.println("information about list counting result:");
		for(int i=0;i<listCountingResults.size();i++){
			System.out.println("number of count result " + i + " : " + listCountingResults.get(i).getListResults().size());
			for(CountingSolution result: listCountingResults.get(i).getListResults()){
				System.out.println("  value: "+ result.getValue() + "; condition: " + result.getCondition());
			}
		}
		System.out.println("----");
	}	
	
	
	protected OptimalSolution findOptimalSolution(MatchableCountingSolution countSolution){
		if(countSolution.allCountTermsIsConstant()){
			return resolveConstantSolution(countSolution);			
			
		}else{		
			if(countSolution.isUniqueModel()){//there is only one satisfying model
				return resolve4UniqueSolution(countSolution);
			}
			else{
				return findOptimalSolution4SingleCase(countSolution);
			}
		}				 
	}
	
	

	protected OptimalSolution findMimimumSolution(List<OptimalSolution> listSolution){
		if(listSolution.size()>0){			
			OptimalSolution bestSolution = listSolution.get(0);	
			bestSolution.printInfo();
			for(int i=1; i<listSolution.size(); i++){
				listSolution.get(i).printInfo();
				if(bestSolution.getOptimizeValue()>listSolution.get(i).getOptimizeValue())
					bestSolution = listSolution.get(i);
			}
			System.out.println("best solution found:");
			bestSolution.printInfo();
			return bestSolution;
			
		}else
			return null;
	}
	
	protected OptimalSolution findMaximumSolution(List<OptimalSolution> listSolution){
		if(listSolution.size()>0){			
			OptimalSolution bestSolution = listSolution.get(0);	
			bestSolution.printInfo();
			for(int i=1; i<listSolution.size(); i++){
				listSolution.get(i).printInfo();
				if(bestSolution.getOptimizeValue()<listSolution.get(i).getOptimizeValue())
					bestSolution = listSolution.get(i);
			}
			System.out.println("best solution found:");
			bestSolution.printInfo();
			return bestSolution;			
		}else
			return null;
	}
	
	/*
	 * add zero result into each PPCountingResult 
	 * */
	private void resolvePPCountingResult(){		
		for(PPCountingResult countResult: listCountingResults){
			countResult.setListResults(countResult.replaceOrCondition());
			//countResult.addZeroResult(services.getTermBuilder());			
		}		
	}
	
}
