package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.math.BigInteger;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.smt.lang.SMTTermBinOp.Op;
import de.uka.ilkd.key.util.Pair;


public abstract class LeakageMaximizer {
	protected List<PPCountingResult> listCountingResults;	
	//private CountingResultTree countTree; //is created from listCountingResult	
	protected Services services;
	protected List<String> listLowVars;
	protected List<MatchableCountingSolution> listMatchableSolutions;	
	protected String optSolver;
	protected final BigInteger numberOfHighValues; //number of possible high values calculated via currentKnowlegde
	
	//protected abstract void extract2ListMatchableCountingSolution();
	
	protected abstract OptimalSolution findOptimalSolution4SingleCase(MatchableCountingSolution matchCountSolution);
	protected abstract OptimalSolution findGlobalOptimalSolution(List<OptimalSolution> listOptimalSolutions);
	protected abstract double computeLeakage(OptimalSolution bestSolution);
	/*
	 * compute Shannon-entropy-leakage for the case all counting term is constant
	 * */
	protected abstract OptimalSolution resolveConstantSolution(MatchableCountingSolution matchCountSolution);
	
	protected abstract OptimalSolution resolve4UniqueSolution(MatchableCountingSolution matchCountSolution);
	
	
	
	public LeakageMaximizer(List<PPCountingResult> listCountingResults, Services services, List<String> listLowVars, String optSolver, BigInteger numberOfHighValues) {
		super();
		this.listCountingResults = listCountingResults;		 
		this.services = services;
		this.listLowVars = listLowVars;
		this.optSolver = optSolver;
		this.numberOfHighValues = numberOfHighValues;
		//printInfoOfListCountingResults();
		resolvePPCountingResult();
	}	
	
	public Pair<Map<String,Long>, Double> findLowInputMaximizingLeakge(){
		List<OptimalSolution> listOptimalSolutions = new LinkedList<OptimalSolution>();
		for(MatchableCountingSolution countingSolution: listMatchableSolutions){
			//countingSolution.printInfo();
			OptimalSolution solution = findOptimalSolution(countingSolution);
			//solution.printInfo();
			if(solution!=null)
				listOptimalSolutions.add(solution);
		}
		if(listOptimalSolutions.size()>0){
			OptimalSolution bestSolution = findGlobalOptimalSolution(listOptimalSolutions);
			
			double maximumLeakage = computeLeakage(bestSolution);
			return new Pair<Map<String,Long>, Double>(bestSolution.getSolution(),maximumLeakage);
		}else
			return null;
	}
	
	public void printInfoOfListCountingResults(){
		System.out.println("information about list counting result:");
		for(int i=0;i<listCountingResults.size();i++){
			System.out.println("number of count result " + i + " : " + listCountingResults.get(i).getListResults().size());
			for(CountingSolution result: listCountingResults.get(i).getListResults()){
				System.out.println("  value: "+ result.getValue() + "; \ncondition: " + result.getCondition());
			}
		}
		System.out.println("----");
	}	
	
	public void printInfoOfListMatchableCountingSolutions(){
		System.out.println("information about list of matchable counting solution:");
		for(MatchableCountingSolution mcSolution: listMatchableSolutions)
			mcSolution.printInfo();
		System.out.println("----");
	}	
	
	protected OptimalSolution findOptimalSolution(MatchableCountingSolution countSolution){
		if(countSolution.allCountTermsIsConstant(services)){
			return resolveConstantSolution(countSolution);			
			
		}else{		
			if(countSolution.isUniqueModel()){//there is only one satisfying model
				return resolve4UniqueSolution(countSolution);
			}
			else{
				return findOptimalSolution4SingleCase(countSolution);
			}
		}				 
	}
	
	

	protected OptimalSolution findMimimumSolution(List<OptimalSolution> listSolution){
		if(listSolution.size()>0){
			System.out.println("number of found solution: " + listSolution.size());
			OptimalSolution bestSolution = listSolution.get(0);	
			bestSolution.printInfo();
			for(int i=1; i<listSolution.size(); i++){
				listSolution.get(i).printInfo();
				if(bestSolution.getOptimizeValue()>listSolution.get(i).getOptimizeValue())
					bestSolution = listSolution.get(i);
			}
			System.out.println("best solution found:");
			bestSolution.printInfo();
			return bestSolution;
			
		}else
			return null;
	}
	
	protected OptimalSolution findMaximumSolution(List<OptimalSolution> listSolution){
		if(listSolution.size()>0){			
			OptimalSolution bestSolution = listSolution.get(0);	
			bestSolution.printInfo();
			for(int i=1; i<listSolution.size(); i++){
				listSolution.get(i).printInfo();
				if(bestSolution.getOptimizeValue()<listSolution.get(i).getOptimizeValue())
					bestSolution = listSolution.get(i);
			}
			System.out.println("best solution found:");
			bestSolution.printInfo();
			return bestSolution;			
		}else
			return null;
	}
	
	
	protected void extract2ListMatchableCountingSolution(){
		//System.out.println("start extracting to list of matchable counting solution!");
		CountingResultTree countTree = new CountingResultTree();
		for(PPCountingResult countResult: listCountingResults){			
			for(CountingResultTree leaf: countTree.getAllLeaves()){
				List<CountingResultTree> leaves = new LinkedList<CountingResultTree>();				
				for(CountingSolution condResult: countResult.getListResults()){
					if(!TermParser.isBooleanFalse(condResult.getCondition()))
						leaves.add(new CountingResultTree(condResult));
				}		
				leaf.addChildren(leaves, services);
			}
		}
		List<CountingResultTree> listAllCountingResults = countTree.getAllLeaves();
		System.out.println("all leaves have been added! number of leaves: " + listAllCountingResults.size());
		//remove all leaf that don't have enough childs (=listCountingResults.size)
		listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
		for(CountingResultTree tre: listAllCountingResults){
			List<Term> listCountTerms = tre.getListCountTerms();
			if(listCountTerms.size() == listCountingResults.size()){
				//create new condition: sum of all possible counting values must equal to numberOfHighValues
				TermBuilder tb = services.getTermBuilder();
				Term sum = tb.zero();
				for(Term t: listCountTerms){
					sum = tb.add(sum, t);
				}
				Term possCondition = tb.equals(sum, tb.zTerm(String.valueOf(numberOfHighValues)));
				Z3Solver z31 = new Z3Solver(possCondition, services);
				Term condition = tre.getConditionTerm();
				if(!z31.checkValid()){ //if possCondition is not valid then add it
					condition = tb.and(possCondition, condition);
				}
				Z3Solver z3 = new Z3Solver(condition, services);
				/*Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
				if(uniqueModel!=null)
					listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));*/
				Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
				if(uniqueModel!=null){
					if(uniqueModel.second==1) //there is only one model
					{
						System.out.println("unique model!!"+uniqueModel.first);
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,true));
					}
					else
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));
				}
			}		
		}		
		System.out.println("finish extracting! We found " + listMatchableSolutions.size() + " matchable solutions");
		if(listMatchableSolutions.size()==0){
			for(PPCountingResult countResult: listCountingResults){
				countResult.setListResults(countResult.replaceOrCondition());
				countResult.addZeroResult(services.getTermBuilder());			
			}
			
		}
	}
	
	protected void extract2ListMatchableSolutions(){
		extract2ListMatchableCountingSolution();
		if(listMatchableSolutions.size()==0){
			for(PPCountingResult countResult: listCountingResults){
				countResult.setListResults(countResult.replaceOrCondition());
				countResult.addZeroResult(services.getTermBuilder());			
			}
			extract2ListMatchableCountingSolution();
		}
	}
	
	/*
	 * add zero result into each PPCountingResult 
	 * */
	protected void resolvePPCountingResult(){		
		for(PPCountingResult countResult: listCountingResults){
			countResult.setListResults(countResult.replaceOrCondition());
			//countResult.addZeroResult(services.getTermBuilder());			
		}		
	}
	
	
	protected OptimalSolution findOptimalSolution4SingleCase(MatchableCountingSolution matchCountSolution, int metric) {		
		OptimizationSolver solver;
		if(optSolver.equals(KEGConstant.OPTSOLVER_ALL)){
			/*
			 * we try all solvers to find the best result
			 * pay attention: is might be very expensive
			 * at the moment we do not take into account couenne because it is usually very slow
			 * */
			List<OptimalSolution> listSolutions = new LinkedList<OptimalSolution>();
			solver = new OptLocalSolver(matchCountSolution, services, metric);
			OptimalSolution solution = solver.findOptimalSolution();
			if(solution!=null){
				System.out.println("solution found by local solver: "+ solution.getSolution() + "; optimal value: " +solution.getOptimizeValue());
				listSolutions.add(solution);
			}
			solver = new AMPLSolver(matchCountSolution, services, metric, KEGConstant.OPTSOLVER_BONMIN);
			solution = solver.findOptimalSolution();
			if(solution!=null){
				System.out.println("solution found by bonmin: "+ solution.getSolution() + "; optimal value: " + solution.getOptimizeValue());
				listSolutions.add(solution);
			}
			/*solver = new AMPLSolver(matchCountSolution, services, metric, KEGConstant.OPTSOLVER_COUENNE);
			solution = solver.findOptimalSolution();
			if(solution!=null)
				listSolutions.add(solution);*/
			
			if(listSolutions.size()>0)
				return findGlobalOptimalSolution(listSolutions);
			else
				return null;
			
			/*//first, we try local solver
			solver = new OptLocalSolver(matchCountSolution, services, metric);
			OptimalSolution solution = solver.findOptimalSolution();
			if(solution!=null)
				return solution;
			else{
				//try bonmin
				solver = new AMPLSolver(matchCountSolution, services, metric, KEGConstant.OPTSOLVER_BONMIN);
				solution = solver.findOptimalSolution();
				if(solution!=null)
					return solution;
				else{
					//try couenne
					solver = new AMPLSolver(matchCountSolution, services, metric, KEGConstant.OPTSOLVER_COUENNE);
					solution = solver.findOptimalSolution();
					if(solution!=null)
						return solution;
					else
						return null;
				}					
			}*/
		}else{
			if(optSolver.equals(KEGConstant.OPTSOLVER_LOCALSOLVER))			
				solver = new OptLocalSolver(matchCountSolution, services, metric);
			else
				solver = new AMPLSolver(matchCountSolution, services, metric, optSolver);
			
			return solver.findOptimalSolution();
		}
	}
	
	
}
