package de.tud.exploitgen.detectleak.specification.declassification;

import java.util.LinkedList;
import java.util.List;

import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.util.DelimitedRelease;
/*
 * store and pre-processing declassification (conditional delimited release)
 * */
public class DeclassificationCenter {
   private final List<CDRExtractor> listCDRExtractors;
   private Services services;
   
   public DeclassificationCenter(ImmutableList<DelimitedRelease> declassifies, Services services){
      this.services = services;
      listCDRExtractors = new LinkedList<CDRExtractor>();     
      if(declassifies!=null){
         if(declassifies.size()>0){
            int id = 0; //assign as id of each CDRExtractor instance
            for(DelimitedRelease decl: declassifies){
               listCDRExtractors.add(new CDRExtractor(decl,services,Integer.toString(id)));
               id++;
            }
         }
      }
   }

   public List<CDRExtractor> getListCDRExtractors() {
      return listCDRExtractors;
   }

   public Services getServices() {
      return services;
   }
   
   //get all ptcResults collected from all CDRExtractors
   public PairTermCollection getALLPtcResults(){
      PairTermCollection ptcResults = new PairTermCollection(services);
      for(CDRExtractor cdrExtractor: listCDRExtractors){
         ptcResults.combine(cdrExtractor.getPairResults());
      }
      return ptcResults;
   }
   
   //get all array terms from all CDRExtractor
   public List<Term> getAllArrays(){
      List<Term> result = new LinkedList<Term>();
      for(CDRExtractor cdrExtractor: listCDRExtractors){
         //List<Term> quanArrTerms = cdrExtractor.getListQuantifiedArrayTerm();
         List<Term> quanArrTerms = cdrExtractor.getListArrays();
         result = TermUtil.mergeListTerm(result, quanArrTerms);
      }
      return result;
   }
   
   //get all quantified array terms from all CDRExtractor
   public List<Term> getAllArrayElements(){
      List<Term> result = new LinkedList<Term>();
      for(CDRExtractor cdrExtractor: listCDRExtractors){
         //List<Term> quanArrTerms = cdrExtractor.getListQuantifiedArrayTerm();
         List<Term> qAElements = cdrExtractor.getListArrayElements();
         result = TermUtil.mergeListTerm(result, qAElements);
      }
      return result;
   }
  
   
   public List<Term> getAllQuantifiableVars(){
      List<Term> result = new LinkedList<Term>();
      for(CDRExtractor cdrExtractor: listCDRExtractors){
         List<Term> quantifiableVars = cdrExtractor.getListQuantifiableVars();
         result = TermUtil.mergeListTerm(result, quantifiableVars);
      }
      return result;
   }
   
   public Term getAllConditionalEscTerms(String heapName, String lowVar, PairTermCollection ptcAllVars, List<Term> listArrays){
      TermBuilder termBuilder = new TermBuilder(new TermFactory(),services);
      Term result = termBuilder.tt();
      for(CDRExtractor drExtractor: listCDRExtractors){     
         if(drExtractor.affect2Var(heapName, lowVar)){
            //integrate interference term with conditional delimited release
            //Term dlr = drExtractor.getConditionalEscTerm(ptcAllVars, heapName,listQuantifiedArrayTerm);
            Term dlr = drExtractor.getConditionalEscTerm(ptcAllVars, heapName,listArrays);
            //System.out.println("conditional escape hatches: " + dlr);
            result = termBuilder.and(result, dlr);         
         }
      }
      return result;
   }
   
   public Term getAllFreshConditionalEscTerms(String heapName, String lowVar, PairTermCollection ptcFoundation){
      TermBuilder termBuilder = new TermBuilder(new TermFactory(),services);
      Term result = termBuilder.tt();
      for(CDRExtractor drExtractor: listCDRExtractors){     
         if(drExtractor.affect2Var(heapName, lowVar)){
            //integrate interference term with conditional delimited release
            //Term dlr = drExtractor.getConditionalEscTerm(ptcAllVars, heapName,listQuantifiedArrayTerm);
            Term dlr = drExtractor.getFreshConditionalEscTerm(ptcFoundation);
            //System.out.println("fresh conditional escape hatches: " + dlr);
            result = termBuilder.and(result, dlr);         
         }
      }
      return result;
   }
}
