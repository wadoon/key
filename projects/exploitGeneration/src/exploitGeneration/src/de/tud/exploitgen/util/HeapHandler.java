/**
 * 
 */
package de.tud.exploitgen.util;



import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class supplies methods to handle heap value in the formula
 * @author Huy Do
 *
 */
public class HeapHandler {
   
   /*
    * check if a term is a value extract from heap memory by function "select(heap,self,..)"
    * return true iff it contains "select(heap"
    * */
   private static final TermBuilder termBuilder = TermBuilder.DF;
   private static final TermFactory tf = TermFactory.DEFAULT;
   
   public static boolean isHeapSelectFunction(Term t){
      if(t.op().toString().contains("::select")){
         return true;
      }else
         return false;
   }
   
 /*  public void printInfoHeapValue(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size());
      System.out.println("field name: " + getFieldName(t));
      
   }
   
   public void printInfoHeapVar(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size()); 
      
   }   */
   
      
   /*
    * get the field name in the term represent a heap (::select(heap,...)
    * */
   public static String getFieldName(Term t){
      Term object =t.sub(1);      
      Term field=t.sub(2); //access the field      
      String fieldString=field.toString();
      //get the field name, it follows "::$" in the fieldString
      String fieldName=fieldString.substring(fieldString.indexOf("$")+1);
      return (object.toString() + "_" + fieldName) ;
   }
   
   /*
    * get the field name in the term represent a heap (::select(heap,...)
    * sometimes, we have to use another heap name (parameter heapName) alter field name at t.sub(2)
    * for example: with precondition, declassification, the heap name is always "self",
    * but actually at each method, heap name could be "self_0", "self_1"
    * so actual heap name should be used (passed to parameter heapName)
    * */
   public static String getFieldName(Term t, String heapName){
      //Term object =t.sub(1);      
      Term field=t.sub(2); //access the field      
      String fieldString=field.toString();
      //get the field name, it follows "::$" in the fieldString
      String fieldName=fieldString.substring(fieldString.indexOf("$")+1);
      //return (object.toString() + "_" + fieldName) ;
      return (heapName + "_" + fieldName) ;
   }
   
   /*
    * get the term (local variable) which has the name is field name and has a same type with select function
    * */
    public Term getReplacedTerm(Term t){
       LocationVariable lv=new LocationVariable(new ProgramElementName(getFieldName(t)),t.sort());
       return termBuilder.var(lv);     
       
    }
    
    /*
     * get the term (local variable) which has the name is field name and has a same type with select function
     * parameter heapName is used to contribute the name of LocationVariable that represents for the field 
     * */
     public Term getReplacedTerm(Term t, String heapName){
        LocationVariable lv=new LocationVariable(new ProgramElementName(getFieldName(t,heapName)),t.sort());
        return termBuilder.var(lv);             
     }
    
   public boolean isField(Term t){      
      if(t.sort().toString().equals("Field"))
         return true;
      else
         return false;
   }
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * */
   public Term replaceSelectFunctionByItsField(Term t){
      if(t !=null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTerm(t);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs()));
         }
      }else return null;
   }
   
   private Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i));    
      return (result);
   }
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * parameter heapName is used to contribute the name of Term representing for the field
    * */
   public Term replaceSelectFunctionByItsField(Term t, String heapName){
      if(t !=null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTerm(t,heapName);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs(),heapName));
         }
      }else return null;
   }
   
   private Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs,String heapName){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i),heapName);    
      return (result);
   }
   
   
   /*
    * check if variables is heap (name = "self")
    * */
   public boolean isHeap(IExecutionVariable var)throws ProofInputException{     
         if(var.getName().startsWith("self"))
            return true;
         else return false;      
   }
   
}
