/**
 * 
 */
package de.tud.exploitgen.util;



import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;

/**
 * this class supplies methods to handle heap value in the formula
 * @author Huy Do
 *
 */
public class HeapHandler {
   
   /*
    * check if a term is a value extract from heap memory by function "select(heap,self,..)"
    * return true iff it contains "select(heap"
    * */
   private static final TermBuilder termBuilder = TermBuilder.DF;
   private static final TermFactory tf = TermFactory.DEFAULT;
   
   public boolean isHeapSelectFunction(Term t){
      if(t.op().toString().contains("::select")){
         return true;
      }else
         return false;
   }
   
   public void printInfoHeapValue(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size());
      System.out.println("field name: " + getFieldName(t));
      
   }
   
   public void printInfoHeapVar(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size()); 
      
   }   
   
   public void investigateTerm(Term t){
      if(t!=null){
         if(isHeapSelectFunction(t))
            printInfoHeapValue(t);
            //System.out.println(getFieldName(t));
         else{
            for(Term st: t.subs()){
               investigateTerm(st);
            }
         }
      }
   }
   
   /*
    * get the field name in the term represent a heap (::select(heap,...)
    * */
   public String getFieldName(Term t){
      Term object =t.sub(1);      
      Term field=t.sub(2); //access the field      
      String fieldString=field.toString();
      //get the field name, it follows "::$" in the fieldString
      String fieldName=fieldString.substring(fieldString.indexOf("$")+1);
      return (object.toString() + "_" + fieldName) ;
   }
   
   /*
    * get the term (local variable) which has the name is field name and has a same type with select function
    * */
    public Term getReplacedTerm(Term t){
       LocationVariable lv=new LocationVariable(new ProgramElementName(getFieldName(t)),t.sort());
       return termBuilder.var(lv);     
       
    }
    
   public boolean isField(Term t){      
      if(t.sort().toString().equals("Field"))
         return true;
      else
         return false;
   }
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * */
   public Term replaceSelectFunctionByItsField(Term t){
      if(t !=null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTerm(t);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs()));
         }
      }else return null;
   }
   
   public Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i));    
      return (result);
   }
   
}
