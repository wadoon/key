/**
 * 
 */
package de.tud.exploitgen.util;



import java.util.LinkedList;
import java.util.List;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.logic.sort.ArraySort;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class supplies methods to handle heap and other elements of object (static field) in the formula
 * @author Huy Do
 *
 */
public class HeapHandler {
   
   /*
    * check if a term is a value extract from heap memory by function "select(heap,self,..)"
    * return true iff it contains "select(heap"
    * */
   //private final Services services;
   private final TermBuilder termBuilder;
   private static final TermFactory tf = new TermFactory();
   
   public HeapHandler(Services services){
	   //this.services=services;
	   termBuilder=new TermBuilder(tf, services);
   }
   
   public static boolean isHeapSelectFunction(Term t){
      if(t!=null){
         if(t.op().toString().contains("::select"))
            return true;         
      }
      return false;
   }
   
  
   
 /*  public void printInfoHeapValue(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size());
      System.out.println("field name: " + getFieldName(t));
      
   }
   
   public void printInfoHeapVar(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size()); 
      
   }   */
   
      
   /*
    * get the field name in the term represent a heap select function (::select(heap,...)
    * */
   public static String getSynthesisNameOfHeapSelectFunction(Term t, String separator){
      
      String fieldName=getObjectNameOfSelect(t, separator)+ separator + getFieldNameOfSelect(t, separator);
      if(isAnonHeapSelectFunction(t)) //if t is a select function via loop heap then add prefix "loop_"
         fieldName = getAnonHeapName(t)+ separator + fieldName;
      return fieldName;
   }
   
   /*
    * get the field name in the term represent a heap select function(::select(heap,...)
    * sometimes, we have to use another heap name (parameter heapName) alter field name at t.sub(2)
    * for example: with precondition, declassification, the heap name is always "self",
    * but actually at each method, heap name could be "self_0", "self_1"
    * so actual heap name should be used (passed to parameter heapName)
    * if the object name (heap name) is "null", it means the variable is static, and we do not change the object name
    * */
   public static String getFieldNameOfHeapSelectFunction(Term t, String separator, String heapName){
      String objectName = getObjectNameOfSelect(t, separator);      
      String fieldName=objectName+ separator + getFieldNameOfSelect(t, separator);
      if(objectName.startsWith("self")){//if the variable is not static or parameter, we replace object name by corresponding heapName         
         //System.out.println("fieldName : -----* : "+fieldName + " ; heapName: " + heapName);
         int idx=fieldName.indexOf(separator);
         fieldName=fieldName.replace(fieldName.substring(0,idx), heapName);
         //System.out.println("fieldName : -------------> : "+fieldName);
      }
      return fieldName;
   }
   
   
   
   /*
    * get the term (local variable) which has the name is field name and has a same type with select function
    * */
    public Term getReplacedTermForSelect(Term t, String separator){
       LocationVariable lv=new LocationVariable(new ProgramElementName(getSynthesisNameOfHeapSelectFunction(t, separator)),t.sort());
       return termBuilder.var(lv);   
       
    }
    
    /*
     * get the term (local variable) which has the name is field name and has a same type with select function
     * parameter heapName is used to contribute the name of LocationVariable that represents for the field 
     * */
     public Term getReplacedTermForSelect(Term t, String separator, String heapName){
        LocationVariable lv=new LocationVariable(new ProgramElementName(getFieldNameOfHeapSelectFunction(t,separator, heapName)),t.sort());
        return termBuilder.var(lv);             
     }
    
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * */
   public Term replaceSelectFunctionByItsField(Term t, String separator){
      if(t != null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTermForSelect(t, separator);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs(), separator), t.boundVars(),t.javaBlock());
            
         }
      }else return null;
   }
   
   private Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs, String separator){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i), separator);    
      return (result);
   }
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * parameter heapName is used to contribute the name of Term representing for the field
    * */
   public Term replaceSelectFunctionByItsField(Term t, String separator, String heapName){
      if(t !=null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTermForSelect(t,separator,heapName);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs(),separator, heapName), t.boundVars(),t.javaBlock());
            
         }
      }else return null;
   }
   
   private Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs,String separator, String heapName){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i),separator, heapName);    
      return (result);
   }
   
   
  
   
   /*
    * get the field name in the term represent a heap (::select(heap,...) 
    * */
   public static String getFieldNameOfSelect(Term t, String separator){
      //Term object =t.sub(1);      
      Term field=t.sub(2); //access the field            
      if(isArrayIdxFunction(field)){
         if (isArrayElementNumber(field)){
            //if the select function accesses to an element of array
            return getArrayElementName(field);
         }else{
            /*Term idx = field.sub(0);
            if(isHeapSelectFunction(idx))
               return "I" + getSynthesisNameOfHeapSelectFunction(idx, separator);
            else if(isLengthFunction(idx))
               return "I" + getVarName4LengthFunction(idx, separator);
            else               
               return "I" + idx.toString();*/
            return resolve2GetIdentifier(field, separator);
         }
      }else{
         //if the select function accesses to a field
         //get the field name, it follows "::$" in the fieldString
         String fieldString=field.toString();
         String fieldName=fieldString.substring(fieldString.indexOf("$")+1);
         return fieldName ;     
      }    
      
   }
   
   /*
    * recursive method to get object name, it has the format:
    * self_obj1_obj2 ... 
    * */
   public static String getObjectNameOfSelect(Term t, String separator){
      Term obj =t.sub(1);
      if(!isHeapSelectFunction(obj))
         return obj.toString();
      else{
         return getObjectNameOfSelect(obj, separator) + separator + getFieldNameOfSelect(obj, separator);
      }         
   }   
   
   
   /*
    * ***** solve heap memory of loop **********
    * */
   
   /*check if select function access the heap memory created by loop*/
   public static boolean isAnonHeapSelectFunction(Term t){
      if(isHeapSelectFunction(t)){
         if(TermParser.isAnonFunction(t.sub(0))|| t.sub(0).toString().contains("anon_heap_"))
            return true;
      }
      return false;
   }
   
   //t is a loop heap select function, return the name of loop heap 
   public static String getAnonHeapName(Term t){
      /*Term anonTerm = t.sub(0);
      Term resolveName = anonTerm;
      if(anonTerm.subs()!=null){
         if(anonTerm.subs().size()>0)
            resolveName = anonTerm.sub(0);
      }
      String name = resolveName.toString();      
      int idx1 = name.indexOf("anon_heap_");
      int idx2 = name.indexOf("<<");
      if(idx2>idx1)
         return name.substring(idx1,idx2);
      else
         return name.substring(idx1);*/
      return "anon" + KEGConfig.SEPARATOR + "heap";
   }    
   
   /*
    *return the name of root object of the chain of subfields
    *for example: if term(t)= select(heap,select(heap, self,..),..) then the root is  "self"
    * */
   public static String getRootNameOfSelectAndLength(Term t){
      if(isLengthFunction(t))
         return getRootNameOfSelectAndLength(t.sub(0));
      else if(isHeapSelectFunction(t))
         return getRootNameOfSelectAndLength(t.sub(1));
      else      
         return t.toString();      
         
   }
   
  
   
   
   
   
   /*
    * resolving path condition created by using loop invariant
    * implication is replaced by and (because we assume that the left side is true)
    * */
   public Term replaceImpByAnd(Term t){
      if(t!=null){
         if(TermParser.isImplication(t)){
            return termBuilder.and(t.subs());
         }else{
            return tf.createTerm(t.op(), replaceImpByAndInSubTerms(t.subs()));
         }
      }else
         return null;
   }
   
   private Term[] replaceImpByAndInSubTerms(final ImmutableArray<Term> subs){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceImpByAnd(subs.get(i));    
      return (result);
   }
   
   /*
    * return the term (local variable) which has the name got from length function and has a same type with length function
    * */
    public Term getReplacedTermForLengthFunction(Term t, String separator){
       LocationVariable lv=new LocationVariable(new ProgramElementName(getVarName4LengthFunction(t,separator)),t.sort());
       return termBuilder.var(lv);   
       
    }
   /*replace all length functions by their corresponding variable*/
   public Term replaceLengthFunctionByVar(Term t, String separator){
      if(t != null){
         if(isLengthFunction(t)){
            Term rt=getReplacedTermForLengthFunction(t, separator);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsLengthFunctionByVar(t.subs(), separator), t.boundVars(),t.javaBlock());
            //return tf.createTerm(t.op(), replaceSubsLengthFunctionByVar(t.subs()));            
         }
      }else 
         return null;
   }
   
   private Term[] replaceSubsLengthFunctionByVar(final ImmutableArray<Term> subs, String separator){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceLengthFunctionByVar(subs.get(i), separator);    
      return (result);
   }
   
  
   
   
   /**
    * @param term the term
    * @return iff. the term is a static field of the class
    * added by Huy
    * */
   public static boolean isPrimitiveStaticField(Term term){
      if(HeapHandler.isHeapSelectFunction(term)&&(TermParser.isPrimitiveType(term))){  
         //System.out.println("***---> : " + HeapHandler.getObjectNameOfSelect(term) + "_" + HeapHandler.getFieldNameOfSelect(term));
         if(HeapHandler.getObjectNameOfSelect(term,"_").startsWith("null_"))
            return true;
      
      }
      
      return false;
   }
   
   /*
    * return true if t is length function of an array,
    * otherwise return false
    * */
   public static boolean isLengthFunction(Term t){    
      if(t!=null){
         if(t.toString().startsWith("length("))
            return true;
      }
      return false;
   }
   /*
    * return the name of variable representing for length function.
    * for example, if t is: length(int[]::select(heap,self,demo.ArrayType::$array1))
    * then the method will return "self_array1_length"
    * */
   public static String getVarName4LengthFunction(Term t, String separator){
      String result = "";
      if(isLengthFunction(t)){         
         return getArrayNameOfLengthFunction(t,separator) + separator + "length";
      }
      
      return result;
   }
   
   public static String getArrayNameOfLengthFunction(Term t, String separator){
      String result = "";
      if(isLengthFunction(t)){
         Term obj = t.sub(0);
         if(isHeapSelectFunction(obj)){
            result = HeapHandler.getSynthesisNameOfHeapSelectFunction(obj, separator);
         }else{
            result = resolve2GetIdentifier(obj, separator);
         }         
      }      
      return result;
   }
   
   
   
   public static boolean isArrayIdxFunction(Term t){
      if(t.toString().startsWith("arr("))
         return true;
      else
         return false;
   }
   
   /*
    * return true if t represents an element of an array
    * otherwise return false
    * */
   public static boolean isArrayElementNumber(Term t){
      if(t.toString().startsWith("arr(Z("))
         return true;
      else
         return false;         
   }
   
   /*
    * input: t = arr(Z(1#))
    * return 1
    * if t is not array element, return -1
    * */
   public static int getArrayIndexNumber(Term t){
      if(isArrayElementNumber(t)){
         return TermParser.getIntegerValue(t.sub(0));
      }
      return -1;         
   }
   
   /*
   * input: t = arr(Z(1#))
   * return I1
   * */
   public static String getArrayElementName(Term t){
      if(isArrayElementNumber(t)){
         return "I" + getArrayIndexNumber(t);
      }
      return "I-1";
   }
   
   /*
    * resolve an arbitrary term to get a String that can be used as identifier
    * */   
   public static String resolve2GetIdentifier(final Term t, String separator){
      if(t!=null){
         if(isHeapSelectFunction(t))
            return getSynthesisNameOfHeapSelectFunction(t, separator);
         else if(isLengthFunction(t))
            return getVarName4LengthFunction(t, separator);
         else if(isArrayIdxFunction(t)){
            if(isArrayElementNumber(t))
               return String.valueOf(getArrayIndexNumber(t));
            else
               return "I" + resolve2GetIdentifier(t.sub(0), separator);
         }else if(TermParser.isInteger(t)){
            int number = TermParser.getIntegerValue(t);
            if(number>=0)               
               return String.valueOf(number);
            else
               return "neg" + separator + String.valueOf((-1)*number);
         }            
         else if(TermParser.isIntegerNegation(t))
            return "neg" + separator + String.valueOf(TermParser.getIntegerValue(t)).substring(1);
         else if(t.subs().isEmpty())
            return t.toString();
         else 
            return t.op().toString() + separator + resolve2GetIdentifier(t.subs(),separator);
      }else
         return "";
   }
   
   private static String resolve2GetIdentifier(final ImmutableArray<Term> subs, String separator){
      String result = "";
      for(int i=0;i<subs.size();i++)
         if(result.equals(""))
            result += resolve2GetIdentifier(subs.get(i), separator);
         else{
            result += separator +  resolve2GetIdentifier(subs.get(i), separator);
         }
      return (result);
   }
   
   /**********************************
    * resolve anon function
    ************************** */
   /*
    * simplify select term containing anon function by replacing it by the heap variable that the select function actually uses
    * */
   public Term simplifyAnonSelectFunction(Term t){
      if(t!=null){
         if(t.subs().size()>0){
            if(isAnonHeapSelectFunction(t)){
               if(TermParser.isAnonFunction(t.sub(0))){
                  if(isHeapSelectFunction(t.sub(1))){
                     Term result = termBuilder.select(t.sort(), t.sub(1).sub(0), t.sub(1), t.sub(2));
                     return result;
                  }
               }
            }else{
               return tf.createTerm(t.op(), simplifyAnonSelectFunctionAtSubTerms(t.subs()), t.boundVars(),t.javaBlock());
            }
         }else
            return t;
      }
      return null;
   }
   
   private Term[] simplifyAnonSelectFunctionAtSubTerms(ImmutableArray<Term> subs){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=simplifyAnonSelectFunction(subs.get(i));    
      return (result);
   }
   
   /***********************************************
    * resolve array
    * *********************************************/
   //check if t represents for an array element
   public boolean isArrayElement(Term t){
      if(isHeapSelectFunction(t)){
         if(TermParser.isArray(t.sub(1))){
            return true;
         }
      }
      return false;
   }
   
   /*
    * resolve term t representing array element by:
    * replacing the array object (t.sub(1)) in select form by its shorten term
    * */
   public Term shortenArrayElementTerm(Term t, String separator){
      if(t!=null){
         if(isHeapSelectFunction(t)){
            if(isArrayElement(t)){               
               return termBuilder.select(t.sort(), t.sub(0), shortenArrayElementTerm(t.sub(1), separator), shortenArrayElementTerm(t.sub(2), separator));               
            }else{
               return replaceSelectFunctionByItsField(t, separator);
            }                           
         }
         else if(isLengthFunction(t)){  
            //FIXME: now length function is treated as an integer variable
            return replaceLengthFunctionByVar(t, separator);
            //return tf.createTerm(t.op(), new Term[]{shortenArrayElementTerm(t.sub(0), separator)}, t.boundVars(),t.javaBlock());
         }
         else if(isArrayElement(t)){
            return termBuilder.select(t.sort(), t.sub(0), shortenArrayElementTerm(t.sub(1), separator), shortenArrayElementTerm(t.sub(2), separator));
         }        
         else if(t.subs().size()>0){
            return tf.createTerm(t.op(), shortenArrayElementInSubTerms(t.subs(), separator), t.boundVars(),t.javaBlock());
         }else{
            return t;
         }
      }else
         return null;
   }
   
   private Term[] shortenArrayElementInSubTerms(final ImmutableArray<Term> subs, String separator){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=shortenArrayElementTerm(subs.get(i), separator);    
      return (result);
   }
   
   /**
    * if t is an array, return the dimension of the array type, otherwise return 0
    * */
   public static int getArrayDimension(Term t){
      if(!TermParser.isArray(t)){
         return 0;
      }else{
         String type = t.sort().toString();
         int result = 0;
         while(type.indexOf("[]")>=0){
            result++;
            type = type.substring(type.indexOf("[]")+2);
            
         }
         return result;
      }
   }
   
   public static String getTypeOfArray(Term t){
      if(TermParser.isArray(t)){
         String arrayType = t.sort().toString();
         int i = arrayType.indexOf("[]");
         return arrayType.substring(0,i-1);      
      }else
         return "null";
   }
   
   public static boolean isBoolArray(Term t){      
      if(getTypeOfArray(t).equals("boolean")){
         return true;
      }      
      return false;
   }
   
   public static boolean isIntArray(Term t){      
      if(getTypeOfArray(t).equals("int")){
         return true;
      }      
      return false;
   }
   
   /****************
    * resolve quantified array term
    * */
   
   /*return true if Term t contain one of quantified array term in listQuantifiedArrayTerm*/
   private boolean containsQATerm(Term t, List<Term> listQuantifiedArrayTerm){
      for(Term qATerm: listQuantifiedArrayTerm){
         if(TermUtil.isDescendant(qATerm, t))
            return true;
      }
      return false;
   }
   
   public Term replaceUnContainQASelectAndLength(Term t, List<Term> listQuantifiedArrayTerm){
      if(t!=null){
         if(HeapHandler.isLengthFunction(t)){
            if(containsQATerm(t,listQuantifiedArrayTerm)){
               return t;
            }else{
               return replaceLengthFunctionByVar(t, KEGConfig.SEPARATOR);
            }
         }else if(HeapHandler.isHeapSelectFunction(t)){
            if(containsQATerm(t,listQuantifiedArrayTerm)){
               return t;
            }else{
               return replaceSelectFunctionByItsField(t, KEGConfig.SEPARATOR);
            }
         }else if(t.subs()==null){
            return t;
         }else if(t.subs().size()==0){
            return t;            
         }else{
            return new TermFactory().createTerm(t.op(), replaceUnContainQASelectAndLengthInSubs(t.subs(),listQuantifiedArrayTerm), t.boundVars(),t.javaBlock());
         }
      }else
         return null;        
         
   }
   
   private Term[] replaceUnContainQASelectAndLengthInSubs(final ImmutableArray<Term> subs,List<Term> listQuantifiedArrayTerm){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceUnContainQASelectAndLength(subs.get(i),listQuantifiedArrayTerm);    
      return (result);
   }
   
   
   /*********************************
    * resolve quantifiable variables
    * **/   
   /*
    * get all Quantifiable variables of term t and return as a list of terms
    * */
   public List<Term> getQVarTerms(Term t){
      List<Term> result = new LinkedList<Term>();
      if(TermParser.isQuantifier(t)){         
         for(QuantifiableVariable qv: t.boundVars()){
            result.add(termBuilder.var(qv));            
         }         
      }
      return result;         
   }
   
   /*
    * get all Quantifiable variables of term t as well as its sub-terms and return as a list of terms
    * */
   public List<Term> getAllQVarTerms(Term t){
      if(t!=null){
         List<Term> result = getQVarTerms(t);
         if(t.subs().size()>0){                     
            for(Term st: t.subs()){
               result = TermUtil.mergeListTerm(result, getAllQVarTerms(st));
            }
         }
         return result;
      }
      return null;
   }
   
   public List<Term> getAllQVTermsFromListTerm(ImmutableList<Term> lt){
      List<Term> result = new LinkedList<Term>();
      for(Term t: lt){
         result = TermUtil.mergeListTerm(result, getAllQVarTerms(t));
      }
      return result;
   }
   
 }
