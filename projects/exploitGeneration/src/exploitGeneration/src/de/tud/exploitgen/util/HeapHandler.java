/**
 * 
 */
package de.tud.exploitgen.util;



import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class supplies methods to handle heap value and other elements of object (static field) in the formula
 * @author Huy Do
 *
 */
public class HeapHandler {
   
   /*
    * check if a term is a value extract from heap memory by function "select(heap,self,..)"
    * return true iff it contains "select(heap"
    * */
   private final Services services;
   private final TermBuilder termBuilder;
   private static final TermFactory tf = new TermFactory();
   
   public HeapHandler(Services services){
	   this.services=services;
	   termBuilder=new TermBuilder(tf, services);
   }
   
   public static boolean isHeapSelectFunction(Term t){
      if(t.op().toString().contains("::select")){
         return true;
      }else
         return false;
   }
   
  
   
 /*  public void printInfoHeapValue(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size());
      System.out.println("field name: " + getFieldName(t));
      
   }
   
   public void printInfoHeapVar(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size()); 
      
   }   */
   
      
   /*
    * get the field name in the term represent a heap select function (::select(heap,...)
    * */
   public static String getFieldNameOfHeapSelectFunction(Term t){
      
      String fieldName=getObjectNameOfSelect(t)+"_" + getFieldNameOfSelect(t);
      if(isLoopHeap(t)) //if t is a select function via loop heap then add prefix "loop_"
         fieldName = getLoopHeapName(t)+ "_" + fieldName;
      return fieldName;
   }
   
   /*
    * get the field name in the term represent a heap select function(::select(heap,...)
    * sometimes, we have to use another heap name (parameter heapName) alter field name at t.sub(2)
    * for example: with precondition, declassification, the heap name is always "self",
    * but actually at each method, heap name could be "self_0", "self_1"
    * so actual heap name should be used (passed to parameter heapName)
    * */
   public String getFieldNameOfHeapSelectFunction(Term t, String heapName){
      /*
      Term field=t.sub(2); //access the field      
      String fieldString=field.toString();
      //get the field name, it follows "::$" in the fieldString
      String fieldName=fieldString.substring(fieldString.indexOf("$")+1);
      //return (object.toString() + "_" + fieldName) ;
      return (heapName + "_" + fieldName) ;*/
      String fieldName=getObjectNameOfSelect(t)+"_" + getFieldNameOfSelect(t);
      //System.out.println("fieldName : -----* : "+fieldName + " ; heapName: " + heapName);
      int idx=fieldName.indexOf("_");
      fieldName=fieldName.replace(fieldName.substring(0,idx), heapName);
      //System.out.println("fieldName : -------------> : "+fieldName);
      return fieldName;
   }
   
   
   
   /*
    * get the term (local variable) which has the name is field name and has a same type with select function
    * */
    public Term getReplacedTermForSelect(Term t){
       LocationVariable lv=new LocationVariable(new ProgramElementName(getFieldNameOfHeapSelectFunction(t)),t.sort());
       return termBuilder.var(lv);     
       
    }
    
    /*
     * get the term (local variable) which has the name is field name and has a same type with select function
     * parameter heapName is used to contribute the name of LocationVariable that represents for the field 
     * */
     public Term getReplacedTermForSelect(Term t, String heapName){
        LocationVariable lv=new LocationVariable(new ProgramElementName(getFieldNameOfHeapSelectFunction(t,heapName)),t.sort());
        return termBuilder.var(lv);             
     }
    
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * */
   public Term replaceSelectFunctionByItsField(Term t){
      if(t !=null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTermForSelect(t);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs()));
         }
      }else return null;
   }
   
   private Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i));    
      return (result);
   }
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * parameter heapName is used to contribute the name of Term representing for the field
    * */
   public Term replaceSelectFunctionByItsField(Term t, String heapName){
      if(t !=null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTermForSelect(t,heapName);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs(),heapName));
         }
      }else return null;
   }
   
   private Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs,String heapName){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i),heapName);    
      return (result);
   }
   
   
   /*
    * check if variables is heap (name = "self")
    * */
   public static boolean isSelf(IExecutionVariable var)throws ProofInputException{     
         if(var.getName().startsWith("self"))
            return true;
         else return false;      
   }
   
   public static boolean isExc(IExecutionVariable var)throws ProofInputException{
      if(var.getName().startsWith("exc"))
         return true;
      else return false;     
   }
   
   
   
   /*
    * get the field name in the term represent a heap (::select(heap,...) 
    * */
   public static String getFieldNameOfSelect(Term t){
      //Term object =t.sub(1);      
      Term field=t.sub(2); //access the field      
      String fieldString=field.toString();
      //get the field name, it follows "::$" in the fieldString
      String fieldName=fieldString.substring(fieldString.indexOf("$")+1);
      //return (object.toString() + "_" + fieldName) ;
      return fieldName ;
   }
   
   /*
    * recursive method to get object name, it has the format:
    * self_obj1_obj2 ... 
    * */
   public static String getObjectNameOfSelect(Term t){
      Term obj =t.sub(1);
      if(!isHeapSelectFunction(obj))
         return obj.toString();
      else{
         return getObjectNameOfSelect(obj) + "_" + getFieldNameOfSelect(obj);
      }         
   }
   
   /*
    * ***** solve heap memory of loop **********
    * */
   
   /*check if select function access the heap memory created by loop*/
   public static boolean isLoopHeap(Term t){
      if(isHeapSelectFunction(t)){
         if(t.sub(0).toString().contains("heap_loop"))
            return true;
      }
      return false;
   }
   
   //t is a loop heap, return the name of loop heap 
   public static String getLoopHeapName(Term t){
      String name = t.sub(0).toString();
      int idx1 = name.indexOf("anon_heap_");
      int idx2 = name.indexOf("<<");
      
      return name.substring(idx1,idx2);
   }    
   
   /**
    * return true if var is static, otherwise return false
    * */
   public static boolean isStaticVar(IExecutionVariable var){
      if(var.getProgramVariable() instanceof LocationVariable){
         LocationVariable lv = (LocationVariable)var.getProgramVariable();
         return (lv.isStatic());
      }  
      return false;
   }
   
   
}
