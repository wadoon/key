/**
 * 
 */
package de.tud.exploitgen.util;



import java.util.List;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.sort.ArraySort;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class supplies methods to handle heap value and other elements of object (static field) in the formula
 * @author Huy Do
 *
 */
public class HeapHandler {
   
   /*
    * check if a term is a value extract from heap memory by function "select(heap,self,..)"
    * return true iff it contains "select(heap"
    * */
   //private final Services services;
   private final TermBuilder termBuilder;
   private static final TermFactory tf = new TermFactory();
   
   public HeapHandler(Services services){
	   //this.services=services;
	   termBuilder=new TermBuilder(tf, services);
   }
   
   public static boolean isHeapSelectFunction(Term t){
      if(t!=null){
         if(t.op().toString().contains("::select"))
            return true;         
      }
      return false;
   }
   
  
   
 /*  public void printInfoHeapValue(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size());
      System.out.println("field name: " + getFieldName(t));
      
   }
   
   public void printInfoHeapVar(Term t){
      System.out.println(t);
      System.out.println("operator: " + t.op());
      System.out.println("Sort: " + t.sort());
      System.out.println("number of subs: " + t.subs().size()); 
      
   }   */
   
      
   /*
    * get the field name in the term represent a heap select function (::select(heap,...)
    * */
   public static String getSynthesisNameOfHeapSelectFunction(Term t){
      
      String fieldName=getObjectNameOfSelect(t)+"_" + getFieldNameOfSelect(t);
      if(isAnonHeapSelectFunction(t)) //if t is a select function via loop heap then add prefix "loop_"
         fieldName = getAnonHeapName(t)+ "_" + fieldName;
      return fieldName;
   }
   
   /*
    * get the field name in the term represent a heap select function(::select(heap,...)
    * sometimes, we have to use another heap name (parameter heapName) alter field name at t.sub(2)
    * for example: with precondition, declassification, the heap name is always "self",
    * but actually at each method, heap name could be "self_0", "self_1"
    * so actual heap name should be used (passed to parameter heapName)
    * if the object name (heap name) is "null", it means the variable is static, and we do not change the object name
    * */
   public static String getFieldNameOfHeapSelectFunction(Term t, String heapName){
      String objectName = getObjectNameOfSelect(t);      
      String fieldName=objectName+"_" + getFieldNameOfSelect(t);
      if(objectName.startsWith("self")){//if the variable is not static or parameter, we replace object name by corresponding heapName         
         //System.out.println("fieldName : -----* : "+fieldName + " ; heapName: " + heapName);
         int idx=fieldName.indexOf("_");
         fieldName=fieldName.replace(fieldName.substring(0,idx), heapName);
         //System.out.println("fieldName : -------------> : "+fieldName);
      }
      return fieldName;
   }
   
   
   
   /*
    * get the term (local variable) which has the name is field name and has a same type with select function
    * */
    public Term getReplacedTermForSelect(Term t){
       LocationVariable lv=new LocationVariable(new ProgramElementName(getSynthesisNameOfHeapSelectFunction(t)),t.sort());
       return termBuilder.var(lv);   
       
    }
    
    /*
     * get the term (local variable) which has the name is field name and has a same type with select function
     * parameter heapName is used to contribute the name of LocationVariable that represents for the field 
     * */
     public Term getReplacedTermForSelect(Term t, String heapName){
        LocationVariable lv=new LocationVariable(new ProgramElementName(getFieldNameOfHeapSelectFunction(t,heapName)),t.sort());
        return termBuilder.var(lv);             
     }
    
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * */
   public Term replaceSelectFunctionByItsField(Term t){
      if(t != null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTermForSelect(t);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs()), t.boundVars(),t.javaBlock());
            
         }
      }else return null;
   }
   
   private Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i));    
      return (result);
   }
   
   
   /*
    * find every select function (to access heap) in the term,
    * replace it by its field name
    * parameter heapName is used to contribute the name of Term representing for the field
    * */
   public Term replaceSelectFunctionByItsField(Term t, String heapName){
      if(t !=null){
         if(isHeapSelectFunction(t)){
            Term rt=getReplacedTermForSelect(t,heapName);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsSelectFunctionByItsField(t.subs(),heapName), t.boundVars(),t.javaBlock());
            
         }
      }else return null;
   }
   
   private Term[] replaceSubsSelectFunctionByItsField(final ImmutableArray<Term> subs,String heapName){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceSelectFunctionByItsField(subs.get(i),heapName);    
      return (result);
   }
   
   
   /*
    * check if variables is heap (name = "self")
    * */
   public static boolean isSelf(IExecutionVariable var)throws ProofInputException{     
         if(var.getName().startsWith("self"))
            return true;
         else return false;      
   }
   
   public static boolean isExc(IExecutionVariable var)throws ProofInputException{
      if(var.getName().startsWith("exc"))
         return true;
      else return false;     
   }
   
   /*return true if var is a parameter of the method, otherwise return false
    * TODO: should be revised because maybe some variable can be started by "_"*/
   public static boolean isParameter(IExecutionVariable var) throws ProofInputException{
      if(var.getParentValue()==null  && var.getName().startsWith("_"))
         return true;
      else
         return false;
   }
   
   /*
    * get the field name in the term represent a heap (::select(heap,...) 
    * */
   public static String getFieldNameOfSelect(Term t){
      //Term object =t.sub(1);      
      Term field=t.sub(2); //access the field            
      if(isArrayIdxFunction(field)){
         if (isArrayElementNumber(field)){
            //if the select function accesses to an element of array
            return getArrayElementName(field);
         }else{
            Term idx = field.sub(0);
            if(isHeapSelectFunction(idx))
               return "I" + getSynthesisNameOfHeapSelectFunction(idx);
            else if(isLengthFunction(idx))
               return "I" + getVarName4LengthFunction(idx);
            else
               return "I" + idx.toString();
         }
      }else{
         //if the select function accesses to a field
         //get the field name, it follows "::$" in the fieldString
         String fieldString=field.toString();
         String fieldName=fieldString.substring(fieldString.indexOf("$")+1);
         return fieldName ;     
      }    
      
   }
   
   /*
    * recursive method to get object name, it has the format:
    * self_obj1_obj2 ... 
    * */
   public static String getObjectNameOfSelect(Term t){
      Term obj =t.sub(1);
      if(!isHeapSelectFunction(obj))
         return obj.toString();
      else{
         return getObjectNameOfSelect(obj) + "_" + getFieldNameOfSelect(obj);
      }         
   }   
   
   
   /*
    * ***** solve heap memory of loop **********
    * */
   
   /*check if select function access the heap memory created by loop*/
   public static boolean isAnonHeapSelectFunction(Term t){
      if(isHeapSelectFunction(t)){
         if(t.sub(0).toString().contains("anon_heap_"))
            return true;
      }
      return false;
   }
   
   //t is a loop heap select function, return the name of loop heap 
   public static String getAnonHeapName(Term t){
      String name = t.sub(0).toString();
      int idx1 = name.indexOf("anon_heap_");
      int idx2 = name.indexOf("<<");
      if(idx2>idx1)
         return name.substring(idx1,idx2);
      else
         return name.substring(idx1);
   }    
   
   /*
    *return the name of root object of the chain of subfields
    *for example: if term(t)= select(heap,select(heap, self,..),..) then the root is  "self"
    * */
   public static String getRootNameOfSelectAndLength(Term t){
      if(isLengthFunction(t))
         return getRootNameOfSelectAndLength(t.sub(0));
      else if(isHeapSelectFunction(t))
         return getRootNameOfSelectAndLength(t.sub(1));
      else      
         return t.toString();      
         
   }
   
   /**
    * return true if var is static, otherwise return false
    * */
   public static boolean isStatic(IExecutionVariable var){
      if(var.getProgramVariable() instanceof LocationVariable){
         LocationVariable lv = (LocationVariable)var.getProgramVariable();
         return (lv.isStatic());
      }  
      return false;
   }
   
   public static boolean isPrimitive(IExecutionVariable var){
      return TermParser.isPrimitiveType(var.getProgramVariable().sort().name().toString());
   }
   
   public static boolean isHeap(IExecutionVariable var) throws ProofInputException{
      return var.getName().equals("heap");
        
   }
   
   //check if var is an array ot not
   public static boolean isArray(IExecutionVariable var){
      if(var.getProgramVariable().getKeYJavaType().getSort() instanceof ArraySort)
         return true;
      else
         return false;
   }
   
   
   
   
   /*
    * resolving path condition created by using loop invariant
    * implication is replaced by and (because we assume that the left side is true)
    * */
   public Term replaceImpByAnd(Term t){
      if(t!=null){
         if(TermParser.isImplication(t)){
            return termBuilder.and(t.subs());
         }else{
            return tf.createTerm(t.op(), replaceImpByAndInSubTerms(t.subs()));
         }
      }else
         return null;
   }
   
   private Term[] replaceImpByAndInSubTerms(final ImmutableArray<Term> subs){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceImpByAnd(subs.get(i));    
      return (result);
   }
   
   /*
    * return the term (local variable) which has the name got from length function and has a same type with length function
    * */
    public Term getReplacedTermForLengthFunction(Term t){
       LocationVariable lv=new LocationVariable(new ProgramElementName(getVarName4LengthFunction(t)),t.sort());
       return termBuilder.var(lv);   
       
    }
   /*replace all length functions by their corresponding variable*/
   public Term replaceLengthFunctionByVar(Term t){
      if(t != null){
         if(isLengthFunction(t)){
            Term rt=getReplacedTermForLengthFunction(t);
            if(rt!=null)
               return rt;
            else return t;
         }else{
            return tf.createTerm(t.op(), replaceSubsLengthFunctionByVar(t.subs()), t.boundVars(),t.javaBlock());
            //return tf.createTerm(t.op(), replaceSubsLengthFunctionByVar(t.subs()));            
         }
      }else 
         return null;
   }
   
   private Term[] replaceSubsLengthFunctionByVar(final ImmutableArray<Term> subs){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replaceLengthFunctionByVar(subs.get(i));    
      return (result);
   }
   
   /**
    * @param term the term
    * @return iff. the term is a field of the class
    * added by Huy
    * */
   public static boolean isField(Term term){      
      if(term.sort().toString().equals("Field"))
         return true;
      else
         return false;
   }
   
   
   /**
    * @param term the term
    * @return iff. the term is a static field of the class
    * added by Huy
    * */
   public static boolean isPremitiveStaticField(Term term){
      if(HeapHandler.isHeapSelectFunction(term)&&(TermParser.isPrimitiveType(term))){  
         //System.out.println("***---> : " + HeapHandler.getObjectNameOfSelect(term) + "_" + HeapHandler.getFieldNameOfSelect(term));
         if(HeapHandler.getObjectNameOfSelect(term).startsWith("null_"))
            return true;
      
      }
      return false;
   }
   
   /*
    * return true if t is length function of an array,
    * otherwise return false
    * */
   public static boolean isLengthFunction(Term t){    
      if(t!=null){
         if(t.toString().startsWith("length("))
            return true;
      }
      return false;
   }
   /*
    * return the name of variable representing for length function.
    * for example, if t is: length(int[]::select(heap,self,demo.ArrayType::$array1))
    * then the method will return "self_array1_length"
    * */
   public static String getVarName4LengthFunction(Term t){
      String result = "";
      if(isLengthFunction(t)){
         
         return getArrayNameOfLengthFunction(t) + "_length";
      }
      
      return result;
   }
   
   public static String getArrayNameOfLengthFunction(Term t){
      String result = "";
      if(isLengthFunction(t)){
         Term obj = t.sub(0);
         if(isHeapSelectFunction(obj)){
            result = HeapHandler.getSynthesisNameOfHeapSelectFunction(obj);
         }else{
            result = obj.toString();
         }         
      }      
      return result;
   }
   
   /**
    * return true if Term t is already in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(Term t, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   public static boolean isArrayIdxFunction(Term t){
      if(t.toString().startsWith("arr("))
         return true;
      else
         return false;
   }
   
   /*
    * return true if t represents an element of an array
    * otherwise return false
    * */
   public static boolean isArrayElementNumber(Term t){
      if(t.toString().startsWith("arr(Z("))
         return true;
      else
         return false;         
   }
   
   /*
    * input: t = arr(Z(1#))
    * return 1
    * if t is not array element, return -1
    * */
   public static int getArrayIndex(Term t){
      if(isArrayElementNumber(t)){
         return TermParser.getIntegerValue(t.sub(0));
      }
      return -1;         
   }
   
   /*
   * input: t = arr(Z(1#))
   * return "[1]"
   * if t is not array element, return [-1]
   * */
   public static String getArrayElementName(Term t){
      if(isArrayElementNumber(t)){
         return "I" + getArrayIndex(t);
      }
      return "I_1";
   }
 }
