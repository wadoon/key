
/* 
*  this class used to check the non-interference of a method
 * it gets all termination nodes of the symbolic execution tree of the method 
 * */


package de.tud.exploitgen.processing;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.processing.exploit.ExploitModelBuilder;
import de.tud.exploitgen.solver.AbstractFormulaSolver;
import de.tud.exploitgen.solver.KeyStoneSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.VariableChecker;
//import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;

import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;



import java.util.LinkedList;
import java.util.List;
import java.util.Map;



import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class MethodProcessor {
   private KeYJavaMethod method; //contains information of method (maybe needed in variable checker)
   private List<IExecutionNode> leafNodes; //contains leaf nodes of symbolic execution tree of method 
   private VariableChecker vc; //check variables in nodes
   

   
     
   /**
    * @param method
    * @param leafNodes
    * @param vc
    * @throws ProofInputException 
    * @throws TermTransformerException 
    */
   public MethodProcessor(List<IExecutionNode> leafNodes,KeYJavaMethod method, VariableChecker vc) throws TermTransformerException, ProofInputException {
      super();
      this.method = method;
      this.leafNodes = leafNodes;
      this.vc = vc;
      /*emCreator=new ExploitModelBuilder(method.getServices());
      emCreator.initiateExploitModelFromNode(leafNodes.get(0),1);
      emCreator.initiateExploitModelFromNode(leafNodes.get(0),2);
      emCreator.getExploitModel().printModelInfo();*/
      //initiateExploitModel();
      //exploitModel.printExploitModel(1);
      //System.out.println("escape heap terms are: --- : " + method.getSeparatedEscapeHatchTerms());
   }


   /**
    * @return the leafNodes
    */
   public List<IExecutionNode> getLeafNodes() {
      return leafNodes;
   }

  
   /**
    * @param leafNodes the leafNodes to set
    */
   public void setLeafNodes(List<IExecutionNode> leafNodes) {
      this.leafNodes = leafNodes;
   }
   
   
    /**
    * check the input method to get list of exploit model if the method is insecure 
    * */
   public List<ExploitModel> checkMethod2GetExploitModels(){
      List<ExploitModel> result=new LinkedList<ExploitModel>();
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
           System.out.println("\n---------------------------------------------"); 
           System.out.print("Checking branch " + i);
            if (j!=i){
               System.out.print(" and branch " + j);
            }
            System.out.println();
            List<ExploitModel> eModels;
            try {
             //check branch i and branch j to get all exploit models if they exists
               eModels=getExploitModels(i, j); 
            }
            catch (TermTransformerException e) {
               eModels=null;
               e.printStackTrace();
            }
            catch (ProofInputException e) {
               eModels=null;
               e.printStackTrace();
            }
            if(eModels!=null){
               result.addAll(eModels);
            }
         }
      }
      return result;
   }
   
   
   /** return concrete values satisfying the interference formula*/
   private Map<String,Integer> getConcreteModel(Term iTerm){
      AbstractFormulaSolver fs=new Z3Solver(iTerm);      //use Z3 solver
      Map<String, Integer> result;
      result = fs.solveFormulaInt();
      return result;
   }
   
   
   /** return list of exploit model generated by solving two nodes 
    * @throws ProofInputException 
    * @throws TermTransformerException */
   private List<ExploitModel> getExploitModels(int node1, int node2) throws ProofInputException, TermTransformerException{      
      List<ExploitModel> result = new LinkedList<ExploitModel>();
      //pass two nodes to TwoBranchesProcessor to solve and get interference formulas
      //TwoBranchesProcessor tp = new TwoBranchesProcessor(leafNodes.get(node1), leafNodes.get(node2),method,vc);
      TwoPathsProcessor tpp=new TwoPathsProcessor(leafNodes.get(node1), leafNodes.get(node2), method, vc);
      
      //get all interference formula for each low variables
      Map<String,Term> mapIFormulas = tpp.getAllInterferenceFormula();
      
      //solve each formular corresponding with specific low variable to get corresponding concrete model and build ExploitModel
      for(String lowVar: mapIFormulas.keySet()){
         Term iTerm=mapIFormulas.get(lowVar);
         System.out.println(iTerm);
         Map<String,Integer> concreteModel = getConcreteModel(iTerm);         
         
         
         if(concreteModel!=null){
            
            
            //assign values for variables
            //emCreator.instantiateExploitModelInt(concreteModel);            
            //ExploitModel exploitModel = emCreator.getExploitModel();            
            ExploitModelBuilder eModelCreator = tpp.getExploitModelCreator();
            eModelCreator.instantiateExploitModelInt(concreteModel);
            ExploitModel exploitModel = eModelCreator.getExploitModel();
            exploitModel.setLowVar(lowVar); //we are working with this low variable
            exploitModel.printModelInfo();
            result.add(exploitModel);
            System.out.println("A vulnerability detected: secret information could be leaked through variable " + lowVar );
         }         
      }      
      return result;
   }
}

