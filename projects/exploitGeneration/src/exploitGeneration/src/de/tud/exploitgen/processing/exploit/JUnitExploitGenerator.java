/**
 * 
 */
package de.tud.exploitgen.processing.exploit;


import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;



import com.csvanefalk.keytestgen.backend.AbstractJavaSourceGenerator;
import com.csvanefalk.keytestgen.backend.junit.JUnitConverterException;


import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;


import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.DelimitedReleaseExtractor;
import de.tud.exploitgen.processing.IFBarrier;

import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TestTransformer;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.util.DelimitedRelease;

/**
 * this class generates JUnit test for checking non-interference property of program 
 * @author Huy Do
 *
 */
public class JUnitExploitGenerator extends AbstractJavaSourceGenerator{
   private final ExploitTestSuite exploitTestSuite;
   
   /**
    * Imports to be included in this test class
    */
   private final HashSet<String> imports = new HashSet<String>();
   
   /**
    * The name of the class for which the test suite is being generated.
    * Kept for the purpose of naming and type declaration.
    */
   private String className = "X";
   
   /**
    * Used to differentiate between the names of test cases.
    */
   private int ID_METHOD = 0;
  
     
   /**
    * The name of the container for the result value (if any) resulting
    * from the invocation of a method being tested. This value is used in
    * the assertion process, and must not conflict with the names of any
    * parameter values.
    */
   private static final String EXECUTION_RESULT = "result";

   /**
    * The name of the root variable (i.e. the variable pointing to the
    * instance of the object that has the methods to be tested).
    */
   private String SELF = "self";
   
   /**
    * @param exploitTestSuite
    */
   public JUnitExploitGenerator(ExploitTestSuite exploitTestSuite) {
      super();
      this.exploitTestSuite = exploitTestSuite; 
     
   }
   
   /**
    * Writes the getField method.
    * @source: Christopher
    */
   private void writeGetFieldMethod() {

       writeComment("Gets the field of a given object", true);
       writeMethodHeader(null,
                         "private",
                         new String[]{"<T>"},
                         "T",
                         "getFieldValue",
                         new String[]{"Object instance", "String fieldName"},
                         new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});

       writeIndentedLine("Field field = instance.getClass().getDeclaredField(fieldName);");
       writeNewLine();

       writeIndentedLine("field.setAccessible(true);");
       writeNewLine();

       writeIndentedLine("return (T)field.get(instance);");
       writeNewLine();

       writeClosingBrace();
   }
  
   /**
    * Writes the setField method.
    * @source: Christopher
    */
   private void writeSetFieldMethod() {

       writeComment("Sets a field of some object to a given value", true);
       writeMethodHeader(null,
                         "private",
                         null,
                         "void",
                         "setFieldValue",
                         new String[]{"Object instance", "String fieldName", "Object value"},
                         new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});

       writeIndentedLine("Field field = instance.getClass().getDeclaredField(fieldName);");
       writeNewLine();

       writeIndentedLine("field.setAccessible(true);");
       writeNewLine();

       writeIndentedLine("field.set(instance, value );");
       writeNewLine();

       writeClosingBrace();
              
   }
   
    
   /**
    * Given a {@link Model}, this method will extract all instances of
    * {@link ModelInstance} from it.
    * @source: Christopher
    * @param model
    * @return
    */
   private List<ModelInstance> extractInstancesFromModel(final Model model) {

       final List<ModelInstance> instances = new LinkedList<ModelInstance>();
       for (final ModelVariable variable : model.getVariables()) {
           if (variable.getValue() instanceof ModelInstance) {
               instances.add((ModelInstance) variable.getValue());
           }
       }
       return instances;
   }
   
   /**
    * Given a set of {@link ExploitTestCases} instances, this method will extract
    * put all {@link ModelInstance} declared in the model of each test case
    * into a single list.
    *
    * @param List<ExploitTestCases> the test cases
    * @return a list of all instances declared in all test cases models
    */
   private List<ModelInstance> collectInstances(final List<ExploitTestCases> testCases) {

       final List<ModelInstance> instances = new LinkedList<ModelInstance>();       
       for (final ExploitTestCases testCase : testCases) {
          for(final ExploitModel eModel: testCase.getExploitModel()){
              final List<ModelInstance> collectedInstances = extractInstancesFromModel(eModel.getModel1());
              instances.addAll(collectedInstances);
              break;
          }
       }
       return instances;
   }
   
    
   //create the content of JUnit file to check non-interference
   private void createExploitContent() throws JUnitConverterException{
      
      final List<ExploitTestCases> listExploitTestCases = exploitTestSuite.getListETC();      

      final KeYJavaClass klass = exploitTestSuite.getKeYJavaClass();
      

      /*
       * Collect the import assertions.
       */
      
      final List<ModelInstance> instances = collectInstances(listExploitTestCases);
      for (final ModelInstance instance : instances) {
          final String toImport = instance.getType();
          imports.add(toImport);
      }
      
      writeImportClauses();
      
      /*
       * Get the name of the class being tested.
       */
      className = klass.getName();
      /*
       * Print the new class header
       */
      className = "Test" + className;
      
      writeClassHeader(null, "public", "", className, "TestCase");
      
      //check all ExploitTestCase
      for(ExploitTestCases exploitTestCases : listExploitTestCases){
         String methodName = exploitTestCases.getMethod().getName();
         /*
          * Create one test method for each tuple of test cases.
          */
         //create comment for the method and the specification
         IFBarrier spec=exploitTestCases.getSpec();
         writeComment("check method "+ methodName + " with noninterference specification: " + spec.getDeclaration(), true);
         //write the content of method
         writeTestMethods(exploitTestCases,spec);
      }

      /*
       * Create the fixture repository for this class
       */
      createFixtureRepository(listExploitTestCases);

      /*
       * Close the class body.
       */
      writeClosingBrace();

      //return new JUnitTestSuite(exploitTestSuite, name, getCurrentOutput());
   }
   
   /**
    * write all import clauses for the test class
    * */
   private void writeImportClauses(){
      /*
       * write the popular imports
       * */
      appendToOutput("import org.junit.*;\n");
      appendToOutput("import junit.framework.TestCase;\n");
      appendToOutput("import java.lang.reflect.*;\n");
      appendToOutput("import java.util.*;\n");

      /*
       * Write the specific imports.
       */
      for (final String importt : imports) {
          appendToOutput("import ");
          appendToOutput(importt);
          appendToOutput(";\n");
      }
      writeNewLine();
   }
   /**
    * Sets up the fixture repository for a given test class. This
    * repository will contain the object instances needed for the test
    * cases to run.
    *
    * @param testCases the test cases for the test class.
    */
   private void createFixtureRepository(final List<ExploitTestCases> testCases) {

       /*
        * Safeguard from first invocation errors.
        */
       if (testCases.isEmpty()) {
           return;
       }
       /*
        * Write the method for setting fields of objects.
        */
       writeSetFieldMethod();

       /*
        * Write the method for getting fields of objects.
        */
       writeGetFieldMethod();
   }
   
   /**
    * overload method writeClassHeader of parent class
    * Supplement information of parent class (should be a subclass of TestCase)
    * */
   private void writeClassHeader(final String[] annotations,
         final String visibility,
         final String modifier,
         final String name,
         final String parentClass) {

            if (annotations != null) {
            for (final String annotation : annotations) {
            writeIndentedLine(annotation + AbstractJavaSourceGenerator.NEWLINE);
            }
            }
            
            indent();           
            appendToOutput(visibility + " ");
            appendToOutput(modifier + " ");
            appendToOutput("class" + " ");
            appendToOutput(name);
            if((parentClass!=null)&&(!parentClass.trim().isEmpty())){
               appendToOutput(" extends " + parentClass);
            }
            appendToOutput(" {\n");
            
            increaseIndentation();
}
   
   
   /**
    * write test methods for a tuple of test cases, for each test case we creat a method
    * @param exploitTestCases, IFBarrier
    * @throws JUnitConverterException
    */
   private void writeTestMethods(final ExploitTestCases exploitTestCases,IFBarrier spec) throws JUnitConverterException {       
           
       //write separated test case for each model  
       final KeYJavaMethod method=exploitTestCases.getMethod();
       final String methodName = "test_" + method.getProgramMethod().getName();
       for(ExploitModel eModel:exploitTestCases.getExploitModel()){
          writeNewLine();      
          /*
           * Write the method header.
           */          
          writeMethodHeader(new String[]{"@Test"},
                            "public",
                            null,
                            "void",
                            methodName + "_" + eModel.getLowVar().getVariableName()+"_" + ID_METHOD++,
                            null,
                            new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});
          //write the content of method
          writeTestMethodContent(eModel,spec,method);
          
          writeClosingBrace();
       }  
      
   }
   
   /**
    * return suffix via branch 
    * */
   private String getSuffix(int branch){
     return "_" + branch;
   }
   /**
    * write test fixture for a branch
    * */
   private void writeTestFixtureForBranch(ExploitModel eModel,int branch){
      /*
       * First, declare and assign values for necessary variables
       * */
      writeComment("Prepare for execution " + branch, false);
      Model model=eModel.getModel(branch);    
      
      for (final ModelVariable variable : model.getVariables()) {
         if(!variable.isParameter()){
             /*
             * Declares and instantiates a reference typed instance.
             */            
            String varName = variable.getIdentifier() + getSuffix(branch);
            if (variable.getValue() instanceof ModelInstance) {                
                writeIndentedLine(variable.getTypeName() + " " + varName + " = " + "new" + " " + variable.getTypeName() + "();");               
                
            
            }else{
               /*
                * Declares and instantiates a primitive typed instance, but
                * only if they are parameters (other primitive values will
                * be configured as part of the classes they are fields of).
                */
                writeIndentedLine(variable.getTypeName() + " " + varName + " = " + variable.getValue() + ";");
            }            
            writeNewLine();            
         }         
      }
      
      /*
       * Next, create the method parameters (we do this separately for the
       * sake of clarity).
       */     
      for (final ModelVariable variable : model.getVariables()) {
          if (variable.isParameter()) {
              /*
               * Declares and instantiates a reference typed instance.
               */
              String varName=variable.getIdentifier() + getSuffix(branch);
              if (variable.getValue() instanceof ModelInstance) {
                 
                  writeIndentedLine(variable.getTypeName() + " " + varName + " = " + "new" + " " + variable
                          .getTypeName() + "();");
              }

              /*
               * Declares and instantiates a primitive typed instance, but
               * only if they are parameters (other primitive values will
               * be configured as part of the classes they are fields of).
               */
              else {
                  writeIndentedLine(variable.getTypeName() + " " + varName + " = " + variable.getValue() + ";");
              }
              writeNewLine();
          }
      }
      
      
      /*
       * Next, configure the needed instances properly.
       */
      for (final ModelVariable variable : model.getVariables()) {
          /*
           * Again, deal only with those variables which are not primitives.
           */
          if (!variable.isPrimitive()) {

              final Object value = variable.getValue();

              if (value instanceof ModelInstance) {
                  final ModelInstance instance = (ModelInstance) value;

                  if (!instance.getFields().isEmpty()) {
                      final String variableIdentifier = variable.getIdentifier()+ getSuffix(branch);

                      writeComment("Configure variable: " + variableIdentifier, false);

                      for (final ModelVariable field : instance.getFields()) {

                          String fieldValueIdentifier = "";
                          /*if (field.getValue() instanceof ModelInstance) { 
                              fieldValueIdentifier = field.getIdentifier();
                          } else {
                              final Object fieldValue = field.getValue();
                              fieldValueIdentifier = fieldValue.toString();
                          }*/
                          fieldValueIdentifier = field.getIdentifier()+getSuffix(branch);
                          writeIndentedLine("setFieldValue(" + variableIdentifier + "," + "\"" + field.getVariableName() + "\"" + "," + fieldValueIdentifier + ");");

                          writeNewLine();
                      }
                  }
              }
          }
      }      
     
   }
   
   
   
   /**
    * write the method invocation for each branch
    *
    * @param testCase
    */
   private void writeMethodInvocation(ExploitModel eModel, KeYJavaMethod method, int branch) {
       //SELF=getSelfName(eModel);
       SELF = eModel.getHEAP_NAME();
       writeComment("Perform execution " + branch,false);      
       
       final String returnType = method.getReturnType();
       String methodInvocation = "";
       if (!returnType.equals("void")) {
           methodInvocation += returnType + " " + EXECUTION_RESULT + getSuffix(branch)+ " = ";
       }

       methodInvocation += SELF + getSuffix(branch)+ "." + method.getProgramMethod().getName() + "(";
       final List<IProgramVariable> parameters = method.getParameters();

       for (int i = 0; i < parameters.size(); i++) {
           final String parameterName = parameters.get(i).name().toString();
           methodInvocation += parameterName +getSuffix(branch);
           if (i != (parameters.size() - 1)) {
               methodInvocation += ",";
           }
       }
       methodInvocation += ");";
       writeIndentedLine(methodInvocation);
       writeNewLine();
   }
   
     
   /**
    * write instruction to get and store the value of low variable when an execution finish
    * to avoid side-effect of self-composition (relating static variable)
    * */  
   
   private void writeAccessToLowVarOutput(ExploitModel eModel, int branch){
      ModelVariable lowVar = eModel.getLowVar();
      writeComment("Get the value of low variable " + lowVar.getVariableName() + " after execution " + branch, false);
     /* if(lowVar.isStatic()){
         
          * TODO: change to use the REAL Class name (for reference type)
          * 
         String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
         String typeName = lowVar.getTypeName();  
         //String className = exploitTestSuite.getKeYJavaClass().getName();
         String className = lowVar.getDeclareClassName();
         writeIndentedLine(typeName + " " + low_out + " = " + 
                           className+"." + lowVar.getVariableName()+";");
         writeNewLine();
      }else{*/
         String low_out = lowVar.getIdentifier()+"_out" + getSuffix(branch);
         String typeName = lowVar.getTypeName();         
         String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
         writeIndentedLine(typeName + " " + low_out + " = ((" + ClassWrapper.wrapperClassName.get(typeName) + 
                           ")getFieldValue(" + parentName + getSuffix(branch) + "," + "\"" + lowVar.getVariableName() + "\"))." 
                           + ClassWrapper.getValueMethodName.get(typeName) + ";" );
         
         writeNewLine();
      //}
   }
   
   /**
    * write assert clause to check non-interference by comparing the output value of low variable in ExploitModel
    * it has the template: assertFalse(l1==l2)
    * */
   private void writeAssert2CompareLowOutput(ExploitModel eModel){
      ModelVariable lowVar = eModel.getLowVar();
      String low_out_1 = lowVar.getIdentifier()+"_out" + getSuffix(1);
      String low_out_2 = lowVar.getIdentifier()+"_out" + getSuffix(2);
      String assertClause = low_out_1 + " == " + low_out_2;
      assertClause = "assertTrue(" + assertClause + ");";
      writeComment("assert that the value of low variable " + lowVar.getIdentifier() + " is not changed after performing two executions", false);
      writeIndentedLine(assertClause);
      writeNewLine();
   }
   
     
     
   /**
    * write assert clause to test declassification (conditional delimited release)
    * the concrete model should satisfy condition:
    * \forall escapes expression e: e(l1,h1) == e(l2,h2) \if c(cl1,h1) and c(l2,h2)
    * the logical clause has the format: 
    * (!(c1(cl1,h1) and c1(l2,h2)) || e1(l1,h1) == e1(l2,h2)) && (!(c2(cl1,h1) and c2(l2,h2)) || e2(l1,h1) == e2(l2,h2))
    * */
   private void writeAssert2DeclassificationByCompareEscapeClause(ExploitModel eModel, KeYJavaMethod method){
      if(method.hasEscapeHatches()){
         SELF=eModel.getHEAP_NAME();
         ModelVariable lowVar=eModel.getLowVar();
         writeComment("Assert that the declassification (conditional delimited release) : \n" +
               " If the values of all escapes expression calculated by input values of both executions are the same, accordingly" +
               " or the conditions are not satisfied by both two executions, then the output value of low variable  " + lowVar + " is independent of all escapes expression", false);     
            
         //get all of declassification clause
         //List<Term> escapeHatchTerms = method.getDeclassificationTerms();
         ImmutableList<DelimitedRelease> declassification = method.getEscapeHatches();
         for(DelimitedRelease decl: declassification){
            DelimitedReleaseExtractor drExtractor = new DelimitedReleaseExtractor(decl, method.getServices());            
            if (drExtractor.affect2Var(SELF, lowVar.getIdentifier())){
               /*
                * create equation of two escape hatches expressions interpreted in two paths
                * */ 
               
               ImmutableList<Term> escapeHatchTerms = decl.escapeHatches;            
               //TestTransformer testTransformer = new TestTransformer(method.getServices());
               String compareClause="";         
               for(Term escapeTerm: escapeHatchTerms){
                    
                  Term declass1=escapeTerm;
                  Term declass2=escapeTerm;            
                              
                  compareClause += "(" + TestTransformer.transformExpression2String(declass1, 1, SELF) +
                                    " == " +
                                    TestTransformer.transformExpression2String(declass2, 2, SELF)+")";             
                  
                  compareClause += "&&";               
                 
               }        
               //eliminate the last "&&" in compareClause
               compareClause = compareClause.substring(0, compareClause.length()-2);
               
               /*
                * create contents for escape hatches conditions 
                * */
                           
               ImmutableList<Term> conditions = decl.conditions; 
               String conditionClause1 = "";
               String conditionClause2 = "";
               if(conditions.size()>0){               
                  Term conditionTerm = drExtractor.getEscCondition();  
                                 
                  conditionClause1 += TestTransformer.transformExpression2String(conditionTerm, 1 , SELF);
                  conditionClause2 += TestTransformer.transformExpression2String(conditionTerm, 2 , SELF);
                  
               }
               String assertClause = "";
               if(conditions.size()>0){    
                  assertClause = "assertTrue(" + compareClause + 
                                 " || " +
                                 "(!(" + conditionClause1 + " && " + conditionClause2 + ")));" ;
                  
               }else
                  assertClause = "assertTrue(" + compareClause + ");" ;
               writeIndentedLine(assertClause);
               writeNewLine();
            }
         }
      }                 
   }
   
   /**
    * write assert clause to check if the preconditions are satisfied with input values of two running
    * */
   private void writeAssert2CheckPrecondition(ExploitModel eModel,KeYJavaMethod method, int branch){
     
      String heapName=eModel.getHEAP_NAME();
      List<Term> preconds = method.getPreconditions();
      String assertClause ="";
      //TestTransformer testTransformer =new TestTransformer(method.getServices());
    		  
      for(int i=0;i<preconds.size();i++){
         Term precond = KeYResourceHandler.removeDefaultPrecondition(preconds.get(i));
         precond = KeYResourceHandler.removeNotnullDefaultCondition(precond);
         //System.out.println(preconds.get(i));
         assertClause += TestTransformer.transformExpression2String(precond, branch , heapName);
         if(i<preconds.size()-1)
            assertClause += " && ";  
         
      }
      //System.out.println("check precondition:" + assertClause);
      if(!assertClause.equals("true")){
         writeComment("assert that the input values of execution " + branch +" satisfies all preconditions of method " + method.getName(), false);
         assertClause = "assertTrue(" + assertClause + ");" ;
         writeIndentedLine(assertClause);
         writeNewLine();
      }
   }
   
   /**
    * write test case for an exploit model
    * @param ExploitModel, IFBarrier, KeyJavaMethod
    * */
   private void writeTestMethodContent(ExploitModel eModel, IFBarrier spec, KeYJavaMethod method){
      //write test fixture for running 1
      writeTestFixtureForBranch(eModel, 1);    
         
      //write assert to check if the input values of running 1 satisfy the precondition or not
      writeAssert2CheckPrecondition(eModel, method, 1);
      
      //write method invocations
      writeMethodInvocation(eModel, method, 1);
      writeAccessToLowVarOutput(eModel, 1);
      
      //write test fixture for running 2
      writeTestFixtureForBranch(eModel, 2);      
      
      //write assert to check if the input values of running 2 satisfy the precondition or not
      writeAssert2CheckPrecondition(eModel, method, 2);
      
      writeMethodInvocation(eModel, method, 2); 
      writeAccessToLowVarOutput(eModel, 2);
      
      
     //write Assert clauses to check declassification (conditional delimited release)
      writeAssert2DeclassificationByCompareEscapeClause(eModel, method);     
                 
      
      //write assert clauses
      //writeAssert2CompareLowValueOutput(eModel);
      writeAssert2CompareLowOutput(eModel);
      
          
      
   }
   
  
    
   public String getExploitTestContent(){
      try {
         createExploitContent();
      }
      catch (JUnitConverterException e) {

         e.printStackTrace();
      }
      return getCurrentOutput();
   }

   
   public String getClassName(){
      return className;
   }
}

/*
 * this class extract and retrieve information concerning some wrapper classes of primitive types (Integer, Long, Byte, Boolean)
 * */
class ClassWrapper{
   public static final Map<String, String> wrapperClassName;
   public static final Map<String, String> getValueMethodName;
   
   static{
      wrapperClassName = new HashMap<String,String>();
      wrapperClassName.put("int", "Integer");
      wrapperClassName.put("long", "Long");
      wrapperClassName.put("byte", "Byte");
      wrapperClassName.put("boolean", "Boolean");
      
      getValueMethodName = new HashMap<String,String>();
      getValueMethodName.put("int", "intValue()");
      getValueMethodName.put("long", "longValue()");
      getValueMethodName.put("byte", "byteValue()");
      getValueMethodName.put("boolean", "booleanValue()");
   }
   
   
}