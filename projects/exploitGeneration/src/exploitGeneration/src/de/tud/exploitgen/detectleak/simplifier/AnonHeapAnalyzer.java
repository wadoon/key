package de.tud.exploitgen.detectleak.simplifier;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.util.Pair;

public class AnonHeapAnalyzer {
   private final Term term; //is a anon heap select function
   private Services services;
   private TermBuilder termBuilder;
   private Map<String,Pair<Term,Term>> map2AnonHeap;
   /**
    * @param term
    * @param services
    */
   public AnonHeapAnalyzer(Term term, Services services) {
      super();
      this.term = term;
      this.services = services;
      termBuilder=new TermBuilder(new TermFactory(), services);
      map2AnonHeap = new HashMap<String, Pair<Term,Term>>();
      analyseTerm(this.term);
   }
   
   private void analyseTerm(Term t){
      if(HeapHandler.isAnonHeapSelectFunction(t)){
         AnonHeapSelectSimplifer anonSimply = new AnonHeapSelectSimplifer(t, services);         
         if(anonSimply.objectChanged()){ //then t.sub(0) must be a anon function
            Term object = t.sub(1);
            Term anonFunc = t.sub(0);            
            Term anonHeap = anonFunc.sub(2);
            if(!map2AnonHeap.containsKey(object.toString())){               
               map2AnonHeap.put(object.toString(), new Pair<Term, Term>(anonHeap, buildCorrectedTerm(object, anonHeap)));
            }
            else{
               Term availHeap = map2AnonHeap.get(object.toString()).first;
               Term heapBuild = anonFunc.sub(0);
               if(TermParser.isAnonFunction(heapBuild)){
                  if(TermUtil.isDescendant(availHeap, heapBuild)){
                     //available heap in map is out-of-date heap, update it
                     map2AnonHeap.put(object.toString(), new Pair<Term, Term>(anonHeap, buildCorrectedTerm(object, anonHeap)));
                  }
               }
            }
         }else{
            for(Term st: t.subs())
               analyseTerm(st);
         }
      }else if(t.subs()!=null){
         for(Term st: t.subs())
            analyseTerm(st);
      }
   }
   
   private Term buildCorrectedTerm(Term object, Term anonHeap){
      KeYJavaType type = services.getJavaInfo().getKeYJavaType(object.sort());
      String correctedName = "";
      if(HeapHandler.isHeapSelectFunction(object))
         correctedName = HeapHandler.getAnonHeapName(anonHeap) + KEGConstant.SEPARATOR + HeapHandler.getSynthesisNameOfHeapSelectFunction(object,  KEGConstant.SEPARATOR);
      else
         correctedName = HeapHandler.getAnonHeapName(anonHeap) + KEGConstant.SEPARATOR + object.toString();
      Term freshObject = termBuilder.var(new LocationVariable(new ProgramElementName(correctedName),type));      
      return freshObject;
   }
   
    
   public Term replaceFreshVariableByCorrectedOne(Term t){
      if(KeYResourceHandler.isArtificialVariable(t)){
         if(map2AnonHeap.containsKey(t.toString()))
            return map2AnonHeap.get(t.toString()).second;
         else
            return t;
      }        
      else if(t.subs()!=null){
         int size = t.subs().size();
         if(size>0){
            Term[] subs = new Term[size];
            for(int i=0;i<size;i++){
               subs[i] = replaceFreshVariableByCorrectedOne(t.sub(i));
            }
            return termBuilder.tf().createTerm(t.op(), subs, t.boundVars(),t.javaBlock());
         }else
            return t;
      }else
         return t;
   }
   
   public Term replaceForEmbeddedLengthFunction(Term t){
      if(HeapHandler.isLengthFunction(t)){
         Term array = t.sub(0);
         if(map2AnonHeap.containsKey(array.toString())){
            Term freshArray = map2AnonHeap.get(array.toString()).second;
            return termBuilder.dotLength(freshArray);
         }else{
            return t;
         }
      }else if(t.subs()!=null){
         int size = t.subs().size();
         if(size>0){
            Term[] subs = new Term[size];
            for(int i=0;i<size;i++){
               subs[i] = replaceForEmbeddedLengthFunction(t.sub(i));
            }
            return termBuilder.tf().createTerm(t.op(), subs, t.boundVars(),t.javaBlock());
         }else
            return t;
      }else
         return t;
   }
   
   
   public void printMap(){
      System.out.println("===PRINT map2AnonHeap ====");
      for(String key: map2AnonHeap.keySet()){
         System.out.println(key + " <-- " + map2AnonHeap.get(key));
      }
      System.out.println("========");
   }
}
