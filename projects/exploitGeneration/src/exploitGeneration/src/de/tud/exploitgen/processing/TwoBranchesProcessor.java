/**
 * 
 */
package de.tud.exploitgen.processing;




import java.util.HashMap;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.TestTransformer;
import de.tud.exploitgen.util.VariableChecker;
import de.tud.exploitgen.util.KeYResourceHandler;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;


/**
 * this class process two branches (two termination nodes) to extract information needed to build interference formula
 * @author Huy Do
 *
 */
public class TwoBranchesProcessor {   
   private IExecutionNode node1,node2; //two termination nodes representing two branches.   
   
   private KeYJavaMethod method;
   private Services services;
   private VariableChecker vc;
   
   private String HEAP_NAME=""; //contains name of heap object (started by "self")
   private final TermBuilder termBuilder;
   private final Term tt = new TermFactory().createTerm(Junctor.TRUE);
   
   /*ingredients to make interference formula*/
   private PairTermCollection listLocalHighVars; //list of high local variables represented as a Term
   private PairTermCollection listLocalLowVars; //list of low local variables represented as a Term   
   private PairTermCollection listLocalLowOutValues1 ; //list of local value of low variables of branch 1
   private PairTermCollection listLocalLowOutValues2 ; //list of value of low variables of branch 2
      
   private PairTermCollection listHeapHighVars; //list of high variables in heap
   private PairTermCollection listHeapLowVars; //list of low variables in heap
   private PairTermCollection listHeapLowOutValues1; //list of values low heap variables at the end of branch 1.
   private PairTermCollection listHeapLowOutValues2; //list of values low heap variables at the end of branch 2.
   
   private PairTermCollection listHighInputs; //list of high input variables, including both local and heap variables
   private PairTermCollection listLowInputs; //list of low input variables, including both local and heap variables
   private PairTermCollection listLowOutputValues1; //list of values of low input variables of branch 1, including both local and heap variables
   private PairTermCollection listLowOutputValues2; //list of values of low input variables of branch 2, including both local and heap variables
   private PairTermCollection listLowOutputs; //list of low output variables, including both local variable and heap variable
   
   //precondition and path condition of two branches, used in making interference formulas
   private Term preCond1,preCond2,pathCond1,pathCond2;
   
   //map<heapLowVar, field>: mapping from heap low variable name to its corresponding field name
   Map<String,String> mapFieldName;
   
   /**
    * @return the node1
    */
   public IExecutionNode getNode1() {
      return node1;
   }

   /**
    * @param node1 the node1 to set
    */
   public void setNode1(IExecutionNode node1) {
      this.node1 = node1;
   }

   /**
    * @return the node2
    */
   public IExecutionNode getNode2() {
      return node2;
   }

   /**
    * @param node2 the node2 to set
    */
   public void setNode2(IExecutionNode node2) {
      this.node2 = node2;
   }

   private IExecutionNode getNodeOfBranch(int branch){
      if(branch==1)
         return node1;
      else
         return node2;
   }
   /**
    * @param node1
    * @param node2
    */
   public TwoBranchesProcessor(IExecutionNode node1, IExecutionNode node2,KeYJavaMethod method,VariableChecker vc) {
      super();
      this.node1 = node1;
      this.node2 = node2;
      this.method=method;
      this.vc=vc;
      services=method.getServices();
      termBuilder=new TermBuilder(new TermFactory(), services);
      
      //initiate for the ingredients
      listHeapHighVars=new PairTermCollection(services);
      listHeapLowOutValues1=new PairTermCollection(services);
      listHeapLowOutValues2=new PairTermCollection(services);
      listHeapLowVars=new PairTermCollection(services);
      listLocalHighVars=new PairTermCollection(services);
      listLocalLowOutValues1=new PairTermCollection(services);
      listLocalLowOutValues2=new PairTermCollection(services);      
      listLocalLowVars=new PairTermCollection(services);
      
      listHighInputs=new PairTermCollection(services);
      listLowInputs=new PairTermCollection(services);
      listLowOutputs=new PairTermCollection(services);
      listLowOutputValues1=new PairTermCollection(services);
      listLocalLowOutValues2=new PairTermCollection(services);
      
      mapFieldName=new HashMap<String,String>();
   }
   
      
   /*
    * get path condition based on branch, after that resolve it
    * if branch is 1 then return path condition of node1, otherwise return path condition of  node2.
    * */
   private Term getResolvedPathCondition(int branch) throws ProofInputException {
      Term pc;
      if(branch==1)
         pc= node1.getPathCondition();
      else
         pc= node2.getPathCondition();
      //replace all select function in path condition (heap value) by the field
      //System.out.println(pc);
      pc=new HeapHandler(services).replaceSelectFunctionByItsField(pc);
      pc=listHighInputs.replacePVByNameAndBranch(pc, branch);
      pc=listLowInputs.replacePVByNameAndBranch(pc, branch);
      return pc;
   }
   
   /*
    * resolve branches by the termination node.
    * get information for listHighVars, listLowVars,listLowOutValues, listLowOutVars, listHeapHighVars, listHeapLowVars, listHeapLowOutValues
    * */
   
   private void resolveBranche2GetInfo(int branch)throws ProofInputException{
      IExecutionVariable[] vars = ((IExecutionStateNode) getNodeOfBranch(branch)).getVariables();      
      for(IExecutionVariable var: vars){  
         //System.out.println(var.getName()+"; type: " + var.getElementType());
         if(vc.isHeap(var)){
            HEAP_NAME=var.getName();
            add2ListHeapVars(var,branch);
         }
         else if(vc.isHigh(var)){            
            add2ListLocalHighVar(var);
         }
         else if(vc.isLow(var)){
            add2ListLocalLowVars(var);
            add2ListLocalLowOutValues(var, branch) ;           
         }
      }   
   }  
   
   /*
    * make ingredients to build interference term: 
    * listLowInputs,slistHighInputs,slistLowOutputs, listLowOutValues1, listLowOutValues2
    * */
   
   private void processIngredients() throws ProofInputException{
      //create listHighInputs from listLocalHighVars and listHeapHighVars
      listHighInputs=listLocalHighVars.combine(listHeapHighVars);      
      
      //create listLowInputs from listLocalLowVars and listHeapLowVars
      listLowInputs=listLocalLowVars.combine(listHeapLowVars);
      
      //create listLowOutputValues1 from listLocalLowOutValue1 and listHeapLowOutValues1
      listLowOutputValues1=listLocalLowOutValues1.combine(listHeapLowOutValues1);
      
      //create listLowOutputValues2 from listLocalLowOutValue2 and listHeapLowOutValues2
      listLowOutputValues2=listLocalLowOutValues2.combine(listHeapLowOutValues2);
      
      
      /*
       * create listLowOuputs from listLowOutputValues1 and listLowOutputValues2
       * and resolve values of low outputs int two branches 
       **/      
      listLowOutputs=new PairTermCollection(services);
      for(String name: listLowOutputValues1.getNameSet()){
         //make pair term of "_out_1" and "_out_2"
         Term lOut1=listLowOutputValues1.getTermByNameAndBranch(name, 1);
         Term lOut2=listLowOutputValues2.getTermByNameAndBranch(name, 1);
         PairTerm pt=new PairTerm(lOut1,lOut2,services);
         listLowOutputs.add(name, pt);
         
         //resolve low outputs of branches 1 (all variables are replaced by fake variables (suffix "_1")
         Term vl1=listLowOutputValues1.getTermByNameAndBranch(name, 2);
         vl1=listHighInputs.replacePVByNameAndBranch(vl1, 1);
         vl1=listLowInputs.replacePVByNameAndBranch(vl1, 1);
         PairTerm pt1=new PairTerm(lOut1,vl1,services);         
         listLowOutputValues1.add(name, pt1);
         
         //resolve low outputs of branches 2 (all variables are replaced by fake variables (suffix "_2")
         Term vl2=listLowOutputValues2.getTermByNameAndBranch(name, 2);
         vl2=listHighInputs.replacePVByNameAndBranch(vl2, 2);
         vl2=listLowInputs.replacePVByNameAndBranch(vl2, 2);
         PairTerm pt2=new PairTerm(lOut2,vl2,services);
         listLowOutputValues2.add(name, pt2);
      }
      
      
      /*
       * get and resolve precondition and path condition of two branches
       * */
      preCond1=getResolvedPrecondition(1);
      preCond2=getResolvedPrecondition(2);
      System.out.println("precondition 1: " + preCond1);
      System.out.println("precondition 2: " + preCond2);
      pathCond1=getResolvedPathCondition(1);
      pathCond2=getResolvedPathCondition(2);
      System.out.println("path condition 1: " + pathCond1);
      System.out.println("path condition 2: " + pathCond2);
   }
   
   
   
   
   /*
    * add variable's information to the list of high local variable
    * */
   private void add2ListLocalHighVar(IExecutionVariable var) throws ProofInputException{
      String varName=new KeYResourceHandler().getVarName(var);
      //if the list of high variable does not contains the variable, add it into the list
      if(!listLocalHighVars.contains(varName)){
         /*
          * create two variables which have the same type with this variable and have two different name 
          * (by adding suffixes _1 and _2)
         */
         LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),var.getProgramVariable().getKeYJavaType());
         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),var.getProgramVariable().getKeYJavaType());
         
         PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2),services);
         listLocalHighVars.add(varName, pair);
      }
   } 
   
   
   /*
    * add variable's information to the list of low local variable
    * */  
   private void add2ListLocalLowVars(IExecutionVariable var) throws ProofInputException{
      /*
       * add to listLowVars
       * create two variables which have the same type with this variable and have two different name 
       * (by adding suffixes _1 and _2)
      */
      String varName=new KeYResourceHandler().getVarName(var);
      //if the list of low variable does not contains the variable, add it into the list
      if(!listLocalLowVars.contains(varName)){
         LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),var.getProgramVariable().getKeYJavaType());
         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),var.getProgramVariable().getKeYJavaType());
        
         PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2),services);
         listLocalLowVars.add(varName, pair);
      }
   }
   
   /*
    * add to the list of output values of low local variables
    * */
   private void add2ListLocalLowOutValues(IExecutionVariable var, int branch) throws ProofInputException{
      String varName=new KeYResourceHandler().getVarName(var);
      //if the list of low output variable's value does not contains the variable, add it into the list
      if(branch==1){ //solve branch 1
         if(!listLocalLowOutValues1.contains(varName)){
            LocationVariable lvo=new LocationVariable(new ProgramElementName(varName + "_out_1"),var.getProgramVariable().getKeYJavaType());
            Term value=var.getValues()[0].getValue();
            //Term value=var.getValues()[1].getValue();
            //replace all select function in the value by the corresponding field name
            value=new HeapHandler(services).replaceSelectFunctionByItsField(value);
            
            PairTerm pair=new PairTerm(termBuilder.var(lvo),value,services);
            listLocalLowOutValues1.add(varName, pair);
         }
      }else{ //solve branch 2
         if(!listLocalLowOutValues2.contains(varName)){
            LocationVariable lvo=new LocationVariable(new ProgramElementName(varName + "_out_2"),var.getProgramVariable().getKeYJavaType());
            Term value=var.getValues()[0].getValue();
            //Term value=var.getValues()[1].getValue();
            //replace all select function in the value by the corresponding field name
            value=new HeapHandler(services).replaceSelectFunctionByItsField(value);
            
            PairTerm pair=new PairTerm(termBuilder.var(lvo),value,services);
            listLocalLowOutValues2.add(varName, pair);
         }
      }
   }
    
   
   /*
   * add to list of high heap variables 
   * */
  private void add2ListHeapHighVars(IExecutionVariable var) throws ProofInputException{
     String varName=var.getName();
     
     varName=HEAP_NAME+"_"+varName; //add prefix heap to make sure that this is heap variable
     //if the list of high variable does not contains the variable, add it into the list
     if(!listHeapHighVars.contains(varName)){
        /*
         * create two variables which have the same type with this variable and have two different name 
         * (by adding prefix "self_" and suffixes _1 and _2)
        */
        LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),var.getProgramVariable().getKeYJavaType());
        LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),var.getProgramVariable().getKeYJavaType());
        
        PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2),services);
        listHeapHighVars.add(varName, pair);
     }           
  }
  
  /*
   * add to list of low heap variables 
   * */
  private void add2ListHeapLowVars(IExecutionVariable var) throws ProofInputException{
     String fieldName=var.getName();
     String varName=HEAP_NAME + "_" + fieldName; //add prefix heap to make sure that this is heap variable
     
     mapFieldName.put(varName, fieldName); //map varName to its original field name
     //if the list of low variable does not contains the variable, add it into the list
     if(!listHeapLowVars.contains(varName)){
        /*
         * create two variables which have the same type with this variable and have two different name 
         * (by adding prefix "self_" and suffixes _1 and _2)
        */
        LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),var.getProgramVariable().getKeYJavaType());
        LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),var.getProgramVariable().getKeYJavaType());
        
        PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2),services);
        listHeapLowVars.add(varName, pair);
     }           
  }
  
  /*
   * add to list of value of output low heap variables via branch 
   * */
  
  private void add2ListHeapLowOutValues(IExecutionVariable var, int branch) throws ProofInputException{
     String fieldName=var.getName();
     String varName=HEAP_NAME + "_" + fieldName; //add prefix heap to make sure that this is heap variable
     
     //map low var name to its original field name
     mapFieldName.put(varName, fieldName);
     
     if(branch==1){ //check branch 1
        //if the list of output of low heap variables does not contains the variable, add it into the list
        if(!listHeapLowOutValues1.contains(varName)){
           LocationVariable lv=new LocationVariable(new ProgramElementName(varName + "_out_1"),var.getProgramVariable().getKeYJavaType());
           Term value=var.getValues()[0].getValue();  
           //replace all select function in the value by the corresponding field name
           value=new HeapHandler(services).replaceSelectFunctionByItsField(value);
           
           PairTerm pair=new PairTerm(termBuilder.var(lv),value,services);     
           listHeapLowOutValues1.add(varName, pair);
        }        
     }else{ //check branch 2
        if(!listHeapLowOutValues2.contains(varName)){
           LocationVariable lv=new LocationVariable(new ProgramElementName(varName + "_out_2"),var.getProgramVariable().getKeYJavaType());
           Term value=var.getValues()[0].getValue();        
           //replace all select function in the value by the corresponding field name
           value=new HeapHandler(services).replaceSelectFunctionByItsField(value);
           
           PairTerm pair=new PairTerm(termBuilder.var(lv),value,services);     
           listHeapLowOutValues2.add(varName, pair);
        } 
     }
  }
  
  private void add2ListHeapVars(IExecutionVariable var,int branch) throws ProofInputException{
     if (var.getProgramVariable() instanceof LocationVariable){
        //System.out.println(var.getName()+":"+var.getParentValue());
        //solve heap high variables
        if(vc.isHigh(var)){
           add2ListHeapHighVars(var);
        }
        
      //solve heap low variables
        if(vc.isLow(var)){
           add2ListHeapLowVars(var);
           add2ListHeapLowOutValues(var, branch);
        }        
        //recursively work with child variable of this variable
        IExecutionValue[] values =var.getValues();
        for(IExecutionValue value:values){
           IExecutionVariable[] vchilds=value.getChildVariables();
           for(IExecutionVariable vchild:vchilds){
              add2ListHeapVars(vchild,branch);
           }
        }
     }         
  }  
  
  /**
   * get all preconditions of the method, except default precondition: java.lang.Object::<inv>(heap,self)
   * replace all low and high values in each precondition by corresponding low and high values of the branch
   * return = and(all preconditions)
   * */
  private Term getResolvedPrecondition(int branch){
     //get all preconditions of the method
     Term result = tt;
     List<Term> preconditions = method.getPreconditions();
     for(Term precond: preconditions){   
        System.out.println("original:" + precond);        
        //precond = precond.sub(0); //eliminate sub(1) (default precondition)
        
        //System.out.println(precond);
        
        precond=new KeYResourceHandler().removeDefaultPrecondition(precond);
        
        //System.out.println("after remove default:" + precond);
        /*
         * with precondition, the heap name is always "self", 
         * but if a class contains more than one method, 
         * the heap object of each method could have another name: "self_0", "self_1",...
         * so we have to use the heap name of the method in resolving precondition
         * * */        
        precond=new HeapHandler(services).replaceSelectFunctionByItsField(precond,HEAP_NAME);        
     
        precond=listHighInputs.replacePVByNameAndBranch(precond, branch);
        precond=listLowInputs.replacePVByNameAndBranch(precond, branch);
        result = termBuilder.and(result,precond);        
     }     
     return result;
  }
  
  
  /**
   * solve declassification constraint to get formula:
   * (l1_outs not in declassify(1)) or (l2_outs not in declassify(2))
   * it means that the leaked information is not in the domain declared by declassification specification
   * so that the program is in secure with this declassification,
   * other wise it is secure
   * The formula l1_outs not in Declassify(1) can be explained like that:
   * there exist l1_out in set l1_outs so that l1_out is not inDeclassify: 
   *   for each function declass1 in Declassify(1)
   *     l1_out != declass1(h1)
   *     
   * We have the same way to work with (l2_outs not in Declassify(2))
   * */
  
  private Term getDeclassificationFormula(){
     
     //get declassification terms of method
     if(method.hasInformationFlowContract()){
        Term result=termBuilder.ff();
        //get all declassification terms
        List<Term> declassificationTerms = method.getDeclassificationTerms();
        //check each low variables
        for(String str: listLowOutputs.getNameSet()){
           //pcd1 contains pairs: (l1_out,declass[i](h1,l1))         
           PairTermCollection pcd1=new PairTermCollection(services);
           
           //pcd2 contains pairs: (l2_out,declass[i](h2,l2))
           PairTermCollection pcd2=new PairTermCollection(services);
           
           for(int i=0; i<declassificationTerms.size()-1;i+=2){
              /*
               * basically, element i and element i+1 of list declassificationTerms are the same
               * so, we use element i to compare with branch 1(l1_out) and use element i+1 to compare with branch 2 (l2_out)               * 
               * */
              Term declass1=declassificationTerms.get(i);
              Term declass2=declassificationTerms.get(i+1);
              //resolve declass1 and declass2: remove select phrase, replace variables by corresponding variables in two branches
              declass1=new HeapHandler(services).replaceSelectFunctionByItsField(declass1);
              declass2=new HeapHandler(services).replaceSelectFunctionByItsField(declass2);
              
              declass1=listHighInputs.replacePVByNameAndBranch(declass1, 1);
              declass1=listLowInputs.replacePVByNameAndBranch(declass1, 1);
              
              declass2=listHighInputs.replacePVByNameAndBranch(declass2, 2);
              declass2=listLowInputs.replacePVByNameAndBranch(declass2, 2);
              
              //create new PairTerm (declass1, l1_out) and add it into pcd1
              pcd1.add(str + i, new PairTerm(
                    declass1, 
                    listLowOutputValues1.getTermByNameAndBranch(str, 2),services
                    ));     
              
              //create new PairTerm (declass2, l2_out) and add it into pcd2
              pcd2.add(str + i, new PairTerm(
                    declass2, 
                    listLowOutputValues2.getTermByNameAndBranch(str, 2),services
                    ));     
           }           
           result=termBuilder.or(pcd1.totalNotEqualTerm(),pcd2.totalNotEqualTerm(),result);           
        }       
        return result;
     } 
     return termBuilder.tt();
  }
  
  
  /**
   * create formula to check non-interference property.
   * the formula will be created from two branches and the collection of high variables and low variables
   * it is based on the idea that one program is non-interference if the output of low variables are different
   * if the input of high variables are changed.
   * We do it by checking two branches (may be different branches, may be the same)
   * the formula looks like below:
   * 
   * PreCon(h1s,l1s) && PreCon(h2s,l2s) && PC1(h1s,l1s)&& PC2(h2s,l2s) 
   * && (h1s!=h2s) && (l1s==l2s) && (l1_outs!=l2_outs) 
   * && l1_outs=runPC1(h1s,l1s) && l2_outs=runPC2(h2s,l2s)
   * && (l1_outs not in Declassify(1) or l2_outs not in Declassify(2))
   * 
   * in which: 
   * PreCon is precondition of the method
   * PC1 and PC2 are path conditions of two corresponding branches.
   * h1s, h2s: the collection of the input of high variables for two corresponding branches
   * l1s, l2s: the collection of the input of low variables for two corresponding branches
   * l1_outs, l2_outs: the collection of the output of low variables for two corresponding branches
   * (Declassify(1), Declassify(2): declassification domain of two branches
   * The formula l1_outs not in Declassify(1) can be explained like that:
   * there exist l1_out in set l1_outs so that l1_out is not inDeclassify: 
   *   for each function declass1 in Declassify(1)
   *     l1_out != declass1(h1)
   *     
   * We have the same way to work with (l2_outs not in Declassify(2))
   *   
   */
  public Term makeInterferenceFormula() throws ProofInputException{   
     resolveBranche2GetInfo(1); //resolve branch 1
     resolveBranche2GetInfo(2); //resolve branch 2
     processIngredients(); //prepare to create interference formula
     
     listHighInputs.printListPairTerm();
     
     //get two preconditions
     Term precond1=getResolvedPrecondition(1);
     Term precond2=getResolvedPrecondition(2);  
     
     
     /*System.out.println("precondition 1: " + precond1);
     System.out.println("precondition 2: " + precond2);*/
     
     //get two path conditions
     Term pc1=getResolvedPathCondition(1);     
     Term pc2=getResolvedPathCondition(2);
     
     System.out.println("path condition 1: " + pc1.toString());
     System.out.println("path condition 2: " + pc2.toString());
     
        
     //make interference formula
     Term equalLowInput=listLowInputs.totalEqualTerm();
     Term notEqualHighInput=listHighInputs.partialNotEqualTerm();      
     Term valueLowOutput1=listLowOutputValues1.totalEqualTerm();
     Term valueLowOutput2=listLowOutputValues2.totalEqualTerm();
     Term notEqualLowOutput=listLowOutputs.partialNotEqualTerm();
     
     
     //listLowOutputValues1.printListPairTerm();
     Term declassification =getDeclassificationFormula();
     /*
      * return the result
      * result = PreCond(h1,l1) && PreCond(h2,l2) && PC1(h1,l1)&& PC2(h2,l2) && (h1!=h2) && (l1==l2) && (l1_out!=l2_out) 
      * && (l1_out=value(Run1)(l1,h1)(l1) &&  (l2_out=value(Run2)(l2,h2)(l2) && declassification formula
      */ 

     return termBuilder.and(precond1, precond2, pc1,pc2,
           equalLowInput,notEqualHighInput,notEqualLowOutput,valueLowOutput1,valueLowOutput2,
           declassification);
  }
  
  
  private Term getDeclassificationFormula(String lowVar){
     
     //get declassification terms of method
     if(method.hasInformationFlowContract()){
        
        //get all declassification terms
        List<Term> declassificationTerms = method.getDeclassificationTerms();
        //pcd1 contains pairs: (l1_out,declass[i](h1,l1))         
        PairTermCollection pcd1=new PairTermCollection(services);
        
        //pcd2 contains pairs: (l2_out,declass[i](h2,l2))
        PairTermCollection pcd2=new PairTermCollection(services);
        
        for(int i=0; i<declassificationTerms.size()-1;i+=2){
           /*
            * basically, element i and element i+1 of list declassificationTerms are the same
            * so, we use element i to compare with branch 1(l1_out) and use element i+1 to compare with branch 2 (l2_out)               * 
            * */
           Term declass1=declassificationTerms.get(i);
           Term declass2=declassificationTerms.get(i+1);
           //resolve declass1 and declass2: remove select phrase, replace variables by corresponding variables in two branches
           /*
            * with declassification, the heap name is always "self", 
            * but if a class contains more than one method,
            * the heap object of each method could have another name: "self_0", "self_1",...
            * so we have to use the heap name of the method in resolving declassification
            * * */     
           declass1=new HeapHandler(services).replaceSelectFunctionByItsField(declass1,HEAP_NAME);
           declass2=new HeapHandler(services).replaceSelectFunctionByItsField(declass2,HEAP_NAME);
           
           declass1=listHighInputs.replacePVByNameAndBranch(declass1, 1);
           declass1=listLowInputs.replacePVByNameAndBranch(declass1, 1);
           
           declass2=listHighInputs.replacePVByNameAndBranch(declass2, 2);
           declass2=listLowInputs.replacePVByNameAndBranch(declass2, 2);
           
           //create new PairTerm (declass1, l1_out) and add it into pcd1
           pcd1.add(lowVar + i, new PairTerm(
                 declass1, 
                 listLowOutputValues1.getTermByNameAndBranch(lowVar, 2),
                 services
                 ));     
           
           //create new PairTerm (declass2, l2_out) and add it into pcd2
           pcd2.add(lowVar + i, new PairTerm(
                 declass2, 
                 listLowOutputValues2.getTermByNameAndBranch(lowVar, 2),
                 services
                 ));     
        }           
        return termBuilder.or(pcd1.totalNotEqualTerm(),pcd2.totalNotEqualTerm());       
     } 
     return termBuilder.tt();
  }
  
  /**
   * get declassification formula
   * it has the form: declassification(h1,l1)=declassification(h2,l2)
   * */
  private Term getDeclassificationTerm(){
     if(method.hasInformationFlowContract()){
      //get all declassification terms
        List<Term> declassificationTerms = method.getDeclassificationTerms();
            
        PairTermCollection pcd=new PairTermCollection(services);
        
        for(int i=0; i<declassificationTerms.size()-1;i+=2){
           /*
            * basically, element i and element i+1 of list declassificationTerms are the same
            * so, we use element i to compare with branch 1(l1_out) and use element i+1 to compare with branch 2 (l2_out)               * 
            * */
           Term declass1=declassificationTerms.get(i);
           Term declass2=declassificationTerms.get(i+1);
           //resolve declass1 and declass2: remove select phrase, replace variables by corresponding variables in two branches
           /*
            * with declassification, the heap name is always "self", 
            * but if a class contains more than one method,
            * the heap object of each method could have another name: "self_0", "self_1",...
            * so we have to use the heap name of the method in resolving declassification
            * * */     
           declass1=new HeapHandler(services).replaceSelectFunctionByItsField(declass1,HEAP_NAME);
           declass2=new HeapHandler(services).replaceSelectFunctionByItsField(declass2,HEAP_NAME);
           
           declass1=listHighInputs.replacePVByNameAndBranch(declass1, 1);
           declass1=listLowInputs.replacePVByNameAndBranch(declass1, 1);
           
           declass2=listHighInputs.replacePVByNameAndBranch(declass2, 2);
           declass2=listLowInputs.replacePVByNameAndBranch(declass2, 2);
           
           //create new PairTerm (declass1, declass2) and add it into pcd1
           pcd.add(String.valueOf(i/2), new PairTerm(declass1,declass2,services));
        }
        return pcd.totalEqualTerm();
     }
     
     return termBuilder.tt();
  }
  
  /**
   * create formula to check non-interference property by checking the output value of low variable lowVar
   * the formula will be created from two branches and the collection of high variables and low variables
   * it is based on the idea that one program is non-interference if the output of low variables are different
   * if the input of high variables are changed.
   * We do it by checking two branches (may be different branches, may be the same)
   * the formula looks like below:
   * 
   * PreCon(h1s,l1s) && PreCon(h2s,l2s) && PC1(h1s,l1s)&& PC2(h2s,l2s) 
   * && (h1s!=h2s) && (l1s==l2s) && (louVar_out_1)1!=lowVar_out_2) 
   * && l1_outs=runPC1(h1s,l1s) && l2_outs=runPC2(h2s,l2s)
   * && Declassify(1,2)
   * 
   * in which: 
   * PreCon is precondition of the method
   * PC1 and PC2 are path conditions of two corresponding branches.
   * h1s, h2s: the collection of the input of high variables for two corresponding branches
   * l1s, l2s: the collection of the input of low variables for two corresponding branches
   * l1_outs, l2_outs: the collection of the output of low variables for two corresponding branches
   * lowVar_out_1, lowVar_out_2: two output values of lowVar at two braches
   * (lowVar_out_1 in l1_outs, lowVar_out_2 in l2_outs)
   * (Declassify(1,2): declassification formula, which claim that the value of an arbitrary expression e (e in D: the set of all escapes expression)
   * interpreted in path 1 and path 2 are equal.
   *   
   */
  private Term makeInterferenceFormula(String lowVar){
     //make interference formula
     Term equalLowInput = listLowInputs.totalEqualTerm();
     //Term notEqualHighInput = listHighInputs.partialNotEqualTerm();      
     Term valueLowOutput1 = listLowOutputValues1.totalEqualTerm();
     Term valueLowOutput2 = listLowOutputValues2.totalEqualTerm();     
     Term notEqualLowOutput = listLowOutputs.getPairTerm(lowVar).notEqualTerm();     
     //Term declassification = getDeclassificationFormula(lowVar);
     Term declassification = getDeclassificationTerm();
     /*
      * return the result
      * result = PreCond(h1,l1) && PreCond(h2,l2) && PC1(h1,l1)&& PC2(h2,l2) && (h1!=h2) && (l1==l2) && (l1_out!=l2_out) 
      * && (l1_out=value(Run1)(l1,h1)(l1) &&  (l2_out=value(Run2)(l2,h2)(l2) && declassification formula
      */     
   /* return termBuilder.and(preCond1, preCond2, pathCond1,pathCond2,
           equalLowInput,notEqualHighInput,notEqualLowOutput,valueLowOutput1,valueLowOutput2,
           declassification);*/
     return termBuilder.and(preCond1, preCond2, pathCond1,pathCond2,
           equalLowInput,notEqualLowOutput,valueLowOutput1,valueLowOutput2,
           declassification);
  }
  
  /**
   * get all interference formulas, each formula correspond to one low variable
   * */ 
  public Map<String,Term> getAllInterferenceFormula() throws ProofInputException{
     Map<String,Term> result=new HashMap<String,Term>();
     resolveBranche2GetInfo(1); //resolve branch 1
     resolveBranche2GetInfo(2); //resolve branch 2
     processIngredients(); //prepare to create interference formula
     
     System.out.println("---------\n high heap variables:");
     listHeapHighVars.printListPairTerm();
     System.out.println("---------\n high local variables:");
     listLocalHighVars.printListPairTerm();
     System.out.println("---------\n high combine variables:");
     listHighInputs.printListPairTerm();
     
     System.out.println("---------\n low heap variables:");
     listHeapLowVars.printListPairTerm();
     System.out.println("---------\n low local variables:");     
     listLocalLowVars.printListPairTerm();     
     System.out.println("---------\n low combine variables:");
     listLowInputs.printListPairTerm();
     
     System.out.println("---------\n low out variables:");
     listLowOutputs.printListPairTerm();
     
     System.out.println("---------\n low out values:");
     listLowOutputValues1.printListPairTerm();
     listLowOutputValues2.printListPairTerm();
     
     for(String lowVar: listLowOutputs.getNameSet()){
        Term interferenceTerm = makeInterferenceFormula(lowVar);
        //use original field name to map with interference term in order to generate JUnit test
        System.out.println(interferenceTerm);
        result.put(mapFieldName.get(lowVar), interferenceTerm);
     }
     return result;
  }
}
