/**
 * 
 */
package de.tud.exploitgen.processing;




import java.util.List;

import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.VariableChecker;
import de.tud.exploitgen.util.KeYResourceHandler;

import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;


/**
 * this class process two branches (two termination nodes) to extract information needed to build interference formula
 * @author Huy Do
 *
 */
public class TwoBranchesProcessor {   
   private IExecutionNode node1,node2; //two termination nodes representing two branches.   
   private static final TermBuilder termBuilder = TermBuilder.DF;
   private KeYJavaMethod method;
   private VariableChecker vc;
   
   private String HEAP_NAME="self";
   
   private static final Term tt = TermFactory.DEFAULT.createTerm(Junctor.TRUE);
   
   /*ingredients to make interference formula*/
   private PairTermCollection listLocalHighVars; //list of high local variables represented as a Term
   private PairTermCollection listLocalLowVars; //list of low local variables represented as a Term   
   private PairTermCollection listLocalLowOutValues1 ; //list of local value of low variables of branch 1
   private PairTermCollection listLocalLowOutValues2 ; //list of value of low variables of branch 2
      
   private PairTermCollection listHeapHighVars; //list of high variables in heap
   private PairTermCollection listHeapLowVars; //list of low variables in heap
   private PairTermCollection listHeapLowOutValues1; //list of values low heap variables at the end of branch 1.
   private PairTermCollection listHeapLowOutValues2; //list of values low heap variables at the end of branch 2.
   
   private PairTermCollection listHighInputs; //list of high input variables, including both local and heap variables
   private PairTermCollection listLowInputs; //list of low input variables, including both local and heap variables
   private PairTermCollection listLowOutputValues1; //list of values of low input variables of branch 1, including both local and heap variables
   private PairTermCollection listLowOutputValues2; //list of values of low input variables of branch 2, including both local and heap variables
   private PairTermCollection listLowOutputs; //list of low output variables, including both local variable and heap variable
   /**
    * @return the node1
    */
   public IExecutionNode getNode1() {
      return node1;
   }

   /**
    * @param node1 the node1 to set
    */
   public void setNode1(IExecutionNode node1) {
      this.node1 = node1;
   }

   /**
    * @return the node2
    */
   public IExecutionNode getNode2() {
      return node2;
   }

   /**
    * @param node2 the node2 to set
    */
   public void setNode2(IExecutionNode node2) {
      this.node2 = node2;
   }

   private IExecutionNode getNodeOfBranch(int branch){
      if(branch==1)
         return node1;
      else
         return node2;
   }
   /**
    * @param node1
    * @param node2
    */
   public TwoBranchesProcessor(IExecutionNode node1, IExecutionNode node2,KeYJavaMethod method,VariableChecker vc) {
      super();
      this.node1 = node1;
      this.node2 = node2;
      this.method=method;
      this.vc=vc;
      
      //initiate for the ingredients
      listHeapHighVars=new PairTermCollection();
      listHeapLowOutValues1=new PairTermCollection();
      listHeapLowOutValues2=new PairTermCollection();
      listHeapLowVars=new PairTermCollection();
      listLocalHighVars=new PairTermCollection();
      listLocalLowOutValues1=new PairTermCollection();
      listLocalLowOutValues2=new PairTermCollection();      
      listLocalLowVars=new PairTermCollection();
      
      listHighInputs=new PairTermCollection();
      listLowInputs=new PairTermCollection();
      listLowOutputs=new PairTermCollection();
      listLowOutputValues1=new PairTermCollection();
      listLocalLowOutValues2=new PairTermCollection();
      
   }
   
      
   /*
    * get path condition based on branch
    * if branch is 1 then return path condition of node1, otherwise return path condition of  node2.
    * */
   private Term getPathCondition(int branch) throws ProofInputException {
      Term pc;
      if(branch==1)
         pc= node1.getPathCondition();
      else
         pc= node2.getPathCondition();
      //replace all select function in path condition (heap value) by the field
      pc=new HeapHandler().replaceSelectFunctionByItsField(pc);
      return pc;
   }
   
   /*
    * resolve branches by the termination node.
    * get information for listHighVars, listLowVars,listLowOutValues, listLowOutVars, listHeapHighVars, listHeapLowVars, listHeapLowOutValues
    * */
   
   private void resolveBranche2GetInfo(int branch)throws ProofInputException{
      IExecutionVariable[] vars = ((IExecutionStateNode) getNodeOfBranch(branch)).getVariables();      
      for(IExecutionVariable var: vars){  
         System.out.println(var.getName()+"; type: " + var.getElementType());
         if(vc.isHeap(var)){
            HEAP_NAME=var.getName();
            add2ListHeapVars(var,branch);
         }
         else if(vc.isHigh(var)){            
            add2ListLocalHighVar(var);
         }
         else if(vc.isLow(var)){
            add2ListLocalLowVars(var);
            add2ListLocalLowOutValues(var, branch) ;           
         }
      }   
   }  
   
   /*
    * make ingredients to build interference term: 
    * listLowInputs,slistHighInputs,slistLowOutputs, listLowOutValues1, listLowOutValues2
    * */
   
   private void processIngredients(){
      //create listHighInputs from listLocalHighVars and listHeapHighVars
      listHighInputs=listLocalHighVars.combine(listHeapHighVars);      
      
      //create listLowInputs from listLocalLowVars and listHeapLowVars
      listLowInputs=listLocalLowVars.combine(listHeapLowVars);
      
      //create listLowOutputValues1 from listLocalLowOutValue1 and listHeapLowOutValues1
      listLowOutputValues1=listLocalLowOutValues1.combine(listHeapLowOutValues1);
      
      //create listLowOutputValues2 from listLocalLowOutValue2 and listHeapLowOutValues2
      listLowOutputValues2=listLocalLowOutValues2.combine(listHeapLowOutValues2);
      
      /*
       * create listLowOuputs from listLowOutputValues1 and listLowOutputValues2
       * and resolve values of low outputs int two branches 
       **/
      
      listLowOutputs=new PairTermCollection();
      for(String name: listLowOutputValues1.getNameSet()){
         //make pair term of "_out_1" and "_out_2"
         Term lOut1=listLowOutputValues1.getTermByNameAndBranch(name, 1);
         Term lOut2=listLowOutputValues2.getTermByNameAndBranch(name, 1);
         PairTerm pt=new PairTerm(lOut1,lOut2);
         listLowOutputs.add(name, pt);
         
         //resolve low outputs of branches 1 (all variables are replaced by fake variables (suffix "_1")
         Term vl1=listLowOutputValues1.getTermByNameAndBranch(name, 2);
         vl1=listHighInputs.replacePVByNameAndBranch(vl1, 1);
         vl1=listLowInputs.replacePVByNameAndBranch(vl1, 1);
         PairTerm pt1=new PairTerm(lOut1,vl1);         
         listLowOutputValues1.add(name, pt1);
         
         //resolve low outputs of branches 2 (all variables are replaced by fake variables (suffix "_2")
         Term vl2=listLowOutputValues2.getTermByNameAndBranch(name, 2);
         vl2=listHighInputs.replacePVByNameAndBranch(vl2, 2);
         vl2=listLowInputs.replacePVByNameAndBranch(vl2, 2);
         PairTerm pt2=new PairTerm(lOut2,vl2);
         listLowOutputValues2.add(name, pt2);
      }
   }
   
   
   
   
   /*
    * add variable's information to the list of high local variable
    * */
   private void add2ListLocalHighVar(IExecutionVariable var) throws ProofInputException{
      String varName=new KeYResourceHandler().getVarName(var);
      //if the list of high variable does not contains the variable, add it into the list
      if(!listLocalHighVars.contains(varName)){
         /*
          * create two variables which have the same type with this variable and have two different name 
          * (by adding suffixes _1 and _2)
         */
         LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),var.getProgramVariable().getKeYJavaType());
         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),var.getProgramVariable().getKeYJavaType());
         
         PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2));
         listLocalHighVars.add(varName, pair);
      }
   } 
   
   
   /*
    * add variable's information to the list of low local variable
    * */  
   private void add2ListLocalLowVars(IExecutionVariable var) throws ProofInputException{
      /*
       * add to listLowVars
       * create two variables which have the same type with this variable and have two different name 
       * (by adding suffixes _1 and _2)
      */
      String varName=new KeYResourceHandler().getVarName(var);
      //if the list of low variable does not contains the variable, add it into the list
      if(!listLocalLowVars.contains(varName)){
         LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),var.getProgramVariable().getKeYJavaType());
         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),var.getProgramVariable().getKeYJavaType());
        
         PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2));
         listLocalLowVars.add(varName, pair);
      }
   }
   
   /*
    * add to the list of output values of low local variables
    * */
   private void add2ListLocalLowOutValues(IExecutionVariable var, int branch) throws ProofInputException{
      String varName=new KeYResourceHandler().getVarName(var);
      //if the list of low output variable's value does not contains the variable, add it into the list
      if(branch==1){ //solve branch 1
         if(!listLocalLowOutValues1.contains(varName)){
            LocationVariable lvo=new LocationVariable(new ProgramElementName(varName + "_out_1"),var.getProgramVariable().getKeYJavaType());
            Term value=var.getValues()[0].getValue();
            //Term value=var.getValues()[1].getValue();
            //replace all select function in the value by the corresponding field name
            value=new HeapHandler().replaceSelectFunctionByItsField(value);
            
            PairTerm pair=new PairTerm(termBuilder.var(lvo),value);
            listLocalLowOutValues1.add(varName, pair);
         }
      }else{ //solve branch 2
         if(!listLocalLowOutValues2.contains(varName)){
            LocationVariable lvo=new LocationVariable(new ProgramElementName(varName + "_out_2"),var.getProgramVariable().getKeYJavaType());
            Term value=var.getValues()[0].getValue();
            //Term value=var.getValues()[1].getValue();
            //replace all select function in the value by the corresponding field name
            value=new HeapHandler().replaceSelectFunctionByItsField(value);
            
            PairTerm pair=new PairTerm(termBuilder.var(lvo),value);
            listLocalLowOutValues2.add(varName, pair);
         }
      }
   }
    
   
   /*
   * add to list of high heap variables 
   * */
  private void add2ListHeapHighVars(IExecutionVariable var) throws ProofInputException{
     String varName=var.getName();
     
     varName=HEAP_NAME+"_"+varName; //add prefix heap to make sure that this is heap variable
     //if the list of high variable does not contains the variable, add it into the list
     if(!listHeapHighVars.contains(varName)){
        /*
         * create two variables which have the same type with this variable and have two different name 
         * (by adding prefix "self_" and suffixes _1 and _2)
        */
        LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),var.getProgramVariable().getKeYJavaType());
        LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),var.getProgramVariable().getKeYJavaType());
        
        PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2));
        listHeapHighVars.add(varName, pair);
     }           
  }
  
  /*
   * add to list of low heap variables 
   * */
  private void add2ListHeapLowVars(IExecutionVariable var) throws ProofInputException{
     String varName=var.getName();
     varName=HEAP_NAME + "_" + varName; //add prefix heap to make sure that this is heap variable
     //if the list of low variable does not contains the variable, add it into the list
     if(!listHeapLowVars.contains(varName)){
        /*
         * create two variables which have the same type with this variable and have two different name 
         * (by adding prefix "self_" and suffixes _1 and _2)
        */
        LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),var.getProgramVariable().getKeYJavaType());
        LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),var.getProgramVariable().getKeYJavaType());
        
        PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2));
        listHeapLowVars.add(varName, pair);
     }           
  }
  
  /*
   * add to list of value of output low heap variables via branch 
   * */
  
  private void add2ListHeapLowOutValues(IExecutionVariable var, int branch) throws ProofInputException{
     String varName=var.getName();
     varName=HEAP_NAME + "_"+varName; //add prefix heap to make sure that this is heap variable
     if(branch==1){ //check branch 1
        //if the list of output of low heap variables does not contains the variable, add it into the list
        if(!listHeapLowOutValues1.contains(varName)){
           LocationVariable lv=new LocationVariable(new ProgramElementName(varName + "_out_1"),var.getProgramVariable().getKeYJavaType());
           Term value=var.getValues()[0].getValue();  
           //replace all select function in the value by the corresponding field name
           value=new HeapHandler().replaceSelectFunctionByItsField(value);
           
           PairTerm pair=new PairTerm(termBuilder.var(lv),value);     
           listHeapLowOutValues1.add(varName, pair);
        }        
     }else{ //check branch 2
        if(!listHeapLowOutValues2.contains(varName)){
           LocationVariable lv=new LocationVariable(new ProgramElementName(varName + "_out_2"),var.getProgramVariable().getKeYJavaType());
           Term value=var.getValues()[0].getValue();        
           //replace all select function in the value by the corresponding field name
           value=new HeapHandler().replaceSelectFunctionByItsField(value);
           
           PairTerm pair=new PairTerm(termBuilder.var(lv),value);     
           listHeapLowOutValues2.add(varName, pair);
        } 
     }
  }
  
  private void add2ListHeapVars(IExecutionVariable var,int branch) throws ProofInputException{
     if (var.getProgramVariable() instanceof LocationVariable){
        //System.out.println(var.getName()+":"+var.getParentValue());
        //solve heap high variables
        if(vc.isHigh(var)){
           add2ListHeapHighVars(var);
        }
        
      //solve heap low variables
        else if(vc.isLow(var)){
           add2ListHeapLowVars(var);
           add2ListHeapLowOutValues(var, branch);
        }        
        //recursively work with child variable of this variable
        IExecutionValue[] values =var.getValues();
        for(IExecutionValue value:values){
           IExecutionVariable[] vchilds=value.getChildVariables();
           for(IExecutionVariable vchild:vchilds){
              add2ListHeapVars(vchild,branch);
           }
        }
     }         
  }  
  
  /*
   * get all preconditions of the method, except default precondition: java.lang.Object::<inv>(heap,self)
   * replace all low and high values in each precondition by corresponding low and high values of the branch
   * return = and(all preconditions)
   * */
  private Term getSolvedPrecondition(int branch){
     //get all preconditions of the method
     Term result = tt;
     List<Term> preconditions = method.getPreconditions();
     for(Term precond: preconditions){   
        //System.out.println("original:" + precond);        
        //precond = precond.sub(0); //eliminate sub(1) (default precondition)
        precond=new KeYResourceHandler().removeDefaultPrecondition(precond);
        //System.out.println("after remove default:" + precond);
        precond=new HeapHandler().replaceSelectFunctionByItsField(precond);
        //System.out.println("after solve heap:" + precond);
        precond=listHighInputs.replacePVByNameAndBranch(precond, branch);
        precond=listLowInputs.replacePVByNameAndBranch(precond, branch);
        result = termBuilder.and(result,precond);        
     }     
     return result;
  }
  
  
  
  
  
  
  /*
   * create formula to check non-interference property.
   * the formula will be created from two branches and the collection of high variables and low variables
   * it is based on the idea that one program is non-interference if the output of low variables are different
   * if the input of high variables are changed.
   * We do it by checking two branches (may be different branches, may be the same)
   * the formula looks like below:
   * 
   * PreCon(h1,l1) && PreCon(h2,l2) && PC1(h1,l1)&& PC2(h2,l2) 
   * && (h1!=h2) && (l1==l2) && (l1_out!=l2_out) 
   * && l1_out=runPC1(h1,l1) && l2_out=runPC2(h2,l2)
   * 
   * in which: 
   * PreCon is precondition of the method
   * PC1 and PC2 are path conditions of two corresponding branches.
   * h1, h2: the collection of the input of high variables for two corresponding branches
   * l1, l2: the collection of the input of low variables for two corresponding branches
   * l1_out, l2_out: the collection of the output of low variables for two corresponding branches
   *   
   */
  public Term makeInterferenceFormula() throws ProofInputException{   
     resolveBranche2GetInfo(1); //resolve branch 1
     resolveBranche2GetInfo(2); //resolve branch 2
     processIngredients(); //prepare to create interference formula
     
     listHighInputs.printListPairTerm();
     
     //get two preconditions
     Term precond1=getSolvedPrecondition(1);
     Term precond2=getSolvedPrecondition(2);  
     
     
     /*System.out.println("precondition 1: " + precond1);
     System.out.println("precondition 2: " + precond2);*/
     
     //get two path conditions
     Term pc1=getPathCondition(1);     
     Term pc2=getPathCondition(2);
     
     System.out.println("path condition 1: " + pc1.toString());
     System.out.println("path condition 2: " + pc2.toString());
     
     //replace all variables in path conditions of branch 1 by corresponding fake variables (added suffix "_1")
     pc1=listHighInputs.replacePVByNameAndBranch(pc1, 1);
     pc1=listLowInputs.replacePVByNameAndBranch(pc1, 1);
     //replace all variables in path conditions of branch 2 by corresponding fake variables (added suffix "_2")
     pc2=listHighInputs.replacePVByNameAndBranch(pc2, 2);
     pc2=listLowInputs.replacePVByNameAndBranch(pc2, 2);
     
     //make interference formula
     Term equalLowInput=listLowInputs.equalTerm();
     Term notEqualHighInput=listHighInputs.notEqualTerm();      
     Term valueLowOutput1=listLowOutputValues1.equalTerm();
     Term valueLowOutput2=listLowOutputValues2.equalTerm();
     Term notEqualLowOutput=listLowOutputs.notEqualTerm();
     //listLowOutputValues1.printListPairTerm();
     /*
      * return the result
      * result = PreCond(h1,l1) && PreCond(h2,l2) && PC1(h1,l1)&& PC2(h2,l2) && (h1!=h2) && (l1==l2) && (l1_out!=l2_out) 
      * && (l1_out=value(Run1)(l1,h1)(l1) &&  (l2_out=value(Run2)(l2,h2)(l2) 
      */
     
          
     return termBuilder.and(precond1, precond2, pc1,pc2,
           equalLowInput,notEqualHighInput,notEqualLowOutput,valueLowOutput1,valueLowOutput2);
  }
}
