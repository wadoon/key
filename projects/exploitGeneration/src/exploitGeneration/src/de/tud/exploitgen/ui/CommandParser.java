package de.tud.exploitgen.ui;

import com.beust.jcommander.Parameter;

import java.util.ArrayList;
import java.util.List;

/**
 * Instances of this class are used in order to parse command line invocations
 * of KEG, both checking syntactical correctness and extracting user
 * supplied data,
 *
 * @author christopher
 */
public class CommandParser {

    private static final String INDENT = "\t\t\t";

    /**
     * @return the indent
     */
    public static String getIndent() {

        return CommandParser.INDENT;
    }

    /**
     * Set to display about information.
     */
    @Parameter(names = {"-a", "--about"}, description = "show version and copyright information")
    private boolean about;

    /**
     * Select the loop treatment: true if using loop invariant, false if unfolding loop content
     * Default is unfolding loop
     */
    @Parameter(names = {"-li", "--loopInv"},
               description = "target the loop treatment: " + CommandParser.INDENT + "exists: true (using loop invariant)" + CommandParser.INDENT +"non exists: false (unfolding loop)" )
    private boolean loopTreatment;

    /**
     * Select the method treatment: true if using method contract, false if expanding method
     * Default is expanding method
     */
    @Parameter(names = {"-mc", "--methodCt"},
               description = "target the method treatment: " + CommandParser.INDENT + "exists: true (using method contract)" + CommandParser.INDENT +"non exists: false (expanding method)" )
    private boolean methodTreatment;
    
    /**
     * Select which Java files to use as a basis for test case generation.
     */
    @Parameter(description = "files", validateWith = JavaFileValidator.class)
    private final List<String> files = new ArrayList<String>();

    /**
     * Flag to decide if usage help should be shown.
     */
    @Parameter(names = {"-h", "--help"}, description = "displays usage help")
    private boolean help;

    /**
     * Select what methods to generate test cases for. This can either be done
     * on a categorical basis (i.e. all, public, private, protected and/or
     * native) or on a specific basis. Both ways can be combined in order to
     * customize method coverage.
     */
    @Parameter(names = {"-m", "--methods"},
               echoInput = true,
               variableArity = true,
               description = "what methods should be included in the test suite.\n" + CommandParser.INDENT + "Parameters:\n" + CommandParser.INDENT + "all\t\tinclude all user defined methods (default)\n" + CommandParser.INDENT + "public\t\tinclude all public methods\n" + CommandParser.INDENT + "private\t\tinclude all private methods\n" + CommandParser.INDENT + "protected\tinclude all protected methods\n" + CommandParser.INDENT + "native\t\tinclude methods declared in Java.lang.Object (not recommended)\n" + CommandParser.INDENT + "[method name]\tspecify methods to include (by identifier)")
    private final List<String> methods = new ArrayList<String>();

    /**
     * Select top-level output directory for the generated test suite(s).
     * Default is the current directory at the time o invocation.
     */
    @Parameter(names = {"-o", "--output"},
               description = "target output directory for generated test suites.\n" + CommandParser.INDENT + "default: current folder (.))",
               arity = 1)
    private final String outputDirectory = ".";

    /**
     * Specify the depth of sub-field's sequence needed be investigated 
     */
    @Parameter(names = {"-d", "--depth"},
          echoInput = true,
          variableArity = true,
          description = "the depth of sub-field's sequence being investigated.\n" + CommandParser.INDENT + "default: 1000")
    private int depth;
    
    /**
     * @return the files
     */
    public List<String> getFiles() {

        return files;
    }

    /**
     * @return the methods
     */
    public List<String> getMethods() {

        return methods;
    }

    /**
     * @return the outputDirectory
     */
    public String getOutputDirectory() {

        return outputDirectory;
    }

    

    /**
     * @return the value of the about flag
     */
    public boolean isAboutFlagSet() {

        return about;
    }

    /**
     * @return the value of the help flag
     */
    public boolean isHelpFlagSet() {

        return help;
    }
    
    /**
     * @return the value of loop invariant flag
     */
    public boolean getLoopTreatment() {
        return loopTreatment;
    }

   /**
    * @return the methodTreatment
    */
   public boolean getMethodTreatment() {
      return methodTreatment;
   }

   public int getDepth() {
      return depth;
   }  
    
  
   
   
}