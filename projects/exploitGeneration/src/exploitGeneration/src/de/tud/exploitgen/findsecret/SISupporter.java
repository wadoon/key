package de.tud.exploitgen.findsecret;
/**
 * this class supplies methods supporting for secret inferring
 * basically, it works as a machine producing next low input value that help maximizing information leakage from experiment
 * */

import java.io.BufferedReader;
import java.io.File;

import java.io.FileOutputStream;

import java.io.IOException;

import java.io.InputStreamReader;
import java.io.PrintStream;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;


import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.barvinokinterface.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.barvinokinterface.ParametricPolytope;
import de.tud.exploitgen.findsecret.barvinokinterface.Term2IsccTransformer;

import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;

public abstract class SISupporter {
	//contains necessary information for secret inferring (extract from symbolic execution tree via leak detection)
	protected final BadMethod badMethod; 
	
	protected List<Experiment> usedExperiments;	
	protected Term currentKnowledge; //current knowledge about high varibles
	
	protected List<Term> listLowVarTerms; //used to create formulas
	private List<QuantifiableVariable> listQuantifiedHighVar; //used to create formula	
	
	public SISupporter(BadMethod badMethod) {
		super();
		this.badMethod = badMethod;
		usedExperiments = new ArrayList<Experiment>();		
		//currentKnowledge = badMethod.getMethod().getServices().getTermBuilder().tt(); //initial knowledge = nothing		
		currentKnowledge = badMethod.getPrecondition();
		extractListLowVarTerms();		
		extractListQuantifiedHighVars();
		
	}	
	
	
	private void extractListLowVarTerms(){
		listLowVarTerms = new LinkedList<Term>();
		Model model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		for(ModelVariable mv: model.getVariables()){
			if (vc.isLow(mv.getIdentifier())){
				Term lowVar= tb.var(new LocationVariable(new ProgramElementName(mv.getIdentifier()),mv.getType()));
				listLowVarTerms.add(lowVar);
			}
		}
	}
	
	private void extractListQuantifiedHighVars(){
		listQuantifiedHighVar = new LinkedList<QuantifiableVariable>();
		Model model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		for(ModelVariable mv: model.getVariables()){
			if (vc.isHigh(mv.getIdentifier())){
				QuantifiableVariable qv = new LogicVariable(new Name(mv.getIdentifier()),mv.getSort());				
				listQuantifiedHighVar.add(qv);
			}
		}
	}
	
	/*
	 * simple idea: we should not conduct the same experiment again (one is too enough :D)
	 * return formula: \forall 0<=k<j: L_j \neq L_k 
	 * */
	protected Term avoidUsedInput(){
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term result = tb.tt();
		for(Experiment experiment: usedExperiments){
			Map<String,Long> mapLowInputs = experiment.getLowInputs();
			Term aggDiffTerm = tb.ff();
			for(Term lowVar: listLowVarTerms){
				Term diffTerm = tb.not(tb.equals(lowVar, tb.zTerm(mapLowInputs.get(lowVar.toString()).intValue())));
				aggDiffTerm = tb.or(aggDiffTerm,diffTerm);
			}
			result = tb.and(result, aggDiffTerm);
		}
		return result;
	}
	
	/*
	 * if the low input always match experiment to a risky path whose outputs are constant or depend only on L, then it is bad low input
	 *  if the low input always match experiment to a matched risky path whose outputs depend only on H, then it is bad low input
	 * return formula: \forall i \in Risk_L \cup Risk_Const: (\exists H: currentKnowledge(H) && !(pc_i(L_j,H) )  &&
	 * \forall i \in Risk_H and matched(i): (\exists H: currentKnowledge(H) && !(pc_i(L_j,H) )  
	 * */
	protected Term avoidAlwayMatchUselessPathsByInput(){
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term result = tb.tt();
		List<RiskyPath> listAvoidPaths = badMethod.getRiskConst_RiskL_MatchedRiskH();
		for(RiskyPath rp: listAvoidPaths){
			Term existH = tb.and(currentKnowledge, tb.not(rp.getPathCondition()));
			existH = tb.ex(listQuantifiedHighVar, existH);
			result = tb.and(result,existH);
		}
		return result;		
	}


	
	
	
	public Term getCurrentKnowledge() {
		return currentKnowledge;
	}


	/*
	 * update current knowledge of high variable with new information about high variable
	 * TODO: some simplification should be applied?
	 * first simplication:
	 * if infoH->currentKnowledge, then currentKnowledge := infoH
	 * */
	public void updateKnowledge(Experiment experiment){		
		//update list of used experiment
		add2UsedExperiments(experiment);
		//update matched path
		badMethod.updateMatchedPath(currentKnowledge, experiment);
		//update knowledge
		Term newInfoH = createSecretInfoFromExperiment(experiment);
		TermBuilder termBuilder = badMethod.getMethod().getServices().getTermBuilder();
		/*
		 * check if inforH -> currentKnowledge?	(1)	 
		 * to do that, check satisfiabiblity of formula:
		 * inforH && !currentKnowledge (2)
		 * if (2) is unsatisfiable, then (1) holds, then currentKnowledge := inforH
		 * otherwise (1) does not hold   then currentKnowledge := currentKnowledge && inforH
		 */
		 Term checkTerm = termBuilder.and(newInfoH, termBuilder.not(currentKnowledge));
		 Z3Solver z3 = new Z3Solver(checkTerm, badMethod.getMethod().getServices());
		 if(z3.checkSatisfiable())
			 currentKnowledge = termBuilder.and(currentKnowledge, newInfoH);
		 else
			 currentKnowledge = newInfoH;
	}
	
	
	/*
	 * create new information of high variables from experiment
	 * */
	private Term createSecretInfoFromExperiment(Experiment experiment){
		Services services = badMethod.getMethod().getServices();
		TermBuilder termBuilder = services.getTermBuilder();
		Term infoH = termBuilder.ff();
		for(RiskyPath rn: badMethod.getListRiskyPaths()){					
			//pathTerm is a disjunct of infoH
			infoH = termBuilder.or(infoH, rn.getInfoH(experiment));			
		}
		return infoH;
	}	
	
	private void add2UsedExperiments(Experiment exp){
		usedExperiments.add(exp);
	}
	
	abstract public Map<String, Long> findBestLowInput() throws IOException;
	
	
	public Map<String,Long> findUsefulLowInput(){
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		Term conditionL = tb.and(avoidUsedInput(), avoidAlwayMatchUselessPathsByInput());
		Z3Solver z3 = new Z3Solver(conditionL,badMethod.getMethod().getServices());
		List<ModelVariable> resultL = z3.solveFormula2GetListModelVariable();
		if(resultL!=null){
			Map<String,Long> mapLowInput = new HashMap<String, Long>();
			VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
			//initiate the value for low inputs to make sure that all low inputs are assigned by default value (0)
			for(String lowVar: vc.getListLowVars())				
				mapLowInput.put(lowVar, (long)0);	
			
			//extract the value of low inputs
			for(ModelVariable mv: resultL){
				if(vc.isLow(mv)){
					mapLowInput.put(mv.getIdentifier(), (long)mv.getValue());
				}				
			}
			return mapLowInput;
		}
		return null;
	}
	/*
	 * return RiskyPath matching with experiment  
	 * if it doest not exist, return null
	 * */
	//private RiskyPath findMatchPath(Experiment experiment){		
		
	//}
	
	/*
	 * TODO: this is only temporary solution
	 * because variable's name is in the form of self_varName
	 * we transform it to the original form so that it can be used to write for the input file
	 * */	
	public Map<String, Long> replaceByOriginalNameOfVars(Map<String, Long> mapValues){
		Map<String, Long> result = new HashMap<String, Long>();
		Model model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		for(String varName: mapValues.keySet()){
			try{
				String originalName = model.getVariable(varName).getVariableName();
				result.put(originalName, mapValues.get(varName));
			}catch(Exception e){//exception occurs when we access artificial var that does not exist in model
				
			}		
		}
		return result;
	}
	
	public Map<String, Long> replaceByIndentifierOfVarInModel(Map<String, Long> mapValues){
		Map<String, Long> result = new HashMap<String, Long>();
		Model model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		for(String varName: mapValues.keySet()){
			try{
				String identifier = model.searchVariableByName(varName).getIdentifier();
				result.put(identifier, mapValues.get(varName));
			}catch(Exception e){//exception occurs when we access artificial var that does not exist in model
				
			}		
		}
		return result;
	}
	
	/*
	 * get the number of possible high value using barvinok tool 
	 * */
	public long findNumberOfPossibleHighValue(Term constraint) throws IOException{
		RiskyPath rn = badMethod.getListRiskyPaths().get(0);
		ParametricPolytope pp = new ParametricPolytope(constraint, new LinkedList<String>(), rn.getVc().getListHighVars());
		PrintStream outFile = new PrintStream(new FileOutputStream("/home/huy/formula.txt"));
		String paraPolytope = Term2IsccTransformer.transformParaPolytope2Iscc(pp);
		//System.out.println("parametric polytope: " + paraPolytope);
		outFile.print("card " + paraPolytope );
		outFile.close();
		
		List<String> command = new ArrayList<String>();
	    command.add("iscc");
	    
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.redirectInput(ProcessBuilder.Redirect.from(new File("/home/huy/formula.txt")));		    
	    final Process process = builder.start();
	    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
	    String line = br.readLine();
	    //return line;
    	Iscc2TermTransformer transformer = new Iscc2TermTransformer(line, badMethod.getMethod().getServices());
    	try{
	    	transformer.translateIsccResult2MapTerm();			   
			return TermParser.getIntegerValue(transformer.getListCountingResult().get(0).getValue());
    	}catch(NullPointerException e){
    		Z3Solver z3 = new Z3Solver(constraint,badMethod.getMethod().getServices());
	    	return z3.findAllSatisfiableModels().size();
    	}
	}
	
		
	public void printInitialInformation() throws IOException{
		Term precondition = badMethod.getPrecondition();		
		System.out.println("Initial knowledge of high variables: " +precondition);
		System.out.println("Number of possible values of high variables: " + findNumberOfPossibleHighValue(precondition));
	}

	/*
	 * check if a low independent path has been matched
	 * */
	public boolean matchLowIndependentPath(){
		return badMethod.matchLowIndependentPath();
	}
	
}
