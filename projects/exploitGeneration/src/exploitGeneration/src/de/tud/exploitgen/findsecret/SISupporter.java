package de.tud.exploitgen.findsecret;
/**
 * this class supplies methods supporting for secret inferring
 * basically, it works as a machine producing next low input value that help maximizing information leakage from experiment
 * */

import java.io.BufferedReader;
import java.io.File;

import java.io.FileOutputStream;

import java.io.IOException;

import java.io.InputStreamReader;
import java.io.PrintStream;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.math.BigInteger;
import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;


import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4LowIndependent;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskConst;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskH;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskL;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskLH;

import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;

public class SISupporter {
	//contains necessary information for secret inferring (extract from symbolic execution tree via leak detection)
	private final BadMethod badMethod; 
	
	private List<Experiment> usedExperiments;	
	private Term currentKnowledge; //current knowledge about high varibles
	
	private List<Term> listLowVarTerms; //used to create formulas
	private List<QuantifiableVariable> listQuantifiedHighVar; //used to create formula	
	private LowInputGenStrategy lowInputGenStrategy; //use to create low input, can be changed during the secret infering process
	private int metric;
	private boolean randomLowInput;  
	private String optSolver;
	public SISupporter(BadMethod badMethod, int metric, boolean randomLowInput,String optSolver) {
		super();
		this.badMethod = badMethod;
		this.metric = metric;
		this.randomLowInput = randomLowInput;
		this.optSolver = optSolver;
		usedExperiments = new ArrayList<Experiment>();		
		//currentKnowledge = badMethod.getMethod().getServices().getTermBuilder().tt(); //initial knowledge = nothing		
		currentKnowledge = badMethod.getPrecondition();
		extractListLowVarTerms();		
		extractListQuantifiedHighVars();	
		lowInputGenStrategy = determineLowInputGenStrategy();
	}	
	
	
	
	public LowInputGenStrategy getLowInputGenStrategy() {
		return lowInputGenStrategy;
	}

	public void setLowInputGenStrategy(LowInputGenStrategy lowInputGen) {
		this.lowInputGenStrategy = lowInputGen;
	}



	private void extractListLowVarTerms(){
		listLowVarTerms = new LinkedList<Term>();
		Model model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		for(ModelVariable mv: model.getVariables()){
			if (vc.isLow(mv.getIdentifier())){
				Term lowVar= tb.var(new LocationVariable(new ProgramElementName(mv.getIdentifier()),mv.getType()));
				listLowVarTerms.add(lowVar);
			}
		}
	}
	
	private void extractListQuantifiedHighVars(){
		listQuantifiedHighVar = new LinkedList<QuantifiableVariable>();
		Model model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
		//TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		for(ModelVariable mv: model.getVariables()){
			if (vc.isHigh(mv.getIdentifier())){
				QuantifiableVariable qv = new LogicVariable(new Name(mv.getIdentifier()),mv.getSort());				
				listQuantifiedHighVar.add(qv);
			}
		}
	}

	public Term getCurrentKnowledge() {
		return currentKnowledge;
	}


	/*
	 * update current knowledge of high variable with new information about high variable
	 * TODO: some simplification should be applied?
	 * first simplication:
	 * if infoH->currentKnowledge, then currentKnowledge := infoH
	 * idx: number of experiment
	 * */
	public void updateKnowledge(Experiment experiment, int idx){		
		//update list of used experiment
		add2UsedExperiments(experiment);
		
		//update knowledge
		Term newInfoH = badMethod.createSecretInfoFromExperiment(currentKnowledge,experiment, idx);
		TermBuilder termBuilder = badMethod.getMethod().getServices().getTermBuilder();
		/*
		 * check if inforH -> currentKnowledge?	(1)	 
		 * to do that, check satisfiabiblity of negation formula:
		 * inforH && !currentKnowledge (2)
		 * if (2) is unsatisfiable, then (1) holds, then currentKnowledge := inforH
		 * otherwise (1) does not hold   then currentKnowledge := currentKnowledge && inforH
		 */
		 Term checkTerm = termBuilder.and(newInfoH, termBuilder.not(currentKnowledge));
		 Z3Solver z3 = new Z3Solver(checkTerm, badMethod.getMethod().getServices());
		 if(z3.checkSatisfiable())
			 currentKnowledge = termBuilder.and(currentKnowledge, newInfoH);
		 else
			 currentKnowledge = newInfoH;
		
		 //currentKnowledge = termBuilder.and(currentKnowledge, newInfoH); //simply adding, do not check
		 System.out.println("attacker knowledge afer updating: " + currentKnowledge);
		 badMethod.updateUnreachablePath(currentKnowledge);
	}
	
	
	private void add2UsedExperiments(Experiment exp){
		usedExperiments.add(exp);
	}
	
	public Map<String, Long> findBestLowInput() throws IOException{
		if(randomLowInput)
			return lowInputGenStrategy.findRandomLowInput();
		else
			return lowInputGenStrategy.findBestLowInput();		
	}
			
	/*
	 * TODO: this is only temporary solution
	 * because variable's name is in the form of self_varName
	 * we transform it to the original form so that it can be used to write for the input file
	 * */	
	public Map<String, Long> replaceByOriginalNameOfVars(Map<String, Long> mapValues){
		Map<String, Long> result = new HashMap<String, Long>();
		Model model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		for(String varName: mapValues.keySet()){
			try{
				String originalName = model.getVariable(varName).getVariableName();
				result.put(originalName, mapValues.get(varName));
			}catch(Exception e){//exception occurs when we access artificial var that does not exist in model
				
			}		
		}
		return result;
	}
	
	public Map<String, Long> replaceByIndentifierOfVarInModel(Map<String, Long> mapValues){
		Map<String, Long> result = new HashMap<String, Long>();
		Model model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		for(String varName: mapValues.keySet()){
			try{
				String identifier = model.searchVariableByName(varName).getIdentifier();
				result.put(identifier, mapValues.get(varName));
			}catch(Exception e){//exception occurs when we access artificial var that does not exist in model
				
			}		
		}
		return result;
	}
	
	/*
	 * get the number of possible high value using barvinok tool 
	 * */
	public BigInteger findNumberOfPossibleHighValue(Term constraint) throws IOException{
		RiskyPath rn = badMethod.getListRiskyPaths().get(0);
		ParametricPolytope pp = new ParametricPolytope(constraint, new LinkedList<String>(), rn.getVc().getListHighVars());
		PrintStream outFile = new PrintStream(new FileOutputStream("/home/huy/formula.txt"));
		String paraPolytope = new Term2IsccTransformer(badMethod.getMethod().getServices()).transformParaPolytope2Iscc(pp);
		//System.out.println("parametric polytope: " + paraPolytope);
		outFile.print("card " + paraPolytope );
		outFile.close();
		
		List<String> command = new ArrayList<String>();
	    command.add("iscc");
	    
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.redirectInput(ProcessBuilder.Redirect.from(new File("/home/huy/formula.txt")));		    
	    final Process process = builder.start();
	    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
	    String line = br.readLine();
	    //return line;
    	Iscc2TermTransformer transformer = new Iscc2TermTransformer(line, badMethod.getMethod().getServices());
    	try{
	    	transformer.translateIsccResult2MapTerm();			   
			return TermParser.getBigIntegerValue(transformer.getListCountingResult().get(0).getValue());
    	}catch(NullPointerException e){
    		Z3Solver z3 = new Z3Solver(constraint,badMethod.getMethod().getServices());
	    	return BigInteger.valueOf(z3.findAllSatisfiableModels().size());
    	}
	}
	
		
	public void printInitialInformation() throws IOException{
		Term precondition = badMethod.getPrecondition();		
		System.out.println("Initial knowledge of high variables: " +precondition);
		System.out.println("Number of possible values of high variables: " + findNumberOfPossibleHighValue(precondition));
	}

	/*
	 * check if a low independent path has been matched
	 * */
	public boolean matchLowIndependentPath(){
		return badMethod.matchLowIndependentPath();
	}

	public BadMethod getBadMethod() {
		return badMethod;
	}


	public List<Experiment> getUsedExperiments() {
		return usedExperiments;
	}

	public List<Term> getListLowVarTerms() {
		return listLowVarTerms;
	}

	public List<QuantifiableVariable> getListQuantifiedHighVar() {
		return listQuantifiedHighVar;
	}  
	
	private LowInputGenStrategy determineLowInputGenStrategy(){		
		if(badMethod.allPathsAreLowIndependent())
			return new LowInputGenStrategy4LowIndependent(this);
		else if(badMethod.allOutputsAreConst())
			return new LowInputGenStrategy4RiskConst(this);
		else if(badMethod.hasRisk_LHPath())
			return new LowInputGenStrategy4RiskLH(this);
		else if(badMethod.hasRisk_HPath())
			return new LowInputGenStrategy4RiskH(this);
		else
			return new LowInputGenStrategy4RiskL(this);
	}
	
	public void reDetermineLowInputGenStrategy(){
		lowInputGenStrategy = determineLowInputGenStrategy();
	}

	public int getMetric() {
		return metric;
	}

	public void setMetric(int metric) {
		this.metric = metric;
	}



	public boolean isRandomLowInput() {
		return randomLowInput;
	}



	public void setRandomLowInput(boolean randomLowInput) {
		this.randomLowInput = randomLowInput;
	}



	public String getOptSolver() {
		return optSolver;
	}



	public void setOptSolver(String optSolver) {
		this.optSolver = optSolver;
	}
	
	
}
