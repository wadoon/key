package de.tud.exploitgen.findsecret;
/**
 * this class supplies methods supporting for secret inferring
 * basically, it works as a machine producing next low input value that help maximizing information leakage from experiment
 * */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.math.BigInteger;

import org.key_project.util.collection.ImmutableArray;

import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.distribution.Partition;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4LowIndependent;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskConst;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskH;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskL;
import de.tud.exploitgen.findsecret.strategy.LowInputGenStrategy4RiskLH;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGTermException;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermSimplifier;
import de.tud.exploitgen.util.TermTransformer;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.proof.io.ProofSaver;

public class SISupporter {
	//contains necessary information for secret inferring (extract from symbolic execution tree via leak detection)
	private final BadMethod badMethod; 
	
	private List<Experiment> usedExperiments;	
	private Term currentKnowledge; //current knowledge about high varibles
	
	private List<Term> listLowVarTerms; //used to create formulas
	private List<QuantifiableVariable> listQuantifiedHighVar; //used to create formula	
	private LowInputGenStrategy lowInputGenStrategy; //use to create low input, can be changed during the secret infering process
	private int metric;
	private boolean randomLowInput;  
	private String optSolver;
	private SecretDistribution sDistribution;
	public SISupporter(BadMethod badMethod, int metric, boolean randomLowInput,String optSolver, SecretDistribution sDistribution) {
		super();
		this.badMethod = badMethod;
		this.metric = metric;
		this.randomLowInput = randomLowInput;
		this.optSolver = optSolver;
		this.sDistribution = sDistribution;
		usedExperiments = new ArrayList<Experiment>();		
		//currentKnowledge = badMethod.getMethod().getServices().getTermBuilder().tt(); //initial knowledge = nothing		
		currentKnowledge = badMethod.getPrecondition();
		extractListLowVarTerms();		
		extractListQuantifiedHighVars();	
		lowInputGenStrategy = determineLowInputGenStrategy();
	}	
	
	
	
	public LowInputGenStrategy getLowInputGenStrategy() {
		return lowInputGenStrategy;
	}

	public void setLowInputGenStrategy(LowInputGenStrategy lowInputGen) {
		this.lowInputGenStrategy = lowInputGen;
	}



	private void extractListLowVarTerms(){
		listLowVarTerms = new LinkedList<Term>();
		KTGModel model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		for(ModelVariable mv: model.getVariables()){
			if (vc.isLow(mv.getIdentifier())){
				Term lowVar= tb.var(new LocationVariable(new ProgramElementName(mv.getIdentifier()),mv.getType()));
				listLowVarTerms.add(lowVar);
			}
		}
	}
	
	private void extractListQuantifiedHighVars(){
		listQuantifiedHighVar = new LinkedList<QuantifiableVariable>();
		KTGModel model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
		//TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		for(ModelVariable mv: model.getVariables()){
			if (vc.isHigh(mv.getIdentifier())){
				QuantifiableVariable qv = new LogicVariable(new Name(mv.getIdentifier()),mv.getSort());				
				listQuantifiedHighVar.add(qv);
			}
		}
	}

	public Term getCurrentKnowledge() {
		return currentKnowledge;
	}


	/*
	 * update current knowledge of high variable with new information about high variable
	 * TODO: some simplification should be applied?
	 * first simplication:
	 * if infoH->currentKnowledge, then currentKnowledge := infoH
	 * idx: number of experiment
	 * */
	public void updateKnowledge(Experiment experiment, int idx) throws KEGTermException{		
		//update list of used experiment
		add2UsedExperiments(experiment);
		
		//update knowledge
		Term newInfoH = badMethod.createSecretInfoFromExperiment(currentKnowledge,experiment, idx);
		TermBuilder termBuilder = badMethod.getMethod().getServices().getTermBuilder();
		/*
		 * check if inforH -> currentKnowledge?	(1)	 
		 * to do that, check satisfiabiblity of negation formula:
		 * inforH && !currentKnowledge (2)
		 * if (2) is unsatisfiable, then (1) holds, then currentKnowledge := inforH
		 * otherwise (1) does not hold   then currentKnowledge := currentKnowledge && inforH
		 */
		 Term checkTerm = termBuilder.and(newInfoH, termBuilder.not(currentKnowledge));
		 checkTerm= new TermTransformer(badMethod.getMethod().getServices()).transformBWXORTerm(checkTerm, 4);
		 Z3Solver z3 = new Z3Solver(checkTerm, badMethod.getMethod().getServices());
		 if(z3.checkSatisfiable())
			 currentKnowledge = termBuilder.and(currentKnowledge, newInfoH);
		 else
			 currentKnowledge = newInfoH;
		
		 //currentKnowledge = termBuilder.and(currentKnowledge, newInfoH); //simply adding, do not check
		 currentKnowledge = TermSimplifier.simplifyConstant(currentKnowledge, badMethod.getMethod().getServices());
		 System.out.println("attacker knowledge afer updating: \n" + ProofSaver.printTerm(currentKnowledge,badMethod.getMethod().getServices()));

		 badMethod.updateUnreachablePath(currentKnowledge);
	}
	
	
	private void add2UsedExperiments(Experiment exp){
		usedExperiments.add(exp);
	}
	
	public Map<String, Long> findBestLowInput() throws IOException, KEGTermException{
		if(randomLowInput)
			return lowInputGenStrategy.findRandomLowInput();
		else
			return lowInputGenStrategy.findBestLowInput();		
	}
			
	/*
	 * TODO: this is only temporary solution
	 * because variable's name is in the form of self_varName
	 * we transform it to the original form so that it can be used to write for the input file
	 * */	
	public Map<String, Long> replaceByOriginalNameOfVars(Map<String, Long> mapValues){
		Map<String, Long> result = new HashMap<String, Long>();
		KTGModel model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		for(String varName: mapValues.keySet()){
			try{
				String originalName = model.getVariable(varName).getVariableName();
				result.put(originalName, mapValues.get(varName));
			}catch(Exception e){//exception occurs when we access artificial var that does not exist in model
				
			}		
		}
		return result;
	}
	
	public Map<String, Long> replaceByIndentifierOfVarInModel(Map<String, Long> mapValues){
		Map<String, Long> result = new HashMap<String, Long>();
		KTGModel model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
		for(String varName: mapValues.keySet()){
			try{
				String identifier = model.searchVariableByName(varName).getIdentifier();
				result.put(identifier, mapValues.get(varName));
			}catch(Exception e){//exception occurs when we access artificial var that does not exist in model
				
			}		
		}
		return result;
	}
	
	public Term getQuantifiedCurrentKnowledge(){
		return quantifyAllNonHighVars(currentKnowledge);
	}
	private Term quantifyAllNonHighVars(Term constraint){
		ImmutableArray<QuantifiableVariable> listQVOfConstraint = constraint.boundVars();
		List<QuantifiableVariable> listQVarMustUse = new LinkedList<QuantifiableVariable>();
		for(Term lowVar: listLowVarTerms){
			if(TermUtil.isDescendant(lowVar, constraint)){
				if(!TermUtil.inListQV(lowVar.toString(), listQVOfConstraint))
					listQVarMustUse.add(new LogicVariable(new Name(lowVar.toString()),lowVar.sort()));
			}
		}
		if(listQVarMustUse.size()>0){
			return badMethod.getMethod().getServices().getTermBuilder().ex(listQVarMustUse, constraint);
		}else
			return constraint;
	}
	
	
	/*
	 * get the number of possible high value using barvinok tool 
	 * */
	public BigInteger findNumberOfPossibleHighValue(Term constraint) throws IOException, KEGTermException{
		/*
		 * preprocessing the constraint, if it contain not only possible high values, then we must quantified all of them
		 * */
		constraint = new TermTransformer(badMethod.getMethod().getServices()).transformBWXORTerm(constraint, 4);
		constraint = quantifyAllNonHighVars(constraint);
		
		//-----------------------------------
		
		RiskyPath rn = badMethod.getListRiskyPaths().get(0);
		//System.out.println("constraint before simplifying: " + constraint);
		constraint = TermSimplifier.simplifyConstant(constraint, badMethod.getMethod().getServices());
		//System.out.println("constraint after simplifying: " + constraint);
		ParametricPolytope pp = new ParametricPolytope(constraint, new LinkedList<String>(), rn.getVc().getListHighVars());
		//File isccInputFile = 
		PrintStream outFile = new PrintStream(new FileOutputStream("formula.txt"));
		String paraPolytope = new Term2IsccTransformer(badMethod.getMethod().getServices()).transformParaPolytope2Iscc(pp);
		System.out.println("parametric polytope: " + paraPolytope);
		outFile.print("card " + paraPolytope );
		outFile.close();
		
		List<String> command = new ArrayList<String>();
	    command.add("iscc");
	    
	    ProcessBuilder builder = new ProcessBuilder(command);
	    //ProcessBuilder builder = new ProcessBuilder("iscc");
	    //builder.directory(new File("/usr/local/bin"));
	    builder.redirectInput(ProcessBuilder.Redirect.from(new File("formula.txt")));		    
	    final Process process = builder.start();
	    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
	    String line = br.readLine();
	    if(line!=null)
	    	System.out.println("iscc returned: " + line);
	    else
	    	System.out.println("there is a problem regarding to iscc");
	    //return line;
    	Iscc2TermTransformer transformer = new Iscc2TermTransformer(line, badMethod.getMethod().getServices());
    	try{
	    	transformer.translateIsccResult2MapTerm();			   
			return TermParser.getBigIntegerValue(transformer.getListCountingResult().get(0).getValue(), badMethod.getMethod().getServices());
    	}catch(Exception e){
    		System.out.println(e.toString());
    		System.out.println("here!!!!!!!");

    		Z3Solver z3 = new Z3Solver(constraint,badMethod.getMethod().getServices());
	    	return BigInteger.valueOf(z3.findAllSatisfiableModels().size());
    	}
	}
	
		
	public void printInitialInformation() throws IOException, KEGTermException{
		Term precondition = badMethod.getPrecondition();		
		System.out.println("Initial knowledge of high variables: " +precondition);
		System.out.println("Number of possible values of high variables: " + findNumberOfPossibleHighValue(precondition));
	}

	/*
	 * check if a low independent path has been matched
	 * */
	public boolean matchLowIndependentPath(){
		return badMethod.matchLowIndependentPath();
	}

	public BadMethod getBadMethod() {
		return badMethod;
	}


	public List<Experiment> getUsedExperiments() {
		return usedExperiments;
	}

	public List<Term> getListLowVarTerms() {
		return listLowVarTerms;
	}

	public List<QuantifiableVariable> getListQuantifiedHighVar() {
		return listQuantifiedHighVar;
	}  
	
	private LowInputGenStrategy determineLowInputGenStrategy(){		
		if(badMethod.allPathsAreLowIndependent())
			return new LowInputGenStrategy4LowIndependent(this);
		else if(badMethod.allOutputsAreConst())
			return new LowInputGenStrategy4RiskConst(this);
		else if(badMethod.hasRisk_LHPath())
			return new LowInputGenStrategy4RiskLH(this);
		else if(badMethod.hasRisk_HPath())
			return new LowInputGenStrategy4RiskH(this);
		else
			return new LowInputGenStrategy4RiskL(this);
	}
	
	public void reDetermineLowInputGenStrategy(){
		lowInputGenStrategy = determineLowInputGenStrategy();
	}

	public int getMetric() {
		return metric;
	}

	public void setMetric(int metric) {
		this.metric = metric;
	}



	public boolean isRandomLowInput() {
		return randomLowInput;
	}



	public void setRandomLowInput(boolean randomLowInput) {
		this.randomLowInput = randomLowInput;
	}



	public String getOptSolver() {
		return optSolver;
	}



	public void setOptSolver(String optSolver) {
		this.optSolver = optSolver;
	}
	
	
	/*
	 * get the sum of all frequency of all possible high values
	 * */
	public BigInteger findSumOfFrequencyOverAllPossibleHighValues() throws IOException, KEGTermException{
		if(sDistribution.isUniform())// all values have the same frequency 1
			return findNumberOfPossibleHighValue(currentKnowledge);
		else{
			BigInteger result = BigInteger.ZERO;
			
			List<Long> listCardOfPartitions = findListCardinalityOfPartitions();
			for(int i = 0;i< sDistribution.getPartitions().size();i++){				
				result = result.add(BigInteger.valueOf(listCardOfPartitions.get(i)).multiply(BigInteger.valueOf(sDistribution.getPartitions().get(i).getFrequency())));
			}
			return result;
		}
	}

	public List<Long> findListCardinalityOfPartitions() throws IOException, KEGTermException{
		List<Long> result = new LinkedList<Long>();
		TermBuilder tb = badMethod.getMethod().getServices().getTermBuilder();
		for(Partition partition: sDistribution.getPartitions()){
			Term partitionTerm = tb.and(currentKnowledge, partition.getFormula());
			result.add(findNumberOfPossibleHighValue(partitionTerm).longValue());
		}
		return result;
	}


	public SecretDistribution getsDistribution() {
		return sDistribution;
	}



	public void setsDistribution(SecretDistribution sDistribution) {
		this.sDistribution = sDistribution;
	}
	
	
	
}
