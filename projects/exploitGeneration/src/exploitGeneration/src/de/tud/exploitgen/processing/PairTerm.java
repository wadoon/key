/**
 * 
 */
package de.tud.exploitgen.processing;

import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;

/**
 * This class contains a pair of term that could be used to build formula from two different branches
 * in oder to check non-interference property of the method.
 * @author Huy Do
 *
 */
public class PairTerm {   
   private Term t1, t2;
   private final TermBuilder termBuilder;
  
   
   /**
    * @return the name
    */
   
   /**
    * @return the t1
    */
   public Term getT1() {
      return t1;
   }
   /**
    * @param t1 the t1 to set
    */
   public void setT1(Term t1) {
      this.t1 = t1;
   }
   /**
    * @return the t2
    */
   public Term getT2() {
      return t2;
   }
   /**
    * @param t2 the t2 to set
    */
   public void setT2(Term t2) {
      this.t2 = t2;
   }
   /**
    * @param name
    * @param t1
    * @param t2
    */
   public PairTerm(Term t1, Term t2,Services services) {
      super();   
      this.t1 = t1;
      this.t2 = t2;      
      termBuilder = new TermBuilder(new TermFactory(), services);
   }
   
   /**
    * @return term t1=t2
    * implement extension for objec-sensitive comparison
    * */
   public Term equalTerm(){
      if(TermParser.isPrimitiveType(t1)&& TermParser.isPrimitiveType(t2))
         return termBuilder.equals(t1, t2);
      else if(TermParser.isQuantifier(t1)||(TermParser.isQuantifier(t2))){ //serving conditional delimited release
         return termBuilder.equals(t1, t2);
      }
      else if(TermParser.isNullSort(t1)){ //if t1==null
         if(TermParser.isNullSort(t2))
            return termBuilder.tt();
         else
            return termBuilder.ff();
      }else{ //if t1!=null
         if(TermParser.isNullSort(t2))
            return termBuilder.ff();
         else{ //if t1!=null && t2!=null           
            if(t1.sort().toString().equals(t2.sort().toString()))
               return termBuilder.tt();
            else
               return termBuilder.ff();
         }                  
      }         
     
   }
   
   /**
    * @return term t1 != t2
    * */
   public Term notEqualTerm(){
      return termBuilder.not(equalTerm());
   }
   
   public String toString(){
      return("(" + t1.toString() + ":"+t1.sort().toString() + " ; " + t2.toString()+":"+t2.sort().toString()+")");
   }
}
