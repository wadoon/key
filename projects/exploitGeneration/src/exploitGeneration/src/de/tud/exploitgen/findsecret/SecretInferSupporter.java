package de.tud.exploitgen.findsecret;
/**
 * this class supplies methods supporting for secret inferring
 * basically, it works as a machine producing next low input value that help maximizing information leakage from experiment
 * */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.detectleak.PairTerm;
import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.findsecret.libinterface.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.libinterface.IsccResult;
import de.tud.exploitgen.findsecret.libinterface.ParametricPolytope;
import de.tud.exploitgen.findsecret.libinterface.Term2IsccTransformer;
import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.proof.init.ProofInputException;

public class SecretInferSupporter {
	private final BadMethod badMethod;
	private List<Experiment> usedExperiments;	
	private Term currentKnowledge; //current knowledge about high varibles
	
	//auxilary tools
	private final TermBuilder termBuilder;
	public static final TermFactory tf = new TermFactory();
	
	public SecretInferSupporter(BadMethod badMethod) {
		super();
		this.badMethod = badMethod;
		usedExperiments = new ArrayList<Experiment>();
		termBuilder = new TermBuilder(tf, badMethod.getMethod().getServices());
		currentKnowledge = termBuilder.tt(); //initial knowledge = nothing
		try {
			badMethod.resolveRiskyPaths();
		} catch (ProofInputException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} //the infoIngredient is ready to be used
	}
	
	public Map<String, Integer> findBestNextLowInput(){
		Map<String, Integer> result = new HashMap<String, Integer>();
		return result;
	}
	
	/*
	 * update current knowledge of high variable with new information about high variable
	 * TODO: some simplification should be applied?
	 * */
	public void updateKnowledge(Term newInfoH){
		currentKnowledge = termBuilder.and(currentKnowledge, newInfoH);
	}
	
	private PairTermCollection getLowInputPTCfromExperiment(Experiment experiment){
		Services services = badMethod.getMethod().getServices();
		PairTermCollection result = new PairTermCollection(services);
		Map<String, Integer> lowInputs = experiment.getLowInputs();
		for(String varName: lowInputs.keySet()){
			Term lowInValueTerm = termBuilder.zTerm(lowInputs.get(varName).intValue());
			PairTerm pt = new PairTerm(lowInValueTerm, lowInValueTerm, services);
			result.add(varName, pt);
		}
		return result;
	}

	/*
	 * create new information of high variables from experiment
	 * */
	public Term createSecretInfoFromExperiment(Experiment experiment){
		Term infoH = termBuilder.ff();
		PairTermCollection ptcLowInputValues = getLowInputPTCfromExperiment(experiment);
		Map<String, Integer> observedOutputs = experiment.getObservableOutputs();
		List<RiskyPath> riskyPaths = badMethod.getRiskyPaths();		
		for(RiskyPath rp: riskyPaths){			
			List<RiskyPathAbstraction> rpAbstracts = rp.getPathAbstractions();
			Term pathTerm = termBuilder.ff();
			for(RiskyPathAbstraction rpAbs: rpAbstracts){
				Term pathAbstractTerm = termBuilder.tt();				
				Term constraint = rpAbs.getConstraint();
				Map<String, Term> mapValue = rpAbs.getObservableSymbolicValues();
				List<String> constOutVars = rpAbs.getConstantOutputVars();
				List<String> notConstOutVars = rpAbs.getNotConstantOutputVars();
				Term compareOutputTerm = termBuilder.tt();
				if(constOutVars.size()>0){
					//first, check if all observed outputs are match to corresponding constant output
					boolean match = true;
					for(String constVarName: constOutVars){
						Term symbolicValue = mapValue.get(constVarName);
						if(TermParser.getIntegerValue(symbolicValue)!= observedOutputs.get(constVarName).intValue()){
							//not match, get rid of this path
							match = false;
							break;
						}
					}	
					//only consider this path if all constant output values are matched to corresponding observed values
					if(match){
						//add to compareOutputTerm the comparison made from notConstOutVars 
						for(String notConstVarName: notConstOutVars){
							Term symbolicValue = mapValue.get(notConstVarName);
							Term comparison = termBuilder.equals(termBuilder.zTerm(observedOutputs.get(notConstVarName).intValue()), mapValue.get(notConstVarName));
							compareOutputTerm = termBuilder.and(compareOutputTerm, comparison);
						}
						pathAbstractTerm = termBuilder.and(constraint, compareOutputTerm);
					}else{
						pathAbstractTerm = termBuilder.ff(); //equals false, means that this path abstraction cannot be taken
					}					
				}else{
					//if there is no constant output value, then we simply compose pathAbstractTerm
					for(String notConstVarName: notConstOutVars){
						Term symbolicValue = mapValue.get(notConstVarName);
						Term comparison = termBuilder.equals(termBuilder.zTerm(observedOutputs.get(notConstVarName).intValue()), mapValue.get(notConstVarName));
						compareOutputTerm = termBuilder.and(compareOutputTerm, comparison);
					}
					pathAbstractTerm = termBuilder.and(constraint, compareOutputTerm);
				}
				//include pathAbstractTerm to pathTerm (pathAbstractTerm is a disjunct of pathTerm)
				pathTerm = termBuilder.or(pathTerm, pathAbstractTerm);				
			}
			//pathTerm is a disjunct of infoH
			infoH = termBuilder.or(infoH, pathTerm);			
		}
		//now, we replace low variables in infoH by corresponding low input values
		infoH = ptcLowInputValues.replacePVByNameAndBranch(infoH, 1);
		return infoH;
	}	
	
	/*
	 * create experiment input from current knowledge and semantic program reprenseted by badMethod
	 * */
	public Map<String, Integer> createExperimentInput(){
		Map<String, Integer> result = new HashMap<String, Integer>();
		//TODO: a lot of implementation needed
		return result;
	}
	
	public void handleConstProgram(){
		List<ParametricPolytope> listPP = new LinkedList<ParametricPolytope>();
		for(RiskyPath rp: badMethod.getRiskyPaths()){
			for(RiskyPathAbstraction rpa: rp.getPathAbstractions()){
				/*
				 * parameters: list of low variables.
				 * vars: list of high variables
				 * */			
				listPP.add(new ParametricPolytope(rpa.getConstraint(), rp.getVc().getListLowVars(), rp.getVc().getListHighVars()));	
			}			
		}
		List<IsccResult> listCountingResult = new LinkedList<IsccResult>();
		/*just test Term2IsccTransformer*/		
		for(ParametricPolytope pp: listPP){
			System.out.println("constraint: "+ pp.getConstraint());
			try {
				PrintStream outFile = new PrintStream(new FileOutputStream("/home/huy/formula.txt"));
				String paraPolytope = Term2IsccTransformer.transformTerm2Iscc(pp);
				//System.out.println("parametric polytope: " + paraPolytope);
				outFile.print("card " + paraPolytope );
				outFile.close();
				
				List<String> command = new ArrayList<String>();
			    command.add("iscc");
			    
			    ProcessBuilder builder = new ProcessBuilder(command);
			    Map<String, String> environ = builder.environment();
			    builder.redirectInput(ProcessBuilder.Redirect.from(new File("/home/huy/formula.txt")));		    
			    final Process process = builder.start();
			    InputStream is = process.getInputStream();
			    InputStreamReader isr = new InputStreamReader(is);
			    BufferedReader br = new BufferedReader(isr);
			    String line = br.readLine();
			    System.out.println("iscc result returned: " + line);
		    	Iscc2TermTransformer transformer = new Iscc2TermTransformer(line, badMethod.getMethod().getServices());
		    	transformer.translateIsccResult2MapTerm();
			    /*while ((line = br.readLine()) != null) {
			    	System.out.println("iscc result returned: " + line);
			    	Iscc2TermTransformer transformer = new Iscc2TermTransformer(line, badMethod.getMethod().getServices());
			    	transformer.translateIsccResult2MapTerm();			    	
			    }*/
				listCountingResult.add(new IsccResult(transformer.getMapResult()));				
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		//print to check
		for(IsccResult isccResult: listCountingResult){
			System.out.println("----------------------------");
			isccResult.printMapResult();
		}
		
		
		//finding the best low input
		
	}
	
	
	/**
	 * return map of low input values maximizing the leakage
	 * */
	public Map<String, Integer> findBestLowInput(List<IsccResult> listResult, List<String> listLowVar){
		Map<String, Integer> resultLowInput = new HashMap<String, Integer>();
		
		
		
		
		return resultLowInput;
	}
	
	
	/*
	 * compute the value of formula using mapValuesS
	 * */
	public double compute(Term arithFormula, Map<String, Integer> mapValues){
		if(TermParser.isInteger(arithFormula)||TermParser.isIntegerNegation(arithFormula)){
			return Double.parseDouble(TermParser.resolveNumber(arithFormula));
		}
		else if(TermParser.isProgramVariable(arithFormula)){
			return (double)mapValues.get(arithFormula.toString());
		}
		else if(TermParser.isAddition(arithFormula)){
			return compute(arithFormula.sub(0), mapValues) + compute(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isSubtraction(arithFormula)){
			return compute(arithFormula.sub(0), mapValues) - compute(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isMultiplication(arithFormula)){
			return compute(arithFormula.sub(0), mapValues) * compute(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isDivision(arithFormula)){
			return compute(arithFormula.sub(0), mapValues) / compute(arithFormula.sub(1),mapValues);
		}	
		else if(TermParser.isPowerFunction(arithFormula)){
			return Math.pow(compute(arithFormula.sub(0), mapValues), compute(arithFormula.sub(1),mapValues));
		}
		//TODO: what should be the default value?
		return 0;
	}
	
}
