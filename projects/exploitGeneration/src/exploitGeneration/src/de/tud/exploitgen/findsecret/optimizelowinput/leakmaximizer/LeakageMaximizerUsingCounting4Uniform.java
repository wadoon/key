package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.math.BigInteger;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;

public abstract class LeakageMaximizerUsingCounting4Uniform extends LeakageMaximizerUsingCounting {
	protected final BigInteger numberOfHighValues; //number of possible high values calculated via currentKnowlegde

	public LeakageMaximizerUsingCounting4Uniform(List<PPCountingResult> listCountingResults, Services services, List<String> listLowVars, String optSolver, BigInteger numberOfHighValues) {
		super(listCountingResults,services,listLowVars,optSolver);		
		this.numberOfHighValues = numberOfHighValues;
		extract2ListMatchableCountingSolution();
	}	
	
	
	
	protected void extract2ListMatchableCountingSolution(){
		//System.out.println("start extracting to list of matchable counting solution!");
		CountingResultTree countTree = new CountingResultTree();
		for(PPCountingResult countResult: listCountingResults){			
			for(CountingResultTree leaf: countTree.getAllLeaves()){
				List<CountingResultTree> leaves = new LinkedList<CountingResultTree>();				
				for(CountingSolution condResult: countResult.getListResults()){
					if(!TermParser.isBooleanFalse(condResult.getCondition()))
						leaves.add(new CountingResultTree(condResult));
				}		
				leaf.addChildren(leaves, services);
			}
		}
		List<CountingResultTree> listAllCountingResults = countTree.getAllLeaves();
		System.out.println("all leaves have been added! number of leaves: " + listAllCountingResults.size());
		//remove all leaf that don't have enough childs (=listCountingResults.size)
		listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
		for(CountingResultTree tre: listAllCountingResults){
			List<CountingSolution> listCountTerms = tre.getListCountingSolutions();
			if(listCountTerms.size() == listCountingResults.size()){
				//create new condition: sum of all possible counting values must equal to numberOfHighValues
				TermBuilder tb = services.getTermBuilder();
				Term sum = tb.zero();
				for(CountingSolution cs: listCountTerms){
					sum = tb.add(sum, cs.getValue());
				}
				Term possCondition = tb.equals(sum, tb.zTerm(String.valueOf(numberOfHighValues)));
				Z3Solver z31 = new Z3Solver(possCondition, services);
				Term condition = tre.getConditionTerm();
				if(!z31.checkValid()){ //if possCondition is not valid then add it
					condition = tb.and(possCondition, condition);
				}
				Z3Solver z3 = new Z3Solver(condition, services);
				/*Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
				if(uniqueModel!=null)
					listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));*/
				Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
				if(uniqueModel!=null){
					if(uniqueModel.second==1) //there is only one model
					{
						System.out.println("unique model!!"+uniqueModel.first);
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,true));
					}
					else
						listMatchableSolutions.add(new MatchableCountingSolution(listCountTerms, condition,uniqueModel.first,false));
				}
			}		
		}		
		System.out.println("finish extracting! We found " + listMatchableSolutions.size() + " matchable solutions");
		if(listMatchableSolutions.size()==0){
			for(PPCountingResult countResult: listCountingResults){
				countResult.setListResults(countResult.replaceOrCondition());
				countResult.addZeroResult(services.getTermBuilder());			
			}
			
		}
	}
	
	protected OptimalSolution findOptimalSolution4SingleCase(MatchableCountingSolution matchCountSolution, int metric) {		
		OptimizationSolver solver;
		if(optSolver.equals(KEGConstant.OPTSOLVER_ALL)){
			/*
			 * we try all solvers to find the best result
			 * pay attention: is might be very expensive
			 * at the moment we do not take into account couenne because it is usually very slow
			 * */
			List<OptimalSolution> listSolutions = new LinkedList<OptimalSolution>();
			solver = new OptLocalSolver(matchCountSolution, services, metric);
			OptimalSolution solution = solver.findOptimalSolution();
			if(solution!=null){
				System.out.println("solution found by local solver: "+ solution.getSolution() + "; optimal value: " +solution.getOptimizeValue());
				listSolutions.add(solution);
			}
			solver = new AMPLSolver(matchCountSolution, services, metric, KEGConstant.OPTSOLVER_BONMIN);
			OptimalSolution solution1 = solver.findOptimalSolution();
			if(solution1!=null){
				System.out.println("solution found by bonmin: "+ solution.getSolution() + "; optimal value: " + solution.getOptimizeValue());
				listSolutions.add(solution1);
			}
			
			//recalculate optimal value using solution found by the solver
			for(OptimalSolution ssolution: listSolutions){
				ssolution.setOptimizeValue(computeOptimalValueUsingSolution(matchCountSolution, ssolution.getSolution()));
			}
			
			if(listSolutions.size()>0)
				return findGlobalOptimalSolution(listSolutions);
			else
				return null;
			
		}else{
			if(optSolver.equals(KEGConstant.OPTSOLVER_LOCALSOLVER))			
				solver = new OptLocalSolver(matchCountSolution, services, metric);
			else
				solver = new AMPLSolver(matchCountSolution, services, metric, optSolver);
			
			return solver.findOptimalSolution();
		}
	}
		
	
}
