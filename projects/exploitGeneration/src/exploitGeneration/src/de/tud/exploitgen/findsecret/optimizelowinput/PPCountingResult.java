package de.tud.exploitgen.findsecret.optimizelowinput;

import java.util.LinkedList;
import java.util.List;

import de.tud.exploitgen.detectleak.exploit.ExploitTestTransformer;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

/**
 * this class wraps the result returned by iscc barvinok tool
 * */
public class PPCountingResult {
	private List<CountingSolution> listResults; //each result has a corresponding condition
	private int partitionIdx; //index number of the partition involved to the counting (in case of non-uniform distribution)
	private String outputValue; //output Value involved to the counting (in case of non-uniform distribution)
	public PPCountingResult(List<CountingSolution> listResult) {
		super();
		this.listResults = listResult;
	}

	
	public void printAllPossibleResults(Services services){
		System.out.println("list of possible result: ");
	    for(CountingSolution cResult: listResults){
	    	System.out.println("value: " + ExploitTestTransformer.transformExpression2String(cResult.getValue(),1, services));
	    	System.out.println("condition: " + ExploitTestTransformer.transformExpression2String(cResult.getCondition(),1, services));
	    	System.out.println("value: " + cResult.getValue());
	    	System.out.println("condition: " + cResult.getCondition());
	    	System.out.println("-------");
	    }
	}
	
	public boolean isConstant(Services services){
		for(CountingSolution cr: listResults){
			if(!cr.isConstValue(services))
				return false;
		}
		return true;
	}
	
	public List<CountingSolution> getNonConstantResult(Services services){
		List<CountingSolution> listNonConstResults = new LinkedList<CountingSolution>();
		for(CountingSolution cr: listResults)
			if(!cr.isConstValue(services))
				listNonConstResults.add(cr);
		return listNonConstResults;
	}
	
	/*
	 * basically, a counting solution performed by iscc barvinok has the form:
	 * 	v_1 if c_1; v_2 if c_2; ... v_n if c_n
	 * we supply a default result: 
	 *  0 if not(c_1 or c_2 or ... or c_n)
	 *  in order to serve for best input producing 
	 * */
	public void addZeroResult(TermBuilder termBuilder){
		Term zeroCondition = termBuilder.tt();
		for(CountingSolution countSolution: listResults){
			if(countSolution.getCondition()!=null)
				zeroCondition = termBuilder.and(zeroCondition, termBuilder.not(countSolution.getCondition()));			
		}
		//zeroCondition = termBuilder.not(zeroCondition);
		CountingSolution zeroResult = new CountingSolution(termBuilder.zero(), zeroCondition);
		listResults.add(zeroResult);
		List<Term> zeroConditions = getListZeroCondition(termBuilder);
		System.out.println("number of zero conditions: " + zeroConditions.size());
		
		/*List<Term> zeroConditions = getListZeroCondition(termBuilder);
		for(Term condition: zeroConditions){
			CountingSolution zeroResult = new CountingSolution(termBuilder.zero(), condition);
			listResults.add(zeroResult);
		}*/
		
	}
	
	/*
	 * one counting condition could be in conjunctive form A && B
	 * then !(A && B) can be transformed to !A || !B 
	 * then we add !A and !B to list of result
	 * */
	private List<Term> getListZeroCondition(TermBuilder termBuilder){
		List<Term> result = new LinkedList<Term>();
		Term zeroCondition = termBuilder.tt();
		result.add(zeroCondition);
		for(CountingSolution countSolution: listResults){
			Term countCondition = countSolution.getCondition();			
			if(countCondition!=null){
				List<Term> listConjunct = getListConjunct(countCondition);
				List<Term> newResult = new LinkedList<Term>();
				for(Term conjunct: listConjunct){
					for(Term t: result){
						newResult.add(termBuilder.and(t, termBuilder.not(conjunct)));
					}
				}
				result = newResult;
			}			
		}
		return result;
	}
	
	/*
	 * if t has the form: A && (B && C)
	 * then return {A, B, C}
	 * */
	private List<Term> getListConjunct(Term t){
		List<Term> result = new LinkedList<Term>();
		if(TermParser.isAnd(t)){
			result.addAll(getListConjunct(t.sub(0)));
			result.addAll(getListConjunct(t.sub(1)));
		}
		else{
			result.add(t);
		}			
		return result;
	}
	
	/*
	 * if a solution have a condition C1 or C2, then we replace it by two corresponding solution
	 * it might ease optimization tools (exactly) (avoid discrete domain)
	 * */
	public List<CountingSolution> replaceOrCondition(){
		List<CountingSolution> newList = new LinkedList<CountingSolution>();
		for(CountingSolution countSolution: listResults){
			Pair<CountingSolution,CountingSolution> pairReplaced = countSolution.getTwoSolutionsViaOrCondition();
			if(pairReplaced!=null){
				newList.add(pairReplaced.first);
				newList.add(pairReplaced.second);
			}else{
				newList.add(countSolution);
			}			
		}
		return newList;
	}

	public List<CountingSolution> getListResults() {
		return listResults;
	}

	public void setListResults(List<CountingSolution> listResults) {
		this.listResults = listResults;
	}


	public int getPartitionIdx() {
		return partitionIdx;
	}


	public void setPartitionIdx(int partitionIdx) {
		this.partitionIdx = partitionIdx;
	}


	public String getOutputValue() {
		return outputValue;
	}


	public void setOutputValue(String outputValue) {
		this.outputValue = outputValue;
	}
	
	public void printInfo(){
		for(CountingSolution cs: listResults){
			System.out.println("outputValue: " + outputValue + " ; partitionIdx : " + partitionIdx);
			cs.printInfo();
		}
	}
	
	
}
