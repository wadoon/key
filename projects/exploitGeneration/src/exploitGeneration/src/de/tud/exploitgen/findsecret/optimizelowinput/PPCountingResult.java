package de.tud.exploitgen.findsecret.optimizelowinput;

import java.util.LinkedList;
import java.util.List;

import de.tud.exploitgen.detectleak.exploit.ExploitTestTransformer;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

/**
 * this class wraps the result returned by iscc barvinok tool
 * */
public class PPCountingResult {
	private List<CountingSolution> listResults; //each result has a corresponding condition
	
	public PPCountingResult(List<CountingSolution> listResult) {
		super();
		this.listResults = listResult;
	}

	public List<CountingSolution> getListResult() {
		return listResults;
	}
	
	public void printAllPossibleResults(){
		System.out.println("list of possible result: ");
	    for(CountingSolution cResult: listResults){
	    	System.out.println("value: " + ExploitTestTransformer.transformExpression2String(cResult.getValue(),1));
	    	System.out.println("condition: " + ExploitTestTransformer.transformExpression2String(cResult.getCondition(),1));
	    	System.out.println("value: " + cResult.getValue());
	    	System.out.println("condition: " + cResult.getCondition());
	    	System.out.println("-------");
	    }
	}
	
	public boolean isConstant(){
		for(CountingSolution cr: listResults){
			if(!cr.isConstValue())
				return false;
		}
		return true;
	}
	
	public List<CountingSolution> getNonConstantResult(){
		List<CountingSolution> listNonConstResults = new LinkedList<CountingSolution>();
		for(CountingSolution cr: listResults)
			if(!cr.isConstValue())
				listNonConstResults.add(cr);
		return listNonConstResults;
	}
	
	/*
	 * basically, a counting solution performed by iscc barvinok has the form:
	 * 	v_1 if c_1; v_2 if c_2; ... v_n if c_n
	 * we supply a default result: 
	 *  0 if not(c_1 or c_2 or ... or c_n)
	 *  in order to serve for best input producing 
	 * */
	public void addZeroResult(TermBuilder termBuilder){
		Term zeroCondition = termBuilder.tt();
		for(CountingSolution countSolution: listResults){
			if(countSolution.getCondition()!=null)
				zeroCondition = termBuilder.and(zeroCondition, termBuilder.not(countSolution.getCondition()));			
		}
		//zeroCondition = termBuilder.not(zeroCondition);
		CountingSolution zeroResult = new CountingSolution(termBuilder.zero(), zeroCondition);
		listResults.add(zeroResult);
	}
	
	/*
	 * if a solution have a condition C1 or C2, then we replace it by two corresponding solution
	 * it might ease optimization tools
	 * */
	public List<CountingSolution> replaceOrCondition(){
		List<CountingSolution> newList = new LinkedList<CountingSolution>();
		for(CountingSolution countSolution: listResults){
			Pair<CountingSolution,CountingSolution> pairReplaced = countSolution.getTwoSolutionsViaOrCondition();
			if(pairReplaced!=null){
				newList.add(pairReplaced.first);
				newList.add(pairReplaced.second);
			}else{
				newList.add(countSolution);
			}			
		}
		return newList;
	}

	public List<CountingSolution> getListResults() {
		return listResults;
	}

	public void setListResults(List<CountingSolution> listResults) {
		this.listResults = listResults;
	}
	
	
}
