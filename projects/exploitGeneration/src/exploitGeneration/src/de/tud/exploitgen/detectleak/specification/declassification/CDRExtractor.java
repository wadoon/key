/**
 * 
 */
package de.tud.exploitgen.detectleak.specification.declassification;

import java.util.LinkedList;
import java.util.List;


import de.tud.exploitgen.detectleak.PairTerm;
import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConfig;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;

import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.java.Services;

import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.util.DelimitedRelease;

/**
 * @author Huy Do
 * this class supplies methods resolving declassification (conditional delimited release)
 * that can be used in other classes
 *
 */
public class CDRExtractor {
   /*get collection of destination (low variables) of escape hatches expression */
   private final DelimitedRelease decl;
   private Services services;
   TermBuilder termBuilder;
   TermFactory tf = new TermFactory();  
   private final String id; //distinguish two arbitrary DelimitedRelease object  
   
   Term syntheziedMC; //synthesized  method contract of all method invocations embedded in delimited release clause
   List<Term> resolvedEscTerms; //all escape hatch expressions that have been resolved (if it contains method invocation)
   Term resolvedEscCondition; //condition corresponding to resolvedEscTerms that has been resolved (if it contains method invocation)
   
   PairTermCollection pairResults; //contains all result terms extracted from syntheziedMC, resolvedEscTerms and resolvedEscCondition 
   //List<Term> listQuantifiedArrayTerm; //list of all array terms that are quantified, we extract them from syntheziedMC, resolvedEscTerms and resolvedEscCondition  
   List<Term> listQuantifiableVars; //list of all quantifiable variables contained in syntheziedMC, resolvedEscTerms and resolvedEscCondition
   private List<Term> listArrays; //list of all arrays
   private List<Term> listArrayElements; //list of quantified array's elements   
   /**
    * @param decl
    * @param services
    */
   public CDRExtractor(DelimitedRelease decl, Services services, String id) {
      super();
      this.decl = decl;
      this.id = id;
      //System.out.println("delimited release: " + decl.toString());
      this.services = services;
      termBuilder=new TermBuilder(new TermFactory(), services);
      resolveCondDelimitedRelease();
      //constructListQATerm();
      buildListArraysAndElements();
      constructListQuantifiableVars();
   }

   private List<String> getEscDestination(String selfName){
      List<String> result = new LinkedList<String>();      
      for(Term tVar : decl.lowVars){
         result.add(HeapHandler.getFieldNameOfHeapSelectFunction(tVar, KEGConfig.SEPARATOR, selfName));
      }
      return result;
   }
   
   public DelimitedRelease getDelimitedRelease(){
      return decl;
   }
   
   /*if there are more than one conditions in escapes conditions, we use conjunction "or" to combine them*/
   public Term getEscCondition(){
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm=termBuilder.ff();     
         for(Term t: conditions){
            conditionTerm = termBuilder.or(conditionTerm,t);
         }
         return conditionTerm;
      }
      return termBuilder.tt();
   }
   
     
   /**
    * get leak condition of a DelimitedRelease specification (escapes E \if C), based on branch
    * output format: c1(hi,li) or c2(hi,li) or ... (cj \in C)
    * */
   /*private Term getEscCondition(PairTermCollection listAllVars, 
         List<Term> listQuantifiedArrayTerm, int branch){
      
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm = getEscCondition();
         
         conditionTerm = new HeapHandler(services).replaceSelectFunctionByItsField(conditionTerm, KEGConfig.SEPARATOR);
         conditionTerm = new HeapHandler(services).replaceLengthFunctionByVar(conditionTerm, KEGConfig.SEPARATOR);
         conditionTerm = refineTerm(conditionTerm, listQuantifiedArrayTerm);
         if(branch==1){          
            conditionTerm = listAllVars.replacePVByNameAndBranch(conditionTerm, 1);
         }else{
            conditionTerm = listAllVars.replacePVByNameAndBranch(conditionTerm, 2);
         }
                  
         return conditionTerm;
      }
      return termBuilder.tt();
   }
*/   
   
   /**
    * fresh version
    * get leak condition of a DelimitedRelease specification (escapes E \if C), based on branch
    * output format: c1(hi,li) or c2(hi,li) or ... (cj \in C)
    * */
  /* private Term getFreshEscCondition(PairTermCollection ptcFoundation, int branch){
      
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm = getEscCondition();         
         
         if(branch==1){          
            conditionTerm = ptcFoundation.replacePVByNameAndBranch(conditionTerm, 1);
         }else{
            conditionTerm = ptcFoundation.replacePVByNameAndBranch(conditionTerm, 2);
         }
                  
         return conditionTerm;
      }
      return termBuilder.tt();
   }*/
   
   
   /*get the negative form of escape condition: !(EscCond(h1,l1) && EscCond(h2,l2))*/
   /*private Term getNegEscConditionByAndConjunction(PairTermCollection listAllVars,
         List<Term> listQuantifiedArrayTerm)  {
      
      Term conditionTerm1 = getEscCondition(listAllVars, listQuantifiedArrayTerm, 1);
      Term conditionTerm2 = getEscCondition(listAllVars, listQuantifiedArrayTerm, 2);
      return termBuilder.not(termBuilder.and(conditionTerm1, conditionTerm2));
   }
   */
   /* fresh version
    * get the negative form of escape condition: !(EscCond(h1,l1) && EscCond(h2,l2))*/
  /* private Term getFreshNegEscConditionByAndConjunction(PairTermCollection ptcFoundation)  {
      
      Term conditionTerm1 = getFreshEscCondition(ptcFoundation, 1);
      Term conditionTerm2 = getFreshEscCondition(ptcFoundation, 2);
      return termBuilder.not(termBuilder.and(conditionTerm1, conditionTerm2));
   }*/
   
   
   /*
    * get escape hatches equal term: \forall e \in E: e(h1,l1)=e(h2,l2) <=> (e1(h1,l1)=e1(h2,l2)) && (e2(h1,l1)=e2(h2,l2)) && ...
    * */
   
   /*private Term getEscapeHatchesEqual(PairTermCollection listAllVars, 
                                    String heapName, List<Term> listQuantifiedArrayTerm){
      
      ImmutableList<Term> leaks = decl.escapeHatches;
      
       * solve leakable expression, because we have to build equation \forall e \in E: e(h1,l1)=e(h2,l2),
       * we will use PairTermCollection
       * 
      if(leaks.size()>0){
         PairTermCollection pairLeakTerms = new PairTermCollection(services);
         //HeapHandler heapHandler = new HeapHandler(services);
         for(Term leakTerm: leaks){
            
            Term declass1 = leakTerm; 
            Term declass2 = leakTerm;
                           
              with declassification, the heap name is always "self", 
             * but if a class contains more than one method,
             * the heap object of each method could have another name: "self_0", "self_1",...
             * so we have to use the heap name of the method in resolving declassification
             *       
            declass1 = heapHandler.replaceSelectFunctionByItsField(declass1,KEGConfig.SEPARATOR,heapName);
            declass1 = heapHandler.replaceLengthFunctionByVar(declass1,KEGConfig.SEPARATOR);
            declass1 = refineTerm(declass1, listQuantifiedArrayTerm);
            declass2 = heapHandler.replaceSelectFunctionByItsField(declass2,KEGConfig.SEPARATOR,heapName);
            declass2 = heapHandler.replaceLengthFunctionByVar(declass2,KEGConfig.SEPARATOR);
            declass2 = refineTerm(declass2, listQuantifiedArrayTerm);
            
            declass1 = listAllVars.replacePVByNameAndBranch(declass1, 1);
                        
            declass2 = listAllVars.replacePVByNameAndBranch(declass2, 2); 
            
            //create new PairTerm (declass1, declass2) and add it into pcd1
            pairLeakTerms.add(leakTerm.toString(), new PairTerm(declass1,declass2,services));
         }
         return pairLeakTerms.totalEqualTerm();
      }
      
      return termBuilder.tt();
   }*/
   
   
   /*
    * fresh version
    * get escape hatches equal term: \forall e \in E: e(h1,l1)=e(h2,l2) <=> (e1(h1,l1)=e1(h2,l2)) && (e2(h1,l1)=e2(h2,l2)) && ...
    * */
   
  /* private Term getFreshEscapeHatchesEqual(PairTermCollection ptcFoundation){
      
      ImmutableList<Term> leaks = decl.escapeHatches;
      
       * solve leakable expression, because we have to build equation \forall e \in E: e(h1,l1)=e(h2,l2),
       * we will use PairTermCollection
       * 
      if(leaks.size()>0){
         PairTermCollection pairLeakTerms = new PairTermCollection(services);
         //HeapHandler heapHandler = new HeapHandler(services);
         for(Term leakTerm: leaks){
            
            Term declass1 = leakTerm; 
            Term declass2 = leakTerm;
                       
            declass1 = ptcFoundation.replacePVByNameAndBranch(declass1, 1);
                        
            declass2 = ptcFoundation.replacePVByNameAndBranch(declass2, 2); 
            
            //create new PairTerm (declass1, declass2) and add it into pcd1
            pairLeakTerms.add(leakTerm.toString(), new PairTerm(declass1,declass2,services));
         }
         return pairLeakTerms.freshTotalEqualTerm();
      }
      
      return termBuilder.tt();
   }*/
      
   /*
    * return conditional escape term for declare: escapes E \if C
    * it's format is:  (!(C(h1,l1) && C(h2,l2))) || (E(h1,l1)=E(h2,l2))
    * */
   /*public Term getConditionalEscTerm(PairTermCollection listAllVars, String heapName, 
         List<Term> listQuantifiedArrayTerm){
      //System.out.println("NegEscConditionByAndConjunction: " + getNegEscConditionByAndConjunction(listAllVars,heapName,listQuantifiedArrayTerm ));
      //System.out.println("getEscapeHatchesEqual: " + getEscapeHatchesEqual(listAllVars,heapName,listQuantifiedArrayTerm ));
      return termBuilder.or(getNegEscConditionByAndConjunction(listAllVars,listQuantifiedArrayTerm ),
                            getEscapeHatchesEqual(listAllVars,heapName,listQuantifiedArrayTerm));
   }*/
   
   /*
    * fresh version
    * return conditional escape term for declare: escapes E \if C
    * it's format is:  (!(C(h1,l1) && C(h2,l2))) || (E(h1,l1)=E(h2,l2))
    * */
   public Term getFreshConditionalEscTerm(PairTermCollection ptcFoundation){      
      /*return termBuilder.or(getFreshNegEscConditionByAndConjunction(ptcFoundation),
                            getFreshEscapeHatchesEqual(ptcFoundation));*/
      
      /*get fresh conditional escape hatch term based on 
       * syntheziedMC, resolvedEscTerm and resolvedEscCondition
       * */
      if(resolvedEscTerms.size()>0){
         /*
          * resolve all method contracts
          * */
         PairTermCollection ptcAllVarNew = new PairTermCollection(services);
         ptcAllVarNew.combine(pairResults);
         ptcAllVarNew.combine(ptcFoundation);
         
                         
         Term synMC1 = ptcAllVarNew.replacePVByNameAndBranch(syntheziedMC, 1);
         Term synMC2 = ptcAllVarNew.replacePVByNameAndBranch(syntheziedMC, 2);
         Term synMC = termBuilder.and(synMC1, synMC2);     
         
         
         /*
          * resolve negative escape hatch condition
          * */
         Term resolvedCondition1 = ptcAllVarNew.replacePVByNameAndBranch(resolvedEscCondition, 1);
         Term resolvedCondition2 = ptcAllVarNew.replacePVByNameAndBranch(resolvedEscCondition, 2);
         Term negEscCondition = termBuilder.not(termBuilder.and(resolvedCondition1,resolvedCondition2));
         
         
         /*
          * resolve equality term of escape hatch expressions
          * */
         PairTermCollection pairLeakTerms = new PairTermCollection(services);
         //resolve each expression
         for(Term resolvedEscTerm: resolvedEscTerms){        
            
            Term escTerm1 = ptcAllVarNew.replacePVByNameAndBranch(resolvedEscTerm, 1);
            Term escTerm2 = ptcAllVarNew.replacePVByNameAndBranch(resolvedEscTerm, 2);
            pairLeakTerms.add(resolvedEscTerm.toString(), new PairTerm(escTerm1,escTerm2,services));
         }
         
         /*
          * return result:   (!(C1&C2)||((e11=e12)&&(e21=e22)&&...)) && SynthesisMethodContract
          * */
         Term freshTotalLeakEqual = pairLeakTerms.freshTotalEqualTerm();
         //System.out.println("freshTotalLeakEqual::: " + freshTotalLeakEqual);
         //System.out.println(" fresh synthesis method contract of method invocation: " + synMC);
         return termBuilder.and(termBuilder.or(negEscCondition,freshTotalLeakEqual),synMC);
 
      }else{
         return termBuilder.tt();
      }
   }
   
   /*check if escape hatches expressions could be applied for specific variable (parameter) or not 
    * return true if escapes destinations (\to clause) is empty, or contains varName
    * */
   public boolean affect2Var(String heapName, String selfName){
      List<String> escDests = getEscDestination(heapName);
      if(escDests.isEmpty() || escDests.contains(selfName))
         return true;
      else
         return false;
   }
   
   
   
   private Term refineTerm(final Term t, List<Term> listQuantifiedArrayTerm ){
      
      /*Term result = heapHandler.replaceLengthFunctionByVar(t, KEGConfig.SEPARATOR);
      result = heapHandler.replaceSelectFunctionByItsField(result, KEGConfig.SEPARATOR);*/
      HeapHandler heapHandler = new HeapHandler(services);
      Term result = heapHandler.shortenArrayElementTerm(t, KEGConfig.SEPARATOR);
      result = heapHandler.replaceUnContainArraySelectAndLength(result,listQuantifiedArrayTerm);
      result = heapHandler.removeJavaCastInt(result);
      result = heapHandler.sum2Bsum(result);
      return result;
   }
   
   /*
    *resolve decl and store synthesized results into:
    *  - synthesizedMC
    *  - resolvedEscTerms
    *  - resolvedEscCondition
    *  - pairResults
    * */
   private void resolveCondDelimitedRelease(){
      /*
       * Initialize for result containers
       * */
      syntheziedMC = termBuilder.tt();
      resolvedEscTerms = new LinkedList<Term>();
      resolvedEscCondition = termBuilder.tt();
      
      /*
       * analyze decl and synthesize result
       * */   
      ImmutableList<Term> leaks = decl.escapeHatches;
      if(leaks.size()>0){ //if there exists escape hatches clauses    
         Term condition = getEscCondition();      
         CDRExpression condExpr;
         if(TermParser.isProgramMethod(condition))
            condExpr = new CDRMethodInvocation(condition, services, id+"0");//assign id of conditional expression is 0
         else
            condExpr = new CDRExpression(condition, services, id+"0");//assign id of conditional expression is 0
         resolvedEscCondition = condExpr.getResolvedTerm();
         syntheziedMC = condExpr.getSynthesisMethodContract();
                 
         /*resolve escape hatch expression*/      
         List<CDRExpression> escExprs = new LinkedList<CDRExpression>();
         int i=1;
         for(Term leak: leaks){
            CDRExpression leakExpr;
            if(TermParser.isProgramMethod(leak))
               leakExpr = new CDRMethodInvocation(leak,services,id+Integer.toString(i));
            else
               leakExpr = new CDRExpression(leak,services,id+Integer.toString(i));
            escExprs.add(leakExpr);
            i++;            
         }                
         //resolve each expression
         for(CDRExpression escExpr: escExprs){
            resolvedEscTerms.add(escExpr.getResolvedTerm());                                 
            syntheziedMC = termBuilder.and(syntheziedMC, escExpr.getSynthesisMethodContract());
         }  
         //print out to check
         //System.out.println("resolvedEscCondition:: " + resolvedEscCondition);
         //System.out.println("syntheziedMC:: " + syntheziedMC);
      }
      
      /*
       * create pairResults
       * */
      pairResults  = new PairTermCollection(services);
      detectAdd2PairResults(syntheziedMC);
      detectAdd2PairResults(resolvedEscCondition);
      for(Term expr: resolvedEscTerms)
         detectAdd2PairResults(expr);
   }
   
   private boolean isResultCDR(Term t){
      return (t.toString().startsWith("result_CDR"+KEGConfig.SEPARATOR) && t.subs().size()==0);
   }
   
   private void detectAdd2PairResults(Term t){
      if(t!=null){
         if(isResultCDR(t)){
            String name = t.op().name().toString();            
            if(!pairResults.contains(name)){
               //add two pairResults;
               pairResults.add(name, new PairTerm(t,services));
            }
         }else{
            for(Term st: t.subs()){
               detectAdd2PairResults(st);
            }
         }
      }
   }
   
   /*
    * get Conditional Escape Hatch Equal term that all embedded method invocation have been resolved:
    * All method invocations are replaced by their return value accordingly (result_...)
    * according to each replacement, corresponding method contract are integrated (using conjunction)     
    * after all, the PairTermCollection is used to resolve   
    * */
   public Term getConditionalEscTerm(PairTermCollection pairAllVar, String heapName, List<Term> listArrays){      
      if(resolvedEscTerms.size()>0){
         /*
          * resolve all method contracts
          * */
         PairTermCollection listAllVarNew = new PairTermCollection(services);
         listAllVarNew.combine(pairResults);
         listAllVarNew.combine(pairAllVar);
         
         
         Term synSingleMC = refineTerm(syntheziedMC,listArrays);         
         Term synMC1 = listAllVarNew.replacePVByNameAndBranch(synSingleMC, 1);
         Term synMC2 = listAllVarNew.replacePVByNameAndBranch(synSingleMC, 2);
         Term synMC = termBuilder.and(synMC1, synMC2);     
         
         
         /*
          * resolve negative escape hatch condition
          * */
         Term resolvedCondition = refineTerm(resolvedEscCondition, listArrays);
         Term resolvedCondition1 = listAllVarNew.replacePVByNameAndBranch(resolvedCondition, 1);
         Term resolvedCondition2 = listAllVarNew.replacePVByNameAndBranch(resolvedCondition, 2);
         Term negEscCondition = termBuilder.not(termBuilder.and(resolvedCondition1,resolvedCondition2));
         
         
         /*
          * resolve equality term of escape hatch expressions
          * */
         PairTermCollection pairLeakTerms = new PairTermCollection(services);
         //resolve each expression
         for(Term resolvedEscTerm: resolvedEscTerms){         
            Term escTerm = refineTerm(resolvedEscTerm, listArrays);
            Term escTerm1 = listAllVarNew.replacePVByNameAndBranch(escTerm, 1);
            Term escTerm2 = listAllVarNew.replacePVByNameAndBranch(escTerm, 2);
            pairLeakTerms.add(escTerm.toString(), new PairTerm(escTerm1,escTerm2,services));
         }
         
         /*
          * return result:   (!(C1&C2)||((e11=e12)&&(e21=e22)&&...)) && SynthesisMethodContract
          * */
         Term totalLeakEqual = pairLeakTerms.totalEqualTerm();
         /*System.out.println("totalLeakEqual::: " + totalLeakEqual);
         System.out.println("synthesis method contract of method invocation: " + synMC);*/
         return termBuilder.and(termBuilder.or(negEscCondition,totalLeakEqual),synMC);
 
      }else{
         return termBuilder.tt();
      }
   }

   public PairTermCollection getPairResults() {
      return pairResults;
   }
   
   
   /*
    * parse all quantified array term from syntheziedMC, resolvedEscTerm and resolvedEscCondition 
    * */
   /*private void constructListQATerm(){
      listQuantifiedArrayTerm = new LinkedList<Term>();
      
      HeapHandler heapHandler = new HeapHandler(services);
      //find quantified array terms from node's constraints
      Term shortSyntheziedMC = heapHandler.shortenArrayElementTerm(syntheziedMC, KEGConfig.SEPARATOR);
      Term shortResolvedEscCondition = heapHandler.shortenArrayElementTerm(resolvedEscCondition, KEGConfig.SEPARATOR);           
      listQuantifiedArrayTerm = TermUtil.mergeListTerm(listQuantifiedArrayTerm, 
                                                       TermUtil.extractQATerms(shortSyntheziedMC));
      listQuantifiedArrayTerm = TermUtil.mergeListTerm(listQuantifiedArrayTerm, 
                                                       TermUtil.extractQATerms(shortResolvedEscCondition));
      for(Term resolvedEscTerm: resolvedEscTerms){
         Term shortResolvedEscTerm = heapHandler.shortenArrayElementTerm(resolvedEscTerm, KEGConfig.SEPARATOR);
         listQuantifiedArrayTerm = TermUtil.mergeListTerm(listQuantifiedArrayTerm, 
               TermUtil.extractQATerms(shortResolvedEscTerm));
      }
   }*/
 
   /*public List<Term> getListQuantifiedArrayTerm() {
      return listQuantifiedArrayTerm;
   }*/
   
   private void constructListQuantifiableVars(){
      HeapHandler heapHandler = new HeapHandler(services);
      listQuantifiableVars = new LinkedList<Term>();
      listQuantifiableVars = TermUtil.mergeListTerm(listQuantifiableVars, 
            heapHandler.getAllQuantifiableVarTerms(syntheziedMC));
      listQuantifiableVars = TermUtil.mergeListTerm(listQuantifiableVars, 
            heapHandler.getAllQuantifiableVarTerms(resolvedEscCondition));
      listQuantifiableVars = TermUtil.mergeListTerm(listQuantifiableVars, 
            heapHandler.getAllQVTermsFromListTerm(resolvedEscTerms));      
   }

   public List<Term> getListQuantifiableVars() {
      return listQuantifiableVars;
   }
 
   private void buildListArraysAndElements(){
      listArrayElements = new LinkedList<Term>();
      listArrays = new LinkedList<Term>();
           
      /*listQuantifiedArrays = TermUtil.mergeListTerm(listQuantifiedArrays, TermUtil.extractQuantifiedArrays(syntheziedMC));
      listQuantifiedArrays = TermUtil.mergeListTerm(listQuantifiedArrays, TermUtil.extractQuantifiedArrays(resolvedEscCondition));*/
      listArrays = TermUtil.mergeListTerm(listArrays, TermUtil.extractArrays(syntheziedMC));
      listArrays = TermUtil.mergeListTerm(listArrays, TermUtil.extractArrays(resolvedEscCondition));
      for(Term escTerm: resolvedEscTerms){
         //listQuantifiedArrays = TermUtil.mergeListTerm(listQuantifiedArrays, TermUtil.extractQuantifiedArrays(escTerm));;
         listArrays = TermUtil.mergeListTerm(listArrays, TermUtil.extractArrays(escTerm));;
      }
      //System.out.println("listQuantifiedArrays of CDR::: " + listArrays);
      
       
      listArrayElements = TermUtil.mergeListTerm(listArrayElements, TermUtil.extractArrayElements(syntheziedMC,listArrays));   
      listArrayElements = TermUtil.mergeListTerm(listArrayElements, TermUtil.extractArrayElements(resolvedEscCondition,listArrays));
      for(Term escTerm: resolvedEscTerms){
         listArrayElements = TermUtil.mergeListTerm(listArrayElements, TermUtil.extractArrayElements(escTerm,listArrays));
      }
      //System.out.println("listQAElements of CDR::: " + listArrayElements);
   }

   public List<Term> getListArrays() {
      return listArrays;
   }

   public List<Term> getListArrayElements() {
      return listArrayElements;
   }

   
}
