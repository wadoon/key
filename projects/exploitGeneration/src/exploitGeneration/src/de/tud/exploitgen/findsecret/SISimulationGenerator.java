package de.tud.exploitgen.findsecret;

import java.io.File;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import com.csvanefalk.keytestgen.backend.AbstractJavaSourceGenerator;
import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelArrayInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ConcreteArrInterp;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.exploit.ExploitTestTransformer;
import de.tud.exploitgen.detectleak.exploit.codegenerator.ClassWrapper;
import de.tud.exploitgen.util.KEGConstant;
import de.uka.ilkd.key.logic.op.IProgramVariable;

public class SISimulationGenerator extends AbstractJavaSourceGenerator{
	private String packageName;
	private String hackingFileName;
	private HashSet<String> importClasses;
	private BadMethod badMethod;
	private File highInputFile;
	private File lowInputFile;
	private static final String EXECUTION_RESULT = "result";
	//private static final String OBJECT_NAME = "self";
	private static final String OBJECT_MAP_NAME = "mapObj";
	
	public SISimulationGenerator(String packageName, String hackingFileName, HashSet<String> importClasses,
			BadMethod badMethod, File highInputFile, File lowInputFile) {
		super();
		this.packageName = packageName;		
		this.hackingFileName = hackingFileName;
		this.importClasses = importClasses;
		this.badMethod = badMethod;
		this.highInputFile = highInputFile;
		this.lowInputFile = lowInputFile;
	}	
	
	private void createHackSimulationContent(){
		writePackage();
		writeImport();
		writeClassContent();
	}
	
	private void writePackage(){
		appendToOutput("package " + packageName + ";");
		writeNewLine();
	}
	
		
	
	private void writeImport(){
	  /*
       * write the popular imports
       * */
      appendToOutput("import java.io.*;\n");   
      appendToOutput("import java.lang.reflect.*;\n");     
      appendToOutput("import java.util.*;\n");    
  
      /*
       * Write the specific imports.
       */
      //System.out.println("import stuffs:"+ getImports());
      for (final String importt : importClasses) {
          appendToOutput("import ");
          appendToOutput(importt);
          appendToOutput(";\n");
      }
      writeNewLine();
	}
	
	private void writeClassContent(){
		writeClassHeader(null,
						"public",
						"",
						hackingFileName
						);
		writeMainMethod();
		writeGetFieldMethod();
		writeSetFieldMethod();
		writeReadInputValuesFromFileMethod();
		writeClosingBrace();	
	}
	
	private void writeMainMethod(){
		writeMainMethodHeader();
		/*writeDeclarations();
		writeExecution();*/
		writeVariableDeclarations();
		writeInstantiateMapObject();
		writeReadInputValue();
		writeSetValuesForAllVars();
		writeMethodInvocation();
		writePrintLowOutput();
		writeClosingBrace();	
	}
	
	
	
	private void writeMainMethodHeader(){
		writeMethodHeader(null,
                "public",
                new String[]{"static"},
                "void",
                "main",
                new String[]{"String[] args"},
                new String[]{"NoSuchFieldException", 
							"SecurityException", 
							"IllegalArgumentException", 
							"IllegalAccessException", 
							"NumberFormatException",
							"IOException"});
	}
	
	 /**
	    * write the method invocation
	    */
	   private void writeMethodInvocation() {
	       writeComment("Perform execution ",false);      
	       
	       final String returnType = badMethod.getMethod().getReturnTypeAsString();
	       String methodInvocation = "";
	       if (!returnType.equals("void")) {
	           methodInvocation += returnType + " " + EXECUTION_RESULT + " = ";
	       }
	       
	       methodInvocation += KEGConstant.SELF_NAME + "." + badMethod.getMethod().getProgramMethod().getName() + "(";
	       final List<IProgramVariable> parameters = badMethod.getMethod().getParameters();

	       for (int i = 0; i < parameters.size(); i++) {
	           final String parameterName = parameters.get(i).name().toString();
	           methodInvocation += parameterName;
	           if (i != (parameters.size() - 1)) {
	               methodInvocation += ",";
	           }
	       }
	       methodInvocation += ");";
	       writeIndentedLine(methodInvocation);
	       writeNewLine();
	   }
	   
	   public String getHackSimulationContent(){
		   try {
			   createHackSimulationContent();
		      }
		      catch (Exception e) {

		         e.printStackTrace();
		      }
		      return getCurrentOutput();
	   }
	   
	   
	   /**
	    * Writes the getField method.
	    * @source: Christopher
	    */
	   private void writeGetFieldMethod() {

	       writeComment("Gets the field of a given object", true);
	       writeMethodHeader(null,
	                         "private",
	                         new String[]{"static","<T>"},
	                         "T",
	                         "getFieldValue",
	                         new String[]{"Object instance", "String fieldName"},
	                         new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});

	       writeIndentedLine("Field field = instance.getClass().getDeclaredField(fieldName);");
	       writeNewLine();

	       writeIndentedLine("field.setAccessible(true);");
	       writeNewLine();

	       writeIndentedLine("return (T)field.get(instance);");
	       writeNewLine();

	       writeClosingBrace();
	   }
	  
	   /**
	    * Writes the setField method.
	    * @source: Christopher
	    */
	   private void writeSetFieldMethod() {

	       writeComment("Sets a field of some object to a given value", true);
	       writeMethodHeader(null,
	                         "private",
	                         new String[]{"static"},
	                         "void",
	                         "setFieldValue",
	                         new String[]{"Object instance", "String fieldName", "Object value"},
	                         new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});

	       writeIndentedLine("Field field = instance.getClass().getDeclaredField(fieldName);");
	       writeNewLine();

	       writeIndentedLine("field.setAccessible(true);");
	       writeNewLine();

	       writeIndentedLine("field.set(instance, value );");
	       writeNewLine();
	       
	       writeClosingBrace();
	              
	   }
	   
	  	   
	  
	   
	  	   
	   private void writeReadInputValuesFromFileMethod(){
		   writeMethodHeader(null,
                   "private",
                   new String[]{"static"},
                   "void",
                   "readInputValuesFromFile",
                   new String[]{"String fileName", "Map<String, Object> mapObj"},
                   new String[]{"NumberFormatException", "IOException"});
		   
		   writeIndentedLine("BufferedReader br = new BufferedReader(new FileReader(new File(fileName)));");
		   writeNewLine();
		   writeIndentedLine("int n = Integer.parseInt(br.readLine());");
		   writeNewLine();
		   writeIndentedLine("for(int i=0;i<n;i++){");
		   writeNewLine();
		   increaseIndentation();
           writeIndentedLine("String assignment = br.readLine();");
           writeNewLine();
           writeIndentedLine("String valueString[] = assignment.split(\":\");");
           writeNewLine();
           writeIndentedLine("String varName = valueString[0].trim();");
           writeNewLine();
           writeIndentedLine("Object var = mapObj.get(varName);");
           writeNewLine();
           writeIndentedLine("if(var !=  null){");
           writeNewLine();
           increaseIndentation();
           writeIndentedLine("if(var instanceof Long)");
           writeNewLine();
           increaseIndentation();
           writeIndentedLine("var = Long.valueOf(valueString[1].trim());");
           writeNewLine();
           decreaseIndentation();
           writeIndentedLine("else");
           writeNewLine();
           increaseIndentation();
           writeIndentedLine("var = Integer.valueOf(valueString[1].trim());");
           writeNewLine();
           decreaseIndentation();
           decreaseIndentation();
           writeIndentedLine("}");
           writeIndentedLine("mapObj.put(varName, var);");
           writeNewLine();
           decreaseIndentation();
           writeIndentedLine("}");
           writeNewLine();
           writeIndentedLine("br.close();");
           writeNewLine();
           writeClosingBrace();
	   }
	   
	   	   
	   /*
	    * write declaration statement for each variable at each branch
	    * */   
	   private void writeVariableDeclaration(ModelVariable variable){
	      String varName = variable.getIdentifier();      
	      if((variable instanceof ModelArrayVariable)&&(variable.getValue() instanceof ModelArrayInstance)){         
	          //if(((ModelArrayInstance)variable.getValue()).length()>0){
	             String arrayType = variable.getTypeName();
	             String baseType = arrayType.substring(0, arrayType.indexOf("[]"));
	             String declaration = arrayType + " " + varName + " = " + "new" + " " + baseType +"[" 
	                   + ((ModelArrayInstance)variable.getValue()).length() + "]";
	             for(int i=1;i<((ModelArrayVariable)variable).dimension();i++){
	                declaration +="[]";
	             }
	             declaration += ";" ;
	             writeIndentedLine(declaration); 
	          //}
	      }else if (!variable.isPrimitive()){       
	         /*
	          * Declares and instantiates a reference typed instance.
	          */   
	         String runtimeType = variable.getRuntimeType();         
	         writeIndentedLine(runtimeType + " " + varName + " = " + "new" + " " + runtimeType + "();");
	      }else {
	         /*
	          * A primitive fields will be wrapped by wrapper object (long -> Long, int -> Integer)
	          */
	          writeIndentedLine(ClassWrapper.wrapperClassName.get(variable.getTypeName()) + " " + varName + 
	        		  " = new " + ClassWrapper.wrapperClassName.get(variable.getTypeName()) + "(0);");
	      }
	   }
	   
	   /*
	    * write assignment to set fields for reference variable
	    * */
	   private void writeSetFieldsForReference(ModelVariable variable){      
	      final Object value = variable.getValue();
	      if(value instanceof ModelArrayInstance && variable instanceof ModelArrayVariable){
	    	  //TODO: instantiating for array must be revised
	         long length = ((ModelArrayInstance)value).length();
	         if(length>0){
	            final String variableIdentifier = variable.getIdentifier();
	            
	            writeComment("Configure variable: " + variableIdentifier, false);
	            /*using ConcreteArrayInterpretation*/
	            ConcreteArrInterp arrInterp = ((ModelArrayVariable)variable).getArrInterp();
	            if(arrInterp!=null){
	               //assign all elements by else value
	               writeIndentedLine("for (int i=0; i<" + variableIdentifier + ".length; i++)");
	               writeNewLine();
	               increaseIndentation();
	               writeIndentedLine(variableIdentifier + "[i] = " + arrInterp.getElseValue().toString() + ";" );
	               decreaseIndentation();
	               writeNewLine();               
	               //assign each element in Entries by corresponding value
	               Map<int[],Object> entries = arrInterp.getEntries();
	               if(!entries.isEmpty()){
	                  for(int[] key: entries.keySet()){
	                     Object entryValue = entries.get(key);
	                     for(int i=0;i<key.length;i++){
	                        if(0<=key[i] && key[i]<key.length){
	                           writeIndentedLine(variableIdentifier + "[" + key[i] + "] = " + entryValue.toString() + ";");
	                           writeNewLine();                           
	                        }                        
	                     }
	                  }
	               }
	            }
	            
	           
	         }
	      }else if (!variable.isPrimitive()) {
	         //System.out.println(variable.getIdentifier() + " is object");
	          final ModelInstance instance = (ModelInstance) value;

	          if (!instance.getFields().isEmpty()) {
	              final String variableIdentifier = variable.getIdentifier();
	              writeComment("Configure variable: " + variableIdentifier, false);
	              for (final ModelVariable field : instance.getFields()) {
	            	  if(!field.isPrimitive()){ 		                  
		                  String fieldValueIdentifier = field.getIdentifier();
		                  writeIndentedLine("setFieldValue(" + variableIdentifier + "," + "\"" + field.getVariableName() + "\"" + "," + fieldValueIdentifier + ");");
		                  writeNewLine();
	            	  }else{
	            		  //if field is primitive, we set the value from corresponding wrapper object	            		  
	            		  String filedValue = "((" + ClassWrapper.wrapperClassName.get(field.getTypeName()) + ")" + 
	            		  OBJECT_MAP_NAME + ".get(\"" +field.getIdentifier() + "\"))." 
	            		  + ClassWrapper.getValueMethodName.get(field.getTypeName());
	            		  writeIndentedLine("setFieldValue(" + variableIdentifier + "," + "\"" + field.getVariableName() + "\"" + "," + filedValue + ");");
		                  writeNewLine();
	            	  }
	              }
	          }
	      }      
	   }
	   
	   private void writePutVariableIntoMapObject(ModelVariable variable){
		   String identifier = variable.getIdentifier();
		   String str = OBJECT_MAP_NAME + ".put(\"" + identifier + "\", " + identifier +");";  
		   writeIndentedLine(str);
		   writeNewLine();
	   }
	   
	   /**
	    * write instruction to get and store the value of low variable when an execution finish
	    * to avoid side-effect of self-composition (relating static variable)
	    * revised: instead of getting directly field's value from object, we make a chain of getFieldValue
	    * For example: to get self_1.f1.ff with self_1.f1= fo, we do not get ff directly from fo but we trace it from self_1  
	    * the reason is self_1.f1 might be changed during the execution of self_1 to refer to another object
	    * */  
	   
	   private void writeAccessAndPrintLowVarOutput(ModelVariable lowVar){
	      KTGModel model = badMethod.getListRiskyPaths().get(0).getModelNode().getModel();
	      writeComment("Get the value of low variable " + lowVar.getIdentifier() + " after execution", false);
	      
	      if(model.hasVar(lowVar.getIdentifier())){ 
	         ModelVariable lowVarNew = model.getVariable(lowVar.getIdentifier());
	         Stack<String> s = new Stack<String>();         
	         String low_out = lowVar.getIdentifier()+"_out";
	         String typeName = lowVar.getTypeName();         
	         if(lowVarNew.isArrayLength()){
	            
	            
	            //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
	            String parentName = lowVarNew.getParentIdentifier();
	            String valueRetrieval = typeName + " " + low_out + " = " + parentName + ".length;" ;
	            s.push(valueRetrieval);
	         }else if(lowVarNew.isArrayElement()){
	            //String low_out = lowVar.getIdentifier()+"_out" ;
	            //String typeName = lowVarNew.getTypeName();         
	            //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
	            String parentName = lowVarNew.getParentIdentifier();
	            //TODO: revise to get array's element whose index value is a variable
	            String valueRetrieval;
	            if(lowVarNew.getArrayIdx()>=0){
	               valueRetrieval = typeName + " " + low_out + " = " + parentName  + "[" + 
	                     lowVarNew.getArrayIdx() + "];" ;               
	            }else{
	               valueRetrieval = typeName + " " + low_out + " = " + parentName + "[" + 
	                     ExploitTestTransformer.transformExpression2String(lowVarNew.getArrayIdxTerm(), 
	                             badMethod.getMethod().getServices())+ "];" ;
	            }
	            s.push(valueRetrieval);
	         }else if(lowVarNew.isPrimitive()){        
	            //String low_out = lowVar.getIdentifier()+"_out";
	            //String typeName = lowVar.getTypeName();
	            //String typeName = lowVarNew.getRuntimeType();
	            //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
	            String parentName = lowVarNew.getParentIdentifier();
	            String valueRetrieval = typeName + " " + low_out + " = ((" + ClassWrapper.wrapperClassName.get(typeName) + 
	                  ")getFieldValue(" + parentName + "," + "\"" + lowVarNew.getVariableName() + "\"))." 
	                  + ClassWrapper.getValueMethodName.get(typeName) + ";\n" ;
	            s.push(valueRetrieval);
	            /*writeIndentedLine(valueRetrieval);            
	            writeNewLine();*/
	         }else if(lowVarNew instanceof ModelArrayVariable){         
	            //if(((ModelArrayInstance)variable.getValue()).length()>0){
	            //String low_out = lowVar.getIdentifier()+"_out" ;
	            String parentName = lowVarNew.getParentIdentifier();         
	            //String typeName = lowVarNew.getRuntimeType();
	            String valueRetrieval =typeName + " " + low_out + " = (" + typeName + 
	                  ")getFieldValue(" + parentName  + "," + "\"" + lowVarNew.getVariableName() + "\"); \n"  ;
	            s.push(valueRetrieval);
	         //}
	         }else{
	            //String low_out = lowVar.getIdentifier()+"_out";
	            //String typeName = lowVar.getTypeName();         
	            typeName = lowVarNew.getRuntimeType();
	            //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
	            String parentName = lowVarNew.getParentIdentifier();
	            String valueRetrieval =typeName + " " + low_out + " = (" + typeName + 
	                  ")getFieldValue(" + parentName + "," + "\"" + lowVarNew.getVariableName() + "\"); \n"  ;
	            s.push(valueRetrieval);
	         }
	         
	         lowVarNew = model.getVariable(lowVarNew.getParentIdentifier());
	         if(lowVarNew!=null){
	            while(lowVarNew.getParentIdentifier()!=null){         
	                  low_out = lowVarNew.getIdentifier();
	                  //String typeName = lowVar.getTypeName();
	                  typeName = lowVarNew.getRuntimeType();
	                  //String parentName = lowVar.getParentModelInstance().getReferees().get(0).getIdentifier();
	                  String parentName = lowVarNew.getParentIdentifier();
	                  String valueRetrieval = low_out + " = (" + typeName + 
	                        ")getFieldValue(" + parentName + "," + "\"" + lowVarNew.getVariableName() + "\"); \n"  ;
	                  s.push(valueRetrieval);  
	                  lowVarNew = model.getVariable(lowVarNew.getParentIdentifier());
	            }
	         }
	         while(!s.empty()){
	            writeIndentedLine(s.pop());
	         }
	         writeNewLine();
	         writeIndentedLine("System.out.println(\""+ lowVar.getIdentifier() +":\" + "  + lowVar.getIdentifier()+"_out" +");");
	         writeNewLine();
	      }else{
	         /*if lowVarNew does not exist in model, we assign it as null value*/
	         String low_out = lowVar.getIdentifier()+"_out" ;
	         String typeName = lowVar.getTypeName();         
	         //String typeName = lowVar.getRuntimeType();                 
	         if(lowVar.isPrimitive())
	            typeName = ClassWrapper.wrapperClassName.get(typeName);            
	         String valueRetrieval =typeName + " " + low_out + " = null;"  ;
	         writeIndentedLine(valueRetrieval);
	      }

	      //}
	   }
	private void writeInstantiateMapObject(){
		writeNewLine();
		writeIndentedLine("Map<String, Object> " + OBJECT_MAP_NAME + " = new HashMap<String,Object>();");
		writeNewLine();
		List<ModelVariable> listVars = badMethod.getListRiskyPaths().get(0).getModelNode().getModel().getVariables();
		for(ModelVariable variable: listVars){
			writePutVariableIntoMapObject(variable);
		}
	}
	
	private void writeVariableDeclarations(){
		List<ModelVariable> listVars = badMethod.getListRiskyPaths().get(0).getModelNode().getModel().getVariables();
		for(ModelVariable variable: listVars){
			writeVariableDeclaration(variable);
			writeNewLine();
		}
				
	}
	
	private void writeReadInputValue(){
		//declare highInputFile and lowInputFile
		writeNewLine();
		writeIndentedLine("String highInputFile = \"" + highInputFile.getAbsolutePath() + "\";") ; 
		writeNewLine();
		writeIndentedLine("String lowInputFile = \"" + lowInputFile.getAbsolutePath() + "\";"); 
		writeNewLine();
		
		//write invoking method readInputValuesFromFile
		writeIndentedLine("readInputValuesFromFile(highInputFile," + OBJECT_MAP_NAME + ");") ; 
		writeNewLine();
		writeIndentedLine("readInputValuesFromFile(lowInputFile," + OBJECT_MAP_NAME + ");") ; 
		writeNewLine();
	}
	
	private void writePrintLowOutput(){
		writeNewLine();
		List<ModelVariable> listLowVars = badMethod.getListLowVars();
		 writeIndentedLine("System.out.println(\"" + listLowVars.size() +"\");");
		writeNewLine();
		for(ModelVariable lowVar: listLowVars){
			writeAccessAndPrintLowVarOutput(lowVar);
		}
	}
	
	private void writeSetValuesForAllVars(){
		writeNewLine();
		List<ModelVariable> listVars = badMethod.getListRiskyPaths().get(0).getModelNode().getModel().getVariables();
		for(ModelVariable variable: listVars){
			writeSetFieldsForReference(variable);
		}

	}
}
