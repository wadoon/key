package de.tud.exploitgen.findsecret;

import java.io.File;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

import com.csvanefalk.keytestgen.backend.AbstractJavaSourceGenerator;
import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelArrayInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import de.uka.ilkd.key.logic.op.IProgramVariable;

public class SISimulationGenerator extends AbstractJavaSourceGenerator{
	private String packageName;
	private String hackingFileName;
	private String className;
	private BadMethod badMethod;
	private File highInputFile;
	private File lowInputFile;
	private static final String EXECUTION_RESULT = "result";
	private static final String OBJECT_NAME = "obj";
	public SISimulationGenerator(String packageName, String hackingFileName, String className,
			BadMethod badMethod, File highInputFile, File lowInputFile) {
		super();
		this.packageName = packageName;		
		this.hackingFileName = hackingFileName;
		this.className = className;
		this.badMethod = badMethod;
		this.highInputFile = highInputFile;
		this.lowInputFile = lowInputFile;
	}	
	
	private void createHackSimulationContent(){
		writePackage();
		writeImport();
		writeClassContent();
	}
	
	private void writePackage(){
		appendToOutput("package " + packageName + ";");
		writeNewLine();
	}
	
	
	private HashSet<String> getImports(){
		HashSet<String> imports = new HashSet<String>();
	    
       final List<ModelInstance> instances = new LinkedList<ModelInstance>();       
     
       for (final RiskyPath riskyNode : badMethod.getListRiskyPaths()) {
           Model model = riskyNode.getModelNode().getModel();
         	  //System.out.println("model: " + model.toString());
           final List<ModelInstance> collectedInstances = extractInstancesFromModel(model);
           instances.addAll(collectedInstances);
           break;           
        }
       for (final ModelInstance instance : instances) {
           final String toImport = instance.getType();
           if(toImport!=null)
              imports.add(toImport);
       }
		return imports;
	}
	
	/**
    * Given a {@link Model}, this method will extract all instances of
    * {@link ModelInstance} from it.
    * @source: Christopher
    * @param model
    * @return
    */
   private List<ModelInstance> extractInstancesFromModel(final Model model) {

       final List<ModelInstance> instances = new LinkedList<ModelInstance>();
       for (final ModelVariable variable : model.getVariables()) {
           if ((variable.getValue() instanceof ModelInstance) && !(variable.getValue() instanceof ModelArrayInstance)) {
               instances.add((ModelInstance) variable.getValue());
           }
       }
       return instances;
   }	
	
	
	private void writeImport(){
	  /*
       * write the popular imports
       * */
      appendToOutput("import java.io.*;\n");   
      appendToOutput("import java.lang.reflect.*;\n");     
      appendToOutput("import java.util.*;\n");    
  
      /*
       * Write the specific imports.
       */
      //System.out.println("import stuffs:"+ getImports());
      for (final String importt : getImports()) {
          appendToOutput("import ");
          appendToOutput(importt);
          appendToOutput(";\n");
      }
      writeNewLine();
	}
	
	private void writeClassContent(){
		writeClassHeader(null,
						"public",
						"",
						hackingFileName
						);
		writeMainMethod();
		writeGetFieldMethod();
		writeSetFieldMethod();
		writeSetInputsMethod();
		writeReadInputValuesFromFileMethod();
		writePrintObserveOutputValueMethod();
		writeClosingBrace();	
	}
	
	private void writeMainMethod(){
		writeMainMethodHeader();
		writeDeclarations();
		writeExecution();
		writeClosingBrace();	
	}
	
	
	
	private void writeMainMethodHeader(){
		writeMethodHeader(null,
                "public",
                new String[]{"static"},
                "void",
                "main",
                new String[]{"String[] args"},
                new String[]{"NoSuchFieldException", 
							"SecurityException", 
							"IllegalArgumentException", 
							"IllegalAccessException", 
							"NumberFormatException",
							"IOException"});
	}
	
	private void writeDeclarations(){
		//first, declare object
		String declaration = className + " " + OBJECT_NAME + " = new " + className + "();";
		writeIndentedLine(declaration); 
		writeNewLine();
		
		//second, declare list observable variables
		declaration = "String[] observableVars = new String[]{";
		for(String oVar: badMethod.getIFBarrier().getDestination()){
			declaration += "\"" + oVar + "\",";
		}
		declaration = declaration.substring(0,declaration.length()-1) + "};";
		writeIndentedLine(declaration); 
		writeNewLine();
		
		//third, declare highInputFile and lowInputFile
		declaration = "String highInputFile = \"" + highInputFile.getAbsolutePath() + "\";"; 
		writeIndentedLine(declaration); 
		writeNewLine();
		declaration = "String lowInputFile = \"" + lowInputFile.getAbsolutePath() + "\";"; 
		writeIndentedLine(declaration); 
		writeNewLine();		
	}
	
	
	private void writeExecution(){	
		
		String setHighInput = "setInputs(" + OBJECT_NAME + ", readInputValuesFromFile(highInputFile));";
		writeIndentedLine(setHighInput); 
		writeNewLine();
		String setLowInput = "setInputs(" + OBJECT_NAME + ", readInputValuesFromFile(lowInputFile));";
		writeIndentedLine(setLowInput); 
		writeNewLine();
		writeMethodInvocation();
		
		/*writeIndentedLine("System.out.println(\"test\");");
		writeNewLine();*/
		String printOutput = "printObserveOutputValue(" + OBJECT_NAME + ", observableVars);";
		writeIndentedLine(printOutput); 
		writeNewLine();
	}
	
	 /**
	    * write the method invocation
	    */
	   private void writeMethodInvocation() {
	       writeComment("Perform execution ",false);      
	       
	       final String returnType = badMethod.getMethod().getReturnTypeAsString();
	       String methodInvocation = "";
	       if (!returnType.equals("void")) {
	           methodInvocation += returnType + " " + EXECUTION_RESULT + " = ";
	       }
	       
	       methodInvocation += OBJECT_NAME + "." + badMethod.getMethod().getProgramMethod().getName() + "(";
	       final List<IProgramVariable> parameters = badMethod.getMethod().getParameters();

	       for (int i = 0; i < parameters.size(); i++) {
	           final String parameterName = parameters.get(i).name().toString();
	           methodInvocation += parameterName;
	           if (i != (parameters.size() - 1)) {
	               methodInvocation += ",";
	           }
	       }
	       methodInvocation += ");";
	       writeIndentedLine(methodInvocation);
	       writeNewLine();
	   }
	   
	   public String getHackSimulationContent(){
		   try {
			   createHackSimulationContent();
		      }
		      catch (Exception e) {

		         e.printStackTrace();
		      }
		      return getCurrentOutput();
	   }
	   
	   
	   /**
	    * Writes the getField method.
	    * @source: Christopher
	    */
	   private void writeGetFieldMethod() {

	       writeComment("Gets the field of a given object", true);
	       writeMethodHeader(null,
	                         "private",
	                         new String[]{"static","<T>"},
	                         "T",
	                         "getFieldValue",
	                         new String[]{"Object instance", "String fieldName"},
	                         new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});

	       writeIndentedLine("Field field = instance.getClass().getDeclaredField(fieldName);");
	       writeNewLine();

	       writeIndentedLine("field.setAccessible(true);");
	       writeNewLine();

	       writeIndentedLine("return (T)field.get(instance);");
	       writeNewLine();

	       writeClosingBrace();
	   }
	  
	   /**
	    * Writes the setField method.
	    * @source: Christopher
	    */
	   private void writeSetFieldMethod() {

	       writeComment("Sets a field of some object to a given value", true);
	       writeMethodHeader(null,
	                         "private",
	                         new String[]{"static"},
	                         "void",
	                         "setFieldValue",
	                         new String[]{"Object instance", "String fieldName", "Object value"},
	                         new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});

	       writeIndentedLine("Field field = instance.getClass().getDeclaredField(fieldName);");
	       writeNewLine();

	       writeIndentedLine("field.setAccessible(true);");
	       writeNewLine();

	       writeIndentedLine("field.set(instance, value );");
	       writeNewLine();

	       writeClosingBrace();
	              
	   }
	   
	  	   
	   private void writeSetInputsMethod(){
		   writeMethodHeader(null,
                   "private",
                   new String[]{"static"},
                   "void",
                   "setInputs",
                   new String[]{"Object instance", "Map<String, Integer> inputs"},
                   new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});
		   
		   writeIndentedLine("for(String var: inputs.keySet())");
		   writeNewLine();
		   increaseIndentation();
           writeIndentedLine("setFieldValue(instance, var, inputs.get(var));");
           decreaseIndentation();
           writeClosingBrace();
	   }
	   
	  	   
	   private void writeReadInputValuesFromFileMethod(){
		   writeMethodHeader(null,
                   "private",
                   new String[]{"static"},
                   "Map<String, Integer>",
                   "readInputValuesFromFile",
                   new String[]{"String fileName"},
                   new String[]{"NumberFormatException", "IOException"});
		   
		   writeIndentedLine("BufferedReader br = new BufferedReader(new FileReader(new File(fileName)));");
		   writeNewLine();
		   writeIndentedLine("Map<String, Integer> result = new HashMap<String, Integer>();");
		   writeNewLine();
		   writeIndentedLine("int n = Integer.parseInt(br.readLine());");
		   writeNewLine();
		   writeIndentedLine("for(int i=0;i<n;i++){");
		   writeNewLine();
		   increaseIndentation();
           writeIndentedLine("String assignment = br.readLine();");
           writeNewLine();
           writeIndentedLine("String valueString[] = assignment.split(\":\");");
           writeNewLine();
           writeIndentedLine("String var = valueString[0].trim();");
           writeNewLine();
           writeIndentedLine("Integer value = Integer.valueOf(valueString[1].trim());");
           writeNewLine();
           writeIndentedLine("result.put(var, value);");
           writeNewLine();
           decreaseIndentation();
           writeIndentedLine("}");
           writeNewLine();
           writeIndentedLine("br.close();");
           writeNewLine();
           writeIndentedLine("return result;");
           writeNewLine();
           writeClosingBrace();
	   }
	   
	     
	   private void writePrintObserveOutputValueMethod(){
		   writeMethodHeader(null,
                   "private",
                   new String[]{"static"},
                   "void",
                   "printObserveOutputValue",
                   new String[]{"Object instance", "String[] observableVars"},
                   new String[]{"NoSuchFieldException", "SecurityException", "IllegalArgumentException", "IllegalAccessException"});
		   
		   writeIndentedLine("System.out.println(observableVars.length);");
		   writeNewLine();
		   writeIndentedLine("for(String varName: observableVars){");
		   writeNewLine();
		   increaseIndentation();
           writeIndentedLine("Integer value = (Integer)getFieldValue(instance, varName);");
           writeNewLine();
           writeIndentedLine("System.out.println(varName + \":\" + value);");
           writeNewLine();
           decreaseIndentation();
           writeIndentedLine("}");
           writeNewLine();
           writeClosingBrace();
	   }
}
