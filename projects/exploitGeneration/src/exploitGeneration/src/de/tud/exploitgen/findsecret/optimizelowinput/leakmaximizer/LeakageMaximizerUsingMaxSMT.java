package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.input.ReversedLinesFileReader;

import de.tud.exploitgen.findsecret.maxsmt.MaxSMTFile;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTProblem;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTTranslator;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTTranslatorBV;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.settings.ProofIndependentSMTSettings;
import de.uka.ilkd.key.settings.ProofIndependentSettings;
import de.uka.ilkd.key.settings.SMTSettings;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.smt.SMTObjTranslator;
import de.uka.ilkd.key.smt.lang.SMTFile;
import de.uka.ilkd.key.util.Pair;

public class LeakageMaximizerUsingMaxSMT implements LeakageMaximizer {
	/*
	 * postEntropyProblem is max-smt problem that contains low input, it formulates min-entropy after running program
	 * */
	private MaxSMTProblem postEntropyProblem;
	/*
	 * pre entropy problem is problem that does not contain low input (only high input). It formulates min-entropy before running program 
	 * */
	private MaxSMTProblem preEntropyProblem;
	private List<String> listLowVars; // list low variables, serve for extracting optimal low input
	private Services services;
	private final String preMaxSMTfile = "pre.smt2";
	private final String postMaxSMTfile = "post.smt2";
	private MaxSMTTranslatorBV translator;
	public LeakageMaximizerUsingMaxSMT(MaxSMTProblem preEntropyproblem, MaxSMTProblem postEntropyProblem,
			List<String> listLowVars, Services services) {
		super();
		this.postEntropyProblem = postEntropyProblem;
		this.preEntropyProblem = preEntropyproblem;
		this.listLowVars = listLowVars;
		this.services = services;
	}

	private long findMaxPreFrequency() throws IllegalFormulaException{
		PrintStream inFile;
		try {			
			inFile = new PrintStream(new FileOutputStream(preMaxSMTfile));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return -1;
		}
		//create ampl content by AMPLTranslator
		String maxSMTContent = new MaxSMTTranslator(preEntropyProblem, services).translateMaxSMTProblem().toString();
		inFile.print(maxSMTContent );
		inFile.close();
		
		//call solver from ampl command to solve optimization problem
		List<String> command = new ArrayList<String>();
	    command.add("z3");
	    command.add(preMaxSMTfile);
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.redirectOutput(new File("pre_max_smt.out"));	   
	   
	    Process process;
		try {
			process = builder.start();
			process.waitFor();
			process.destroy();	
			//builder.start().getInputStream();
			return readResultFromPreEntropyOutFile("pre_max_smt.out");
		} catch (IOException e) {
			e.printStackTrace();
			return -1;
		} catch (InterruptedException e) {
			e.printStackTrace();
			return -1;
		}
	}
	
	private Pair<Map<String, Long>, Long> findOptimalLowInput() throws IllegalFormulaException{
		PrintStream inFile;
		try {			
			inFile = new PrintStream(new FileOutputStream(postMaxSMTfile));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return null;
		}
		//create ampl content by AMPLTranslator
		MaxSMTFile maxSMTFile = new MaxSMTTranslator(postEntropyProblem, services).translateMaxSMTProblem();
		for(String varName: listLowVars){
			maxSMTFile.addVarName(varName);
		}
		inFile.print(maxSMTFile.toString());
		inFile.close();
		
		//call solver from ampl command to solve optimization problem
		List<String> command = new ArrayList<String>();
	    command.add("z3");
	    command.add(postMaxSMTfile);
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.redirectOutput(new File("post_max_smt.out"));	   
	   
	    Process process;
		try {
			process = builder.start();
			process.waitFor();
			process.destroy();	
			//builder.start().getInputStream();
			return readResultFromPostEntropyOutFile("post_max_smt.out");
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		} catch (InterruptedException e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private long readResultFromPreEntropyOutFile(String fileName) throws IOException{
		//ReversedLinesFileReader rFile = new ReversedLinesFileReader(new File(fileName), 4, Charset.defaultCharset());
		ReversedLinesFileReader rReader = new ReversedLinesFileReader(new File(fileName));		
		try{
			int numOfClauses = preEntropyProblem.getMapMaxSMTClauses2Weight().keySet().size();
			
			for(int i=0;i<numOfClauses;i++){			
				String varValue = rReader.readLine();			
				//separate variable and value
				varValue = varValue.substring(2, varValue.length()-2);
				
				String[] valuePharse = varValue.split(" ");
				//valuePharse[0]: name of clause, varPharse[1]: value (true, false)
				if(valuePharse[1].equals("true")){
					rReader.close();
					return preEntropyProblem.getMapMaxSMTClauses2Weight().get(valuePharse[0]).second;
				}
				
			}
			rReader.close();
			return -1;
		}catch(Exception e){
			e.printStackTrace();
			rReader.close();
			return -1;
		}
		
	}	
	
	private Pair<Map<String, Long>, Long> readResultFromPostEntropyOutFile(String fileName) throws IOException{
		//ReversedLinesFileReader rFile = new ReversedLinesFileReader(new File(fileName), 4, Charset.defaultCharset());
		ReversedLinesFileReader rReader = new ReversedLinesFileReader(new File(fileName));
	
		try{
			Map<String, Pair<Term, Long>> mapMaxSMTClause = postEntropyProblem.getMapMaxSMTClauses2Weight();
			int numOfClauses = mapMaxSMTClause.keySet().size();
			long sumFrequencies = 0;
			//rReader.readLine(); //skip the last line (it is a blank line)
			for(int i=0;i<numOfClauses;i++){			
				String varValue = rReader.readLine();			
				//separate variable and value
				varValue = varValue.substring(2, varValue.length()-2);
				
				String[] valuePharse = varValue.split(" ");
				//valuePharse[0]: name of clause, varPharse[1]: value (true, false)
				if(valuePharse[1].equals("true")){
					sumFrequencies += mapMaxSMTClause.get(valuePharse[0]).second;
				}				
			}
			Map<String, Long> mapLowValue = new HashMap<String, Long>();
			for(int i=0; i< listLowVars.size();i++){
				String varValue = rReader.readLine();			
				//separate variable and value
				
				varValue = varValue.substring(2, varValue.length()-2);
				
				String[] valuePharse = varValue.split(" ");
				mapLowValue.put(valuePharse[0], Long.valueOf(valuePharse[1]));		
			}
			rReader.close();
			return new Pair<Map<String, Long>, Long>(mapLowValue, sumFrequencies);
		}catch(Exception e){
			e.printStackTrace();
			rReader.close();
			return null;
		}
		
	}	
	
	private Pair<Map<String, Long>, Long> readResultFromPostEntropyOutFileBV(String fileName) throws IOException{
		//ReversedLinesFileReader rFile = new ReversedLinesFileReader(new File(fileName), 4, Charset.defaultCharset());
		ReversedLinesFileReader rReader = new ReversedLinesFileReader(new File(fileName));
	
		try{
			Map<String, Pair<Term, Long>> mapMaxSMTClause = postEntropyProblem.getMapMaxSMTClauses2Weight();
			int numOfClauses = mapMaxSMTClause.keySet().size();
			long sumFrequencies = 0;
			//rReader.readLine(); //skip the last line (it is a blank line)
			for(int i=0;i<numOfClauses;i++){			
				String varValue = rReader.readLine();			
				//separate variable and value
				varValue = varValue.substring(2, varValue.length()-2);
				
				String[] valuePharse = varValue.split(" ");
				//valuePharse[0]: name of clause, varPharse[1]: value (true, false)
				if(valuePharse[1].equals("true")){
					sumFrequencies += mapMaxSMTClause.get(valuePharse[0]).second;
				}				
			}
			Map<String, Long> mapLowValue = new HashMap<String, Long>();
			for(int i=0; i< listLowVars.size();i++){
				String varValue = rReader.readLine();			
				//separate variable and value
				
				varValue = varValue.substring(2, varValue.length()-2);
				
				String[] valuePharse = varValue.split(" ");
				String val = valuePharse[1];
				val = val.replace("#", "");
				long x=0;
				long intBound = translator.getTypes().getSort(MaxSMTTranslatorBV.BINT_SORT).getBound();
				if(val.startsWith("b")){
					val = val.replace("b", "");
	
					x = Long.parseLong(val,2);
	
	
	
					if(x >= intBound/2){							
						x = (int) (x - intBound);							
					}						
				
				}else if (val.startsWith("x")){ //start with #x: hex number
					val = val.replace("x", "");
					x = Long.parseLong(val, 16);
					if(x >= intBound/2){							
						x = (int) (x - intBound);							
					}	
				}else
					System.err.println("wrong number format!!");
				

				mapLowValue.put(valuePharse[0], x);		
			}
			rReader.close();
			return new Pair<Map<String, Long>, Long>(mapLowValue, sumFrequencies);
		}catch(Exception e){
			e.printStackTrace();
			rReader.close();
			return null;
		}
		
	}	
	
	
	@Override
	public Pair<Map<String, Long>, Double> findLowInputMaximizingLeakge() {
		try {
			long maxPreFrequency = findMaxPreFrequency();
			//Pair<Map<String, Long>, Long> optimalLowInput = findOptimalLowInput();
			Pair<Map<String, Long>, Long> optimalLowInput = findOptimalLowInputUsingBV();
			if(maxPreFrequency>0 && (optimalLowInput!=null)){
				//compute min-entropy-based leakage
				double leakage = Math.log((double)optimalLowInput.second/(double)maxPreFrequency)/Math.log(2);
				return new Pair<Map<String, Long>, Double>(optimalLowInput.first, leakage);
			}
		} catch (IllegalFormulaException e) {
			e.printStackTrace();
		}
		
		
		return null;
	}
	
	
	/*
	 * use MaxSMTTranslatorBV
	 * */
	private Pair<Map<String, Long>, Long> findOptimalLowInputUsingBV() throws IllegalFormulaException{
		PrintStream inFile;
		try {			
			inFile = new PrintStream(new FileOutputStream(postMaxSMTfile));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return null;
		}
		//create ampl content by AMPLTranslator
		ProofIndependentSMTSettings proofIndependentSettings = ProofIndependentSettings.DEFAULT_INSTANCE.getSMTSettings();
		int intBound = findSuitableIntBound(postEntropyProblem);
		if(intBound>0)
			proofIndependentSettings.intBound = intBound;
		
		 SMTSettings smtsettings = new SMTSettings(services.getProof().getSettings().getSMTSettings(),
	              proofIndependentSettings,services.getProof());
		 
		 translator = new MaxSMTTranslatorBV(smtsettings, services,null);
		MaxSMTFile maxSMTFile = translator.translateMaxSMTProblem(postEntropyProblem);
		for(String varName: listLowVars){
			maxSMTFile.addVarName(varName);
		}
		inFile.print(maxSMTFile.toString());
		inFile.close();
		
		//call solver from ampl command to solve optimization problem
		List<String> command = new ArrayList<String>();
	    command.add("z3");
	    command.add(postMaxSMTfile);
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.redirectOutput(new File("post_max_smt.out"));	   
	   
	    Process process;
		try {
			process = builder.start();
			process.waitFor();
			process.destroy();	
			//builder.start().getInputStream();
			return readResultFromPostEntropyOutFileBV("post_max_smt.out");
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		} catch (InterruptedException e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private int findSuitableIntBound(MaxSMTProblem problem){
		List<Term> listNumTerm = new LinkedList<Term>();
		for(Term t: problem.getListConstraints())
			listNumTerm.addAll(TermUtil.extractNumber(t, services));
		
		for(String clauseName: problem.getMapMaxSMTClauses2Weight().keySet()){
			listNumTerm.addAll(TermUtil.extractNumber(problem.getMapMaxSMTClauses2Weight().get(clauseName).first, services));
		}
		int maxIntBound = -1;
		for(Term numTerm: listNumTerm){
			long num = TermParser.getIntegerValue(numTerm, services);
			if(num<0)
				num=0-num;
			if(num>0){
				int numBit = Long.SIZE - Long.numberOfLeadingZeros(num)+1;
				if(maxIntBound<numBit)
					maxIntBound = numBit;
			}
		}
		return maxIntBound;
	}
	

}
