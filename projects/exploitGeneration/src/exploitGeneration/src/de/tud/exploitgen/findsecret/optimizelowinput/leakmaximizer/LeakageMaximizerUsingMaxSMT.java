package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.input.ReversedLinesFileReader;

import de.tud.exploitgen.findsecret.maxsmt.MaxSMTFile;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTProblem;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTTranslator;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.smt.lang.SMTFile;
import de.uka.ilkd.key.util.Pair;

public class LeakageMaximizerUsingMaxSMT implements LeakageMaximizer {
	/*
	 * postEntropyProblem is max-smt problem that contains low input, it formulates min-entropy after running program
	 * */
	private MaxSMTProblem postEntropyProblem;
	/*
	 * pre entropy problem is problem that does not contain low input (only high input). It formulates min-entropy before running program 
	 * */
	private MaxSMTProblem preEntropyProblem;
	private List<String> listLowVars; // list low variables, serve for extracting optimal low input
	private Services services;
	private final String preMaxSMTfile = "pre.smt2";
	private final String postMaxSMTfile = "post.smt2";
	public LeakageMaximizerUsingMaxSMT(MaxSMTProblem preEntropyproblem, MaxSMTProblem postEntropyProblem,
			List<String> listLowVars, Services services) {
		super();
		this.postEntropyProblem = postEntropyProblem;
		this.preEntropyProblem = preEntropyproblem;
		this.listLowVars = listLowVars;
		this.services = services;
	}

	private long findMaxPreFrequency() throws IllegalFormulaException{
		PrintStream inFile;
		try {			
			inFile = new PrintStream(new FileOutputStream(preMaxSMTfile));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return -1;
		}
		//create ampl content by AMPLTranslator
		String maxSMTContent = new MaxSMTTranslator(preEntropyProblem, services).translateMaxSMTProblem().toString();
		inFile.print(maxSMTContent );
		inFile.close();
		
		//call solver from ampl command to solve optimization problem
		List<String> command = new ArrayList<String>();
	    command.add("z3");
	    command.add(preMaxSMTfile);
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.redirectOutput(new File("pre_max_smt.out"));	   
	   
	    Process process;
		try {
			process = builder.start();
			process.waitFor();
			process.destroy();	
			//builder.start().getInputStream();
			return readResultFromPreEntropyOutFile("pre_max_smt.out");
		} catch (IOException e) {
			e.printStackTrace();
			return -1;
		} catch (InterruptedException e) {
			e.printStackTrace();
			return -1;
		}
	}
	
	private Pair<Map<String, Long>, Long> findOptimalLowInput() throws IllegalFormulaException{
		PrintStream inFile;
		try {			
			inFile = new PrintStream(new FileOutputStream(postMaxSMTfile));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return null;
		}
		//create ampl content by AMPLTranslator
		MaxSMTFile maxSMTFile = new MaxSMTTranslator(postEntropyProblem, services).translateMaxSMTProblem();
		for(String varName: listLowVars){
			maxSMTFile.addVarName(varName);
		}
		inFile.print(maxSMTFile.toString());
		inFile.close();
		
		//call solver from ampl command to solve optimization problem
		List<String> command = new ArrayList<String>();
	    command.add("z3");
	    command.add(postMaxSMTfile);
	    ProcessBuilder builder = new ProcessBuilder(command);
	    builder.redirectOutput(new File("post_max_smt.out"));	   
	   
	    Process process;
		try {
			process = builder.start();
			process.waitFor();
			process.destroy();	
			//builder.start().getInputStream();
			return readResultFromPostEntropyOutFile("post_max_smt.out");
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		} catch (InterruptedException e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private long readResultFromPreEntropyOutFile(String fileName) throws IOException{
		//ReversedLinesFileReader rFile = new ReversedLinesFileReader(new File(fileName), 4, Charset.defaultCharset());
		ReversedLinesFileReader rReader = new ReversedLinesFileReader(new File(fileName));		
		try{
			int numOfClauses = preEntropyProblem.getMapMaxSMTClauses2Weight().keySet().size();
			
			for(int i=0;i<numOfClauses;i++){			
				String varValue = rReader.readLine();			
				//separate variable and value
				varValue = varValue.substring(2, varValue.length()-2);
				
				String[] valuePharse = varValue.split(" ");
				//valuePharse[0]: name of clause, varPharse[1]: value (true, false)
				if(valuePharse[1].equals("true")){
					rReader.close();
					return preEntropyProblem.getMapMaxSMTClauses2Weight().get(valuePharse[0]).second;
				}
				
			}
			rReader.close();
			return -1;
		}catch(Exception e){
			e.printStackTrace();
			rReader.close();
			return -1;
		}
		
	}	
	
	private Pair<Map<String, Long>, Long> readResultFromPostEntropyOutFile(String fileName) throws IOException{
		//ReversedLinesFileReader rFile = new ReversedLinesFileReader(new File(fileName), 4, Charset.defaultCharset());
		ReversedLinesFileReader rReader = new ReversedLinesFileReader(new File(fileName));
	
		try{
			Map<String, Pair<Term, Long>> mapMaxSMTClause = postEntropyProblem.getMapMaxSMTClauses2Weight();
			int numOfClauses = mapMaxSMTClause.keySet().size();
			long sumFrequencies = 0;
			//rReader.readLine(); //skip the last line (it is a blank line)
			for(int i=0;i<numOfClauses;i++){			
				String varValue = rReader.readLine();			
				//separate variable and value
				varValue = varValue.substring(2, varValue.length()-2);
				
				String[] valuePharse = varValue.split(" ");
				//valuePharse[0]: name of clause, varPharse[1]: value (true, false)
				if(valuePharse[1].equals("true")){
					sumFrequencies += mapMaxSMTClause.get(valuePharse[0]).second;
				}				
			}
			Map<String, Long> mapLowValue = new HashMap<String, Long>();
			for(int i=0; i< listLowVars.size();i++){
				String varValue = rReader.readLine();			
				//separate variable and value
				
				varValue = varValue.substring(2, varValue.length()-2);
				
				String[] valuePharse = varValue.split(" ");
				mapLowValue.put(valuePharse[0], Long.valueOf(valuePharse[1]));		
			}
			rReader.close();
			return new Pair<Map<String, Long>, Long>(mapLowValue, sumFrequencies);
		}catch(Exception e){
			e.printStackTrace();
			rReader.close();
			return null;
		}
		
	}	
	
	@Override
	public Pair<Map<String, Long>, Double> findLowInputMaximizingLeakge() {
		try {
			long maxPreFrequency = findMaxPreFrequency();
			Pair<Map<String, Long>, Long> optimalLowInput = findOptimalLowInput();
			if(maxPreFrequency>0 && (optimalLowInput!=null)){
				//compute min-entropy-based leakage
				double leakage = Math.log((double)optimalLowInput.second/(double)maxPreFrequency)/Math.log(2);
				return new Pair<Map<String, Long>, Double>(optimalLowInput.first, leakage);
			}
		} catch (IllegalFormulaException e) {
			e.printStackTrace();
		}
		
		
		return null;
	}
	
	

}
