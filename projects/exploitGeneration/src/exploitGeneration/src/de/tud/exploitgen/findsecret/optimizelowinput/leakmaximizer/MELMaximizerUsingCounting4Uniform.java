package de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingResultTree;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.AMPLSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptLocalSolver;
import de.tud.exploitgen.findsecret.optimizelowinput.optimization.OptimizationSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

public class MELMaximizerUsingCounting4Uniform extends LeakageMaximizerUsingCounting4Uniform{

	public MELMaximizerUsingCounting4Uniform(List<PPCountingResult> listCountingResults,
			Services services, List<String> listLowVars,String optSolver) {
		super(listCountingResults, services, listLowVars, optSolver,null); //we dont need the number of possible high values
		/*
		 * print list of all counting solutions
		 * */
		
		extract2ListMatchableCountingSolution();
	}

	
	/*
	 * compute Min-entropy-leakage for the case all counting term is constant
	 * */
	protected OptimalSolution resolveConstantSolution(MatchableCountingSolution matchCountSolution){
		/*
		 * calculate scaled min-entropy-leakage
		 * because MELeak = log|O_Lj|, we have only one counting term fo each matchable counting solution
		 * */
		double optimizeValue = TermParser.getBigIntegerValue(matchCountSolution.getListCountingSolutions().get(0).getValue(), services).doubleValue();
		
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		return new OptimalSolution(solution, optimizeValue);
	}
	
	
	protected OptimalSolution findGlobalOptimalSolution(List<OptimalSolution> listSolution){
		return findMaximumSolution(listSolution);
	}

	@Override
	protected void extract2ListMatchableCountingSolution() {			
		listMatchableSolutions = new LinkedList<MatchableCountingSolution>();
		for(CountingSolution cSolution: listCountingResults.get(0).getListResults()){
			Term condition = cSolution.getCondition();
			Z3Solver z3 = new Z3Solver(condition, services);
			Pair<Map<String,Long>,Integer> uniqueModel= z3.onlyOneSatisfiableModel(listLowVars);
			if(uniqueModel!=null){
				List<CountingSolution> listCS = new LinkedList<CountingSolution>();
				listCS.add(cSolution);
				if(uniqueModel.second==1) //there is only one model
					listMatchableSolutions.add(new MatchableCountingSolution(listCS, condition,uniqueModel.first,true));
				else
					listMatchableSolutions.add(new MatchableCountingSolution(listCS, condition,uniqueModel.first,false));
			}
		}		
		System.out.println("finish extracting! We found " + listMatchableSolutions.size() + " matchable solutions");		
	}


	@Override
	protected OptimalSolution findOptimalSolution4SingleCase(
			MatchableCountingSolution matchCountSolution) {
		
		return findOptimalSolution4SingleCase(matchCountSolution, KEGConstant.MIN_ENTROPY);

	}


	/*
	 * min-entropy-based leakage = ln(bestSolution.optimalValue)/ln(2)
	 * */
	@Override
	protected double computeLeakage(OptimalSolution bestSolution) {
		return Math.log(bestSolution.getOptimizeValue())/Math.log(2);
	}
	
	/*
	 * add zero result into each PPCountingResult 
	 * */
	protected void resolvePPCountingResult(){		
		for(PPCountingResult countResult: listCountingResults){
			countResult.setListResults(countResult.replaceOrCondition());			
		}		
	}


	@Override
	protected double computeOptimalValueUsingSolution(
			MatchableCountingSolution countingResults,
			Map<String, Long> optSolution) {
		// TODO Auto-generated method stub
		
		Term countTerm= countingResults.getListCountingSolutions().get(0).getValue();		
		double optimizeValue = TermUtil.computeDouble(countTerm, optSolution, services);		
		return optimizeValue;
	}
}

