/**
 * 
 */
package de.tud.exploitgen.processing;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Arrays;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.processing.exploit.ExploitModelBuilder;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.VariableChecker;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
import de.uka.ilkd.key.util.Declassifier;

/**
 * @author Huy Do
 *
 */
public class TwoPathsProcessor {
 private IExecutionNode node1,node2; //two termination nodes representing two branches.   
   
   private KeYJavaMethod method;
   private Services services;
   private VariableChecker vc;
   
   //private String HEAP_NAME=""; //contains name of heap object (started by "self")
   private final TermBuilder termBuilder;
   private final Term tt = new TermFactory().createTerm(Junctor.TRUE);
   
   private ExploitModelBuilder eModelCreator;
   
   //map<heapLowVar, field>: mapping from low variable name to its corresponding field name
   Map<String,String> mapLowVars;
   
   //list of various kind of variables
   PairTermCollection listInputHighVars;
   PairTermCollection listInputNotHighVars;   
   PairTermCollection listOutputLowPairs; //list of pair output low variables (name low_out_...)
   PairTermCollection listOutputLowValues1; //list of output value of low variables at node 1
   PairTermCollection listOutputLowValues2; //list of output value of low variables at node 2   
   
   
   public TwoPathsProcessor(IExecutionNode node1, IExecutionNode node2,KeYJavaMethod method,VariableChecker vc) throws TermTransformerException, ProofInputException {
      super();
      this.node1 = node1;
      this.node2 = node2;
      this.method=method;
      this.vc=vc;
      services=method.getServices();
      termBuilder=new TermBuilder(new TermFactory(), services);
      mapLowVars=new HashMap<String,String>();
      
      /*construct model, serving for two purposes:
       * 1. prepare for lists of variables
       * 2. generate exploit model that can be instantiated by concrete model generated by SMT Solver
       * */      
      eModelCreator=new ExploitModelBuilder(services);      
      eModelCreator.initiateExploitModelFromNode(node1,1);
      eModelCreator.initiateExploitModelFromNode(node2,2);    
     
      
      listInputHighVars = new PairTermCollection(services);
      listInputNotHighVars = new PairTermCollection(services);
      listOutputLowPairs = new PairTermCollection(services);      
      listOutputLowValues1 = new PairTermCollection(services);      
      listOutputLowValues2 = new PairTermCollection(services);    
      
      //prepare materials for generating interference formulas
      constructLists(1);
      constructLists(2);
      resolveOutputLowPairs();
   }
   
   /*
    * construct list of inputs (high, not high and low) from the model created by eModelCreator
    * */
   private void constructLists(int branch) throws ProofInputException{
      Model model=eModelCreator.getModel(branch);
      for(ModelVariable mv : model.getVariables()){
         if(mv.isPrimitive()){ //just check primitive variables, object variables are constructed from primitive variables
            if (vc.isHigh(mv.getVariableName())){
               add2ListInputHighVars(mv);
            }else{
               add2ListInputNotHighVars(mv);
            }
            if(vc.isLow(mv.getVariableName())){
               add2MapLowVars(mv);
               add2ListOutputLowValues(mv,branch);
            }
         }
      }       
   }
   
   /*
    * add to list of input high variables 
    * */
   private void add2ListInputHighVars(ModelVariable mv) throws ProofInputException{
      String varName=mv.getIdentifier();
           
      //if the list of high variable does not contains the variable, add it into the list
      if(!listInputHighVars.contains(varName)){
         /*
          * create two variables which have the same type with this variable and have two different name 
          * (by adding prefix "self_" and suffixes _1 and _2)
         */
         
         LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),mv.getType());
         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),mv.getType());
         
         PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2),services);
         listInputHighVars.add(varName, pair);         
         
      }           
   }
   
   /*
    * add to list of input not high variables 
    * */
   private void add2ListInputNotHighVars(ModelVariable mv) throws ProofInputException{
      String varName=mv.getIdentifier();
           
      //if the list of high variable does not contains the variable, add it into the list
      if(!listInputNotHighVars.contains(varName)){
                  
         LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),mv.getType());
         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),mv.getType());
         
         PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2),services);
         listInputNotHighVars.add(varName, pair);
      }           
   }
   
   /*
    * add to list of input low variables 
    * */
   private void add2MapLowVars(ModelVariable mv) throws ProofInputException{
      String varName=mv.getIdentifier();      //key is the variable name     
      //if the list of high variable does not contains the variable, add it into the list
      if(!mapLowVars.containsKey(varName)){                  
        mapLowVars.put(varName, mv.getVariableName());        //data is the resolved name
      }           
   }
   
   /*
    * add to list of input low variables via branch
    * */
   private void add2ListOutputLowValues(ModelVariable mv, int branch){
      String varName=mv.getIdentifier();
      if(branch==1){
         if(!listOutputLowValues1.contains(varName)){
            LocationVariable lvo=new LocationVariable(new ProgramElementName(varName + "_out_1"),mv.getType());
                       
            PairTerm pair=new PairTerm(termBuilder.var(lvo),mv.getSymbolicValue(),services);
            listOutputLowValues1.add(varName, pair);
         }
      }else{
         if(!listOutputLowValues2.contains(varName)){
            LocationVariable lvo=new LocationVariable(new ProgramElementName(varName + "_out_2"),mv.getType());
                       
            PairTerm pair=new PairTerm(termBuilder.var(lvo),mv.getSymbolicValue(),services);
            listOutputLowValues2.add(varName, pair);
         }
      }    
      
   }
      
   /*
    * synthesis listOutputLowPairs from listOutputLowValues1 and listOutputLowValues2
    * as well as replacing the value term by listInputHighVars and listInputNotHighVars 
    * */
   private void resolveOutputLowPairs(){
      for(String name: listOutputLowValues1.getNameSet()){
         //make pair term of "_out_1" and "_out_2"
         PairTerm pt1=listOutputLowValues1.getPairTerm(name);
         PairTerm pt2=listOutputLowValues2.getPairTerm(name);         
         
         //create pair term of pt1.T1 and pt2.T1 and add it into listOutputLowPairs        
         PairTerm pt=new PairTerm(pt1.getT1(),pt2.getT1(),services);
         listOutputLowPairs.add(name, pt);
         
         //resolve the value term T2
         Term value1=pt1.getT2();
         value1=listInputHighVars.replacePVByNameAndBranch(value1, 1);
         value1=listInputNotHighVars.replacePVByNameAndBranch(value1, 1);
         pt1.setT2(value1);
         
         Term value2=pt2.getT2();
         value2=listInputHighVars.replacePVByNameAndBranch(value2, 2);
         value2=listInputNotHighVars.replacePVByNameAndBranch(value2, 2);
         pt2.setT2(value2);
      }
   }
   
   /*
    * get path condition based on branch, after that resolve it
    * if branch is 1 then return path condition of node1, otherwise return path condition of  node2.
    * */
   private Term getResolvedPathCondition(int branch) throws ProofInputException {
      Term pc;
      if(branch==1)
         pc= node1.getPathCondition();
      else
         pc= node2.getPathCondition();
      //replace all select function in path condition (heap value) by the field
      System.out.println("original path condition: " + pc);
      
      pc=new HeapHandler(services).replaceSelectFunctionByItsField(pc);
      pc=new KeYResourceHandler().removeNotnullDefaultCondition(pc);
      pc=listInputHighVars.replacePVByNameAndBranch(pc, branch);
      pc=listInputNotHighVars.replacePVByNameAndBranch(pc, branch);
      System.out.println("resolved path condition: " + pc);
      return pc;
   }
   
   /**
    * get all preconditions of the method, except default precondition: java.lang.Object::<inv>(heap,self)
    * replace all low and high values in each precondition by corresponding low and high values of the branch
    * return = and(all preconditions)
    * */
   private Term getResolvedPrecondition(int branch){
      //get all preconditions of the method
      Term result = tt;
      List<Term> preconditions = method.getPreconditions();
      System.out.println("HEAP_NAME: " + eModelCreator.getHEAP_NAME());
      for(Term precond: preconditions){         
         
         precond=new KeYResourceHandler().removeDefaultPrecondition(precond);
         
         //System.out.println("after remove default:" + precond);
         /*
          * with precondition, the heap name is always "self", 
          * but if a class contains more than one method, 
          * the heap object of each method could have another name: "self_0", "self_1",...
          * so we have to use the heap name of the method in resolving precondition
          * * */        
         //precond=new HeapHandler(services).replaceSelectFunctionByItsField(precond,eModelCreator.getHEAP_NAME());        
         precond=new HeapHandler(services).replaceSelectFunctionByItsField(precond,eModelCreator.getHEAP_NAME());
      
         precond=listInputHighVars.replacePVByNameAndBranch(precond, branch);
         precond=listInputNotHighVars.replacePVByNameAndBranch(precond, branch);
         
         result = termBuilder.and(result,precond);        
      }     
      return result;
   }
   
   /**
    * get declassification formula
    * it has the form: escape(h1,l1)=escape(h2,l2)
    * */
   private Term getEscapeHatchEqualTerm(){
      if(method.hasEscapeHatchTerms()){
         
       //get all declassification terms
         List<Term> declassificationTerms = method.getSeparatedEscapeHatchTerms();
             
         PairTermCollection pcd=new PairTermCollection(services);
         
         for(int i=0; i<declassificationTerms.size();i++){
            
             /* basically, element i and element i+1 of list declassificationTerms are the same
             * so, we use element i to compare with branch 1(l1_out) and use element i+1 to compare with branch 2 (l2_out)               * 
             */ 
            Term declass1=declassificationTerms.get(i);
            Term declass2=declassificationTerms.get(i);
            //System.out.println("declass1: "+ declass1);
            //resolve declass1 and declass2: remove select phrase, replace variables by corresponding variables in two branches
            
             /* with declassification, the heap name is always "self", 
             * but if a class contains more than one method,
             * the heap object of each method could have another name: "self_0", "self_1",...
             * so we have to use the heap name of the method in resolving declassification
             * */      
            declass1=new HeapHandler(services).replaceSelectFunctionByItsField(declass1,eModelCreator.getHEAP_NAME());
            declass2=new HeapHandler(services).replaceSelectFunctionByItsField(declass2,eModelCreator.getHEAP_NAME());
            
            declass1=listInputHighVars.replacePVByNameAndBranch(declass1, 1);
            declass1=listInputNotHighVars.replacePVByNameAndBranch(declass1, 1);
            
            declass2=listInputHighVars.replacePVByNameAndBranch(declass2, 2);
            declass2=listInputNotHighVars.replacePVByNameAndBranch(declass2, 2);
            
            //create new PairTerm (declass1, declass2) and add it into pcd1
            pcd.add(String.valueOf(i), new PairTerm(declass1,declass2,services));
         }
         return pcd.totalEqualTerm();
      }      
      
      /*if(method.hasEscapeHatchTerms())
         System.out.println("escape clause: " + method.getSeparatedEscapeHatchTerms().get(0));
      else
         System.out.println("escape clause: null");*/
      return termBuilder.tt();
   }
   
   /**
    * get declassification term specified by conditional delimited release
    * we have a list of declassification: ImmutableList<Declassifier>
    * each declassification D has the format: \if C \escapes E
    *    C: the conditional (logical formula)
    *    E: the expressions that are allowed to leak if C holds.
    * The term claiming that program does not satisfy declassification D (so that it is insecure)
    * has the format: C(h1,l1) && C(h2,l2) && (E(h1,l1)=E(h2,l2))
    *    C(hi,li) means \exists c \in C: c(hi,li),
    *    Equation (E(h1,l1)=E(h2,l2)) means \forall e \in E: e(h1,l1) = e(h2,l2)
    * The synthesized formula is:
    * \exists D: C(h1,l1) && C(h2,l2) && (E(h1,l1)=E(h2,l2))  
    * */
   private Term getDeclassificationTerm(){
      if(method.hasDeclassifies()){         
         Term result=termBuilder.ff();
         
         ImmutableList<Declassifier> declassifies = method.getDeclassifies();  
         //System.out.println("declassifies : <><><>: " + declassifies);
         for(Declassifier decl: declassifies){
            ImmutableList<Term> conditions = decl.conditions;
            //System.out.println("conditions : <><><>: " + conditions);
            ImmutableList<Term> leaks = decl.leaks;
            //System.out.println("leaks : <><><>: " + leaks);
            /*
             * solve conditions, if there are more than one conditions, then we use conjunction "or"
             * */
            Term conditionTerm1=termBuilder.tt();
            Term conditionTerm2;
            if(conditions.size()>0){
               Term[] arrayCond = new Term[conditions.size()];
               conditions.toArray(arrayCond);
               conditionTerm1 = arrayCond[0];               
               for(int i=1; i< arrayCond.length; i++ ){
                  conditionTerm1 = termBuilder.or(conditionTerm1,arrayCond[i]);                  
               }               
            }
            //resolve conditionTerm with two paths
            conditionTerm1 = new HeapHandler(services).replaceSelectFunctionByItsField(conditionTerm1, eModelCreator.getHEAP_NAME());
            conditionTerm2 = conditionTerm1;
            conditionTerm1 = listInputHighVars.replacePVByNameAndBranch(conditionTerm1, 1);
            conditionTerm1 = listInputNotHighVars.replacePVByNameAndBranch(conditionTerm1, 1);
            conditionTerm2 = listInputHighVars.replacePVByNameAndBranch(conditionTerm2, 2);
            conditionTerm2 = listInputNotHighVars.replacePVByNameAndBranch(conditionTerm2, 2);
            System.out.println("conditionTerm1 : <><><>: " + conditionTerm1);
            System.out.println("conditionTerm2 : <><><>: " + conditionTerm2);
            
            /*
             * solve leakable expression, because we have to build equation \forall e \in E: e(h1,l1)=e(h2,l2),
             * we will use PairTermCollection
             * */
            PairTermCollection pairLeakTerms = new PairTermCollection(services);
            for(Term leakTerm: leaks){
               Term declass1=leakTerm;
               Term declass2=leakTerm;
                              
                /* with declassification, the heap name is always "self", 
                * but if a class contains more than one method,
                * the heap object of each method could have another name: "self_0", "self_1",...
                * so we have to use the heap name of the method in resolving declassification
                * */      
               declass1=new HeapHandler(services).replaceSelectFunctionByItsField(declass1,eModelCreator.getHEAP_NAME());
               declass2=new HeapHandler(services).replaceSelectFunctionByItsField(declass2,eModelCreator.getHEAP_NAME());
               
               declass1=listInputHighVars.replacePVByNameAndBranch(declass1, 1);
               declass1=listInputNotHighVars.replacePVByNameAndBranch(declass1, 1);
               
               declass2=listInputHighVars.replacePVByNameAndBranch(declass2, 2);
               declass2=listInputNotHighVars.replacePVByNameAndBranch(declass2, 2);
               
               //create new PairTerm (declass1, declass2) and add it into pcd1
               pairLeakTerms.add(leakTerm.toString(), new PairTerm(declass1,declass2,services));
            }
            Term leakTerm = pairLeakTerms.totalEqualTerm();
            System.out.println("leakTerm : <><><>: " + leakTerm);
            /*
             * integrate conditionTerm and leakTerm into result:
             * result = and(result, and(conditionTerm1, conditionTerm2, leakTerm))
             */
            result = termBuilder.or(result, 
                                      termBuilder.and(conditionTerm1, conditionTerm2, leakTerm));
            
         }
         return result;
      }
      return termBuilder.tt();
   }
   
   /**
    * get leak condition of a Declassifier specification (declassify E \if C), based on branch
    * output format: c1(hi,li) or c2(hi,li) or ... (ci \in C)
    * */
   private Term getLeakCondition(Declassifier decl, int branch){
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm=termBuilder.tt();     
         Term[] arrayCond = new Term[conditions.size()];
         conditions.toArray(arrayCond);
         conditionTerm = arrayCond[0];    
         /*
          * solve conditions, if there are more than one conditions, then we use conjunction "or"
          * */
         for(int i=1; i< arrayCond.length; i++ ){
            conditionTerm = termBuilder.or(conditionTerm,arrayCond[i]);                  
         }
         conditionTerm = new HeapHandler(services).replaceSelectFunctionByItsField(conditionTerm, eModelCreator.getHEAP_NAME());
         if(branch==1){          
            conditionTerm = listInputHighVars.replacePVByNameAndBranch(conditionTerm, 1);
            conditionTerm = listInputNotHighVars.replacePVByNameAndBranch(conditionTerm, 1);
         }else{
            conditionTerm = listInputHighVars.replacePVByNameAndBranch(conditionTerm, 2);
            conditionTerm = listInputNotHighVars.replacePVByNameAndBranch(conditionTerm, 2);
         }
         
         return conditionTerm;
      }
      return termBuilder.tt();
   }
   
   private Term getLeakEqualTerm(Declassifier decl){
      ImmutableList<Term> leaks = decl.leaks;
      /*
       * solve leakable expression, because we have to build equation \forall e \in E: e(h1,l1)=e(h2,l2),
       * we will use PairTermCollection
       * */
      if(leaks.size()>0){
         PairTermCollection pairLeakTerms = new PairTermCollection(services);
         for(Term leakTerm: leaks){
            Term declass1=leakTerm;
            Term declass2=leakTerm;
                           
             /* with declassification, the heap name is always "self", 
             * but if a class contains more than one method,
             * the heap object of each method could have another name: "self_0", "self_1",...
             * so we have to use the heap name of the method in resolving declassification
             * */      
            declass1=new HeapHandler(services).replaceSelectFunctionByItsField(declass1,eModelCreator.getHEAP_NAME());
            declass2=new HeapHandler(services).replaceSelectFunctionByItsField(declass2,eModelCreator.getHEAP_NAME());
            
            declass1=listInputHighVars.replacePVByNameAndBranch(declass1, 1);
            declass1=listInputNotHighVars.replacePVByNameAndBranch(declass1, 1);
            
            declass2=listInputHighVars.replacePVByNameAndBranch(declass2, 2);
            declass2=listInputNotHighVars.replacePVByNameAndBranch(declass2, 2);
            
            //create new PairTerm (declass1, declass2) and add it into pcd1
            pairLeakTerms.add(leakTerm.toString(), new PairTerm(declass1,declass2,services));
         }
         return pairLeakTerms.totalEqualTerm();
      }
      
      return termBuilder.tt();
   }
   
   /**
    * create formula to check non-interference property by checking the output value of low variable lowVar
    * the formula will be created from two branches and the collection of high variables and low variables
    * it is based on the idea that one program is non-interference if the output of low variables are different
    * if the input of high variables are changed.
    * We do it by checking two branches (may be different branches, may be the same)
    * the formula looks like below:
    * 
    * PreCon(h1s,l1s) && PreCon(h2s,l2s) && PC1(h1s,l1s)&& PC2(h2s,l2s) 
    * && (h1s!=h2s) && (l1s==l2s) && (louVar_out_1)!=lowVar_out_2) 
    * && l1_outs=runPC1(h1s,l1s) && l2_outs=runPC2(h2s,l2s)
    * && Declassify(1,2)
    * 
    * in which: 
    * PreCon is precondition of the method
    * PC1 and PC2 are path conditions of two corresponding branches.
    * h1s, h2s: the collection of the input of high variables for two corresponding branches
    * l1s, l2s: the collection of the input of low variables for two corresponding branches
    * l1_outs, l2_outs: the collection of the output of low variables for two corresponding branches
    * lowVar_out_1, lowVar_out_2: two output values of lowVar at two braches
    * (lowVar_out_1 in l1_outs, lowVar_out_2 in l2_outs)
    * (Declassify(1,2): declassification formula, which claim that the value of an arbitrary expression e (e in D: the set of all escapes expression)
    * interpreted in path 1 and path 2 are equal.
    *   
    */
  
   public Map<String,Term> getAllInterferenceFormula() throws ProofInputException{
	   Map<String,Term> result=new HashMap<String,Term>();
	     
	      Term equalNotHighInput = listInputNotHighVars.totalEqualTerm();
	      System.out.println("********************************************");
	      System.out.println("equalNotHighInput: " + equalNotHighInput);
	      //Term notEqualHighInput = listHighInputs.partialNotEqualTerm();      
	      //Term declassification = getEscapeHatchEqualTerm();
	      //Term declassification = getDeclassificationTerm();
	      //System.out.println("declassification: " + declassification);
	      Term preCond1=getResolvedPrecondition(1); //precondition interpreted in path 1
	      System.out.println("preCond1: " + preCond1);
	      Term preCond2=getResolvedPrecondition(2);//precondition interpreted in path 2
	      System.out.println("preCond2: " + preCond2);
	      Term pathCond1=getResolvedPathCondition(1); ////path condition of path 1
	      System.out.println("pathCond1: " + pathCond1);
	      Term pathCond2=getResolvedPathCondition(2); ////path condition of path 1
	      System.out.println("pathCond2: " + pathCond2);
	      //generate interference formula to check if secret infor can be leaked throw lowVar or not
	      for(String lowVar: mapLowVars.keySet()){
	         Term valueLowOutput1 = listOutputLowValues1.getPairTerm(lowVar).equalTerm();
	         Term valueLowOutput2 = listOutputLowValues2.getPairTerm(lowVar).equalTerm();
	         Term notEqualLowOutput = listOutputLowPairs.getPairTerm(lowVar).notEqualTerm();
	         
	         System.out.println("**********************");
	         System.out.println("low output value 1: " + valueLowOutput1);
	         System.out.println("low output value 2: " + valueLowOutput2);
	         System.out.println("notEqualLowOutput: " + notEqualLowOutput);
	         System.out.println("**********************");
	         
	         Term leakTerm = termBuilder.tt();
	         Term interferenceTerm = termBuilder.and(preCond1, preCond2, pathCond1,pathCond2,
	               equalNotHighInput,notEqualLowOutput,valueLowOutput1,valueLowOutput2);
	                  
	         /* get all declassifier and synthesize to make interference formula*/         
	         ImmutableList<Declassifier> declassifies = method.getDeclassifies();
	        
	         if(declassifies.size()>0){
	            for(Declassifier decl: declassifies){
	               Term leakCondition1 = getLeakCondition(decl, 1);
	               Term leakCondition2 = getLeakCondition(decl, 2);
	               Term satLeakCondition = termBuilder.and(interferenceTerm,
	                                                      leakCondition1,
	                                                      leakCondition2,
	                                                      getLeakEqualTerm(decl));
	               Term unsatLeakCondition = termBuilder.and(interferenceTerm,
	                                                         termBuilder.or(termBuilder.not(leakCondition1),
	                                                                        termBuilder.not(leakCondition2))
	                                                         );
	               leakTerm = termBuilder.and(leakTerm,
	                                          termBuilder.or(satLeakCondition,unsatLeakCondition));
	            }
	         }
	            
	         System.out.println("leakTerm:^^^: \n" + leakTerm);        
	         result.put(mapLowVars.get(lowVar), leakTerm);         
	      }
	      
	      return result;
   }
   
   public ExploitModel getExploitModel(){      
      return eModelCreator.getExploitModel();      
   }
   
   public ExploitModelBuilder getExploitModelCreator(){
      return eModelCreator;
   }
}
