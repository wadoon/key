package de.tud.exploitgen.findsecret;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelArrayInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.uka.ilkd.key.proof.init.ProofInputException;

public class SIFactory {
	private BadMethod badMethod;
	private KeYJavaClass javaClass;
	private File javaFile;
	private final String HACK_FOLDER = "hack"; //the prefix name for hack folder, contains hacking simulation file
	public SIFactory(File javaFile, BadMethod badMethod,
			KeYJavaClass javaClass) throws ProofInputException {
		super();
		this.javaFile = javaFile;
		this.badMethod = badMethod;
		this.javaClass = javaClass;
		
	}
	
	
	
	/*
	 * create hacking program for bad method
	 * */
	public File createHackingProgram(){
		 File folder=createHackFolder();
	      String javaPackage=folder.getName();	 
	      String hackingFileName = createHackingClassName();
	      File highInputFile = makeHighInputFile();
	      File lowInputFile = makeLowInputFile();
	      File hackFile=new File(folder,hackingFileName+".java");	   
	      HashSet<String> imports = getImports();
	      try {
	         //BufferedWriter writer = new BufferedWriter(new FileWriter(testFile));
	         BufferedWriter writer = Files.newBufferedWriter(Paths.get(hackFile.getPath()), StandardCharsets.UTF_8);         
	         String javaTextHackCode = new SISimulationGenerator(javaPackage, 
	        		 												hackingFileName, 
	        		 												imports, 
	        		 												badMethod, 
	        		 												highInputFile, 
	        		 												lowInputFile)
	         																	.getHackSimulationContent();
 			
	         writer.write(javaTextHackCode);
	         writer.close();
	         System.out.println("hacking simulation program has been created at:\n" + hackFile.toString());	        
	      }	      
	      catch (IOException e) {
	         System.out.println("error in creating hacking file");
	         e.printStackTrace();
	      }
	      //try to compile hack file
	      Process process;
		try {
			/*we assume that all object types are defined by user in the same package with javaFile*/
			File parentFolder = javaFile.getParentFile().getParentFile();
			String compileClass = "";
			for(String importClass: imports){
				String importFile = importClass.replace(".", File.separator);
				compileClass += " " + parentFolder.getAbsolutePath() + File.separator + importFile + ".java";
			}
			System.out.println("javac " + hackFile + compileClass);
			process = Runtime.getRuntime().exec(/*"javac " + hackFile + " " + javaFile.getAbsolutePath()*/"javac " + hackFile + compileClass);
			process.waitFor();
			System.out.println("hacking file has been compiled!");
		} catch (IOException e) {			
			// TODO Auto-generated catch block			
			e.printStackTrace();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 return hackFile;
	}
	
	public String createHackingClassName(){
		return javaClass.getName()+ "_" + badMethod.getMethod().getName()+ "_SecretInferSimulator";
	}	
	 /**
	    * return the folder contains JUnit test.
	    * at the moment, we place the test folder in the same directory with the folder containing Java source needed be tested
	    * the name of the folder is the name of Java source's folder, prefixed by TEST_FOLDER
	    * */
   public File createHackFolder(){
      File folder=new File(javaFile.getParentFile().getParent()+File.separator+HACK_FOLDER+javaFile.getParentFile().getName());
      if(!folder.exists())
         folder.mkdir();
      return folder;
   }  
   
   
   public File makeHighInputFile(){
	   File folder = createHackFolder();
	   String highInputFileName = javaClass.getName()+"_" + badMethod.getMethod().getName() + "_HighInput.in";
	   return new File(folder,highInputFileName);
   }
   
   public File makeLowInputFile(){
	   File folder = createHackFolder();
	   String lowInputFileName =  javaClass.getName()+"_" + badMethod.getMethod().getName() + "_LowInput.in";
	   return new File(folder,lowInputFileName);
   }
   
   /*
    * create log file that help collecting data for experiments
    * */
   public File createLogFile(){
	   File folder = createHackFolder();
	   String highInputFileName = javaClass.getName()+"_" + badMethod.getMethod().getName() + "_Experiments.log";
	   return new File(folder,highInputFileName);
   }
   
   public File createIsccFile(){
	   File folder = createHackFolder();
	   String isccInputFile = javaClass.getName()+"_" + badMethod.getMethod().getName() + "_IsccInput.txt";
	   return new File(folder,isccInputFile);

   }
   
   private HashSet<String> getImports(){
		HashSet<String> imports = new HashSet<String>();
	    
      final List<ModelInstance> instances = new LinkedList<ModelInstance>();       
    
      for (final RiskyPath riskyNode : badMethod.getListRiskyPaths()) {
          Model model = riskyNode.getModelNode().getModel();
        	  //System.out.println("model: " + model.toString());
          final List<ModelInstance> collectedInstances = extractInstancesFromModel(model);
          instances.addAll(collectedInstances);
          break;           
       }
      for (final ModelInstance instance : instances) {
          final String toImport = instance.getType();
          if(toImport!=null)
             imports.add(toImport);
      }
		return imports;
	}
   /**
    * Given a {@link Model}, this method will extract all instances of
    * {@link ModelInstance} from it.
    * @source: Christopher
    * @param model
    * @return
    */
   private List<ModelInstance> extractInstancesFromModel(final Model model) {

       final List<ModelInstance> instances = new LinkedList<ModelInstance>();
       for (final ModelVariable variable : model.getVariables()) {
           if ((variable.getValue() instanceof ModelInstance) && !(variable.getValue() instanceof ModelArrayInstance)) {
               instances.add((ModelInstance) variable.getValue());
           }
       }
       return instances;
   }
   
   }
