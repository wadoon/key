/**
 * 
 */
package de.tud.exploitgen.solver;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.uka.ilkd.key.gui.configuration.ProofIndependentSettings;
import de.uka.ilkd.key.gui.smt.ProofDependentSMTSettings;
import de.uka.ilkd.key.gui.smt.ProofIndependentSMTSettings;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Sequent;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.gui.smt.SMTSettings;
import de.uka.ilkd.key.gui.testgen.TestGenerationSettings;
import de.uka.ilkd.key.smt.SMTObjTranslator;
import de.uka.ilkd.key.smt.SMTProblem;
import de.uka.ilkd.key.smt.SMTSolverResult;
import de.uka.ilkd.key.smt.SmtLib2Translator;
import de.uka.ilkd.key.smt.SolverLauncher;
import de.uka.ilkd.key.smt.SolverLauncherListener;
import de.uka.ilkd.key.smt.SolverTimeout;
import de.uka.ilkd.key.smt.SolverType;
import de.uka.ilkd.key.smt.AbstractSMTTranslator.Configuration;
import de.uka.ilkd.key.smt.model.Model;
import de.uka.ilkd.key.smt.SmtLibTranslator;
import de.uka.ilkd.key.smt.SMTSolver;
import de.uka.ilkd.key.testgen.ProofInfo;
/**
 * @author Huy Do
 *
 */
public class SMTLibSolver extends AbstractFormulaSolver implements SolverLauncherListener{
   private Services services;
   public SMTLibSolver(final Term formula, Services services){
      super(formula);
      this.services = services;
   }

   @Override
   public Map<String, Integer> solveFormulaInt() {
      // TODO Auto-generated method stub
      return null;
   }

   @Override
   public List<ModelVariable> solveFormula() {
      // TODO Auto-generated method stub
      
      return null;
   }
   
   public StringBuffer translate2SMTLib2(Services services) throws IllegalFormulaException{   
      
     
      //Vector<QuantifiableVariable> boundVars = new Vector<QuantifiableVariable>();
      SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());
      //SmtLib2Translator smt = new SmtLib2Translator(services,new Configuration(false,false));
      SMTObjTranslator smt = new SMTObjTranslator(settings,services,new ProofInfo(services.getProof()));
      return smt.translateProblem(formula, services, settings);                  
   }
   
   public StringBuffer translate2SMTLib(Services services) throws IllegalFormulaException{
      SmtLibTranslator smt = new SmtLibTranslator(services,new Configuration(false,false));
      Vector<QuantifiableVariable> boundVars = new Vector<QuantifiableVariable>();
      SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());
      
      return smt.translateProblem(formula, services, settings);     
   }
   
   public void export2SMTLib2File(Services services, String fileName){
      
   }
   
   public SMTSolverResult getFinalResult(Services services){
      SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());
      SMTSolver ss = SolverType.Z3_CE_SOLVER.createSolver(new SMTProblem(formula), new SolverLauncher(settings), services);      
      return ss.getFinalResult();
      
   }
   
   public String getSolverOutput(){
      /*SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());*/
      //SMTSolver ss = SolverType.Z3_CE_SOLVER.createSolver(new SMTProblem(formula), new SolverLauncher(settings), services);
      //ss.start(new SolverTimeout(ss, 10000), settings);
     launch();
     return "DONE";
   }
   
   /**
    * Try finding a model for the term with z3.
    */
   public void launch(){
      System.out.println("Launch");
      SolverLauncher launcher = prepareLauncher();
      SolverType solver = SolverType.Z3_CE_SOLVER;
      if(SolverType.Z3_CE_SOLVER.isInstalled(true)){
         System.out.println("Z3 is installed");
      }
      
      //FIXME: link to z3.exe should be a global parameter and must be loaded whenever KEG is loaded
      solver.setSolverCommand("D:\\Working\\Tools\\SMTSolvers\\z3\\bin\\z3.exe");
      if(SolverType.Z3_CE_SOLVER.isInstalled(true)){
         System.out.println("Z3 is installed");
      }
      SMTProblem problem = new SMTProblem(formula);
      launcher.addListener(this);
      
      final List<SolverType> solvers = new LinkedList<SolverType>();
      solvers.add(SolverType.Z3_CE_SOLVER);
      
      final List<SMTProblem> problems = new LinkedList<SMTProblem>();
      problems.add(problem);
      
      launcher.launch(solvers, problems, services);
      
     // launcher.launch(problem, services, solver);      
   }
   
   /**
    * Creates a SolverLauncher with the appropriate settings.
    * @return
    */
   private SolverLauncher prepareLauncher(){
      TestGenerationSettings settings = ProofIndependentSettings.DEFAULT_INSTANCE.getTestGenerationSettings();
      final ProofIndependentSMTSettings piSettings = ProofIndependentSettings.DEFAULT_INSTANCE.getSMTSettings().clone();
      

      piSettings.setMaxConcurrentProcesses(1);
      final ProofDependentSMTSettings pdSettings = ProofDependentSMTSettings.getDefaultSettingsData();
      pdSettings.invariantForall = settings.invaraiantForAll();
      // invoke z3 for counterexamples
      final SMTSettings smtsettings = new SMTSettings(pdSettings,
            piSettings, null);
      return new SolverLauncher(smtsettings);
   }

   @Override
   public void launcherStopped(SolverLauncher launcher,
         Collection<SMTSolver> finishedSolvers) {
      System.out.println("Stopped!!");
      for(SMTSolver solver : finishedSolvers){   
         System.out.println("found solver::");
         SMTSolverResult result = solver.getFinalResult();
         if(result.equals(SMTSolverResult.ThreeValuedTruth.FALSIFIABLE) ){
            System.out.println("formula is solvable!");
            System.out.println(solver.getSolverOutput());
            Model model = solver.getSocket().getQuery().getModel();                     
         }
         else{
            System.out.println("formula is unsolvable!");           
         }        
         finish();
      }      
      
   }

   @Override
   public void launcherStarted(Collection<SMTProblem> problems,
         Collection<SolverType> solverTypes, SolverLauncher launcher) {
      System.out.println("\nStarted: ");
      for(SMTProblem p : problems){
         System.out.println(p.getTerm());
      }
      
   }
   
   private void finish(){
      System.out.println("\n\nFinished:\n");      
   }
   
   
}
