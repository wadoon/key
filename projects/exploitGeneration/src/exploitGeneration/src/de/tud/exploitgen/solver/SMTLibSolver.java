/**
 * 
 */
package de.tud.exploitgen.solver;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
//import java.util.Vector;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.microsoft.z3.BoolExpr;
import com.microsoft.z3.Context;
import com.microsoft.z3.Model;
import com.microsoft.z3.Solver;
import com.microsoft.z3.Status;
import com.microsoft.z3.Z3Exception;

import de.uka.ilkd.key.gui.configuration.ProofIndependentSettings;
import de.uka.ilkd.key.gui.smt.ProofDependentSMTSettings;
import de.uka.ilkd.key.gui.smt.ProofIndependentSMTSettings;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
//import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.gui.smt.SMTSettings;
import de.uka.ilkd.key.gui.testgen.TestGenerationSettings;
import de.uka.ilkd.key.smt.SMTObjTranslator;
import de.uka.ilkd.key.smt.SMTProblem;
import de.uka.ilkd.key.smt.SMTSolverResult;
import de.uka.ilkd.key.smt.SolverLauncher;
import de.uka.ilkd.key.smt.SolverLauncherListener;
import de.uka.ilkd.key.smt.SolverType;
import de.uka.ilkd.key.smt.AbstractSMTTranslator.Configuration;
//import de.uka.ilkd.key.smt.model.Model;
import de.uka.ilkd.key.smt.SmtLibTranslator;
import de.uka.ilkd.key.smt.SMTSolver;
import de.uka.ilkd.key.testgen.ProofInfo;
/**
 * @author Huy Do
 *
 */
public class SMTLibSolver implements SolverLauncherListener{
   private Services services;
   private Term formula;
   Context ctx;
   public SMTLibSolver(final Term formula, Services services){
      //super(formula);
      this.formula = formula;
      this.services = services;
      HashMap<String, String> cfg = new HashMap<String, String>();
      cfg.put("proof", "true"); 
      try {
         ctx = new Context(cfg);
      }
      catch (Z3Exception e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
   }

   //@Override
   public Map<String, Integer> solveFormulaInt() {
      // TODO Auto-generated method stub
      return null;
   }

   //@Override
   public List<ModelVariable> solveFormula() {
      // TODO Auto-generated method stub
      try {
         export2SMTLib2File("D:\\smtlib", "l");
         //BoolExpr formulaExpr = ctx.ParseSMTLIB2File(translate2SMTLib2().toString(), null, null, null, null);
         BoolExpr formulaExpr = ctx.ParseSMTLIB2File("D:\\smtlib\\l.smt2", null, null, null, null);
         System.out.println("formula parsed form SMTLib2 String:\n" + formulaExpr);
         Model model=check(ctx,formulaExpr,Status.SATISFIABLE);
         if(model!=null){
            System.out.println("SATISFIABLE!");
            System.out.println(model);
         }
         else
            System.out.println("UNSATISFIABLE!!!!");
            
      }
      catch (Z3Exception | IllegalFormulaException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
      catch (IOException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
      }
      return null;
   }
   
   public StringBuffer translate2SMTLib2() throws IllegalFormulaException{   
      
     
      //Vector<QuantifiableVariable> boundVars = new Vector<QuantifiableVariable>();
      SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());
      //SmtLib2Translator smt = new SmtLib2Translator(services,new Configuration(false,false));
      SMTObjTranslator smt = new SMTObjTranslator(settings,services,new ProofInfo(services.getProof()));
      return smt.translateProblem(formula, services, settings);                  
   }
   
   public StringBuffer translate2SMTLib() throws IllegalFormulaException{
      SmtLibTranslator smt = new SmtLibTranslator(services,new Configuration(false,false));
      //Vector<QuantifiableVariable> boundVars = new Vector<QuantifiableVariable>();
      SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());
      
      return smt.translateProblem(formula, services, settings);     
   }
   
   public void export2SMTLib2File(String directory, String fileName) throws IOException, IllegalFormulaException{ 
      File folder=new File(directory);
      if(!folder.exists())
         folder.mkdir();
      File smtFile;
      while(true){
         smtFile=new File(folder,fileName+".smt2");
         if(smtFile.exists() && !smtFile.isDirectory()){
            fileName = fileName+"1";
            smtFile=new File(folder,fileName+".smt2");          
         }else
            break;
      }
      BufferedWriter writer = Files.newBufferedWriter(Paths.get(smtFile.getPath()), StandardCharsets.UTF_8);             
      writer.write(translate2SMTLib2().toString());
      writer.close();
   }
   
   public SMTSolverResult getFinalResult(){
      SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());
      SMTSolver ss = SolverType.Z3_CE_SOLVER.createSolver(new SMTProblem(formula), new SolverLauncher(settings), services);      
      return ss.getFinalResult();
      
   }
   
   public String getSolverOutput(){
      /*SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());*/
      //SMTSolver ss = SolverType.Z3_CE_SOLVER.createSolver(new SMTProblem(formula), new SolverLauncher(settings), services);
      //ss.start(new SolverTimeout(ss, 10000), settings);
     launch();
     return "DONE";
   }
   
   /**
    * Try finding a model for the term with z3.
    */
   public void launch(){
      System.out.println("Launch");
      SolverLauncher launcher = prepareLauncher();
      SolverType solver = SolverType.Z3_CE_SOLVER;
      if(SolverType.Z3_CE_SOLVER.isInstalled(true)){
         System.out.println("Z3 is installed");
      }
      
      //FIXME: link to z3.exe should be a global parameter and must be loaded whenever KEG is loaded
      solver.setSolverCommand("D:\\Working\\Tools\\SMTSolvers\\z3\\bin\\z3.exe");
      if(SolverType.Z3_CE_SOLVER.isInstalled(true)){
         System.out.println("Z3 is installed: "+solver.getSolverCommand());
      }
      SMTProblem problem = new SMTProblem(formula);
      System.out.println("SMTProblem::: \n"+problem.getTerm());
      launcher.addListener(this);
      
      final List<SolverType> solvers = new LinkedList<SolverType>();
      solvers.add(SolverType.Z3_CE_SOLVER);
      
      final List<SMTProblem> problems = new LinkedList<SMTProblem>();
      problems.add(problem);
      
      launcher.launch(solvers, problems, services);
      
     // launcher.launch(problem, services, solver);      
   }
   
   /**
    * Creates a SolverLauncher with the appropriate settings.
    * @return
    */
   private SolverLauncher prepareLauncher(){
      TestGenerationSettings settings = ProofIndependentSettings.DEFAULT_INSTANCE.getTestGenerationSettings();
      final ProofIndependentSMTSettings piSettings = ProofIndependentSettings.DEFAULT_INSTANCE.getSMTSettings().clone();
      

      piSettings.setMaxConcurrentProcesses(1);
      
      final ProofDependentSMTSettings pdSettings = ProofDependentSMTSettings.getDefaultSettingsData();
      
      pdSettings.invariantForall = settings.invaraiantForAll();
      // invoke z3 for counterexamples
      final SMTSettings smtsettings = new SMTSettings(pdSettings,
            piSettings, null);
      return new SolverLauncher(smtsettings);
   }

   @Override
   public void launcherStopped(SolverLauncher launcher,
         Collection<SMTSolver> finishedSolvers) {
      System.out.println("Stopped!!");
      for(SMTSolver solver : finishedSolvers){   
         System.out.println("found solver::");
         SMTSolverResult result = solver.getFinalResult();
         try{
            System.out.println("RESULT: " + result.toString());        
            if(result.equals(SMTSolverResult.ThreeValuedTruth.VALID) ){
               System.out.println("formula is valid!");
               System.out.println(solver.getSolverOutput());                             
            }
            else if(result.equals(SMTSolverResult.ThreeValuedTruth.UNKNOWN)){
               System.out.println("formula is unknown!");
            }
            else if(result.equals(SMTSolverResult.ThreeValuedTruth.FALSIFIABLE)){
               System.out.println("formula is falsifiable!");
               //Model model = solver.getSocket().getQuery().getModel();            
               //System.out.println(model.toString());
            }else if(result.equals(SMTSolverResult.NO_IDEA)){
               System.out.println("the result: no idea!");
            }else{
               System.out.println("different result!");
            }  
         }catch(NullPointerException e){
            System.out.println("RESULT is null!");
         }
         finish();
      }      
      
   }

   @Override
   public void launcherStarted(Collection<SMTProblem> problems,
         Collection<SolverType> solverTypes, SolverLauncher launcher) {
     
      System.out.println("\nStarted: ");
      for(SMTProblem p : problems){
         System.out.println(p.getTerm());
      }
      
   }
   
   private void finish(){
      System.out.println("\n\nFinished:\n");      
   }
   
   Model check(Context ctx, BoolExpr f, Status sat) throws Z3Exception{
      Solver s = ctx.MkSolver();
      s.Assert(f);
      if (s.Check() != sat){
         //System.out.println("unsatisfiable!");      
         return null;
      }else return s.Model();
    }
}
