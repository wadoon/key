/**
 * 
 */
package de.tud.exploitgen.solver;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
//import java.util.Vector;







import java.util.Set;

import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelArrayInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstanceFactory;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ConcreteArrInterp;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariableFactory;
import com.microsoft.z3.Z3Exception;

































import de.tud.exploitgen.detectleak.exploit.ExploitModel;
import de.tud.exploitgen.detectleak.node.NodeDetail;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.JavaInfo;
//import de.uka.ilkd.key.gui.configuration.ProofIndependentSettings;
//import de.uka.ilkd.key.gui.smt.ProofDependentSMTSettings;
//import de.uka.ilkd.key.gui.smt.ProofIndependentSMTSettings;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.declaration.MethodDeclaration;
import de.uka.ilkd.key.java.declaration.ParameterDeclaration;
import de.uka.ilkd.key.ldt.HeapLDT;
import de.uka.ilkd.key.logic.SequentFormula;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.IProgramMethod;
import de.uka.ilkd.key.logic.op.ObserverFunction;
import de.uka.ilkd.key.logic.op.Operator;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.proof.Node;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.io.ProofSaver;
import de.uka.ilkd.key.proof.mgt.SpecificationRepository;
import de.uka.ilkd.key.settings.ProofDependentSMTSettings;
import de.uka.ilkd.key.settings.ProofIndependentSMTSettings;
import de.uka.ilkd.key.settings.ProofIndependentSettings;
import de.uka.ilkd.key.settings.SMTSettings;
import de.uka.ilkd.key.settings.TestGenerationSettings;
//import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.smt.KegSMTProblem;
import de.uka.ilkd.key.smt.ModelExtractor;
import de.uka.ilkd.key.smt.SMTComprehensionTranslator;
//import de.uka.ilkd.key.gui.smt.SMTSettings;
//import de.uka.ilkd.key.gui.testgen.TestGenerationSettings;
import de.uka.ilkd.key.smt.SMTObjTranslator;
import de.uka.ilkd.key.smt.SMTProblem;
import de.uka.ilkd.key.smt.SMTSolverResult;
import de.uka.ilkd.key.smt.SolverLauncher;
import de.uka.ilkd.key.smt.SolverLauncherListener;
import de.uka.ilkd.key.smt.SolverType;
import de.uka.ilkd.key.smt.AbstractSMTTranslator.Configuration;
//import de.uka.ilkd.key.smt.model.Model;
import de.uka.ilkd.key.smt.SmtLibTranslator;
import de.uka.ilkd.key.smt.SMTSolver;
import de.uka.ilkd.key.smt.lang.SMTFile;
import de.uka.ilkd.key.smt.model.Heap;
import de.uka.ilkd.key.smt.model.Model;
import de.uka.ilkd.key.smt.model.ObjectVal;
import de.uka.ilkd.key.testgen.Assignment;
import de.uka.ilkd.key.testgen.ModelGenerator;
import de.uka.ilkd.key.testgen.RefEx;
import de.uka.ilkd.key.testgen.ReflectionClassCreator;
import de.uka.ilkd.key.testgen.TestCaseGenerator;
import de.uka.ilkd.key.testgen.oracle.OracleGenerator;
//import de.uka.ilkd.key.testgen.ProofInfo;
/**
 * @author Huy Do
 *
 */
public class SMTLibSolver implements SolverLauncherListener{
	private static final String NULLABLE = "/*@ nullable */";
   private Services services;
   private Term formula;
   private KeYJavaType typeOfClassUnderTest; 
   private ExploitModel exploitModel;
   private ModelVariable lowVar; //just for checking purpose
   private ExploitModel resultModel;
   public SMTLibSolver(final Term formula, Services services, KeYJavaType typeOfClassUnderTest, ExploitModel exploitModel, ModelVariable lowVar){
      //super(formula);
      this.formula = formula;
      this.services = services;
      this.typeOfClassUnderTest = typeOfClassUnderTest;
      //System.out.println("typeOfClassUnderTest::: "+ typeOfClassUnderTest);
      this.exploitModel = exploitModel;
      this.lowVar = lowVar;
      this.resultModel = null;
      /*System.out.println("POST HEAP VALUE 1: \n" + exploitModel.getModelNode1().getNodeDetail().getPostHeapValue());
      System.out.println("POST HEAP VALUE 2: \n" + exploitModel.getModelNode2().getNodeDetail().getPostHeapValue());*/
      
	   //System.out.println("insecurity formula: \n" +  ProofSaver.printTerm(formula, services));

   }

   
   
   public ExploitModel solveFormula() {
	   String folderName = "/Users/huydo/Working/KEG_SMT";
 	  String fileName = "smtF";
      try {
		export2SMTLib2File(folderName, fileName);
	} catch (IOException | IllegalFormulaException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
      launch();     
      return resultModel;
   }
   
   public StringBuffer translate2SMTLib2() throws IllegalFormulaException{   
      
     
      //Vector<QuantifiableVariable> boundVars = new Vector<QuantifiableVariable>();
      /*SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),null);*/
	  
      SMTSettings settings = new SMTSettings(services.getProof().getSettings().getSMTSettings(),
              ProofIndependentSettings.DEFAULT_INSTANCE.getSMTSettings(),services.getProof());
	        //SmtLib2Translator smt = new SmtLib2Translator(services,new Configuration(false,false));
      //SMTObjTranslator smt = new SMTObjTranslator(settings,services,new ProofInfo(services.getProof()));
      SpecificationRepository specrep = services.getSpecificationRepository();
      KeYJavaType typeOfClassUnderTest = specrep.getProofOblInput(services.getProof()).getContainerType();
      SMTComprehensionTranslator smt = new SMTComprehensionTranslator(settings,services,null);
      SMTFile file = smt.translateProblem(formula);
      //System.out.println("===============\n default logic:: " + file.getFormulas());

      return new StringBuffer(file.toString());
      //return smt.translateProblem(formula, services, settings);       
      
   }
   
   public StringBuffer translate2SMTLib() throws IllegalFormulaException{
      SmtLibTranslator smt = new SmtLibTranslator(services,new Configuration(false,false));
      //Vector<QuantifiableVariable> boundVars = new Vector<QuantifiableVariable>();
      SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());
      
            return smt.translateProblem(formula, services, settings);     
   }
   
   public void export2SMTLib2File(String directory, String fileName) throws IOException, IllegalFormulaException{ 
      File folder=new File(directory);
      if(!folder.exists())
         folder.mkdir();
      File smtFile;
      //smtFile=new File(fileName);
      while(true){
         smtFile=new File(folder,fileName+".smt2");
         if(smtFile.exists() && !smtFile.isDirectory()){
            fileName = fileName+"1";
            smtFile=new File(folder,fileName+".smt2");                 
         }else
            break;
      }
      BufferedWriter writer = Files.newBufferedWriter(Paths.get(smtFile.getPath()), StandardCharsets.UTF_8); 
      writer.write(";" + formula.toString() + "\n");
      writer.write("; low variable: " + lowVar.getIdentifier() + "\n");
      writer.write(translate2SMTLib2().toString());
      writer.write("\n(get-model)");
      writer.close();
   }
   
   public SMTSolverResult getFinalResult(){
      SMTSettings settings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
            ProofIndependentSMTSettings.getDefaultSettingsData(),services.getProof());
      SMTSolver ss = SolverType.Z3_CE_SOLVER.createSolver(new SMTProblem(formula), new SolverLauncher(settings), services);      
      return ss.getFinalResult();
      
   }
   
     
   /**
    * Try finding a model for the term with z3.
    */
   public void launch(){
      
      SolverLauncher launcher = prepareLauncher();
      
      
      SolverType z3 = SolverType.Z3_EG_SOLVER;
      z3.setSolverCommand("/opt/local/bin/z3");
      if(z3.isInstalled(true)){
         System.out.println("Z3 is installed");
      }
     
      
      //FIXME: link to z3.exe should be a global parameter and must be loaded whenever KEG is loaded
      
      final List<SolverType> solvers = new LinkedList<SolverType>();
      solvers.add(z3);
      
      SMTProblem problem = new KegSMTProblem(formula,services, typeOfClassUnderTest);
      
      System.out.println("SMTProblem::: \n"+problem.getTerm());    
      launcher.addListener(this);
      
      
      
      final List<SMTProblem> problems = new LinkedList<SMTProblem>();
      problems.add(problem);
      
      launcher.launch(solvers, problems, services);
      
      
      
      
    }
   
   /**
    * Creates a SolverLauncher with the appropriate settings.
    * @return
    */
   private SolverLauncher prepareLauncher(){
      /*TestGenerationSettings settings = ProofIndependentSettings.DEFAULT_INSTANCE.getTestGenerationSettings();
      final ProofIndependentSMTSettings piSettings = ProofIndependentSettings.DEFAULT_INSTANCE.getSMTSettings().clone();
      

      piSettings.setMaxConcurrentProcesses(10);
      
      final ProofDependentSMTSettings pdSettings = ProofDependentSMTSettings.getDefaultSettingsData();
      
      pdSettings.invariantForall = settings.invaraiantForAll();
      // invoke z3 for counterexamples
      
      
      final SMTSettings smtsettings = new SMTSettings(pdSettings,
            piSettings, services.getProof());*/
      /*SMTSettings smtsettings = new SMTSettings(ProofDependentSMTSettings.getDefaultSettingsData(),
              ProofIndependentSMTSettings.getDefaultSettingsData(),null);*/
      SMTSettings smtsettings = new SMTSettings(services.getProof().getSettings().getSMTSettings(),
              ProofIndependentSettings.DEFAULT_INSTANCE.getSMTSettings(),services.getProof());
      
      return new SolverLauncher(smtsettings);
   }

   @Override
   public void launcherStopped(SolverLauncher launcher,
         Collection<SMTSolver> finishedSolvers) {
	   System.out.println("finished solvers: " + finishedSolvers);
	   for(SMTSolver solver : finishedSolvers){   
		   //System.out.println(solver.getTranslation());
		   Model model = null;
		   if(solver.getSocket()==null)
			   System.out.println("cannot extract model!");
		   try{
			   
	      	 ModelExtractor modelExtractor = solver.getSocket().getQuery();
	      	 model = modelExtractor.getModel();
	       }catch(Exception e){
	    	   System.out.println(e.toString());
	      	 System.out.println("Cannot find model (SMTLibSolver)");
	       }
		   
		   if(TestCaseGenerator.modelIsOK(model)){
			   //System.out.println("\n0000000000000000\nraw result from SMT Solver: \n" + solver.getSolverOutput()+ "\n000000000000000000");
			   System.out.println(model.toString());
			   System.out.println("--------------- PRINT MODEL INFORMATION -------------------------");
			   extractModelInfo(model);
			   
			   resultModel = extractSMTModel2ExploitModel(model);
			   //resultModel.printModelInfo();
			   System.out.println("--------------- END -------------------------");
		   }
	   } 	   
      
   }

   @Override
   public void launcherStarted(Collection<SMTProblem> problems,
         Collection<SolverType> solverTypes, SolverLauncher launcher) {
     
      System.out.println("\nStarted: "+ solverTypes);
      for(SMTProblem p : problems){
         System.out.println(p.getTerm());
      }
      for(SolverType solver: solverTypes)
    	  System.out.println("get solver command: \n" + solver.getSolverCommand());   
    }
   
      
   private void extractModelInfo(Model m){
	   m.removeUnnecessaryObjects();
	   Map<String, Sort> typeInfMap = generateTypeInferenceMap(exploitModel.getModelNode1().getNodeDetail().getNode().getProofNode());
	   for (final Heap h : m.getHeaps()) {
		   System.out.println("heap name: " + h.getName());
		   Set<String> objects = new HashSet<String>();
		   final List<Assignment> assignments = new LinkedList<Assignment>();
		   for (final ObjectVal o : h.getObjects()) {
			   
				if (o.getName().equals("#o0")) {
					continue;
				}
				final String type = getSafeType(o.getSort());
				String right;
				if (type.endsWith("[]")) {
					right = "new " + type.substring(0, type.length() - 2) + "["
							+ o.getLength() + "]";
				}else if(o.getSort() == null || o.getSort().toString().equals("Null")){
					right = "null";
				}else{
						right = "new " + type + "()";
				}
				System.out.println("object: " + o.getName() + " , type: " + type);
				String objName = createObjectName(o);
				objects.add(objName);
				assignments.add(new Assignment(type, objName, right));
				assignments.add(new Assignment(type, objName, right));				
			}
		   
		   
		   
		   for (final String c : m.getConstants().keySet()) {
			    
				String val = m.getConstants().get(c);
				if ( !c.equals("null")) {
				    boolean isObject = false;
					String type = "int";
					String declType = "int";
					if (val.equals("true") || val.equals("false")) {
						type = "boolean";
					} else if (val.startsWith("#o")) {
					    isObject = true;
					    type = this.inferSort(typeInfMap, c);
					    /*
						final ObjectVal o = getObject(heap, val);
						if (o != null) {
							if (val.equals("#o0")
									&& m.getTypes().getOriginalConstantType(c) != null) {
								type = m.getTypes().getOriginalConstantType(c)
										.name().toString();
							} else {
								type = getSafeType(o.getSort()); //o.getSort().name().toString();
							}
						} else {
							type = "Object";
						}
						*/
	                    
					}
					if(isObject){
	                    declType = NULLABLE +" "+type;
					}
					else{
	                    declType = type;				    
					}
					System.out.println("constant: "+ c.toString() + "; value: " + val);
					val = translateValueExpression(val);
					assignments.add(new Assignment(declType, c, "("+type+")"+val));
					
				}
				
			}
		   
		// init fields
			if (h != null) {
				for (final ObjectVal o : h.getObjects()) {
					if (o.getName().equals("#o0") || o.getSort().name().toString().endsWith("Exception")) {
						continue;
					}
					final String receiverObject = createObjectName(o);
					System.out.println("\n----+++++++++++------\nObject: " + o.getName() + ", receiver object: " + receiverObject);
					for (final String f : o.getFieldvalues().keySet()) {
						
						if (f.contains("<") || f.contains(">")) {
							continue;
						}
						System.out.println("f:: " + f);
						String fieldName = f.substring(f.lastIndexOf(":") + 1);
						fieldName = fieldName.replace("|", "");
						String val = o.getFieldvalues().get(f);
						
						//final String vType = getTypeOfValue(heap, m, val);
	                    String fieldName2 = f.replace("|","");
						final String vType = this.inferSort(typeInfMap, fieldName2); //getTypeOfValue(heap, m, val);
						//rflCreator.addSort(vType); //possible bug if vType represents an abstract type or an interface. See: getSafeType.
						//System.out.println("Added sort (init fields):"+vType);
						
						System.out.println("field name: " + fieldName + "; val: " + val);
						val = translateValueExpression(val);
						final String rcObjType = getSafeType(o.getSort());
						assignments.add(new Assignment(new RefEx(rcObjType,receiverObject,vType,fieldName), "("+vType+")"+val));

						//if(junitFormat && isInPrestate(prestate, o)){
							//if value that is pointed to is object and in prestate then use prestate object
							if(!vType.equals("int") && !vType.equals("boolean") && /*isInPrestate(prestate, val) &&*/ !val.equals("null")){
								val = getPreName(val);
							//}
							
							
							
							assignments
							.add(new Assignment(new RefEx(rcObjType,getPreName(receiverObject),vType,fieldName),"("+vType+")"+ val));
						}
						

					}
					if (o.getSort() != null
							&& o.getSort().name().toString().endsWith("[]")) {

						String safeType = getSafeType(o.getSort());
						//rflCreator.addSort(safeType);
						//System.out.println("Added sort (init array fields):"+safeType);					
						System.out.println("length of "+ o.getName() + " : " + o.getLength());
						for (int i = 0; i < o.getLength(); i++) {
							final String fieldName = "[" + i + "]";
							String val = o.getArrayValue(i);
							val = translateValueExpression(val);
							System.out.println(receiverObject  + fieldName + ": val: " + val);
							assignments.add(new Assignment(receiverObject + fieldName, val));
							//assignments.add(new Assignment("",new RefArrayEx("","",name,""+i), val));

							


						}
					}
					System.out.println("--------------");
				}
			}

		   
		   
		   		   /*for(Assignment a: assignments){
			   System.out.println(a.toString());
		   }*/
			System.out.println(" --------- end of heap " + h.getName());

		}
   }
   
   public String getSafeType(Sort sort) {
		if (sort == null || sort.name().toString().equals("Null")) {
			return "java.lang.Object"; // TODO:Hopefully this is correct
		} else if (sort.isAbstract()) {
			//return buildDummyClassForAbstractSort(sort);
			return "abstract";
		} else {
			return sort.name().toString();
		}
	}
   
   private String createObjectName(final ObjectVal o) {
		return o.getName().replace("#", "_");
	}
   
   protected Map<String, Sort>  generateTypeInferenceMap(Node n){
       HashMap<String,Sort> typeInfMap = new HashMap<String,Sort>();
       Iterator<SequentFormula> formIter = n.sequent().iterator();
       //System.out.println("\n---------------------------------------");
       while(formIter.hasNext()){
           Term t = formIter.next().formula();
           generateTypeInferenceMapHelper(t,typeInfMap);
       }
       return typeInfMap;
   }
   
   private void generateTypeInferenceMapHelper(Term t, Map<String, Sort> map){
       Operator op = t.op();
       if(op instanceof ProgramVariable){
           ProgramVariable pv = (ProgramVariable)t.op();
           final String name = pv.name().toString();
           if(map.containsKey(name)){
               if(map.get(name)!=pv.sort()){
                   System.out.println("Warning: ProgramVariable "+name+" is ambiguous.");                    
               }
           }else{
               //System.out.println("PV "+name+"  Sort: "+pv.sort()+ " KeYJavaType: "+pv.getKeYJavaType().toString());
               map.put(name, pv.sort());
               //add self_1 and self_2
               if(pv.sort().equals(typeOfClassUnderTest.getSort())||pv.sort().equals(services.getTypeConverter().getHeapLDT().getHeap().sort())){
            	   map.put(name+"_1", pv.sort());
            	   map.put(name+"_2", pv.sort());
               }
            	   
           }
       }/*  ObserverFunctions are query methods and ObsFunc java.lang.Object::<inv>
       else if(op instanceof ObserverFunction){
           ObserverFunction func = (ObserverFunction)t.op();
           final String name = func.name().toString();
           if(map.containsKey(name)){
               if(map.get(name)!=func.sort()){
                   System.out.println("ObsFunction "+name+" is AMBIGUOUS.");
               }
           }else{
               System.out.println("ObsFunc "+name+"  KeYJavaType: "+func.getType());                
               map.put(name, func.sort());
           }
       }*/
       else if(op instanceof Function && !(op instanceof ObserverFunction)){
           //This case collects fields of classes. The function itself has 
           // sort "Field" because it is just the name of the field. To get
           // the actual class of the field
           Function func = (Function)t.op();
           String name = func.name().toString();
           Sort sort = func.sort();
           HeapLDT hLDT = services.getTypeConverter().getHeapLDT();
           if(sort==hLDT.getFieldSort()){
               String fieldSort = HeapLDT.getClassName(func);
               ProgramVariable pv = getProgramVariable(t);

               if(pv!=null){
                   name = name.replace("::$", "::");

                   if(map.containsKey(name)){
                       if(map.get(name)!=pv.sort()){
                           System.out.println("Warning: Function "+name+" is ambiguous.");
                       }
                   }else{
                       //System.out.println("Func "+name+"  Sort: "+func.sort()+ " FieldSort:"+fieldSort + "  PV.sort:"+pv.sort());                
                       map.put(name, pv.sort());
                   }  
               }else{
                   //TODO:
                   //System.out.println("Program variable could not be determined:"+t.toString());
               }
           }
       } 
       
       for(int i = 0; i<t.arity(); i++){
           generateTypeInferenceMapHelper(t.sub(i),map);
       }
   }

   
   private ProgramVariable getProgramVariable(Term locationTerm) {
       final HeapLDT heapLDT = services.getTypeConverter().getHeapLDT();
       ProgramVariable result = null;
       if (locationTerm.op() instanceof Function) {
           Function function = (Function)locationTerm.op();
           // Make sure that the function is not an array
           if (heapLDT.getArr() != function) {
               String typeName = HeapLDT.getClassName(function);
               KeYJavaType type = services.getJavaInfo().getKeYJavaType(typeName);
               if (type != null) {
                   String fieldName = HeapLDT.getPrettyFieldName(function);
                   result = services.getJavaInfo().getAttribute(fieldName, type);
               }
           }
       }
       return result;
   }

   protected String inferSort(Map<String, Sort> typeInfMap, String progVar){
	    if(typeInfMap.containsKey(progVar)){
	        return typeInfMap.get(progVar).name().toString();	        
	    }
	    System.out.println("Warning: inferSort did not find:"+progVar);
	    return "NOTYPE";
	}
   
   private String translateValueExpression(String val) {
		if (val.contains("/")) {
			val = val.substring(0, val.indexOf("/"));
		}
		if (val.equals("#o0")) {
			return "null";
		}
		val = val.replace("|", "");
		val = val.replace("#", "_");
		return val;
	}

   private String getPreName(String val) {
		return OracleGenerator.PRE_STRING+val;
	}
   
   private ExploitModel extractSMTModel2ExploitModel(Model model){
	   model.removeUnnecessaryObjects();
	   //Map<String, Sort> typeInfMap = generateTypeInferenceMap(exploitModel.getModelNode1().getNodeDetail().getNode().getProofNode());
	   //System.out.println(typeInfMap);
	   ExploitModel result = new ExploitModel(exploitModel);
	   /*List<Term> listFoundations = result.getListFoundations();
	   for (final Heap h : model.getHeaps()) {
		   String heapName = h.getName();
		   System.out.println("heap name: " + heapName);
		   
		   String branch = heapName.substring(heapName.length()-1);
		   KTGModel ktgModel = result.getModel(Integer.parseInt(branch));		   
		   				   		   
		   for (final String c : model.getConstants().keySet()) {
			    //System.out.println("constant: "+ c.toString());				
				if ( !c.equals("null")) {
					if(c.endsWith(branch)){
						String origName = getNameWithoutSuffix(c);
						//System.out.println("origName: " + origName);
						if(TermUtil.inListTerm(origName, listFoundations)){
							String val = model.getConstants().get(c);
						    boolean isObject = false;
							String type = "int";
							if (val.equals("true") || val.equals("false")) {
								type = "boolean";
							} else if (val.startsWith("#o")) {
							    isObject = true;
							}
							val = translateValueExpression(val);
							ModelVariable mv = ktgModel.getVariable(origName);
							if(mv!=null){
								System.out.println("found ModelVariable " + mv.getIdentifier() + " for const " + c);
								mv.setValueByString(val);
								if(mv.isReferenceType()){
									instantiateObject(val, h, ktgModel);
								}
							}							
						}
					}
				}				
			}	   
		}*/
	   result.setSmtModel(model);
	   return result;
   
   }
   
   private void instantiateObject(String instanceIdentifier, Heap h, KTGModel ktgModel){
	   for (final ObjectVal o : h.getObjects()) {
			if (o.getName().equals("#o0") || o.getSort().name().toString().endsWith("Exception")) {
				continue;
			}
			final String receiverObject = createObjectName(o);	
			if(instanceIdentifier.equals(receiverObject)){			
				ModelVariable object = ktgModel.searchVariabaleByInstanceIdentifier(receiverObject);
				if(object!=null){					
					System.out.println(object.getIdentifier() + " has instance's identifier: " + receiverObject);
					for (final String f : o.getFieldvalues().keySet()) {						
						if (f.contains("<") || f.contains(">")) {
							continue;
						}
						//System.out.println("f:: " + f);
						String fieldName = f.substring(f.lastIndexOf(":") + 1);
						fieldName = fieldName.replace("|", "");
						String val = o.getFieldvalues().get(f);
						val = translateValueExpression(val);
						ModelVariable field = object.searchField(fieldName);
						if(field != null){
							field.setValueByString(val);
							//System.out.println("field name: " + fieldName + "; val: " + val);
							if(field.isReferenceType()){
								instantiateObject(val, h, ktgModel);
							}
						}					
					}					
					//resolve array's elements
					if (o.getSort() != null
							&& o.getSort().name().toString().endsWith("[]") 
							&& object instanceof ModelArrayVariable) {	
						
						int length = o.getLength();
						//System.out.println(o.getName() + " has length: " + length);
						/*
						 * get and assign length variable
						 * */
						ModelVariable lengthMV = object.searchField("length");
						if(lengthMV!=null){
							lengthMV.setValueByString(String.valueOf(length));
						}
						
						/*
						 * assign value for array's elements
						 * we also create a ConcreteArrInterp object for the array
						 * */
						ConcreteArrInterp arrInterp = new ConcreteArrInterp();
						
						for (int i = 0; i < length; i++) {
							String val = o.getArrayValue(i);
							val = translateValueExpression(val);
							ModelVariable element = ((ModelArrayVariable)object).searchArrayElement(i);
							if(element!=null){								
								element.setValueByString(val);
								if(element.isReferenceType()){
									instantiateObject(val, h, ktgModel);
								}
							}/*else{
								ModelVariable elementI = new ModelVariable(object.getIdentifier() + KEGConstant.SEPARATOR + "I"+i);
								elementI.setArrayIdx(i);
								elementI.setParentIdentifier(object.getIdentifier());
								//ModelInstance instance = ModelInstanceFactory.constructModelInstance(object.)
							}*/
							
							
						}
					}						
				}
			}
		}
   }
   
   
   private String getNameWithoutSuffix(String varName){
	   if(varName.endsWith("_1")||varName.endsWith("_2"))
		   return varName.substring(0, varName.length()-2);
	   else
		   return varName;
   }

}
