package de.tud.exploitgen.findsecret.optimizelowinput.optimization.ampltranslation;

import java.math.BigInteger;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4NU;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.util.LinkedHashMap;

/*
 * translate an optimal solution
 * */
public class AMPLTranslator {
	
	class MyLinkedMap<K, V> extends LinkedHashMap<K, V>
	{

	    public V getValue(int i)
	    {

	       Map.Entry<K, V>entry = this.getEntry(i);
	       if(entry == null) return null;

	       return entry.getValue();
	    }

	    public Map.Entry<K, V> getEntry(int i)
	    {
	        // check if negetive index provided
	        Set<Map.Entry<K,V>>entries = entrySet();
	        int j = 0;

	        for(Map.Entry<K, V>entry : entries)
	            if(j++ == i)return entry;

	        return null;

	    }

	}
	
	private MatchableCountingSolution aggSolutions;
	private String solverName;
	private Map<String,Sort> mapVariables;// <name, type>
	private List<Term> listAtomicConstraints;// list of constraints composing condition
	private Services services;
	private final int metric; //measured via Shannon-entropy, min entropy or guessing entropy
	private final SecretDistribution sDistribution;
	public AMPLTranslator(MatchableCountingSolution countSolutions, String solverName, Services services, int metric, SecretDistribution sDistribution) {
		super();
		this.aggSolutions = countSolutions;
		this.solverName = solverName;
		this.services = services;
		this.metric = metric;
		this.sDistribution = sDistribution;
		mapVariables = new HashMap<String, Sort>();
		for(CountingSolution t: countSolutions.getListCountingSolutions()){
			parseTerm2FindVar(t.getValue());
		}
		parseTerm2FindVar(countSolutions.getConditionTerm());
		
		listAtomicConstraints = new LinkedList<Term>();		
		decomposeCondition(countSolutions.getConditionTerm());
		
	}
	
	
	private void parseTerm2FindVar(Term term){
		if(KeYResourceHandler.isArtificialVariable(term, services)){ //we only work with integer type
			mapVariables.put(term.toString(), term.sort());
		}else if(term.subs().size()>0){
			for(Term t: term.subs())
				parseTerm2FindVar(t);
		}
	}
	
	/*
	 * decompose a condition a && b to two atomic constraint a and b and store a, b to listAtomicConstraint	 * 
	 * */
	private void decomposeCondition(Term condition){		
		if(TermParser.isAnd(condition)){
			decomposeCondition(condition.sub(0));
			decomposeCondition(condition.sub(1));
		}else{			
			listAtomicConstraints.add(resolveConstraint(condition, services.getTermBuilder()));
		}
	}	
	
	
	private Term resolveConstraint(Term constraint, TermBuilder tb){
		/*
		 * resolve constraint (only apply for integer arithmetic)
		 * a>b -> a>=b+1
		 * a<b -> a+1<=b
		 * reason: some solves accept only operators: >=, <=, = 
		 * */
		if(TermParser.isLessThan(constraint, services)){
			return tb.leq(tb.add(constraint.sub(0),tb.zTerm(1)), constraint.sub(1));
		}
		else if(TermParser.isGreaterThan(constraint, services)){
			return tb.geq(constraint.sub(0), tb.add(constraint.sub(1),tb.zTerm(1)));
		}
		
		/*
		 * resolve constraint (only apply for integer arithmetic)
		 * a>=b -> a+1>b
		 * a<=b -> a<b+1
		 * reason: some solves accept only operators: >=, <=, = 
		 * */
		/*if(TermParser.isGreaterOrEquals(constraint)){
			return tb.gt(tb.add(constraint.sub(0),tb.zTerm(1)), constraint.sub(1));
		}
		else if(TermParser.isLessOrEquals(constraint)){
			return tb.lt(constraint.sub(0), tb.add(constraint.sub(1),tb.zTerm(1)));
		}*/
		
		
		/*=================================
		 * resolve negative constraint:
		 * !(a<b) -> a>=b
		 * !(a>b) -> a<=b
		 * !(a<=b) -> a>=b+1
		 * !(a>=b) -> a+1<=b 
		 * !(a=b) -> a>=b+1 || a+1 <=b
		 */		
		else if(TermParser.isNot(constraint)){
			Term subConstraint = constraint.sub(0);
			if(TermParser.isLessThan(subConstraint, services)){
				return tb.geq(subConstraint.sub(0), subConstraint.sub(1));
			}else if(TermParser.isGreaterThan(subConstraint, services)){
				return tb.leq(subConstraint.sub(0), subConstraint.sub(1));
			}else if(TermParser.isLessOrEquals(subConstraint, services)){
				return tb.geq(subConstraint.sub(0), tb.add(subConstraint.sub(1),tb.zTerm(1)));
			}else if(TermParser.isGreaterOrEquals(subConstraint, services)){
				return tb.leq(tb.add(subConstraint.sub(0),tb.zTerm(1)), subConstraint.sub(1));
			}else
				return constraint;
		}		
		else
			return constraint;
	}
	
	public String translate2AMPL(){
		String result = getSolverOption();
		result += getVarDeclaration();
		result += getObjFunction();
		result += getConstraints();
		result += getStartingPoint();
		result += getSolveCommand();
		result += getPrintSolution();
		return result;
	}	
	
	private String getSolverOption(){
		return "option solver " + solverName + ";\n";
	}
	
	private String getVarDeclaration(){
		String result = "\n# declare the variables and their bounds\n";
		for(String var: mapVariables.keySet()){
			result += "var " + var + " integer; \n"; //TODO: should use Sort information? 
		}	
		return result;
	}
	
	private String getObjFunction(){
		if(sDistribution==null||sDistribution.isUniform())
			return getObjFunction4UniformDistribution();
		else
			return getObjFunction4NU();
	}
	
	private String getObjFunction4UniformDistribution(){
		String result = "\n# specify the objective function \n";
		if(metric==KEGConstant.SHANNON_ENTROPY || metric == KEGConstant.GUESSING_ENTROPY)
			result += "minimize obj:\n";
		else //min entropy
			result += "maximize obj:\n";
		
		List<CountingSolution> listCountingSolutions = aggSolutions.getListCountingSolutions();
		int i;
		if(metric==KEGConstant.SHANNON_ENTROPY){
			for(i=0;i<listCountingSolutions.size()-1;i++){
				Term countTerm = listCountingSolutions.get(i).getValue();
				if(TermParser.isIntegerConst(countTerm, services)){
					//long number = TermParser.getIntegerValue(countTerm);
					BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
					if(number.longValue()==0)				
						result += "0 + ";
					else
						result += number + "*log(" +number+") + ";
				}else{
					String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);
					countExpr =  countExpr + "*log(" + countExpr + ") + ";
					result += countExpr;
				}			
			}
			
			Term countTerm = listCountingSolutions.get(i).getValue();
			if(TermParser.isIntegerConst(countTerm, services)){
				BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
				if(number.longValue()==0)				
					result += "0;";
				else
					result += number + "*log(" +number+");";
			}else{
				String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);
				countExpr =  countExpr + "*log(" + countExpr + ");" ;
				result += countExpr;
			}
		}else if(metric==KEGConstant.GUESSING_ENTROPY){
			for(i=0;i<listCountingSolutions.size()-1;i++){
				Term countTerm = listCountingSolutions.get(i).getValue();
				if(TermParser.isIntegerConst(countTerm, services)){
					//long number = TermParser.getIntegerValue(countTerm);
					BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
					if(number.longValue()==0)				
						result += "0 + ";
					else
						result += number + "*(" +number+" + 1) + ";
				}else{
					String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);
					countExpr =  countExpr + "*(" + countExpr + " + 1) + ";
					result += countExpr;
				}			
			}
			
			Term countTerm = listCountingSolutions.get(i).getValue();
			if(TermParser.isIntegerConst(countTerm, services)){
				//long number = TermParser.getIntegerValue(countTerm);
				BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
				if(number.longValue()==0)				
					result += "0;";
				else
					result += number + "*(" +number+" + 1);";
			}else{
				String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);
				countExpr =  countExpr + "*(" + countExpr + " + 1);" ;
				result += countExpr;
			}
		}else{ //min entropy
			//in min-entropy-based metric, we only optimize |O| which means that there is only one countTerm for each MatchableCountingSolution
			Term countTerm = listCountingSolutions.get(0).getValue();
			if(TermParser.isIntegerConst(countTerm, services)){
				//long number = TermParser.getIntegerValue(countTerm);
				BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
				result += number + ";";
			}else{
				String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);				
				result += countExpr + ";";
			}
		}
		return result;
	}
	
	private String getObjFunction4NU(){
		String result = "\n# specify the objective function \n";
		//for non-uniform distribution, we only deal Shannon and guessing entropy, hence we must minimize the objective function
		result += "minimize obj:\n";
		
		MyLinkedMap<String,Term> mapTermOfOutValue = (MyLinkedMap<String, Term>)getMapTermOfOutValue();
		int i;
		
		if(metric==KEGConstant.SHANNON_ENTROPY){
			for(i=0;i<mapTermOfOutValue.size()-1;i++){
				Term countTerm = mapTermOfOutValue.getEntry(i).getValue();
				if(TermParser.isIntegerConst(countTerm, services)){
					//long number = TermParser.getIntegerValue(countTerm);
					BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
					if(number.longValue()==0)				
						result += "0 + ";
					else
						result += number + "*log(" +number+") + ";
				}else{
					String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);
					countExpr =  countExpr + "*log(" + countExpr + ") + ";
					result += countExpr;
				}			
			}
			
			Term countTerm = mapTermOfOutValue.getEntry(i).getValue();
			if(TermParser.isIntegerConst(countTerm, services)){
				BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
				if(number.longValue()==0)				
					result += "0;";
				else
					result += number + "*log(" +number+");";
			}else{
				String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);
				countExpr =  countExpr + "*log(" + countExpr + ");" ;
				result += countExpr;
			}
		}else { // must be guessing entropy if not Shannon entropy
			for(i=0;i<mapTermOfOutValue.size()-1;i++){
				Term countTerm = mapTermOfOutValue.getEntry(i).getValue();
				if(TermParser.isIntegerConst(countTerm, services)){
					//long number = TermParser.getIntegerValue(countTerm);
					BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
					result += number + " + ";
				}else{
					String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);
					countExpr =  countExpr + " + ";
					result += countExpr;
				}			
			}
			
			Term countTerm = mapTermOfOutValue.getEntry(i).getValue();
			if(TermParser.isIntegerConst(countTerm, services)){
				//long number = TermParser.getIntegerValue(countTerm);
				BigInteger number = TermParser.getBigIntegerValue(countTerm, services);
				result += number + ";";
			}else{
				String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm, services);
				countExpr =  countExpr + ";" ;
				result += countExpr;
			}
		}
		return result;
	}
	
	private Map<String, Term> getMapTermOfOutValue(){
		Map<String, Term> result = new MyLinkedMap<String, Term>();
		TermBuilder tb = services.getTermBuilder();
		if(metric==KEGConstant.SHANNON_ENTROPY){
			for(CountingSolution cSolution: aggSolutions.getListCountingSolutions()){
				if(result.containsKey(cSolution.getOutputValue())){
					Term currentTerm = result.get(cSolution.getOutputValue());
					currentTerm = tb.add(currentTerm, 
							tb.mul(cSolution.getValue(), 
									tb.zTerm(
											sDistribution.getPartitions().get(
													cSolution.getPartitionIdx()
													).getFrequency()
											)
									));
					result.put(cSolution.getOutputValue(), currentTerm);
				}else{
					
					Term currentTerm = tb.mul(cSolution.getValue(), 
												tb.zTerm(
														sDistribution.getPartitions().get(
																cSolution.getPartitionIdx()
																).getFrequency()
														)
												);
					result.put(cSolution.getOutputValue(), currentTerm);
				}
			}
		}else{ //Guessing entropy
			Map<String, List<CountingSolution>> mapByOutValue = GELMaximizerUsingCounting4NU.transformListMatchableCountingSolution2Map(aggSolutions.getListCountingSolutions());
			for(String outValue: mapByOutValue.keySet()){
				Term outValTerm = tb.zero();
				List<CountingSolution> listCountSolutions = mapByOutValue.get(outValue);
				for(int i=0;i<listCountSolutions.size();i++){
					Term iTerm = tb.div(tb.add(listCountSolutions.get(i).getValue(),tb.zTerm(1)),tb.zTerm(2));
					for(int j=0;j<i;j++){
						iTerm = tb.add(iTerm, listCountSolutions.get(j).getValue());
					}
					iTerm = tb.mul(iTerm, listCountSolutions.get(i).getValue());
					iTerm = tb.mul(iTerm, 
							tb.zTerm(
									sDistribution.getPartitions().get(
											listCountSolutions.get(i).getPartitionIdx()
											).getFrequency()
									)
							);
					outValTerm = tb.add(outValTerm, iTerm);
				}
				result.put(outValue, outValTerm);
			}
			
		}
			
		return result;
	}
	
	private String getConstraints(){
		String result = "\n# specify the constraints \n";
		for(int i=0; i<listAtomicConstraints.size();i++){
			Term constraint = listAtomicConstraints.get(i);
			result += "constraint" + i+ ":\n";
			result += new AMPLExprTransformer().transformExpression2StringNoParenthesis(constraint, services)+";\n";
		}
		return result;
	}
	
	/*
	 * starting point coming from concrete model of countSolutions
	 * */
	private String getStartingPoint(){
		String result = "\n# specify the starting point\n";
		Map<String,Long> concreteModel = aggSolutions.getOneConcreteModel();
		for(String varName:concreteModel.keySet()){
			result += "let " + varName + " := " + concreteModel.get(varName) + ";\n";
		}
		return result;
	}
	
	private String getSolveCommand(){
		return "\n# solve the problem \n solve;\n";
	}
	
	private String getPrintSolution(){
		String result = "\n# print the solution \n display obj; \n";
		for(String varName: mapVariables.keySet()){
			result += "display " + varName + ";\n";
		}
		return result;
	}


	public Map<String, Sort> getMapVariables() {
		return mapVariables;
	}
	
	
	
}
