package de.tud.exploitgen.findsecret.optimizelowinput.optimization.ampltranslation;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.barvinokinterface.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.sort.Sort;

/*
 * translate an optimal solution
 * */
public class AMPLTranslator {
	private MatchableCountingSolution aggSolutions;
	private String solverName;
	private Map<String,Sort> mapVariables;// <name, type>
	private List<Term> listAtomicConstraints;// list of constraints composing condition
	private Services services;
	
	public AMPLTranslator(MatchableCountingSolution countSolutions, String solverName, Services services) {
		super();
		this.aggSolutions = countSolutions;
		this.solverName = solverName;
		this.services = services;
		mapVariables = new HashMap<String, Sort>();
		for(Term t: countSolutions.getListCountTerms()){
			parseTerm2FindVar(t);
		}
		parseTerm2FindVar(countSolutions.getConditionTerm());
		
		listAtomicConstraints = new LinkedList<Term>();		
		decomposeCondition(countSolutions.getConditionTerm());
	}
	
	
	private void parseTerm2FindVar(Term term){
		if(KeYResourceHandler.isArtificialVariable(term)){ //we only work with integer type
			mapVariables.put(term.toString(), term.sort());
		}else if(term.subs().size()>0){
			for(Term t: term.subs())
				parseTerm2FindVar(t);
		}
	}
	
	/*
	 * decompose a condition a && b to two atomic constraint a and b and store a, b to listAtomicConstraint	 * 
	 * */
	private void decomposeCondition(Term condition){		
		if(TermParser.isAnd(condition)){
			decomposeCondition(condition.sub(0));
			decomposeCondition(condition.sub(1));
		}else{			
			listAtomicConstraints.add(resolveConstraint(condition, services.getTermBuilder()));
		}
	}	
	
	/*
	 * resolve constraint (only apply for integer arithmetic)
	 * a>b -> a>=b+1
	 * a<b -> a+1<=b
	 * reason: some solves accept only operators: >=, <=, = 
	 * */
	private Term resolveConstraint(Term constraint, TermBuilder tb){
		if(TermParser.isGreaterThan(constraint)){
			return tb.geq(constraint.sub(0), tb.add(constraint.sub(1),tb.zTerm(1)));
		}
		else if(TermParser.isLessThan(constraint)){
			return tb.leq(tb.add(constraint.sub(0),tb.zTerm(1)), constraint.sub(1));
		}
		else
			return constraint;
	}
	
	public String translate2AMPL(){
		String result = getSolverOption();
		result += getVarDeclaration();
		result += getObjFunction();
		result += getConstraints();
		result += getStartingPoint();
		result += getSolveCommand();
		result += getPrintSolution();
		return result;
	}	
	
	private String getSolverOption(){
		return "option solver " + solverName + ";\n";
	}
	
	private String getVarDeclaration(){
		String result = "\n# declare the variables and their bounds\n";
		for(String var: mapVariables.keySet()){
			result += "var " + var + " integer; \n"; //TODO: should use Sort information? 
		}	
		return result;
	}
	
	private String getObjFunction(){
		String result = "\n# specify the objective function \n minimize obj:\n";
		List<Term> listCountTerms = aggSolutions.getListCountTerms();
		int i;
		for(i=0;i<listCountTerms.size()-1;i++){
			Term countTerm = listCountTerms.get(i);
			String countExpr = Term2IsccTransformer.transformExpression2String(countTerm);
			countExpr = "(" + countExpr + ")*log(" + countExpr + ") + ";
			result += countExpr;
		}
		
		Term countTerm = listCountTerms.get(i);
		String countExpr = Term2IsccTransformer.transformExpression2String(countTerm);
		countExpr = "(" + countExpr + ")*log(" + countExpr + ");\n";
		result += countExpr;
		return result;
	}
	
	private String getConstraints(){
		String result = "\n# specify the constraints \nsubject to \n";
		for(int i=0; i<listAtomicConstraints.size();i++){
			Term constraint = listAtomicConstraints.get(i);
			result += "constraint" + i+ ":\n";
			result += Term2IsccTransformer.transformExpression2String(constraint)+";\n";
		}
		return result;
	}
	
	/*
	 * starting point coming from concrete model of countSolutions
	 * */
	private String getStartingPoint(){
		String result = "\n# specify the starting point\n";
		Map<String,Long> concreteModel = aggSolutions.getOneConcreteModel();
		for(String varName:concreteModel.keySet()){
			result += "let " + varName + " := " + concreteModel.get(varName) + ";\n";
		}
		return result;
	}
	
	private String getSolveCommand(){
		return "\n# solve the problem \n solve;\n";
	}
	
	private String getPrintSolution(){
		String result = "\n# print the solution \n display obj; \n";
		for(String varName: mapVariables.keySet()){
			result += "display " + varName + ";\n";
		}
		return result;
	}


	public Map<String, Sort> getMapVariables() {
		return mapVariables;
	}
	
	
	
}
