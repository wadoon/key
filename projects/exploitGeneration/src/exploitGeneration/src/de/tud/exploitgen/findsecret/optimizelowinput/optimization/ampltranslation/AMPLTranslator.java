package de.tud.exploitgen.findsecret.optimizelowinput.optimization.ampltranslation;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.sort.Sort;

/*
 * translate an optimal solution
 * */
public class AMPLTranslator {
	private MatchableCountingSolution aggSolutions;
	private String solverName;
	private Map<String,Sort> mapVariables;// <name, type>
	private List<Term> listAtomicConstraints;// list of constraints composing condition
	private Services services;
	private final int metric; //measured via Shannon-entropy, min entropy or guessing entropy
	public AMPLTranslator(MatchableCountingSolution countSolutions, String solverName, Services services, int metric) {
		super();
		this.aggSolutions = countSolutions;
		this.solverName = solverName;
		this.services = services;
		this.metric = metric;
		mapVariables = new HashMap<String, Sort>();
		for(Term t: countSolutions.getListCountTerms()){
			parseTerm2FindVar(t);
		}
		parseTerm2FindVar(countSolutions.getConditionTerm());
		
		listAtomicConstraints = new LinkedList<Term>();		
		decomposeCondition(countSolutions.getConditionTerm());
	}
	
	
	private void parseTerm2FindVar(Term term){
		if(KeYResourceHandler.isArtificialVariable(term)){ //we only work with integer type
			mapVariables.put(term.toString(), term.sort());
		}else if(term.subs().size()>0){
			for(Term t: term.subs())
				parseTerm2FindVar(t);
		}
	}
	
	/*
	 * decompose a condition a && b to two atomic constraint a and b and store a, b to listAtomicConstraint	 * 
	 * */
	private void decomposeCondition(Term condition){		
		if(TermParser.isAnd(condition)){
			decomposeCondition(condition.sub(0));
			decomposeCondition(condition.sub(1));
		}else{			
			listAtomicConstraints.add(resolveConstraint(condition, services.getTermBuilder()));
		}
	}	
	
	
	private Term resolveConstraint(Term constraint, TermBuilder tb){
		/*
		 * resolve constraint (only apply for integer arithmetic)
		 * a>b -> a>=b+1
		 * a<b -> a+1<=b
		 * reason: some solves accept only operators: >=, <=, = 
		 * */
		if(TermParser.isLessThan(constraint)){
			return tb.leq(tb.add(constraint.sub(0),tb.zTerm(1)), constraint.sub(1));
		}
		else if(TermParser.isGreaterThan(constraint)){
			return tb.geq(constraint.sub(0), tb.add(constraint.sub(1),tb.zTerm(1)));
		}
		
		/*
		 * resolve constraint (only apply for integer arithmetic)
		 * a>=b -> a+1>b
		 * a<=b -> a<b+1
		 * reason: some solves accept only operators: >=, <=, = 
		 * */
		/*if(TermParser.isGreaterOrEquals(constraint)){
			return tb.gt(tb.add(constraint.sub(0),tb.zTerm(1)), constraint.sub(1));
		}
		else if(TermParser.isLessOrEquals(constraint)){
			return tb.lt(constraint.sub(0), tb.add(constraint.sub(1),tb.zTerm(1)));
		}*/
		
		
		/*=================================
		 * resolve negative constraint:
		 * !(a<b) -> a>=b
		 * !(a>b) -> a<=b
		 * !(a<=b) -> a>=b+1
		 * !(a>=b) -> a+1<=b 
		 * !(a=b) -> a>=b+1 || a+1 <=b
		 */		
		else if(TermParser.isNot(constraint)){
			Term subConstraint = constraint.sub(0);
			if(TermParser.isLessThan(subConstraint)){
				return tb.geq(subConstraint.sub(0), subConstraint.sub(1));
			}else if(TermParser.isGreaterThan(subConstraint)){
				return tb.leq(subConstraint.sub(0), subConstraint.sub(1));
			}else if(TermParser.isLessOrEquals(subConstraint)){
				return tb.geq(subConstraint.sub(0), tb.add(subConstraint.sub(1),tb.zTerm(1)));
			}else if(TermParser.isGreaterOrEquals(subConstraint)){
				return tb.leq(tb.add(subConstraint.sub(0),tb.zTerm(1)), subConstraint.sub(1));
			}else
				return constraint;
		}		
		else
			return constraint;
	}
	
	public String translate2AMPL(){
		String result = getSolverOption();
		result += getVarDeclaration();
		result += getObjFunction();
		result += getConstraints();
		result += getStartingPoint();
		result += getSolveCommand();
		result += getPrintSolution();
		return result;
	}	
	
	private String getSolverOption(){
		return "option solver " + solverName + ";\n";
	}
	
	private String getVarDeclaration(){
		String result = "\n# declare the variables and their bounds\n";
		for(String var: mapVariables.keySet()){
			result += "var " + var + " integer; \n"; //TODO: should use Sort information? 
		}	
		return result;
	}
	
	private String getObjFunction(){
		String result = "\n# specify the objective function \n";
		if(metric==KEGConstant.SHANNON_ENTROPY || metric == KEGConstant.GUESSING_ENTROPY)
			result += "minimize obj:\n";
		else //min entropy
			result += "maximize obj:\n";
		
		List<Term> listCountTerms = aggSolutions.getListCountTerms();
		int i;
		if(metric==KEGConstant.SHANNON_ENTROPY){
			for(i=0;i<listCountTerms.size()-1;i++){
				Term countTerm = listCountTerms.get(i);
				if(TermParser.isIntegerConst(countTerm)){
					long number = TermParser.getIntegerValue(countTerm);
					if(number==0)				
						result += "0 + ";
					else
						result += number + "*log(" +number+") + ";
				}else{
					String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm);
					countExpr =  countExpr + "*log(" + countExpr + ") + ";
					result += countExpr;
				}			
			}
			
			Term countTerm = listCountTerms.get(i);
			if(TermParser.isIntegerConst(countTerm)){
				long number = TermParser.getIntegerValue(countTerm);
				if(number==0)				
					result += "0;";
				else
					result += number + "*log(" +number+");";
			}else{
				String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm);
				countExpr =  countExpr + "*log(" + countExpr + ");" ;
				result += countExpr;
			}
		}else if(metric==KEGConstant.GUESSING_ENTROPY){
			for(i=0;i<listCountTerms.size()-1;i++){
				Term countTerm = listCountTerms.get(i);
				if(TermParser.isIntegerConst(countTerm)){
					long number = TermParser.getIntegerValue(countTerm);
					if(number==0)				
						result += "0 + ";
					else
						result += number + "*(" +number+" + 1) + ";
				}else{
					String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm);
					countExpr =  countExpr + "*(" + countExpr + " + 1) + ";
					result += countExpr;
				}			
			}
			
			Term countTerm = listCountTerms.get(i);
			if(TermParser.isIntegerConst(countTerm)){
				long number = TermParser.getIntegerValue(countTerm);
				if(number==0)				
					result += "0;";
				else
					result += number + "*(" +number+" + 1);";
			}else{
				String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm);
				countExpr =  countExpr + "(" + countExpr + " + 1);" ;
				result += countExpr;
			}
		}else{ //min entropy
			//in min-entropy-based metric, we only optimize |O| which means that there is only one countTerm for each MatchableCountingSolution
			Term countTerm = listCountTerms.get(0);
			if(TermParser.isIntegerConst(countTerm)){
				long number = TermParser.getIntegerValue(countTerm);
				result += number + ";";
			}else{
				String countExpr = new AMPLExprTransformer().transformExpression2String(countTerm);				
				result += countExpr + ";";
			}
		}
		return result;
	}
	
	private String getConstraints(){
		String result = "\n# specify the constraints \n";
		for(int i=0; i<listAtomicConstraints.size();i++){
			Term constraint = listAtomicConstraints.get(i);
			result += "constraint" + i+ ":\n";
			result += new AMPLExprTransformer().transformExpression2StringNoParenthesis(constraint)+";\n";
		}
		return result;
	}
	
	/*
	 * starting point coming from concrete model of countSolutions
	 * */
	private String getStartingPoint(){
		String result = "\n# specify the starting point\n";
		Map<String,Long> concreteModel = aggSolutions.getOneConcreteModel();
		for(String varName:concreteModel.keySet()){
			result += "let " + varName + " := " + concreteModel.get(varName) + ";\n";
		}
		return result;
	}
	
	private String getSolveCommand(){
		return "\n# solve the problem \n solve;\n";
	}
	
	private String getPrintSolution(){
		String result = "\n# print the solution \n display obj; \n";
		for(String varName: mapVariables.keySet()){
			result += "display " + varName + ";\n";
		}
		return result;
	}


	public Map<String, Sort> getMapVariables() {
		return mapVariables;
	}
	
	
	
}
