/**
 * 
 */
package de.tud.exploitgen.processing.exploit;



import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
//import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

/**
 * this class wraps the model of an exploit. It includes 
 *    two {@link com.csvanefalk.keytestgen.core.model.implementation.Model} variables
 *    methods to parse the output model of solver into exploit model
 *    methods to parse variables in term into exploit model   
 * @author Huy Do
 *
 */
public class ExploitModel {
   private Model model1, model2; //two model for two leaking information
   private ModelVariable lowVar; //low variable that secret information could be leaked through
   
   private String HEAP_NAME;
   /**
    * @param model1
    * @param model2
    * @param hEAP_NAME
    */
   public ExploitModel(Model model1, Model model2, String hEAP_NAME) {
      super();
      this.model1 = model1;
      this.model2 = model2;
      HEAP_NAME = hEAP_NAME;
      lowVar=null; //default, the value of lowVar could be assigned later
   }

   /**
    * @return the hEAP_NAME
    */
   public String getHEAP_NAME() {
      return HEAP_NAME;
   }

   /**
    * @param hEAP_NAME the hEAP_NAME to set
    */
   public void setHEAP_NAME(String hEAP_NAME) {
      HEAP_NAME = hEAP_NAME;
   }

   /**
    * @return the model1
    */
   public Model getModel1() {
      return model1;
   }

   /**
    * @param model1 the model1 to set
    */
   public void setModel1(Model model1) {
      this.model1 = model1;
   }

   /**
    * @return the model2
    */
   public Model getModel2() {
      return model2;
   }

   /**
    * @param model2 the model2 to set
    */
   public void setModel2(Model model2) {
      this.model2 = model2;
   }

   /**
    * @param model1
    * @param model2
    */
   public ExploitModel(Model model1, Model model2) {
      super();
      this.model1 = model1;
      this.model2 = model2;
   }
   
   
   
   
   public Model getModel(int branch){
      if(branch==1)
         return model1;
      else
         return model2;
   }
   
   
      
    
   /**
    * @return the lowVar
    */
   public ModelVariable getLowVar() {
      return lowVar;
   }

   /**
    * @param lowVar the lowVar to set
    */
   public void setLowVar(ModelVariable lowVar) {
      this.lowVar = lowVar;
   }

   /**
    * print out exploit model, just for checking purpose
    * */
   public void printExploitModel(int branch){
      Model model;
      if(branch==1){ 
         model=model1;
      }else{
         model=model2;
      }
      System.out.println("model " + branch + " : ");
      for(ModelVariable mv : model.getVariables()){
         if(mv.isPrimitive())
            System.out.println(mv.getIdentifier()+": " + mv.getValue());
      }
      
      for(ModelVariable mv : model.getVariables()){
         System.out.println(mv.getIdentifier()+": " + mv.getSymbolicValue());
         if(mv.isPrimitive())
            System.out.println(mv.getValue());
         else{
            ModelInstance mi=(ModelInstance)mv.getValue();
            System.out.println(" ; " + mi.getReferees().get(0) + " includes: ");
            for(ModelVariable mvv : mi.getFields()){
               System.out.println(mvv.getIdentifier()+" : " + mvv.getVariableName()+" : " + mvv.getValue());
            }
            System.out.println("-----");
         }
      }
      
      System.out.println();      
   }
   
   public void printModelInfo(){
      System.out.println("INFORMATION OF EXPLOIT MODEL");
      System.out.println("-=========model 1========----");     
      //System.out.println("secret information is leaked through variable: " + lowVar);
      System.out.println(model1.toString());
      System.out.println("-=========model 2========----");
      System.out.println(model2.toString());
      System.out.println("************************");
   }
   
   /**
    * Instantiate values for exploit model from an integer concrete model
    * */
   public void instantiateExploitModelInt(final Map<String,Integer> concreteValues){
      
      //resetPrimitiveValue();
      
      for(String varName: concreteValues.keySet()){         
         if(!isDualVar(concreteValues, varName)){  //if varName is not a high or low value
            final ModelVariable variable1 =model1.getVariable(varName);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(varName));
            
            final ModelVariable variable2 =model2.getVariable(varName);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(varName));
         }else{
            String prefix=varName.substring(0, varName.length()-2);
            //get variable in concrete model corresponding with model1            
            final ModelVariable variable1 = model1.getVariable(prefix);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(prefix+"_1"));
            
            // get variable in concrete model corresponding with model2            
            final ModelVariable variable2 = model2.getVariable(prefix);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(prefix+"_2"));
         }
      }
   }
   
   /**
    * Instantiate values for exploit model from a list of ModelVariable containing concrete values
    * */
   public void instantiateExploitModel(List<ModelVariable> lMV){
      
      for(ModelVariable mv: lMV){
         String varName = mv.getIdentifier();
         System.out.println(mv.getIdentifier() + " ::: " + mv.getValue());
         if(varName.endsWith("_1")){            
            ModelVariable v1 = model1.getVariable(varName.substring(0, varName.length()-2));
            if(v1!=null){
               System.out.println("detected: -> " + v1.getIdentifier());
               v1.setValue(mv.getValue());
            }
         }else if(varName.endsWith("_2")){
            ModelVariable v2 = model2.getVariable(varName.substring(0, varName.length()-2));
            
            if(v2!=null){
               System.out.println("detected: -> " + v2.getIdentifier());
               v2.setValue(mv.getValue());
            }
         }         
        
      }
      
     
   }
      
   
   /**
    * check if a variable is dual value or not
    * dual value: is high or low value (h1, h2) or (l1,l2)
    * */
   private boolean isDualVar(final Map<String,Integer> concreteValues,final String varName){
      //remove the suffix  _1 or _2 of varName
      if((!varName.endsWith("_1"))&&(!varName.endsWith("_2"))){
         return false;
      }else{
         String prefix=varName.substring(0, varName.length()-2);
         if((concreteValues.containsKey(prefix+"_1"))&&(concreteValues.containsKey(prefix+"_2")))
            return true;
         else
            return false;
      }
   }
   
   /**
    * check if a variable is dual value or not
    * dual value: is high or low value (h1, h2) or (l1,l2)
    * */
   private boolean isDualVar(final List<ModelVariable> concreteValues,final String varName){
      //remove the suffix  _1 or _2 of varName
      if((!varName.endsWith("_1"))&&(!varName.endsWith("_2"))){
         return false;
      }else{
         String prefix=varName.substring(0, varName.length()-2);
         for(ModelVariable mv: concreteValues){
            if((mv.getIdentifier().equals(prefix+"_1"))&&(mv.getIdentifier().equals(prefix+"_2")))
               return true;            
         }
         return false;
      }
   }
   
   public void resetPrimitiveValue(){
      model1.resetPrimitiveValue();
      model2.resetPrimitiveValue();
   }
   
}

