/**
 * 
 */
package de.tud.exploitgen.processing.exploit;

import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.ModelBuilder;
import com.csvanefalk.keytestgen.core.model.implementation.ModelBuilderVisitor;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstanceFactory;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariableFactory;


import com.csvanefalk.keytestgen.util.parsers.TermParserTools;
import com.csvanefalk.keytestgen.util.transformers.RemoveAxiomaticExpressionsTransformer;
import com.csvanefalk.keytestgen.util.transformers.RemoveIfThenElseTransformer;
import com.csvanefalk.keytestgen.util.transformers.RemoveImplicationsTransformer;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.declaration.ParameterDeclaration;
import de.uka.ilkd.key.java.declaration.VariableSpecification;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.LocationVariable;

import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionMethodCall;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class wraps the model of an exploit. It includes 
 *    two {@link com.csvanefalk.keytestgen.core.model.implementation.Model} variables
 *    methods to parse the output model of solver into exploit model
 *    methods to parse variables in term into exploit model   
 * @author Huy Do
 *
 */
public class ExploitModel {
   private Model model1, model2;
   
   private String HEAP_NAME="";
   /**
    * @return the model1
    */
   public Model getModel1() {
      return model1;
   }

   /**
    * @param model1 the model1 to set
    */
   public void setModel1(Model model1) {
      this.model1 = model1;
   }

   /**
    * @return the model2
    */
   public Model getModel2() {
      return model2;
   }

   /**
    * @param model2 the model2 to set
    */
   public void setModel2(Model model2) {
      this.model2 = model2;
   }

   /**
    * @param model1
    * @param model2
    */
   public ExploitModel(Model model1, Model model2) {
      super();
      this.model1 = model1;
      this.model2 = model2;
   }
   
   public ExploitModel(){
      model1=Model.constructModel();
      model2=Model.constructModel();
   }
   
   
   public Model getModel(int branch){
      if(branch==1)
         return model1;
      else
         return model2;
   }
   
   /**
    * Brings a pathcondition into a state which is suitable for model generation.
    *
    * @param pathCondition
    * @return
    * @throws TermTransformerException
    * @author Christopher Svalnefak
    */
   private Term configurePathConditionForModelGeneration(Term pathCondition) throws TermTransformerException {

       /*
        * Remove all axiomatic expressions
        */
       pathCondition = RemoveAxiomaticExpressionsTransformer.getInstance().transform(pathCondition);

       /*
        * Remove all implications from the path condition.
        */
       pathCondition = RemoveImplicationsTransformer.getInstance().transform(pathCondition);

       /*
        * Remove if-then-else assertions from the path condition.
        */
       pathCondition = RemoveIfThenElseTransformer.getInstance().transform(pathCondition);

       return pathCondition;
   }
   
   /**
    * initiate exploit model from a node in execution tree.
    * All primitive variables will be initiated by default values
    * all fields will be investigated recursively
    * */
   public void initiateExploitModelFromNode(IExecutionNode node) throws ProofInputException, TermTransformerException{
      Term pathCondition=node.getPathCondition(); 
      
      pathCondition = configurePathConditionForModelGeneration(pathCondition);

      /*
       * Create the initial Model, without any concrete values assigned to
       * primitive integer values in it.
       */
       //model1 = new ModelBuilder().createModel(node, pathCondition);
       //model2 = new ModelBuilder().createModel(node, pathCondition);       
       
      // get all parameters of method
      addMethodParameters(node, 1);
      addMethodParameters(node, 2);
      
      
       //investigate heap to add all fields into model
       
       IExecutionVariable[] vars = ((IExecutionStateNode) node).getVariables();      
       for(IExecutionVariable var: vars){
          if(new HeapHandler().isHeap(var)){
             addSelfToModel(var, 1);
             addSelfToModel(var, 2);
             HEAP_NAME=var.getName();
             //add "self" object to model              
             investigateSelf(var);
             break;
          }else{
             
          }
       }
       
   }   
   
   private void addMethodParameters(IExecutionNode node,int branch){
      final IExecutionMethodCall methodCall = getMethodCallNode(node);
      final ImmutableArray<ParameterDeclaration> parameterDeclarations = methodCall.getProgramMethod()
            .getParameters();
      
      for (final ParameterDeclaration parameterDeclaration : parameterDeclarations) {
      
         for (final VariableSpecification variableSpecification : parameterDeclaration.getVariables()) {
         
            /*
            * Convert the declaration to a program variable
            * 
            * FIXME: Define common abstraction and stop flipflopping
            * between existing ones.
            */
            final KeYJavaType type = (KeYJavaType) variableSpecification.getType();
            
            final ProgramElementName name = new ProgramElementName(variableSpecification.getName());
            
            final IProgramVariable programVariable = new LocationVariable(name, type);
            
            final ModelVariable modelParameter = ModelVariableFactory.constructModelVariable(programVariable,
                                    name.toString());
            
            modelParameter.setParameter(true);
            
            /*
            * The parameter is primitive.
            */
            Object value = null;
            if (TermParser.isPrimitiveType(modelParameter.getTypeName())) {
               value = ModelBuilderVisitor.resolvePrimitiveType(programVariable);
            } else {
               value = ModelInstanceFactory.constructModelInstance(type);
            }
            if(branch==1)
               model1.add(modelParameter, value);
            else
               model2.add(modelParameter, value);
         }
      }
      
   }
   
   /**
    * Given an {@link IExecutionNode} somewhere in a symbolic execution tree
    * and below the method call node, backtracks until the method call node is
    * found. Excludes all intermediary method calls.
    *
    * @param node the node
    * @author Christopher
    */
   private IExecutionMethodCall getMethodCallNode(final IExecutionNode node) {

       IExecutionMethodCall methodCall = getMethodCallNode_helper(node);
       while (true) {
           IExecutionMethodCall next = getMethodCallNode_helper(methodCall.getParent());
           if (next == null) {
               break;
           } else {
               methodCall = next;
           }
       }
       return methodCall;
   }

   private IExecutionMethodCall getMethodCallNode_helper(final IExecutionNode node) {
       if (node == null || node instanceof IExecutionMethodCall) {
           return (IExecutionMethodCall) node;
       } else {
           return getMethodCallNode_helper(node.getParent());
       }
   }
   
   
   /**
    * investigate self object to retrieve information of all fields and add it into exploit model
    * */
   private void investigateSelf(IExecutionVariable var) throws ProofInputException{
      if (var.getProgramVariable() instanceof LocationVariable){         
         //add variable to model1 and model 2
         if(!new HeapHandler().isHeap(var)){               
            addFieldToModel(var,1);
            addFieldToModel(var,2);
         }
         //recursively work with child variable of this variable
         IExecutionValue[] values =var.getValues();
         for(IExecutionValue value:values){
            IExecutionVariable[] vchilds=value.getChildVariables();
            for(IExecutionVariable vchild:vchilds){
               investigateSelf(vchild) ;
            }
         }
      }         
   }
   
   /**
    * called if var is heap (started by "self")
    * @throws ProofInputException 
    * */
   private void addSelfToModel(IExecutionVariable var, int branch) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
      final ModelInstance selfInstance = ModelInstanceFactory.constructModelInstance(container);
      
      final ModelVariable self = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), var.getName());
      
      if(branch==1)
         model1.add(self, selfInstance);
      else
         model2.add(self, selfInstance);
   }
   
   /**
    * adds field to model, links fields with container object
    * */
   private void addFieldToModel(IExecutionVariable var, int branch) throws ProofInputException{
      String identifier=var.getName();      
      identifier=HEAP_NAME+"_"+identifier;

      /*
       * Check that the variable we found is not already present in the model.
       */
      ModelVariable currentVariable;
      if(branch==1){
         currentVariable = model1.getVariable(identifier);
      }else{
         currentVariable = model2.getVariable(identifier);
      }
      if ((currentVariable != null) && currentVariable.isParameter()) {
          return;
      }

      //final ModelVariable variable = ModelVariableFactory.constructModelVariable((ProgramVariable)var, identifier);
      final ModelVariable variable=new ModelVariable(var.getProgramVariable(),identifier);
      Object instance;
      if (TermParser.isPrimitiveType(var.getProgramVariable().sort().name().toString())) {
          //The term is a static variable. Identify and connect it with its parent class.
          instance = ModelBuilderVisitor.resolvePrimitiveType(var.getProgramVariable());
      } else {
          instance = ModelInstanceFactory.constructModelInstance(var.getProgramVariable().getKeYJavaType());
      }

      /*
       * Add the variable and its instance to the Model. This might seem
       * premature, but must be done to preserve referential integrity and
       * avoiding extra work.
       */
      if(branch==1){
         model1.add(variable, instance);
         model1.assignField(variable, model1.getVariable(HEAP_NAME));
      }else{
         model2.add(variable, instance);
         model2.assignField(variable, model2.getVariable(HEAP_NAME));
      }
   }
   
   /**
    * print out exploit model, just for checking purpose
    * */
   public void printExploitModel(int branch){
      Model model;
      if(branch==1){
         model=model1;
      }else{
         model=model2;
      }
      System.out.println("model " + branch + " : ");
      for(ModelVariable mv : model.getVariables()){
         System.out.print(mv.getIdentifier()+": ");
         if(mv.isPrimitive())
            System.out.println(mv.getValue());
         else{
            ModelInstance mi=(ModelInstance)mv.getValue();
            System.out.println(mi.toString() + " ; " + mi.getReferees().get(0) + " includes: ");
            for(ModelVariable mvv : mi.getFields()){
               System.out.println(mvv.getIdentifier()+" : " + mvv.getVariableName()+" : " + mvv.getValue());
            }
            System.out.println("-----");
         }
      }
      System.out.println();      
   }
   
   /**
    * Instantiate values for exploit model from an integer concrete model
    * */
   public void instantiateExploitModelInt(final Map<String,Integer> concreteValues){
      for(String varName: concreteValues.keySet()){         
         if(!isDualVar(concreteValues, varName)){  //if varName is not a high or low value
            final ModelVariable variable1 =model1.getVariable(varName);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(varName));
            
            final ModelVariable variable2 =model2.getVariable(varName);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(varName));
         }else{
            String prefix=varName.substring(0, varName.length()-2);
            //get variable in concrete model corresponding with model1            
            final ModelVariable variable1 = model1.getVariable(prefix);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(prefix+"_1"));
            
            // get variable in concrete model corresponding with model2            
            final ModelVariable variable2 = model2.getVariable(prefix);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(prefix+"_2"));
         }
      }
   }
   
   /**
    * check if a variable is dual value or not
    * dual value: is high or low value (h1, h2) or (l1,l2)
    * */
   private boolean isDualVar(final Map<String,Integer> concreteValues,final String varName){
      //remove the suffix  _1 or _2 of varName
      if((!varName.endsWith("_1"))&&(!varName.endsWith("_2"))){
         return false;
      }else{
         String prefix=varName.substring(0, varName.length()-2);
         if((concreteValues.containsKey(prefix+"_1"))&&(concreteValues.containsKey(prefix+"_2")))
            return true;
         else
            return false;
      }
   }
}

