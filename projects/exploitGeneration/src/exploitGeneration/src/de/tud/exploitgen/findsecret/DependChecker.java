package de.tud.exploitgen.findsecret;

import java.util.List;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.PairTerm;
import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.TermTransformer;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;

/*
 * given a function f(V)
 * check if the value of function f(V) depends on C \in V (V=C \cup D)
 * idea: check satisfiability of formula:
 * f(C1,D) != f(C2,D)
 * if above formula is satisfiable, then f(V) depends on C
 * otherwise f(V) is C-free
 * */
public class DependChecker {
	private Term func; //function to be checked
	private List<ModelVariable> listCheckingVars;
	private Services services; //used to construct term
	public DependChecker(Term func, List<ModelVariable> listCheckingVars,
			Services services) {
		super();
		this.func = func;
		this.listCheckingVars = listCheckingVars;
		this.services = services;
		
	}
	
	private PairTermCollection createPTCCheckingVars(){
		PairTermCollection result = new PairTermCollection(services);
		TermBuilder tb = services.getTermBuilder();
		//TODO: solve array!
		for(ModelVariable mv: listCheckingVars){
			String varName=mv.getIdentifier(); 
			LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),mv.getType());
	         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),mv.getType());
	         
	         //create two terms from two location variables
	         Term t1 = tb.var(lv1);
	         Term t2 = tb.var(lv2);
			result.add(varName, new PairTerm(t1,t2,services));
		}
		return result;
	}
	
	public boolean checkDependence(){
		PairTermCollection ptcCheckingVars = createPTCCheckingVars();
		TermBuilder tb = services.getTermBuilder();
		
		Term value1 = ptcCheckingVars.replacePVByNameAndBranch(func, 1);
		Term value2 = ptcCheckingVars.replacePVByNameAndBranch(func, 2);
		
		Term formula = tb.not(tb.equals(value1, value2));
		formula = new TermTransformer(services).transformBWXORTerm(formula, 4);
		//System.out.println("low-independent formula: " + formula);
		Z3Solver z3Solver = new Z3Solver(formula, services);
		return z3Solver.checkSatisfiable();
	}
	
}
