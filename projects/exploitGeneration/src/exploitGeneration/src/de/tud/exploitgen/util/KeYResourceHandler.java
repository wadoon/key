/**
 * 
 */
package de.tud.exploitgen.util;



import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class supplies several necessary methods to resolve resource relevant to KeY (precondition, program variable etc)
 * @author Huy Do
 *
 */
public class KeYResourceHandler {
   
   
   private static final TermFactory tf = new TermFactory();
   private static final Term tt = tf.createTerm(Junctor.TRUE);
   private static final Term ff = tf.createTerm(Junctor.FALSE);
   /* **************************************************************
    * resolve precondition
    * **************************************************************/
      
   /*********************************************************
    * @param precond
    * @return precond without default item java.lang.Object::<inv>(heap,self)
    */   
   public static Term removeDefaultPrecondition(Term precond){
      if(precond!=null){
         //if found default precondition, just remove it (replace it by null)
         if(!precond.toString().contains("java.lang.Object::<inv>(heap,self)"))
            return precond;
         else if(precond.toString().equals("java.lang.Object::<inv>(heap,self)"))
            return tt;
         else{       
            return tf.createTerm(precond.op(),removeDefaultPreconditionInSubTerm(precond.subs()));
         }
      }else return null;
   }
   private static Term[] removeDefaultPreconditionInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeDefaultPrecondition(subs.get(i));    
      return (result);
   }
   
   
   
   
   /* *********************************************************************
    * resolve IProgramVaribale
    * *********************************************************************/
   
   /**********************************************************************************************
    * @param var: {@link IExecutionVariable}
    * get name of variable. 
    * The name will be resolved in case it is parameter of method (prefix "_" is added to the name)
    * or
    * if variable is static, it will remove prefix "<class name>::"
    * */
   public static String getVarName(IExecutionVariable var) throws ProofInputException{      
      String varName=var.getName();
      
      /*
       * check if var is method parameter. In this case, name of var is added by prefix "_" that should be eliminated before checking
       * */
      if(HeapHandler.isParameter(var) && (varName.startsWith("_"))){ //is method parameter        
         varName=varName.substring(1); //eliminate prefix "_"
      }else if(HeapHandler.isStatic(var)){
         int idx = varName.indexOf("::");
         varName = varName.substring(idx+2);
         varName = "null_" + varName;
      }
      return varName;
   }   
   
   /***
    * get name of class containing static variable
    * the name is stated between "." and "::"
    * */
   public static String getAccessClassNameOfStaticVar(IExecutionVariable var)throws ProofInputException{     
      if(HeapHandler.isStatic(var)){
         String varName=var.getName();
         int idx = varName.indexOf("::");
         varName =  varName.substring(0, idx);
         idx = varName.indexOf(".");
         varName = varName.substring(idx+1);
         return varName;
      }else
         return "";
   }
   
   /*
    * remove default condition added automatically by KeY for object variables.
    * it usually appears in path condition accessing an object
    * */
   public static Term removeNotnullDefaultCondition(Term t){
      if(isNotnullDefaultCondition(t))
         return tt;
      else{
         return tf.createTerm(t.op(),removeNotnullDefaultConditionInSubTerm(t.subs()));
      }
   }
   
   private static Term[] removeNotnullDefaultConditionInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeNotnullDefaultCondition(subs.get(i));    
      return (result);
   }
     
   
   /*
    * replace EqualNull term by ff (FALSE value)
    * */
   public static Term removeEqualNull(Term t){
      if(isEqualNull(t))
         return ff;
      else{
         return tf.createTerm(t.op(),removeEqualNullInSubTerm(t.subs()));
      }
   }
   
   private static Term[] removeEqualNullInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeEqualNull(subs.get(i));    
      return (result);
   }
     
   
   /*
    * replace EqualTrue term by tt (TRUE value)
    * */
   public static Term removeEqualTRUE(Term t){
      if(isEqualTRUEConstraint(t))
         return tt;
      else{
         return tf.createTerm(t.op(),removeEqualTRUEInSubTerm(t.subs()));
      }
   }
   
   private static Term[] removeEqualTRUEInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeEqualTRUE(subs.get(i));    
      return (result);
   }
   
   /************* methods classifying the constraint of node or variable ****************************/
   
   /*
    * check if a term is not null default condition, which has following format:
    * not(equals(obj,null))
    * */
   public static boolean isNotnullDefaultCondition(Term t){      
      if(t.op().toString().equalsIgnoreCase("nonNull"))
         return true;
      else{
         if(TermParser.isNot(t)){
            Term tsub=t.sub(0);
            if(TermParser.isEquals(tsub)){
               if(TermParser.isNullSort(tsub.sub(1)))
                  return true;
            }
         }
      }
      return false;
   }
   
   /*
    * check if t is equal comparator of an object and a null value
    * */
   public static boolean isEqualNull(Term t){
      if(TermParser.isEquals(t)){
         if(TermParser.isNullSort(t.sub(0)) || TermParser.isNullSort(t.sub(1)))
            return true;
      }
      return false;
   }
   
   /*
    * check if term is equal TRUE constraint, which has following format:
    * equals(obj, TRUE)
    * */
   public static boolean isEqualTRUEConstraint(Term t){
      if(TermParser.isEquals(t)){
         if(TermParser.isBooleanTrue(t.sub(1)))
            return true;
      }
      return false;
   }
   /*
    * check if term is wellFormed(heap) 
    * TODO: should revise using sort of term
    * */
   public static boolean isWellFormed(Term t){
      if(t.toString().startsWith("wellFormed"))
         return true;
      else
         return false;
   }
   
   /*
    * check if term is measuredByEmpty
    * TODO: should revise using sort of term
    * */
   public static boolean isMeasuredByEmpty(Term t){
      if(t.toString().equalsIgnoreCase("measuredByEmpty"))
         return true;
      else
         return false;
   }
   
   /*
    * check if a term is null constraint, which has following format:
    * nequals(exc_0,null))
    * */
   public static boolean isNullConstraint(Term t){
      
      if(TermParser.isEquals(t)){
         if(TermParser.isNullSort(t.sub(1)))
            return true;
      }      
      return false;
   }
   
   public static boolean isNotUpdateApp(Term t){
      if(TermParser.isNot(t)){
         if(t.sub(0).toString().startsWith("update-application"))
            return true;
      }
      return false;
   }
   
   //check if constraint term t is a useful constraint (means that t can be used to construct interference term)
   public static boolean isUsefulConstraint(Term t){
      if(   isMeasuredByEmpty(t) ||
            isNotnullDefaultCondition(t) ||
            isNullConstraint(t) ||
            isEqualTRUEConstraint(t) ||
            isNotUpdateApp(t) ||
            TermParser.isForAllQuantifier(t)||
            isWellFormed(t))
         return false;
      else
         return true;               
   }
   
   /*********** useful methods resolving array type */
   
   /*
    * return true if t is length function of an array,
    * otherwise return false
    * */
   public static boolean isLengthFunction(Term t){
      if(TermParser.isFunction(t)){
         if(t.op().toString().equals("length"))
            return true;
      }
      return false;
   }
   
   /*
    * return true if t represents an element of an array
    * otherwise return false
    * */
   public static boolean isArrayElement(Term t){
      if(t.toString().startsWith("arr(Z("))
         return true;
      else
         return false;         
   }
   
   /*
    * input: t = arr(Z(1#))
    * return 1
    * if t is not array element, return -1
    * */
   public static int getArrayIndex(Term t){
      if(isArrayElement(t)){
         return TermParser.getIntegerValue(t.sub(0));
      }
      return -1;         
   }
   
   /*
   * input: t = arr(Z(1#))
   * return "[1]"
   * if t is not array element, return [-1]
   * */
   public static String getArrayElementName(Term t){
      if(isArrayElement(t)){
         return "[" + getArrayIndex(t) + "]";
      }
      return "[-1]";
   }
   
   /*
    * return the name of variable representing for length function.
    * for example, if t is: length(int[]::select(heap,self,demo.ArrayType::$array1))
    * then the method will return "self_array1_length"
    * */
   public static String getVarName4LengthFunction(Term t){
      String result = "";
      if(isLengthFunction(t)){
         Term obj = t.sub(0);
         if(HeapHandler.isHeapSelectFunction(t)){
            result = HeapHandler.getFieldNameOfHeapSelectFunction(obj);
         }else{
            result = obj.toString();
         }
         return result + "_length";
      }
      
      return result;
   }
   
   
}
