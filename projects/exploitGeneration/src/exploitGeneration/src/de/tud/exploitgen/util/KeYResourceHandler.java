/**
 * 
 */
package de.tud.exploitgen.util;



import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class supplies several necessary methods to resolve resource relevant to KeY (precondition, program variable etc)
 * @author Huy Do
 *
 */
public class KeYResourceHandler {
   
   
   private static final TermFactory tf = new TermFactory();
   private static final Term tt = tf.createTerm(Junctor.TRUE);
   /* **************************************************************
    * resolve precondition
    * **************************************************************/
      
   /*********************************************************
    * @param precond
    * @return precond without default item java.lang.Object::<inv>(heap,self)
    */   
   public static Term removeDefaultPrecondition(Term precond){
      if(precond!=null){
         //if found default precondition, just remove it (replace it by null)
         if(!precond.toString().contains("java.lang.Object::<inv>(heap,self)"))
            return precond;
         else if(precond.toString().equals("java.lang.Object::<inv>(heap,self)"))
            return tt;
         else{       
            return tf.createTerm(precond.op(),removeDefaultPreconditionInSubTerm(precond.subs()));
         }
      }else return null;
   }
   private static Term[] removeDefaultPreconditionInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeDefaultPrecondition(subs.get(i));    
      return (result);
   }
   
   
   
   
   /* *********************************************************************
    * resolve IProgramVaribale
    * *********************************************************************/
   
   /**********************************************************************************************
    * @param var: {@link IExecutionVariable}
    * get name of variable. 
    * The name will be resolved in case it is parameter of method (prefix "_" is added to the name)
    * or
    * if variable is static, it will remove prefix "<class name>::"
    * */
   public static String getVarName(IExecutionVariable var) throws ProofInputException{      
      String varName=var.getName();
      
      /*
       * check if var is method parameter. In this case, name of var is added by prefix "_" that should be eliminated before checking
       * */
      if(HeapHandler.isParameter(var) && (varName.startsWith("_"))){ //is method parameter        
         varName=varName.substring(1); //eliminate prefix "_"
      }else if(HeapHandler.isStatic(var)){
         int idx = varName.indexOf("::");
         varName = varName.substring(idx+2);
         varName = "null_" + varName;
      }
      return varName;
   }   
   
   /***
    * get name of class containing static variable
    * the name is stated between "." and "::"
    * */
   public static String getAccessClassNameOfStaticVar(IExecutionVariable var)throws ProofInputException{     
      if(HeapHandler.isStatic(var)){
         String varName=var.getName();
         int idx = varName.indexOf("::");
         varName =  varName.substring(0, idx);
         idx = varName.indexOf(".");
         varName = varName.substring(idx+1);
         return varName;
      }else
         return "";
   }
   
   /*
    * remove default condition added automatically by KeY for object variables.
    * it usually appears in path condition accessing an object
    * */
   public static Term removeNotnullDefaultCondition(Term t){
      if(isNotnullDefaultCondition(t))
         return tt;
      else{
         return tf.createTerm(t.op(),removeNotnullDefaultConditionInSubTerm(t.subs()));
      }
   }
   
   private static Term[] removeNotnullDefaultConditionInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeNotnullDefaultCondition(subs.get(i));    
      return (result);
   }
     
   
   /************* methods classifying the constraint of node or variable ****************************/
   
   /*
    * check if a term is not null default condition, which has following format:
    * not(equals(obj,null))
    * */
   public static boolean isNotnullDefaultCondition(Term t){
      if(TermParser.isNot(t)){
         Term tsub=t.sub(0);
         if(TermParser.isEquals(tsub)){
            if(TermParser.isNullSort(tsub.sub(1)))
               return true;
         }
      }
      return false;
   }
   
   /*
    * check if term is equal TRUE constraint, which has following format:
    * equals(obj, TRUE)
    * */
   public static boolean isEqualTRUEConstraint(Term t){
      if(TermParser.isEquals(t)){
         if(TermParser.isBooleanTrue(t.sub(1)))
            return true;
      }
      return false;
   }
   /*
    * check if term is wellFormed(heap) 
    * TODO: should revise using sort of term
    * */
   public static boolean isWellFormed(Term t){
      if(t.toString().startsWith("wellFormed"))
         return true;
      else
         return false;
   }
   
   /*
    * check if term is measuredByEmpty
    * TODO: should revise using sort of term
    * */
   public static boolean isMeasuredByEmpty(Term t){
      if(t.toString().equalsIgnoreCase("measuredByEmpty"))
         return true;
      else
         return false;
   }
   
   /*
    * check if a term is null constraint, which has following format:
    * nequals(exc_0,null))
    * */
   public static boolean isNullConstraint(Term t){
      
      if(TermParser.isEquals(t)){
         if(TermParser.isNullSort(t.sub(1)))
            return true;
      }      
      return false;
   }
   
   public static boolean isNotUpdateApp(Term t){
      if(TermParser.isNot(t)){
         if(t.sub(0).toString().startsWith("update-application"))
            return true;
      }
      return false;
   }
   
   //check if constraint term t is a useful constraint (means that t can be used to construct interference term)
   public static boolean isUsefulConstraint(Term t){
      if(   isMeasuredByEmpty(t) ||
            isNotnullDefaultCondition(t) ||
            isNullConstraint(t) ||
            isEqualTRUEConstraint(t) ||
            isNotUpdateApp(t) ||
            TermParser.isForAllQuantifier(t)||
            isWellFormed(t))
         return false;
      else
         return true;               
   }
   
   /*********** useful methods resolving array type */
   
   public static boolean isLengthFunction(Term t){
      if(TermParser.isFunction(t)){
         if(t.op().toString().equals("length"))
            return true;
      }
      return false;
   }
   
   
}
