/**
 * 
 */
package de.tud.exploitgen.util;




import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.abstraction.PrimitiveType;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;

import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class supplies several necessary methods to resolve resource relevant to KeY (precondition, program variable etc)
 * @author Huy Do
 *
 */
public class KeYResourceHandler {
   
   
   private static final TermFactory tf = new TermFactory();
   private static final Term tt = tf.createTerm(Junctor.TRUE);
   private static final Term ff = tf.createTerm(Junctor.FALSE);
   /* **************************************************************
    * resolve precondition
    * **************************************************************/
      
   /*********************************************************
    * @param precond
    * @return precond without default item java.lang.Object::<inv>(heap,self)
    */   
   public static Term removeDefaultPrecondition(Term precond){
      if(precond!=null){
         //if found default precondition, just remove it (replace it by null)
         if(!precond.toString().contains("java.lang.Object::<inv>(heap,self)"))
            return precond;
         else if(precond.toString().equals("java.lang.Object::<inv>(heap,self)"))
            return tt;
         else{       
            return tf.createTerm(precond.op(),removeDefaultPreconditionInSubTerm(precond.subs()));
         }
      }else return null;
   }
   private static Term[] removeDefaultPreconditionInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeDefaultPrecondition(subs.get(i));    
      return (result);
   }
   
   
   
   
   /* *********************************************************************
    * resolve IProgramVaribale
    * *********************************************************************/
   
   /**********************************************************************************************
    * @param var: {@link IExecutionVariable}
    * get name of variable. 
    * The name will be resolved in case it is parameter of method (prefix "_" is added to the name)
    * or
    * if variable is static, it will remove prefix "<class name>::"
    * */
   public static String getVarName(IExecutionVariable var) throws ProofInputException{      
      String varName=var.getName();
      
      /*
       * check if var is method parameter. In this case, name of var is added by prefix "_" that should be eliminated before checking
       * */
      if(HeapHandler.isParameter(var) && (varName.startsWith("_"))){ //is method parameter        
         varName=varName.substring(1); //eliminate prefix "_"
      }else if(HeapHandler.isStatic(var)){
         int idx = varName.indexOf("::");
         varName = varName.substring(idx+2);
         varName = "null_" + varName;
      }
      return varName;
   }   
   
   /***
    * get name of class containing static variable
    * the name is stated between "." and "::"
    * */
   public static String getAccessClassNameOfStaticVar(IExecutionVariable var)throws ProofInputException{     
      if(HeapHandler.isStatic(var)){
         String varName=var.getName();
         int idx = varName.indexOf("::");
         varName =  varName.substring(0, idx);
         idx = varName.indexOf(".");
         varName = varName.substring(idx+1);
         return varName;
      }else
         return "";
   }
   
   /*
    * remove default condition added automatically by KeY for object variables.
    * it usually appears in path condition accessing an object
    * */
   public static Term removeNotnullDefaultCondition(Term t){
      if(isNotnullDefaultCondition(t))
         return tt;
      else{
         return tf.createTerm(t.op(),removeNotnullDefaultConditionInSubTerm(t.subs()),t.boundVars(), t.javaBlock());
      }
   }
   
   private static Term[] removeNotnullDefaultConditionInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeNotnullDefaultCondition(subs.get(i));    
      return (result);
   }
     
   
   /*
    * replace EqualNull term by ff (FALSE value)
    * */
   public static Term removeEqualNull(Term t){
      if(isEqualNull(t))
         return ff;
      else{
         return tf.createTerm(t.op(),removeEqualNullInSubTerm(t.subs()));
      }
   }
   
   private static Term[] removeEqualNullInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeEqualNull(subs.get(i));    
      return (result);
   }
     
   
  
   
   /*
    * replace all unnecessary terms
    * those terms are equal null, equal true and not null term, used to maintain that all objects has been created already
    * */
   public static Term removeUnnecessaryTerm(Term t){
      if(t!=null){
         if(isObjectCreatedEqualTrue(t) || isNotnullDefaultCondition(t)){
            return tt;
         }else if(isEqualNull(t)){
            return ff;
         }else {
            return tf.createTerm(t.op(), removeUnnecessaryInSubTerm(t.subs()), t.boundVars(),t.javaBlock());
         }
         
      }else
         return null;
   }
   
   private static Term[] removeUnnecessaryInSubTerm(final ImmutableArray<Term> subs ){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=removeUnnecessaryTerm(subs.get(i));    
      return (result);
   }
   
   /************* methods classifying the constraint of node or variable ****************************/
   
   /*
    * check if a term is not null default condition, which has following format:
    * not(equals(obj,null))
    * */
   public static boolean isNotnullDefaultCondition(Term t){      
      if(t.op().toString().equalsIgnoreCase("nonNull"))
         return true;
      else{
         if(TermParser.isNot(t)){
            Term tsub=t.sub(0);
            if(TermParser.isEquals(tsub)){
               if(TermParser.isNullSort(tsub.sub(1)))
                  return true;
            }
         }
      }
      return false;
   }
   
   /*
    * check if t is equal comparator of an object and a null value
    * */
   public static boolean isEqualNull(Term t){
      if(TermParser.isEquals(t)){
         if(TermParser.isNullSort(t.sub(0)) || TermParser.isNullSort(t.sub(1)))
            return true;
      }
      return false;
   }
   
   
   
   /*
    * check if term is wellFormed(heap) 
    * TODO: should revise using sort of term
    * */
   public static boolean isWellFormed(Term t){
      if(t.toString().startsWith("wellFormed"))
         return true;
      else
         return false;
   }
   
   /*
    * check if term is measuredByEmpty
    * TODO: should revise using sort of term
    * */
   public static boolean isMeasuredByEmpty(Term t){
      if(t.toString().equalsIgnoreCase("measuredByEmpty"))
         return true;
      else
         return false;
   }
   
   
   
   public static boolean isNotUpdateApp(Term t){
      if(TermParser.isNot(t)){
         if(t.sub(0).toString().startsWith("update-application"))
            return true;
      }
      return false;
   }
  
   public static boolean isEqualAnon(Term t){
      if(TermParser.isEquals(t))
         if(t.sub(0).toString().startsWith("anon"))
            return true;
      return false;
   }
   
   public static boolean isEqualNullOrObjectCreatedEqualTrue(Term t){
      if(TermParser.isOr(t)){
         if(isEqualNull(t.sub(0)) && isObjectCreatedEqualTrue(t.sub(1)))
            return true;
      }
      return false;
   }
   
   public static boolean isOrNotEqualNull(Term t){
      if(TermParser.isOr(t)){
         if(TermParser.isNot(t.sub(1))){
            if(isEqualNull(t.sub(1).sub(0)))
               return true;
         }
      }
      return false;
   }
   
   //check if constraint term t is a useful constraint (means that t can be used to construct interference term)
   public static boolean isUsefulConstraint(Term t){
      if(   isMeasuredByEmpty(t) ||
            isNotnullDefaultCondition(t) ||
            isEqualNull(t) ||
            isObjectCreatedEqualTrue(t) ||
            isNotObjectCreatedEqualTrue(t) ||
            isNotUpdateApp(t) ||
            isExactInstanceEqualTrue(t) ||
            //TermParser.isIfThenElse(t)|| 
            isOrNotEqualNull(t) ||
            isEqualNullOrObjectCreatedEqualTrue(t) ||
            isEqualAnon(t) ||
            isObjectInv(t) ||
            isWellFormed(t))
         return false;
      else
         return true;               
   }
  
   public static boolean containUselessConstraint(Term t){
      if(t!=null){
         if(!isUsefulConstraint(t))
            return true;
         else{
            return containUselessConstraintInSubs(t.subs());
         }
      }else
         return false;
   }
   
   private static boolean containUselessConstraintInSubs(ImmutableArray<Term> subs){
      for(Term t: subs){
         if(containUselessConstraint(t))
            return true;
      }
      return false;
   } 
   
   //check if term t is the equal term that check if an object is created or not
   public static boolean isObjectCreatedTerm(Term t){
      if(t.toString().contains("java.lang.Object::<created>"))
         return true;
      else
         return false;
   }
   
  
  
   
   public static boolean isObjectCreatedEqualTrue(Term t){
      if(TermParser.isEquals(t)){
         if(isObjectCreatedTerm(t.sub(0))&& TermParser.isBooleanTrue(t.sub(1))){
            return true;
         }       
            
      }
      return false;
   }
   
   public static boolean isNotObjectCreatedEqualTrue(Term t){
      if(TermParser.isNot(t)){
         if(isObjectCreatedEqualTrue(t.sub(0)))
            return true;
        
      }
      return false;
   }
   
   public static boolean isExactInstanceEqualTrue(Term t){
      if(TermParser.isEquals(t)){
         if(TermParser.isBooleanTrue(t.sub(1)))
            if(t.sub(0).toString().contains("exactInstance("))
               return true;               
      }
      return false;
   }
   
   public static boolean isObjectInv(Term t){
      if(t.toString().startsWith("java.lang.Object::<inv>"))
         return true;
      else
         return false;
   }
   
   /**
    * @param term the term
    * @return iff. the term is not a program variable, but is a artificial variable with primitive type (integer, boolean)
    * added by Huy
    * used for loop invariant variables
    * TODO: should be refined to eliminate parameter
    * */
   
   public static boolean isArtificialVariable(final Term term){
      if(HeapHandler.isAnonHeapSelectFunction(term))
            return true;
      else if(/*TermParser.isPrimitiveType(term)&&*/((term.subs()).size()==0) && !HeapHandler.isField(term) && 
            !TermParser.isInteger(term) &&!TermParser.isIntegerNegation(term)&&!TermParser.isBooleanConstant(term)
            && !isObjectCreatedTerm(term) && !(term.op().toString().equals("#")) && !TermParser.isNullSort(term)){
        //if (term.op().toString().startsWith("_"))
           return true;      
         
      }
      return false;
   }
   
   /*********** useful methods resolving array type */
   
   
   
   
   
  
   /*
    * create KeYJavaType via sort
    * TODO: must be refined!
    * */
   
   public static KeYJavaType createType(Term t){
      
      if(TermParser.isPrimitiveType(t)){
         String typeName = t.sort().name().toString();
         return new KeYJavaType(PrimitiveType.getPrimitiveType(typeName), t.sort());              
      }else{
         return new KeYJavaType(t.sort());
      }
   }
   
}
