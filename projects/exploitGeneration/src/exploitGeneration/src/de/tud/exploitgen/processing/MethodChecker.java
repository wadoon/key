
/* 
*  this class used to check the non-interference of a method
 * it gets all termination nodes of the symbolic execution tree of the method 
 * */


package de.tud.exploitgen.processing;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.processing.exploit.ExploitModelCreator;
import de.tud.exploitgen.processing.exploit.ExploitTestCases;
import de.tud.exploitgen.processing.node.NodeDetail;
import de.tud.exploitgen.processing.node.NodeInvestigator;
import de.tud.exploitgen.processing.node.NodeParser;
import de.tud.exploitgen.processing.specification.IFBarrier;
import de.tud.exploitgen.processing.specification.VariableClassifier;
import de.tud.exploitgen.solver.AbstractFormulaSolver;
import de.tud.exploitgen.solver.SMTWorker;

import de.tud.exploitgen.solver.Z3Solver;
//import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;

import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.smt.AbstractSMTTranslator.Configuration;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class MethodChecker {
   private KeYJavaMethod method; //contains information of method (maybe needed in variable checker)
   private List<IExecutionNode<?>> leafNodes; //contains leaf nodes of symbolic execution tree of method   
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   IExecutionStart root;  //the root node of symbolic execution tree
   private List<NodeDetail> nodeDetails;
   private int depth; //depth of sub-field's sequence being investigated
   
   /**
    * @param method
    * @param ifSpecs
    * @param root
    * @throws ProofInputException 
    * @throws IllegalFormulaException 
    */
   public MethodChecker(KeYJavaMethod method, List<IFBarrier> ifSpecs,
         IExecutionStart root, int depth) throws ProofInputException, IllegalFormulaException {
      super();
      this.method = method;
      this.ifSpecs = ifSpecs;
      this.root = root;
      leafNodes = parseLeafNodes(root);      
      System.out.println("number of symbolic execution paths that have to resolve: " + leafNodes.size());
      this.depth = depth;      
      nodeDetails = createListNodeDetail();
   }


       
   
   /**
    * check the input method to get list of exploit model if the method is insecure 
    * @throws IllegalFormulaException 
    * */
   private List<ExploitModel> checkMethod2GetExploitModels(VariableClassifier vc) throws IllegalFormulaException{
      List<ExploitModel> result = Collections.synchronizedList(new LinkedList<ExploitModel>());
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
           System.out.println("\n---------------------------------------------"); 
           System.out.print("Investigating symbolic execution path " + i);
            if (j!=i){
               System.out.print(" and path " + j);
            }
            System.out.println();
            try {
             //check branch i and branch j to get all exploit models if they exists               
               List<ExploitModel> eModels = getExploitModelsVia2Nodes(i, j,vc);
             //add models to the result
               
               if(eModels.size()>0){                  
                 /* for(ExploitModel em: eModels){
                     result.add(em);
                  }*/
                  
                  result.addAll(eModels);
               }
            }
            catch (TermTransformerException e) {
               //eModels=null;
               e.printStackTrace();
            }
            catch (ProofInputException e) {
               //eModels=null;
               e.printStackTrace();
            }
            
         }
      }
      return result;
   }
    
    
   private List<ModelVariable> getListConcreteMV(Term iTerm){
      AbstractFormulaSolver fs=new Z3Solver(iTerm);      //use Z3 solver
      List<ModelVariable> result = fs.solveFormula();
      /*if(result!=null){
         System.out.println("List of ModelVariable objects containing concrete values:");
         for(ModelVariable mv: result){
            System.out.println(mv.getIdentifier() + " : " + mv.getValue());
         }
      }*/
      return result;
   }
   
  
   
   
   /** return list of exploit model generated by solving two nodes 
    * @param node1, node2, vc
    * @throws ProofInputException 
    * @throws TermTransformerException 
    * @throws IllegalFormulaException */
   private List<ExploitModel> getExploitModelsVia2Nodes(int node1, int node2, VariableClassifier vc) throws ProofInputException, TermTransformerException, IllegalFormulaException{      
      List<ExploitModel> result = Collections.synchronizedList(new LinkedList<ExploitModel>());
      //pass two nodes to TwoBranchesProcessor to solve and get interference formulas      
      
      //NodeDetail nd1 = new NodeDetail(leafNodes.get(node1));
      //NodeDetail nd2 = new NodeDetail(leafNodes.get(node2));
      NodeDetail nd1 = new NodeDetail(nodeDetails.get(node1));
      NodeDetail nd2 = new NodeDetail(nodeDetails.get(node2));
      ExploitModel exploitModel = new ExploitModelCreator(nd1, nd2).getExploitModel();
      
      vc.buildListIdentifiers(exploitModel);//necessary step!
      TwoNodesProcessor tnp = new TwoNodesProcessor(nd1, nd2, method, vc);
      
      //get all interference formula for each low variables     
      Map<ModelVariable,Term> mapIFormulas = tnp.getAllInterferenceFormula();
      //solve each formular corresponding with specific low variable to get corresponding concrete model and build ExploitModel
      boolean oneExploitModel = true;
      for(ModelVariable lowVar: mapIFormulas.keySet()){
         System.out.println("\nlow locations: " + lowVar);
         Term iTerm = mapIFormulas.get(lowVar);
         System.out.println(iTerm);
         
        /* SMTWorker worker = new SMTWorker(method.getServices(),new Configuration(false,false));
         Vector<QuantifiableVariable> boundVars = new Vector<QuantifiableVariable>();
         for(QuantifiableVariable qv: iTerm.boundVars())
            boundVars.add(qv);
         System.out.println("translated term (SMT-LIB2): -----\n" + worker.translateTerm(iTerm, boundVars, method.getServices())+ "\n--------\n");*/
         
         //Map<String,Integer> concreteModel = getConcreteModel(iTerm);        
         List<ModelVariable> concreteModel = getListConcreteMV(iTerm);
         if(concreteModel!=null){        
            if(oneExploitModel){              
               
               //assign values for variables               
           
               
               exploitModel.setLowVar(lowVar); //we are working with this low variable       
               exploitModel.instantiateExploitModel(concreteModel);
               //exploitModel.printModelInfo();
               System.out.println("A vulnerability detected: secret information could be leaked through variable " + exploitModel.getLowVar().getIdentifier() );
               result.add(exploitModel);
               oneExploitModel = false; //change the flag oneExploitModel
            }else{
               //if there are more than one exploit model, we have to recreate ExploitModelBuilder to avoid aliasing
               
               //ExploitModel exploitModel = new ExploitModelCreator(new NodeDetail(leafNodes.get(node1)), new NodeDetail(leafNodes.get(node2))).getExploitModel();
               exploitModel = new ExploitModelCreator(new NodeDetail(nodeDetails.get(node1)), new NodeDetail(nodeDetails.get(node2))).getExploitModel();
               exploitModel.setLowVar(lowVar); //we are working with this low variable
               exploitModel.instantiateExploitModel(concreteModel);
               //exploitModel.printModelInfo();
               System.out.println("A vulnerability detected: secret information could be leaked through variable " + exploitModel.getLowVar().getIdentifier());
               result.add(exploitModel);
            }
         }         
      }      
      return result;
   }
   
   
   /**
    * get leaf nodes of symbolic execution tree from root
    */
   private List<IExecutionNode<?>> parseLeafNodes(IExecutionStart root){
      List<IExecutionNode<?>> leafNodes = new LinkedList<IExecutionNode<?>>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode<?> node = iterator.next();
         /*if(NodeParser.isTerminationNode(node))
            System.out.println("termination node detected: " + node.toString());*/
         if(NodeParser.isNormalTerminationNode(node) && !NodeParser.isExceptionalTerminationNode(node)
               &&!NodeParser.isLoopBodyTerminationNode(node)){            
            IExecutionNode<?> parentNode = node.getParent();
            //if(parentNode instanceof IExecutionNode)
            leafNodes.add(parentNode);
            /*try{
               System.out.println("path condition:: " + parentNode.getPathCondition());
            }catch(Exception e){}*/
         }
      } 
      return leafNodes;
   }
   
   /**
    * get resolved nodes of symbolic execution tree from root
    * @throws ProofInputException 
    * @throws IllegalFormulaException 
    * */
   private List<NodeDetail> createListNodeDetail() throws ProofInputException, IllegalFormulaException{
      List<NodeDetail> result = new LinkedList<NodeDetail>();
      for(IExecutionNode<?> node: leafNodes){
         NodeInvestigator ni = new NodeInvestigator(node, depth);
         result.add(ni.extractNodeDetail());
      }
      
      return result;
   }
 
   public List<ExploitTestCases> checkMethod2GetExploitTestCases() throws IllegalFormulaException{     
      List<ExploitTestCases> result = Collections.synchronizedList(new LinkedList<ExploitTestCases>());
      for(IFBarrier declar: ifSpecs){
         System.out.println("\n==========================================================");
         System.out.println("Checking noninterference specification: " + declar.getDeclaration());
         //create variable checker via declaration
         VariableClassifier vc=new VariableClassifier(method,declar.getDestination(),declar.getSource());         
         
         //get list of exploit model by checking the method with current information flow security specification
         List<ExploitModel> listEM = checkMethod2GetExploitModels(vc);
         //add list of exploit model into exploitTestSuite
         if(!listEM.isEmpty()){            
               ExploitTestCases exploitTestCases=new ExploitTestCases(method, declar, listEM);
               result.add(exploitTestCases);            
         }         
      }
      return result;
   }
   
   
      
}



