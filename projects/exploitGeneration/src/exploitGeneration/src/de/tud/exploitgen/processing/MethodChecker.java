
/* 
*  this class used to check the non-interference of a method
 * it gets all termination nodes of the symbolic execution tree of the method 
 * */


package de.tud.exploitgen.processing;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.processing.exploit.ExploitTestCases;
import de.tud.exploitgen.processing.node.NodeDetail;
import de.tud.exploitgen.processing.node.NodeInvestigator;
import de.tud.exploitgen.processing.node.NodeParser;
import de.tud.exploitgen.processing.specification.IFBarrier;
import de.tud.exploitgen.processing.specification.VariableClassifier;

//import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.proof.init.ProofInputException;

import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionUtil;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class MethodChecker {
   private KeYJavaMethod method; //contains information of method (maybe needed in variable checker)
   private List<IExecutionNode<?>> leafNodes; //contains leaf nodes of symbolic execution tree of method   
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   IExecutionStart root;  //the root node of symbolic execution tree
   private List<NodeDetail> nodeDetails;
   private int depth; //depth of sub-field's sequence being investigated
   
   /**
    * @param method
    * @param ifSpecs
    * @param root
    * @throws ProofInputException 
    * @throws IllegalFormulaException 
    */
   public MethodChecker(KeYJavaMethod method, List<IFBarrier> ifSpecs,
         IExecutionStart root, int depth) throws ProofInputException, IllegalFormulaException {
      super();
      this.method = method;
      this.ifSpecs = ifSpecs;
      this.root = root;
      leafNodes = parseLeafNodes(root);      
      System.out.println("number of symbolic execution paths that have to resolve: " + leafNodes.size());
      this.depth = depth;      
      nodeDetails = createListNodeDetail();      
   }


       
   
   /**
    * check the input method to get list of exploit model if the method is insecure 
    * @throws IllegalFormulaException 
    * */
   private List<ExploitModel> checkMethod2GetExploitModels(VariableClassifier vc) throws IllegalFormulaException{
      List<ExploitModel> result = Collections.synchronizedList(new LinkedList<ExploitModel>());
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
           System.out.println("\n---------------------------------------------"); 
           System.out.print("Investigating symbolic execution path " + i);
            if (j!=i){
               System.out.print(" and path " + j);
            }
            System.out.println();
            try {
             //check branch i and branch j to get all exploit models if they exists               
               List<ExploitModel> eModels = getExploitModelsVia2Nodes(i, j,vc);
             //add models to the result
               
               if(eModels.size()>0){                  
                 /* for(ExploitModel em: eModels){
                     result.add(em);
                  }*/
                  
                  result.addAll(eModels);
               }
            }
            catch (TermTransformerException e) {
               //eModels=null;
               e.printStackTrace();
            }
            catch (ProofInputException e) {
               //eModels=null;
               e.printStackTrace();
            }
            
         }
      }
      return result;
   }
    
    
   /** return list of exploit model generated by solving two nodes 
    * @param node1, node2, vc
    * @throws ProofInputException 
    * @throws TermTransformerException 
    * @throws IllegalFormulaException */
   private List<ExploitModel> getExploitModelsVia2Nodes(int node1, int node2, VariableClassifier vc) throws ProofInputException, TermTransformerException, IllegalFormulaException{     

      //pass two nodes to TwoBranchesProcessor to solve and get interference formulas      
      NodeDetail nd1 = new NodeDetail(nodeDetails.get(node1));
      NodeDetail nd2 = new NodeDetail(nodeDetails.get(node2));     
      
      TwoNodesProcessor tnp = new TwoNodesProcessor(nd1, nd2, method, vc);     
     
      return tnp.getAllExploitModels();   
   }
   
   
   /**
    * get leaf nodes of symbolic execution tree from root
    */
   private List<IExecutionNode<?>> parseLeafNodes(IExecutionStart root){
      List<IExecutionNode<?>> leafNodes = new LinkedList<IExecutionNode<?>>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode<?> node = iterator.next();
         /*if(NodeParser.isTerminationNode(node))
            System.out.println("termination node detected: " + node.toString());*/
         if(NodeParser.isNormalTerminationNode(node) && !NodeParser.isExceptionalTerminationNode(node)
               &&!NodeParser.isLoopBodyTerminationNode(node)){            
            //IExecutionNode<?> parentNode = node.getParent();
            //if(parentNode instanceof IExecutionNode)
            //leafNodes.add(parentNode);
            leafNodes.add(node);
            /*try{
               System.out.println("path condition:: " + parentNode.getPathCondition());
            }catch(Exception e){}*/
         }
      } 
      return leafNodes;
   }
   
   /**
    * get resolved nodes of symbolic execution tree from root
    * @throws ProofInputException 
    * @throws IllegalFormulaException 
    * */
   private List<NodeDetail> createListNodeDetail() throws ProofInputException, IllegalFormulaException{
      List<NodeDetail> result = new LinkedList<NodeDetail>();
      for(int i=0; i<leafNodes.size();i++){
         IExecutionNode<?> node = leafNodes.get(i);
         NodeInvestigator ni = new NodeInvestigator(node, depth);
         NodeDetail nd = ni.extractNodeDetail();
         nd.setIndex(i);
         result.add(nd);
      }
      
      return result;
   }
 
   public List<ExploitTestCases> checkMethod2GetExploitTestCases() throws IllegalFormulaException{     
      List<ExploitTestCases> result = Collections.synchronizedList(new LinkedList<ExploitTestCases>());
      for(IFBarrier declar: ifSpecs){
         System.out.println("\n==========================================================");
         System.out.println("Checking noninterference specification: " + declar.getDeclaration());
         //create variable checker via declaration
         VariableClassifier vc=new VariableClassifier(method,declar.getDestination(),declar.getSource());         
         
         //get list of exploit model by checking the method with current information flow security specification
         List<ExploitModel> listEM = checkMethod2GetExploitModels(vc);
         //add list of exploit model into exploitTestSuite
         if(!listEM.isEmpty()){            
               ExploitTestCases exploitTestCases=new ExploitTestCases(method, declar, listEM);
               result.add(exploitTestCases);            
         }         
      }
      return result;
   }
   
   
      
}



