
/* 
*  this class used to check the non-interference of a method
 * it gets all termination nodes of the symbolic execution tree of the method 
 * */


package de.tud.exploitgen.processing;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.processing.exploit.ExploitModelCreator;
import de.tud.exploitgen.processing.exploit.ExploitTestCases;
import de.tud.exploitgen.processing.node.NodeDetail;
import de.tud.exploitgen.processing.node.NodeParser;
import de.tud.exploitgen.processing.specification.IFBarrier;
import de.tud.exploitgen.processing.specification.VariableClassifier;
import de.tud.exploitgen.solver.AbstractFormulaSolver;

import de.tud.exploitgen.solver.Z3Solver;
//import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;

import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;




import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;


import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class MethodChecker {
   private KeYJavaMethod method; //contains information of method (maybe needed in variable checker)
   private List<IExecutionNode<?>> leafNodes; //contains leaf nodes of symbolic execution tree of method   
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   IExecutionStart root;  //the root node of symbolic execution tree
   private List<NodeDetail> nodeDetails;
      
   
   /**
    * @param method
    * @param ifSpecs
    * @param root
    * @throws ProofInputException 
    */
   public MethodChecker(KeYJavaMethod method, List<IFBarrier> ifSpecs,
         IExecutionStart root) throws ProofInputException {
      super();
      this.method = method;
      this.ifSpecs = ifSpecs;
      this.root = root;
      leafNodes = parseLeafNodes(root);      
      System.out.println("number of leaf nodes: " + leafNodes.size());
      //nodeDetails = createListNodeDetail();
   }


       
   
   /**
    * check the input method to get list of exploit model if the method is insecure 
    * */
   private List<ExploitModel> checkMethod2GetExploitModels(VariableClassifier vc){
      List<ExploitModel> result = Collections.synchronizedList(new LinkedList<ExploitModel>());
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
           System.out.println("\n---------------------------------------------"); 
           System.out.print("Investigating symbolic execution path " + i);
            if (j!=i){
               System.out.print(" and " + j);
            }
            System.out.println();
            try {
             //check branch i and branch j to get all exploit models if they exists
               //List<ExploitModel> eModels = getExploitModels(i, j,vc); 
               List<ExploitModel> eModels = getExploitModelsVia2Nodes(i, j,vc);
             //add models to the result
               
               if(eModels.size()>0){                  
                 /* for(ExploitModel em: eModels){
                     result.add(em);
                  }*/
                  
                  result.addAll(eModels);
               }
            }
            catch (TermTransformerException e) {
               //eModels=null;
               e.printStackTrace();
            }
            catch (ProofInputException e) {
               //eModels=null;
               e.printStackTrace();
            }
            
         }
      }
      return result;
   }
   
   
   /** return concrete values satisfying the interference formula*/
   private Map<String,Integer> getConcreteModel(Term iTerm){
      AbstractFormulaSolver fs=new Z3Solver(iTerm);      //use Z3 solver
      Map<String, Integer> result;
      result = fs.solveFormulaInt();
      return result;
   }
   
      
   
  
   
   
   /** return list of exploit model generated by solving two nodes 
    * @param node1, node2, vc
    * @throws ProofInputException 
    * @throws TermTransformerException */
   private List<ExploitModel> getExploitModelsVia2Nodes(int node1, int node2, VariableClassifier vc) throws ProofInputException, TermTransformerException{      
      List<ExploitModel> result = Collections.synchronizedList(new LinkedList<ExploitModel>());
      //pass two nodes to TwoBranchesProcessor to solve and get interference formulas      
      
      NodeDetail nd1 = new NodeDetail(leafNodes.get(node1));
      NodeDetail nd2 = new NodeDetail(leafNodes.get(node2));
      TwoNodesProcessor tnp = new TwoNodesProcessor(nd1, nd2, method, vc);
      
      //get all interference formula for each low variables     
      Map<ModelVariable,Term> mapIFormulas = tnp.getAllInterferenceFormula();
      //solve each formular corresponding with specific low variable to get corresponding concrete model and build ExploitModel
      boolean oneExploitModel = true;
      for(ModelVariable lowVar: mapIFormulas.keySet()){
         Term iTerm = mapIFormulas.get(lowVar);
         System.out.println(iTerm);
         Map<String,Integer> concreteModel = getConcreteModel(iTerm);        
         
         if(concreteModel!=null){        
            if(oneExploitModel){               
               
               //assign values for variables                
               
               ExploitModel exploitModel = new ExploitModelCreator(nd1, nd2).getExploitModel();
               exploitModel.setLowVar(lowVar); //we are working with this low variable         
               exploitModel.instantiateExploitModelInt(concreteModel);
               //exploitModel.printModelInfo();
               System.out.println("A vulnerability detected: secret information could be leaked through variable " + exploitModel.getLowVar().getVariableName() );
               result.add(exploitModel);
               oneExploitModel = false; //change the flag oneExploitModel
            }else{
               //if there are more than one exploit model, we have to recreate ExploitModelBuilder to avoid aliasing
               
               ExploitModel exploitModel = new ExploitModelCreator(new NodeDetail(leafNodes.get(node1)), new NodeDetail(leafNodes.get(node2))).getExploitModel();
               exploitModel.setLowVar(lowVar); //we are working with this low variable  
               exploitModel.instantiateExploitModelInt(concreteModel);
               //exploitModel.printModelInfo();
               System.out.println("A vulnerability detected: secret information could be leaked through variable " + exploitModel.getLowVar().getVariableName() );
               result.add(exploitModel);
            }
         }         
      }      
      return result;
   }
   
   
   /**
    * get leaf nodes of symbolic execution tree from root
    */
   private List<IExecutionNode<?>> parseLeafNodes(IExecutionStart root){
      List<IExecutionNode<?>> leafNodes = new LinkedList<IExecutionNode<?>>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode<?> node = iterator.next();
         if(NodeParser.isNormalTerminationNode(node)){
            IExecutionNode<?> parentNode = node.getParent();
            //if(parentNode instanceof IExecutionStateNode)
               leafNodes.add(parentNode);
         }
      } 
      return leafNodes;
   }
   
   /**
    * get resolved nodes of symbolic execution tree from root
    * @throws ProofInputException 
    * */
   private List<NodeDetail> createListNodeDetail() throws ProofInputException{
      List<NodeDetail> result = new LinkedList<NodeDetail>();
      for(IExecutionNode<?> node: leafNodes){
         result.add(new NodeDetail(node));
      }
      return result;
   }
 
   public List<ExploitTestCases> checkMethod2GetExploitTestCases(){     
      List<ExploitTestCases> result = Collections.synchronizedList(new LinkedList<ExploitTestCases>());
      for(IFBarrier declar: ifSpecs){
         System.out.println("\n==========================================================");
         System.out.println("Checking noninterference specification: " + declar.getDeclaration());
         //create variable checker via declaration
         VariableClassifier vc=new VariableClassifier(method,declar.getDestination(),declar.getSource());         
         
         //get list of exploit model by checking the method with current information flow security specification
         List<ExploitModel> listEM = checkMethod2GetExploitModels(vc);
         //add list of exploit model into exploitTestSuite
         if(!listEM.isEmpty()){            
               ExploitTestCases exploitTestCases=new ExploitTestCases(method, declar, listEM);
               result.add(exploitTestCases);            
         }         
      }
      return result;
   }
   
   
      
}



