
/* 
*  this class used to check the non-interference of a method
 * it gets all termination nodes of the symbolic execution tree of the method 
 * */


package de.tud.exploitgen.processing;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.processing.exploit.ExploitModelBuilder;
import de.tud.exploitgen.processing.exploit.ExploitTestCases;
import de.tud.exploitgen.solver.AbstractFormulaSolver;

import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.VariableClassifier;
//import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;

import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination.TerminationKind;



import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;


import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class MethodChecker {
   private KeYJavaMethod method; //contains information of method (maybe needed in variable checker)
   private List<IExecutionNode> leafNodes; //contains leaf nodes of symbolic execution tree of method   
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   IExecutionStart root;  //the root node of symbolic execution tree

      
   
   /**
    * @param method
    * @param ifSpecs
    * @param root
    */
   public MethodChecker(KeYJavaMethod method, List<IFBarrier> ifSpecs,
         IExecutionStart root) {
      super();
      this.method = method;
      this.ifSpecs = ifSpecs;
      this.root = root;
      leafNodes = parseLeafNodes(root);
      
   }


       
   
   /**
    * check the input method to get list of exploit model if the method is insecure 
    * */
   private List<ExploitModel> checkMethod2GetExploitModels(VariableClassifier vc){
      List<ExploitModel> result = Collections.synchronizedList(new LinkedList<ExploitModel>());
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
           System.out.println("\n---------------------------------------------"); 
           System.out.print("Investigating symbolic execution path " + i);
            if (j!=i){
               System.out.print(" and " + j);
            }
            System.out.println();
            try {
             //check branch i and branch j to get all exploit models if they exists
               List<ExploitModel> eModels = getExploitModels(i, j,vc); 
             //add models to the result
               
               if(eModels.size()>0){                  
                 /* for(ExploitModel em: eModels){
                     result.add(em);
                  }*/
                  
                  result.addAll(eModels);
               }
            }
            catch (TermTransformerException e) {
               //eModels=null;
               e.printStackTrace();
            }
            catch (ProofInputException e) {
               //eModels=null;
               e.printStackTrace();
            }
            
         }
      }
      return result;
   }
   
   
   /** return concrete values satisfying the interference formula*/
   private Map<String,Integer> getConcreteModel(Term iTerm){
      AbstractFormulaSolver fs=new Z3Solver(iTerm);      //use Z3 solver
      Map<String, Integer> result;
      result = fs.solveFormulaInt();
      return result;
   }
   
      
   
   /** return list of exploit model generated by solving two nodes 
    * @param node1, node2, vc
    * @throws ProofInputException 
    * @throws TermTransformerException */
   private List<ExploitModel> getExploitModels(int node1, int node2, VariableClassifier vc) throws ProofInputException, TermTransformerException{      
      List<ExploitModel> result = Collections.synchronizedList(new LinkedList<ExploitModel>());
      //pass two nodes to TwoBranchesProcessor to solve and get interference formulas
      //TwoBranchesProcessor tp = new TwoBranchesProcessor(leafNodes.get(node1), leafNodes.get(node2),method,vc);
      TwoPathsProcessor tpp=new TwoPathsProcessor(leafNodes.get(node1), leafNodes.get(node2), method, vc);
      
      //get all interference formula for each low variables
      Map<ModelVariable,Term> mapIFormulas = tpp.getAllInterferenceFormula();
      
      //solve each formular corresponding with specific low variable to get corresponding concrete model and build ExploitModel
      boolean oneExploitModel = true;
      for(ModelVariable lowVar: mapIFormulas.keySet()){
         Term iTerm=mapIFormulas.get(lowVar);
         System.out.println(iTerm);
         Map<String,Integer> concreteModel = getConcreteModel(iTerm);        
         
         if(concreteModel!=null){        
            if(oneExploitModel){
               //if there is only one exploit model, we take full advantage of ExploitModelBuilder field of tpp 
               ExploitModelBuilder eModelBuilder = tpp.getExploitModelBuilder();
               //assign values for variables                  
               eModelBuilder.instantiateExploitModelInt(concreteModel);
               ExploitModel exploitModel = eModelBuilder.getExploitModel();
               exploitModel.setLowVar(lowVar); //we are working with this low variable            
               //exploitModel.printModelInfo();
               System.out.println("A vulnerability detected: secret information could be leaked through variable " + exploitModel.getLowVar().getVariableName() );
               result.add(exploitModel);
               oneExploitModel = false; //change the flag oneExploitModel
            }else{
               //if there are more than one exploit model, we have to recreate ExploitModelBuilder to avoid aliasing
               ExploitModelBuilder eModelBuilder = new ExploitModelBuilder(method.getServices());
               eModelBuilder.initiateExploitModelFromNode(leafNodes.get(node1), 1);
               eModelBuilder.initiateExploitModelFromNode(leafNodes.get(node1), 2);
               eModelBuilder.instantiateExploitModelInt(concreteModel);
               ExploitModel exploitModel = eModelBuilder.getExploitModel();
               exploitModel.setLowVar(lowVar); //we are working with this low variable            
               //exploitModel.printModelInfo();
               System.out.println("A vulnerability detected: secret information could be leaked through variable " + exploitModel.getLowVar().getVariableName() );
               result.add(exploitModel);
            }
         }         
      }      
      return result;
   }
   
   
   /**
    * get leaf nodes of symbolic execution tree from root
    */
   private List<IExecutionNode> parseLeafNodes(IExecutionStart root){
      List<IExecutionNode> leafNodes = new LinkedList<IExecutionNode>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode node = iterator.next();
         if(isTerminationNode(node) && !isLoopBodyTerminationNode(node)){
            IExecutionNode parentNode = node.getParent();
            if(parentNode instanceof IExecutionStateNode)
               leafNodes.add(node.getParent());
         }
      } 
      return leafNodes;
   }
   
   /**
    * check if the node is a terminating node
    * */
   private boolean isTerminationNode(final IExecutionNode node) {
      return node instanceof IExecutionTermination;
   }
   
   private boolean isLoopBodyTerminationNode(final IExecutionNode node){
      if(isTerminationNode(node)){
          if(((IExecutionTermination)node).getTerminationKind()==TerminationKind.LOOP_BODY)
             return true;
      }
      return false;
   }
   
   
   public List<ExploitTestCases> checkMethod2GetExploitTestCases(){     
      List<ExploitTestCases> result = Collections.synchronizedList(new LinkedList<ExploitTestCases>());
      for(IFBarrier declar: ifSpecs){
         System.out.println("\n==========================================================");
         System.out.println("Checking noninterference specification: " + declar.getDeclaration());
         //create variable checker via declaration
         VariableClassifier vc=new VariableClassifier(method,declar.getDestination(),declar.getSource());
         
         //create MethodProcessor object to check the method, including leaf nodes, method info and variable checker info
         //MethodProcessor mp=new MethodProcessor(leafNodes,method,vc);         
         
        /* for(int i=0;i<leafNodes.size();i++){
            for(int j=i;j<leafNodes.size();j++){
               try {
                  List<ExploitModel> eModels = getExploitModels(i, j,vc);
                  if(eModels.size()>0){
                     ExploitTestCases exploitTestCases=new ExploitTestCases(method, declar, eModels);
                     result.add(exploitTestCases);        
                  }
               }
               catch (TermTransformerException e) {
                  // TODO Auto-generated catch block
                  e.printStackTrace();
               }
               catch (ProofInputException e) {
                  // TODO Auto-generated catch block
                  e.printStackTrace();
               } 
               
            }
         }*/
         //get list of exploit model by checking the method with current information flow security specification
         List<ExploitModel> listEM = checkMethod2GetExploitModels(vc);
         //add list of exploit model into exploitTestSuite
         if(!listEM.isEmpty()){            
               ExploitTestCases exploitTestCases=new ExploitTestCases(method, declar, listEM);
               result.add(exploitTestCases);            
         }         
      }
      return result;
   }
   
   
      
}



