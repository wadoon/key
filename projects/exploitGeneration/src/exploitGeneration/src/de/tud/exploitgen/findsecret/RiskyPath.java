package de.tud.exploitgen.findsecret;


import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.FormulaBuilder;
import de.tud.exploitgen.detectleak.PairTermCollection;

import de.tud.exploitgen.detectleak.exploit.ExploitModel;
import de.tud.exploitgen.detectleak.exploit.ExploitModelCreator;
import de.tud.exploitgen.detectleak.node.ModelNode;


import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.solver.AbstractFormulaSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConfig;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.proof.init.ProofInputException;

/*
 * wrap risky symbolic path
 * */
public class RiskyPath {
	private final ModelNode modelNode;
	private final KeYJavaMethod method;
	private final VariableClassifier vc;
	/*
	 * risk_L the flag indicating how the observable output values are depended on L  
	 * 	
	 *  1: depend
	 *  -1: no depend
	 *  0: unidentified
	 *  
	 * */
	private int depend_L; 
	
	/*
	 * risk_H the flag indicating how the observable output values are depended on H
	 * 	true: depend
	 *  false: not depend  
	 */ 	
	private boolean depend_H; //for risk_H, it is always identified after the object is instantiated t
	private boolean lowIndependent; //check if both path condition and observable symbolic value are low-free or not
	private Term pathCondition; 
	private ObservableOutput observaleOutputs;	
	
	
	private boolean matched; // flag indicating that this path has been used (corresponding to an experiment)
	
	public RiskyPath(ModelNode modelNode, KeYJavaMethod method,
			VariableClassifier vc, boolean depend_H) {
		super();
		this.modelNode = modelNode;
		this.method = method;
		this.vc = vc;
		this.depend_H = depend_H;
		this.depend_L = 0;		
		matched = false;
	}

	public ModelNode getModelNode() {
		return modelNode;
	}

	public KeYJavaMethod getMethod() {
		return method;
	}

	public VariableClassifier getVc() {
		return vc;
	}

	public int getDepend_L() {
		return depend_L;
	}

	public void setDepend_L(int depend_L) {
		this.depend_L = depend_L;
	}

	public boolean isDepend_H() {
		return depend_H;
	}

	public void setDepend_H(boolean depend_H) {
		this.depend_H = depend_H;
	}
	
	/*if Risk_H == false and Risk_L==false then the observable output doest not depend on H nor L, then it is constant*/
	public boolean outputIsConstant(){
		return !depend_H && depend_L==-1;
	}
	
	/*if Risk_H == true and Risk_L==false then the observable output depends only on H */
	public boolean outputDependsOnlyOnH(){
		return depend_H && depend_L==-1;
	}
	
	/*if Risk_H == false and Risk_L==true then the observable output depends only on L */
	public boolean outputDependsOnlyOnL(){		
		return !depend_H && depend_L==1;		
	}
	
	/*if Risk_H == true and Risk_L==true then the observable output depends on both H and L */
	public boolean outputDependsOnBoth(){		
		return depend_H && depend_L==1;
	}
	
	/*
	 * a risky path can be classified into one of four categories: Risk_Const, Risk_L, Risk_H, Risk_LH
	 * this method returns the name of category
	 * for testing purpose only
	 * */
	public String categoryName(){
		if(lowIndependent)
			return KEGConfig.LOW_INDEPENDENT;
		if(outputIsConstant())
			return KEGConfig.RISK_CONSTANT;
		if(outputDependsOnlyOnH())
			return KEGConfig.RISK_H;
		if(outputDependsOnlyOnL())
			return KEGConfig.RISK_L;
		if(outputDependsOnBoth())
			return KEGConfig.RISK_LH;
		return KEGConfig.RISK_UNKNOWN;					
	}
	
	public boolean sameIdxNumber(RiskyPath anotherNode){
		if(modelNode.sameIdxNumber(anotherNode.getModelNode()))
			return true;
		else
			return false;
	}
	
	/*
	 * check whether or not there is an information flow from L to L ascribed to this path
	 * */
	private void updateDepend_L() throws ProofInputException{
		VariableClassifier newVC = new VariableClassifier(method, vc.getListLowVars(), vc.getListLowVars());
		//DeclassificationCenter declCenter = new DeclassificationCenter(null, method.getServices()); //don't care about declassification
	      ExploitModelCreator eModelCreator = new ExploitModelCreator(modelNode.getNodeDetail(),modelNode.getNodeDetail());
	      
	      List<Term> listArtificialVars = eModelCreator.getSynthesisArtificialVar();
	      List<Term> listArrays = modelNode.getNodeDetail().getListArrays();

	      Term nodeConstraint1 = modelNode.getNodeDetail().getConstraint(); //TODO: value's conditions are counted two times
	      Term nodeConstraint2 = modelNode.getNodeDetail().getConstraint();
	      ExploitModel eModel = eModelCreator.getMergedExploitModel(modelNode.getIdx(), modelNode.getIdx());
	      FormulaBuilder fb = new FormulaBuilder(eModel, method, newVC, null, 
                  listArtificialVars, listArrays,                     
                  nodeConstraint1, nodeConstraint2);
          Term syntheziedFormula = fb.getSyntheziedFormula();
	      
          AbstractFormulaSolver fs=new Z3Solver(syntheziedFormula, method.getServices());      //use Z3 solver
		   if (fs.checkSatisfiable())
			   depend_L = 1;
		   else
			   depend_L = -1;		   
	}
	
	private void resolvePathCondition() throws ProofInputException{
		List<Term> listArrays = modelNode.getNodeDetail().getListArrays();		
		HeapHandler heapHandler = new HeapHandler(method.getServices());		
		
		pathCondition = modelNode.getConstraint();
		//pathCondition =  heapHandler.refineTerm(modelNode.getNodeDetail().getPathCondition(), listArrays);		
		pathCondition = method.getServices().getTermBuilder().and(pathCondition, modelNode.getValueCondition());
	}
	
	private void updateLowIndependence(){
		if(depend_L==1)//mean that observable symbolic output depends on L
			lowIndependent = false;
		else{ //if observable symbolic output does not depend on L, check path condition
			List<ModelVariable> listLowVars = getListLowVars();
			DependChecker dependChecker = new DependChecker(pathCondition, listLowVars, method.getServices());
			if(dependChecker.checkDependence()) //if path condition depends on low variables, then lowIndependence = false;
				lowIndependent = false;
			else
				lowIndependent = true;
		}
			
	}
	
	private List<ModelVariable> getListLowVars(){
		List<ModelVariable> result = new LinkedList<ModelVariable>();
		for(ModelVariable mv : modelNode.getModel().getVariables()){
	         if(!mv.isFresh()){
	            if(!mv.getIdentifier().equals("result")){
	               if(!mv.getIdentifier().equals("self")){             
	                  if (vc.isLow(mv.getIdentifier())){
	                     result.add(mv);
	                  }	                
	               }
	            }
	         }
	      }
		return result;
	}
	
	public void selfCategorizeNExtractInfo() throws ProofInputException{
		resolvePathCondition();
		updateDepend_L();
		updateLowIndependence();
		extractObservableOutput();
	}
/*	
	public Map<String, Term> getObservableSymbolicValues() {
		return observableSymbolicValues;
	}*/
	
	
	
	public boolean isMatched() {
		return matched;
	}

	public void setMatched(boolean matched) {
		this.matched = matched;
	}

	
	public boolean isLowIndependent() {
		return lowIndependent;
	}

	public Term getPathCondition() {
		return pathCondition;
	}
	
	/*
	 * check the validity of formula:
	 * \forall H: Knowledge(H) -> pc(L_j,H) (1)
	 * by solve negation formula:
	 * Knowledge(H) && !(pc(L_j,H))          (2)
	 * if (2) is satisfiable, then (1) does not hold, then the return false, otherwise return true
	 * */
	public boolean alwaysMatchByLowInputs(Term knowledge, Experiment experiment){
		Services services = method.getServices();
		PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
		TermBuilder tb = services.getTermBuilder();
		//replace low variables in path condition by corresponding concrete values
		Term notPc = ptcLowInput.replacePVByNameAndBranch(pathCondition, 1);
		notPc = tb.not(notPc);
		Term checkFormula = tb.and(knowledge, notPc);
		Z3Solver solver = new Z3Solver(checkFormula, services);
		if(solver.checkSatisfiable())
			return false;
		else
			return true;
	}
	
	/*
	 * check the validity of formula:
	 * \exists H: Knowledge(H) && pc(L_j,H) (1)
	 * by solve negation formula:
	 * Knowledge(H) && (pc(L_j,H))          (2)
	 * if (2) is satisfiable, then (1) hold, then the return true, otherwise return false
	 * */
	public boolean canMatchByLowInputs(Term knowledge, Experiment experiment){
		Services services = method.getServices();
		PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
		TermBuilder tb = services.getTermBuilder();
		//replace low variables in path condition by corresponding concrete values
		Term pc = ptcLowInput.replacePVByNameAndBranch(pathCondition, 1);		
		Term checkFormula = tb.and(knowledge, pc);
		Z3Solver solver = new Z3Solver(checkFormula, services);
		if(solver.checkSatisfiable())
			return false;
		else
			return true;
	}
	
	/*
	 * check the validity of formula:
	 * \forall H: Knowledge(H) -> O_j = f_j^O(L_j,H) (1)
	 * by solve negation formula:
	 * Knowledge(H) && !(O_j = f_j^O(L_j,H))          (2)
	 * if (2) is satisfiable, then (1) does not hold, then the return false, otherwise return true
	 * */
	public boolean alwaysMatchByOutputs(Term knowledge, Experiment experiment){
		Services services = method.getServices();		
		TermBuilder termBuilder = services.getTermBuilder();		
		Term compareOutputTerm = getCompareOutputTerm(experiment);
		if(TermParser.isBooleanFalse(compareOutputTerm))
			return false;
		else{
			compareOutputTerm = termBuilder.and(termBuilder.not(compareOutputTerm),knowledge);			
			Z3Solver z3Solver = new Z3Solver(compareOutputTerm,services);
			return !z3Solver.checkSatisfiable();
		}
	}
	
	/*
	 * check the satisfiability of following formula:
	 * Knowledge(H) && pc(L_j,H) && O_j = f_j^O(L_j,H)
	 * if it is satisfiable, then return true, otherwise return false
	 * */
	public boolean canMatchByOutputs(Term knowledge, Experiment experiment){
		Services services = method.getServices();		
		TermBuilder termBuilder = services.getTermBuilder();		
		Term compareOutputTerm = getCompareOutputTerm(experiment);
						
		if(TermParser.isBooleanFalse(compareOutputTerm))
			return false;
		else{
			PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
			Term pc = ptcLowInput.replacePVByNameAndBranch(pathCondition, 1);
			Term formula = termBuilder.and(compareOutputTerm,knowledge,pc);			
			Z3Solver z3Solver = new Z3Solver(formula,services);
			return z3Solver.checkSatisfiable();
		}
	}
	
	/*
	 * get compare output term from experiment
	 * */
	private Term getCompareOutputTerm(Experiment experiment){
		return observaleOutputs.getCompareOutputTerm(experiment);
	}
	
	
	
	/*
	 * get term representing information of high variables from experiment
	 * */
	public Term getInfoH(Experiment experiment){
		Services services = method.getServices();
		TermBuilder termBuilder = services.getTermBuilder();		
		PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
		Term inforH = termBuilder.tt();
		Term compareOutputTerm = getCompareOutputTerm(experiment);
		System.out.println("compareOutputTerm: " + compareOutputTerm);
		if(TermParser.isBooleanFalse(compareOutputTerm))
			inforH = termBuilder.ff();
		else{
			Term pc = ptcLowInput.replacePVByNameAndBranch(pathCondition, 1);
			inforH = termBuilder.and(compareOutputTerm,pc);		
		}
		Z3Solver z3 = new Z3Solver(inforH, method.getServices());
		if(z3.checkSatisfiable())
			return inforH;
		else
			return termBuilder.ff();
	}
	
	public boolean correspond2ExperimentByLowInput(Term knowledge, Experiment experiment){
		if(alwaysMatchByLowInputs(knowledge, experiment) && canMatchByOutputs(knowledge, experiment))
			return true;
		else
			return false;
	} 
	
	private void extractObservableOutput(){
		List<String> listObservableVars = vc.getListLowVars();
		HeapHandler heapHandler = new HeapHandler(method.getServices());
		List<Term> listArrays = modelNode.getNodeDetail().getListArrays();
		Map<String,Term> mapValues = new HashMap<String, Term>();
		for(String outVarName: listObservableVars){
			ModelVariable mv = modelNode.getModel().getVariable(outVarName);
			if(mv!=null){
				Term symbolicValue = heapHandler.refineTerm(mv.getSymbolicValue(), listArrays);
				mapValues.put(outVarName, symbolicValue);
			}
		}		
		
		observaleOutputs = new ObservableOutput(mapValues, this);
	}
	
	public ObservableOutput getObservaleOutputs() {
		return observaleOutputs;
	}
	
	/*
	 * return a @Term describing the condition that the program can run by this path and return hybridValues
	 * */
	public Term getCondition4MatchHybridOutput(Map<String, Term> hybridValues){
		Services services = method.getServices();
		TermBuilder tb = services.getTermBuilder();
		Term outputMatch = TermUtil.identicalCondition(hybridValues, observaleOutputs.getMapValues(), services);
		if(TermParser.isBooleanFalse(outputMatch))
			return tb.ff();
		else
			return tb.and(pathCondition,outputMatch);		
	}
}
