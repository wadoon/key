package de.tud.exploitgen.findsecret;
/**
 * This class wraps a risky path where leakage can happen.
 * @author: Huy Do
 * */
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.tud.exploitgen.detectleak.TwoNodesProcessor;
import de.tud.exploitgen.detectleak.node.NodeDetail;
import de.tud.exploitgen.detectleak.specification.declassification.DeclassificationCenter;
import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.HeapHandler;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.util.DelimitedRelease;
import de.uka.ilkd.key.util.Pair;

public class RiskyPath {
	private final NodeDetail node; //leafNode of path
	private KeYJavaMethod method;
	private int id; // id of the node
	private VariableClassifier vc;
	private List<RiskyPathAbstraction> pathAbstractions; //list of path abstraction w.r.t. specific variable classifier
	/*
	 * risk_L the flag indicating how the observable output values are depended on L  
	 * 	
	 *  1: depend
	 *  -1: no depend
	 *  0: unidentified
	 *  
	 * */
	private int risk_L; 
	/*
	 * risk_H the flag indicating how the observable output values are depended on H
	 * 	true: depend
	 *  false: not depend  
	 */ 	
	private boolean risk_H; //for risk_H, it is always identified after the object is instantiated t
	
	/*public RiskyPath(NodeDetail node, int id) {
		super();
		this.node = node;
		this.id = id;
		this.risk_L = 0; 
		this.risk_H = 0;
	}*/
	
	/*public RiskyPath(NodeDetail node, int id, int risk_L, int risk_H) {
		super();
		this.node = node;
		this.id = id;
		this.risk_L = risk_L; 
		this.risk_H = risk_H;
	}*/
	
	public RiskyPath(NodeDetail node, int id, boolean risk_H, KeYJavaMethod method, VariableClassifier vc) {
		super();
		this.node = node;
		this.id = id;
		this.risk_H = risk_H;
		this.method = method;
		this.vc = vc;		
		/*try {
			updateRisk_L();
		} catch (ProofInputException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		updatePathAbstractions();*/
	}
	
	public KeYJavaMethod getMethod() {
		return method;
	}

	public VariableClassifier getVc() {
		return vc;
	}

	public List<RiskyPathAbstraction> getPathAbstractions() {
		return pathAbstractions;
	}

	public NodeDetail getNode() {
		return node;
	}
	
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
			
	public int getRisk_L() {
		return risk_L;
	}
	public void setRisk_L(int risk_L) {
		this.risk_L = risk_L;
	}
	public boolean isRisk_H() {
		return risk_H;
	}
	public void setRisk_H(boolean risk_H) {
		this.risk_H = risk_H;
	}
	
	/*if Risk_H == false and Risk_L==false then the observable output doest not depend on H nor L, then it is constant*/
	public boolean outputIsConstant(){
		return !risk_H && risk_L==-1;
	}
	
	/*if Risk_H == true and Risk_L==false then the observable output depends only on H */
	public boolean outputDependsOnlyOnH(){
		return risk_H && risk_L==-1;
	}
	
	/*if Risk_H == false and Risk_L==true then the observable output depends only on L */
	public boolean outputDependsOnlyOnL(){		
		return !risk_H && risk_L==1;		
	}
	
	/*if Risk_H == true and Risk_L==true then the observable output depends on both H and L */
	public boolean outputDependsOnBoth(){		
		return risk_H && risk_L==1;
	}
	
	
	
	/**
	 * update value for risk_L using vc and supplied constraint 
	 * to update risk_L, we check if there exists information flow from low variables to observable variables? (in this case two sets are the same)
	 * basically, we check wherether L->L?
	 * @throws ProofInputException 
	 * @throws TermTransformerException 
	 * */
	public void updateRisk_L() throws ProofInputException{
		//if(risk_L==0){ //only update if risk_L is unidentified
			//now listLowVars is considered as both high variables and low variables
			VariableClassifier newVC = new VariableClassifier(method, vc.getListLowVars(), vc.getListLowVars());
			//ImmutableList<DelimitedRelease> declassifies = method.getEscapeHatches();
		    //DeclassificationCenter declCenter = new DeclassificationCenter(declassifies, method.getServices());
			DeclassificationCenter declCenter = new DeclassificationCenter(null, method.getServices()); //don't care about declassification
			TwoNodesProcessor tnp = new TwoNodesProcessor(node, node, method, newVC, declCenter);		
			//now check if the information from L is leaked to L
			if(tnp.checkInformationFlow())
				risk_L= 1;
			else
				risk_L = -1;
		//}
	}
	
	
	
	/*
	 * a risky path can be classified into one of four categories: Risk_Const, Risk_L, Risk_H, Risk_LH
	 * this method returns the name of category
	 * for testing purpose only
	 * */
	public String categoryName(){
		if(outputIsConstant())
			return "Risk_Const";
		if(outputDependsOnlyOnH())
			return "Risk_H";
		if(outputDependsOnlyOnL())
			return "Risk_L";
		if(outputDependsOnBoth())
			return "Risk_LH";
		return "unknown";					
	}
	
	
	public void updatePathAbstractions(){
		/*prepare for necessary tools*/
		HeapHandler heapHandler = new HeapHandler(method.getServices());
		List<Term> listArrays = node.getListArrays();
		
		pathAbstractions = new LinkedList<RiskyPathAbstraction>();
		List<String> listObservableVars = vc.getListLowVars(); //temporarily consider the low variable is also the observable variable
		Term nodeConstraint = node.getConstraint();		
		
		TermBuilder termBuilder = new TermBuilder(new TermFactory(), method.getServices());
		/*
		 * if there is only one model, we don't have to take into account the value condition (because it is true)
		 * */
		if(node.getModels().size()>1){
			for(Model model: node.getModels()){
				Term modelValueCondition = termBuilder.tt();				
				for(ModelVariable mv: model.getVariables()){
					 if(!mv.isFresh()){
			            if(!mv.getIdentifier().equals("self"))
			               modelValueCondition = termBuilder.and(modelValueCondition, mv.getValueCondition());
			         }					 
				}
				Map<String, Term> mapValue = new HashMap<String, Term>();
				for(String outVarName: listObservableVars){
					ModelVariable mv = model.getVariable(outVarName);
					if(mv!=null){
						Term symbolicValue = heapHandler.refineTerm(mv.getSymbolicValue(), listArrays);
						mapValue.put(outVarName, symbolicValue);
					}
				}
				Term synsConstraint = termBuilder.and(nodeConstraint, modelValueCondition);
				synsConstraint = heapHandler.refineTerm(synsConstraint, listArrays);
				pathAbstractions.add(new RiskyPathAbstraction(synsConstraint, mapValue));
			}
		}else{
			Map<String, Term> mapValue = new HashMap<String, Term>();
			Model model = node.getModel(0);
			for(String outVarName: listObservableVars){
				ModelVariable mv = model.getVariable(outVarName);
				if(mv!=null){
					Term symbolicValue = heapHandler.refineTerm(mv.getSymbolicValue(), listArrays);
					mapValue.put(outVarName, symbolicValue);					
				}
			}
			nodeConstraint = heapHandler.refineTerm(nodeConstraint, listArrays);
			pathAbstractions.add(new RiskyPathAbstraction(nodeConstraint, mapValue));
		}
	}
}
