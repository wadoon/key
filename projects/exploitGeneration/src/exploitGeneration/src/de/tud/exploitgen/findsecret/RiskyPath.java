package de.tud.exploitgen.findsecret;


import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.PairTerm;
import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.detectleak.node.ModelNode;
import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermTransformer;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;

/*
 * wrap risky symbolic path
 * */
public class RiskyPath {
	private final ModelNode modelNode;
	private final KeYJavaMethod method;
	private final VariableClassifier vc;
	/*
	 * risk_L the flag indicating how the observable output values are depended on L  
	 * 	
	 *  1: depend
	 *  -1: no depend
	 *  0: unidentified
	 *  
	 * */
	private int depend_L; 
	
	/*
	 * risk_H the flag indicating how the observable output values are depended on H
	 * 	true: depend
	 *  false: not depend  
	 */ 	
	private boolean depend_H; //for risk_H, it is always identified after the object is instantiated t
	private boolean lowIndependent; //check if both path condition and observable symbolic value are low-free or not
	private Term pathCondition; 
	private ObservableOutput observaleOutputs;	
		
	private boolean matched; // flag indicating that this path has been used (corresponding to an experiment)
	private boolean reachable; //flag indicating that this path cannot be taken actually (via latest experiment)
	public RiskyPath(ModelNode modelNode, KeYJavaMethod method,
			VariableClassifier vc, boolean depend_H) {
		super();
		this.modelNode = modelNode;
		this.method = method;
		this.vc = vc;
		this.depend_H = depend_H;
		this.depend_L = 0;		
		matched = false;
		reachable = true;
	}

	public ModelNode getModelNode() {
		return modelNode;
	}

	public KeYJavaMethod getMethod() {
		return method;
	}

	public VariableClassifier getVc() {
		return vc;
	}

	public int getDepend_L() {
		return depend_L;
	}

	public void setDepend_L(int depend_L) {
		this.depend_L = depend_L;
	}

	public boolean isDepend_H() {
		return depend_H;
	}

	public void setDepend_H(boolean depend_H) {
		this.depend_H = depend_H;
	}
	
	/*if Risk_H == false and Risk_L==false then the observable output doest not depend on H nor L, then it is constant*/
	public boolean outputIsConstant(){
		return !depend_H && depend_L==-1;
	}
	
	/*if Risk_H == true and Risk_L==false then the observable output depends only on H */
	public boolean outputDependsOnlyOnH(){
		return depend_H && depend_L==-1;
	}
	
	/*if Risk_H == false and Risk_L==true then the observable output depends only on L */
	public boolean outputDependsOnlyOnL(){		
		return !depend_H && depend_L==1;		
	}
	
	/*if Risk_H == true and Risk_L==true then the observable output depends on both H and L */
	public boolean outputDependsOnBoth(){		
		return depend_H && depend_L==1;
	}
	
	/*
	 * a risky path can be classified into one of four categories: Risk_Const, Risk_L, Risk_H, Risk_LH
	 * this method returns the name of category
	 * for testing purpose only
	 * */
	public String categoryName(){
		if(lowIndependent)
			return KEGConstant.LOW_INDEPENDENT;
		if(outputIsConstant())
			return KEGConstant.RISK_CONSTANT;
		if(outputDependsOnlyOnH())
			return KEGConstant.RISK_H;
		if(outputDependsOnlyOnL())
			return KEGConstant.RISK_L;
		if(outputDependsOnBoth())
			return KEGConstant.RISK_LH;
		return KEGConstant.RISK_UNKNOWN;					
	}
	
	public boolean sameIdxNumber(RiskyPath anotherNode){
		if(modelNode.sameIdxNumber(anotherNode.getModelNode()))
			return true;
		else
			return false;
	}
	
	/*
	 * check whether or not there is an information flow from L to L ascribed to this path
	 * */
	private void updateDepend_L() throws ProofInputException{
		/*System.out.println("checking if output value depends on low input or not");
		VariableClassifier newVC = new VariableClassifier(method, vc.getListLowVars(), vc.getListLowVars());
		//DeclassificationCenter declCenter = new DeclassificationCenter(null, method.getServices()); //don't care about declassification
	      ExploitModelCreator eModelCreator = new ExploitModelCreator(modelNode.getNodeDetail(),modelNode.getNodeDetail());
	      
	      List<Term> listArtificialVars = eModelCreator.getSynthesisArtificialVar();
	      List<Term> listArrays = modelNode.getNodeDetail().getListArrays();

	      Term nodeConstraint1 = modelNode.getNodeDetail().getConstraint(); //TODO: value's conditions are counted two times
	      Term nodeConstraint2 = modelNode.getNodeDetail().getConstraint();
	      ExploitModel eModel = eModelCreator.getMergedExploitModel(modelNode.getIdx(), modelNode.getIdx());
	      FormulaBuilder fb = new FormulaBuilder(eModel, method, newVC, null, 
                  listArtificialVars, listArrays,                     
                  nodeConstraint1, nodeConstraint2);
          Term syntheziedFormula = fb.getSyntheziedFormula();
	      
          AbstractFormulaSolver fs=new Z3Solver(syntheziedFormula, method.getServices());      //use Z3 solver
		   if (fs.checkSatisfiable())
			   depend_L = 1;
		   else
			   depend_L = -1;*/		 
		
		//update depend_L by using information from observable outputs
		if((observaleOutputs.getLowDependOutputVars().size()>0)||(observaleOutputs.getDependLHOutputVars().size()>0))
			depend_L = 1;
		else
			depend_L = -1;
	}
	
	private void resolvePathCondition() throws ProofInputException{
		TermBuilder tb = method.getServices().getTermBuilder();
		//List<Term> listArrays = modelNode.getNodeDetail().getListArrays();		
		//HeapHandler heapHandler = new HeapHandler(method.getServices());		
		
		pathCondition = modelNode.getConstraint();
		//pathCondition =  heapHandler.refineTerm(modelNode.getNodeDetail().getPathCondition(), listArrays);		
		pathCondition = tb.and(pathCondition, modelNode.getValueCondition());	
		//System.out.println("risky path condition:: " + pathCondition);
	}
	
	
	
	
	private void updateLowIndependence(){
		if(depend_L==1)//mean that observable symbolic output depends on L
			lowIndependent = false;
		else{ //if observable symbolic output does not depend on L, check path condition
			List<ModelVariable> listLowVars = getListLowVars();
			/*DependChecker dependChecker = new DependChecker(getExistPathCondition(), listLowVars, method.getServices());
			if(dependChecker.checkDependence()) //if path condition depends on low variables, then lowIndependence = false;
				lowIndependent = false;
			else
				lowIndependent = true;*/
			
			//because DependChecker is very expensive, we simply use String.contains method
			if(pathConditionContainsLowVar())
				lowIndependent = false;
			else
				lowIndependent = true;
		}
			
	}
	
	private boolean pathConditionContainsLowVar(){
		for(String lowVar: vc.getListLowVars()){
			if(pathCondition.toString().contains(lowVar))
				return true;
		}
		return false;
	}
	
	private List<ModelVariable> getListLowVars(){
		List<ModelVariable> result = new LinkedList<ModelVariable>();
		for(ModelVariable mv : modelNode.getModel().getVariables()){
	         if(!mv.isFresh()){
	            if(!mv.getIdentifier().equals("result")){
	               if(!mv.getIdentifier().equals("self")){             
	                  if (vc.isLow(mv.getIdentifier())){
	                     result.add(mv);
	                  }	                
	               }
	            }
	         }
	      }
		return result;
	}
	
	public void selfCategorizeNExtractInfo(Services services) throws ProofInputException{
		resolvePathCondition();		
		extractObservableOutput(services);
		updateDepend_L();
		updateLowIndependence();
	}
/*	
	public Map<String, Term> getObservableSymbolicValues() {
		return observableSymbolicValues;
	}*/
	
	
	
	public boolean isMatched() {
		return matched;
	}

	public void setMatched(boolean matched) {
		this.matched = matched;
	}

	
	public boolean isLowIndependent() {
		return lowIndependent;
	}

	public Term getPathCondition() {
		return getExistPathCondition();
	}
	
	/*
	 * check the validity of formula:
	 * \forall H: Knowledge(H) -> pc(L_j,H) (1)
	 * by solve negation formula:
	 * Knowledge(H) && !(pc(L_j,H))          (2)
	 * if (2) is satisfiable, then (1) does not hold, then the return false, otherwise return true
	 * */
	public boolean alwaysMatchByLowInputs(Term knowledge, Experiment experiment){
		Services services = method.getServices();
		PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
		TermBuilder tb = services.getTermBuilder();
		//replace low variables in path condition by corresponding concrete values
		Term notPc = ptcLowInput.replacePVByNameAndBranch(getExistPathCondition(), 1);
		notPc = tb.not(notPc);
		Term checkFormula = tb.and(knowledge, notPc);
		checkFormula = new TermTransformer(method.getServices()).transformBWXORTerm(knowledge, 4);
		Z3Solver solver = new Z3Solver(checkFormula, services);
		if(solver.checkSatisfiable())
			return false;
		else
			return true;
	}
	
	/*
	 * check the validity of formula:
	 * \exists H: Knowledge(H) && pc(L_j,H) (1)
	 * by solve negation formula:
	 * Knowledge(H) && (pc(L_j,H))          (2)
	 * if (2) is satisfiable, then (1) hold, then the return true, otherwise return false
	 * */
	public boolean canMatchByLowInputs(Term knowledge, Experiment experiment){
		Services services = method.getServices();
		PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
		TermBuilder tb = services.getTermBuilder();
		//replace low variables in path condition by corresponding concrete values
		Term pc = ptcLowInput.replacePVByNameAndBranch(getExistPathCondition(), 1);		
		Term checkFormula = tb.and(knowledge, pc);
		Z3Solver solver = new Z3Solver(checkFormula, services);
		if(solver.checkSatisfiable())
			return false;
		else
			return true;
	}
	
	/*
	 * check the validity of formula:
	 * \forall H: Knowledge(H) -> O_j = f_j^O(L_j,H) (1)
	 * by solve negation formula:
	 * Knowledge(H) && !(O_j = f_j^O(L_j,H))          (2)
	 * if (2) is satisfiable, then (1) does not hold, then the return false, otherwise return true
	 * */
	public boolean alwaysMatchByOutputs(Term knowledge, Experiment experiment){
		Services services = method.getServices();		
		TermBuilder termBuilder = services.getTermBuilder();		
		Term compareOutputTerm = getCompareOutputTerm(experiment);
		if(TermParser.isBooleanFalse(compareOutputTerm))
			return false;
		else{
			compareOutputTerm = termBuilder.and(termBuilder.not(compareOutputTerm),knowledge);			
			Z3Solver z3Solver = new Z3Solver(compareOutputTerm,services);
			return !z3Solver.checkSatisfiable();
		}
	}
	
	/*
	 * check the satisfiability of following formula:
	 * Knowledge(H) && pc(L_j,H) && O_j = f_j^O(L_j,H)
	 * if it is satisfiable, then return true, otherwise return false
	 * */
	public boolean canMatchByOutputs(Term knowledge, Experiment experiment){
		Services services = method.getServices();		
		TermBuilder termBuilder = services.getTermBuilder();		
		Term compareOutputTerm = getCompareOutputTerm(experiment);
						
		if(TermParser.isBooleanFalse(compareOutputTerm))
			return false;
		else{
			PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
			Term pc = ptcLowInput.replacePVByNameAndBranch(getExistPathCondition(), 1);
			Term formula = termBuilder.and(compareOutputTerm,knowledge,pc);		
			//System.out.println("matchable detecting formula: " + formula);
			formula = new TermTransformer(method.getServices()).transformBWXORTerm(formula, 4);
			Z3Solver z3Solver = new Z3Solver(formula,services);
			return z3Solver.checkSatisfiable();
		}
	}
	
	/*
	 * get compare output term from experiment
	 * */
	private Term getCompareOutputTerm(Experiment experiment){
		return observaleOutputs.getCompareOutputTerm(experiment);
	}
	
	
	
	/*
	 * get term representing information of high variables from experiment
	 * idx: number of experiment, used in renaming artificial variables (bounded by exists operator)
	 * */
	public Term getInfoH(Experiment experiment, int idx){
		Services services = method.getServices();
		TermBuilder termBuilder = services.getTermBuilder();		
		PairTermCollection ptcLowInput = experiment.getLowInputPTCfromExperiment(services);
		Term inforH = termBuilder.tt();
		Term compareOutputTerm = getCompareOutputTerm(experiment);
		/*System.out.println("path condition::: " + getExistPathCondition());
		System.out.println("observable value:::: " + observaleOutputs.getMapValues());
		System.out.println("compareOutputTerm: " + compareOutputTerm);*/
		if(TermParser.isBooleanFalse(compareOutputTerm))
			inforH = termBuilder.tt(); //know nothing about H
		else{
			Term pc = ptcLowInput.replacePVByNameAndBranch(getExistPathCondition(), 1);
			inforH = termBuilder.and(compareOutputTerm,pc);		
		}
		
		//System.out.println("infoH before check satisfiable: " + inforH);
		//inforH = new TermTransformer(method.getServices()).transformBWXORTerm(inforH, 4);
		Z3Solver z3 = new Z3Solver(new TermTransformer(method.getServices()).transformBWXORTerm(inforH, 4), method.getServices());
		if(z3.checkSatisfiable())
			return inforH;
		else
			return termBuilder.tt(); //know nothing about H
	}
	
	public boolean correspond2ExperimentByLowInput(Term knowledge, Experiment experiment){
		if(alwaysMatchByLowInputs(knowledge, experiment) && canMatchByOutputs(knowledge, experiment))
			return true;
		else
			return false;
	} 
	
	private void extractObservableOutput(Services services){		
		List<String> listObservableVars = vc.getListLowVars();
		HeapHandler heapHandler = new HeapHandler(method.getServices());
		List<Term> listArrays = modelNode.getNodeDetail().getListArrays();
		Map<String,Term> mapValues = new HashMap<String, Term>();
		for(String outVarName: listObservableVars){
			ModelVariable mv = modelNode.getModel().getVariable(outVarName);
			if(mv!=null){
				Term symbolicValue = heapHandler.refineTerm(mv.getSymbolicValue(), listArrays);
				mapValues.put(outVarName, symbolicValue);
				
			}
		}		
		observaleOutputs = new ObservableOutput(mapValues, this, services);
	}
	
	public ObservableOutput getObservaleOutputs() {
		return observaleOutputs;
	}
	
	/*
	 * return a @Term describing the condition that the program can run by this path and return hybridValues
	 * */
	public Term getCondition4MatchHybridOutput(Map<String, Term> hybridValues){
		Services services = method.getServices();
		TermBuilder tb = services.getTermBuilder();
		Term outputMatch = TermUtil.identicalCondition(hybridValues, observaleOutputs.getMapValues(), services);
		if(TermParser.isBooleanFalse(outputMatch))
			return tb.ff();
		else
			return tb.and(getExistPathCondition(),outputMatch);		
	}

	public boolean isReachable() {
		return reachable;
	}

	public void setReachable(boolean cantMatched) {
		this.reachable = cantMatched;
	}
	
	/*
	 * check whether this path is reachable w.r.t. newest knowledge about H
	 * to do that, check the satisfiable of formula 
	 * knowledge && pc
	 * if above formula is satisfiable, then return true, otherwise return false
	 * */
	public boolean checkReachable(Term knowledge){
		Services services = method.getServices();
		TermBuilder tb = services.getTermBuilder();
		Term formula = tb.and(knowledge, getExistPathCondition());
		formula = new TermTransformer(method.getServices()).transformBWXORTerm(formula, 4);
		Z3Solver z3 = new Z3Solver(formula, services);
		if(z3.checkSatisfiable())
			return true;
		else
			return false;
	}
	
	/*
	 * if path condition contains artificial variable, then quantify them by exists operator
	 * */
	private Term getExistPathCondition(){
		List<Term> listArtificialVar = new LinkedList<Term>();
		for(Term artTerm : modelNode.getNodeDetail().getArtificialVariables()){
			if(TermUtil.isDescendant(artTerm, pathCondition)){
				listArtificialVar.add(artTerm);
			}
		}
		if(listArtificialVar.size()>0){
			List<QuantifiableVariable> listQVar = new LinkedList<QuantifiableVariable>();
			
			TermBuilder tb = method.getServices().getTermBuilder();
			for(Term t: listArtificialVar){			
					QuantifiableVariable qv = new LogicVariable(new Name(t.toString()),t.sort());				
					listQVar.add(qv);			
			}
			return tb.ex(listQVar, pathCondition);
		}else
			return pathCondition;	
	}
	
	public void reset(){
		matched = false;
		reachable = true;
		observaleOutputs.resetMapHighDependOutputVars();
	}

	/*
	 * @return: pc(L,H) && f_i^O(L,H) = O_out
	 * */
	public Term getCompareFreshOutputTerm(Map<String,Term> mapFreshOutputTerm){
		TermBuilder tb = method.getServices().getTermBuilder();
		Term result = tb.tt();
		Map<String,Term> mapValues = observaleOutputs.getMapValues();
		for(String varName: mapValues.keySet()){
			result = tb.and(result, tb.equals(mapValues.get(varName), mapFreshOutputTerm.get(varName)));			
		}
		
		result = tb.and(result,getExistPathCondition());
		//result = tb.and(result,getResolvedBWXOrPathCondition(4));
		
		List<Term> listArtificialVar = new LinkedList<Term>();
		for(Term artificialVar: modelNode.getNodeDetail().getArtificialVariables()){
			if(TermUtil.isDescendant(artificialVar, result))
				listArtificialVar.add(artificialVar);
		}
		if(listArtificialVar.size()>0){
			List<QuantifiableVariable> listQuantifiedHighVar = new LinkedList<QuantifiableVariable>();			
			for(Term t: listArtificialVar){			
					QuantifiableVariable qv = new LogicVariable(new Name(t.toString()),t.sort());				
					listQuantifiedHighVar.add(qv);			
			}
			return tb.ex(listQuantifiedHighVar, result);
		}else
			return result;	
	}
	
}
