package de.tud.exploitgen.findsecret.strategy;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.MELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KEGTermException;

public class LowInputGenStrategy4RiskLH extends LowInputGenStrategy{

	public LowInputGenStrategy4RiskLH(SISupporter siSupporter) {
		super(siSupporter);
		// TODO Auto-generated constructor stub
	}

	@Override
	public Map<String, Long> findBestLowInput() throws IOException, KEGTermException {
		/*
		 * if program contains path whose output depend only on H, try to guide the execution following that
		 * */
		BadMethod badMethod = siSupporter.getBadMethod();
		List<RiskyPath> listRiskyPaths = badMethod.getListRiskyPaths();
		for(RiskyPath rp: listRiskyPaths){
			if(rp.isReachable()){
				if(rp.outputDependsOnlyOnH()){
					if(!rp.isMatched()){
						Map<String,Long> mapValues = findLowInputForcingExecutionFollowingPath(rp);
						if(mapValues!=null)
							return mapValues;
					}
				}
			}
		}
		/*
		for(RiskyPath rp: listRiskyPaths){
			if(rp.isReachable()){
				if(rp.outputDependsOnBoth()){					
						Map<String,Long> mapValues = findLowInputForcingExecutionFollowingPath(rp);
						if(mapValues!=null)
							return mapValues;
					
				}
			}
		}*/
		
		//if we cannot find any low input forcing program along to a H-depend only path, then try to maximize |O|
		return findLowInputMaximizingNumberOfOutputValue();
		
		//return findUsefulLowInput();		
	}

}
