package de.tud.exploitgen.detectleak;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelArrayVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.exploit.ExploitModel;
import de.tud.exploitgen.detectleak.simplifier.QuantifiableVarUnifier;
import de.tud.exploitgen.detectleak.specification.declassification.DeclassificationCenter;
import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;

public class FormulaBuilder {
   private final ExploitModel eModel; //two detail nodes representing two branches.   
   private final List<Term> listArtificialVars;
   private final Term nodeConstraint1, nodeConstraint2;  
   
   private KeYJavaMethod method;
   private Services services;
   private VariableClassifier vc;
   private DeclassificationCenter declCenter;
   private HeapHandler heapHandler;  
   
   private final TermBuilder termBuilder;
      
   
   
   //map<heapLowVar, field>: mapping from low variable name to its corresponding field name
   Map<String,ModelVariable> mapLowVars;
   
   //list of various kind of variables
   PairTermCollection ptcInputHighVars;
   PairTermCollection ptcInputNotHighVars;   
   PairTermCollection ptcOutputLowPairs; //list of pair output low variables (name low_out_...)
   PairTermCollection ptcOutputLowValues1; //list of output value of low variables at node 1
   PairTermCollection ptcOutputLowValues2; //list of output value of low variables at node 2   
   PairTermCollection ptcArtificalVars; //collection of pairs of artificial variables (met with loop)
   //List<Term> listVarConstraints1; //list of variable's constraints at node 1 represented as a term 
   //List<Term> listVarConstraints2; //list of variable's constraints at node 2 represented as a term
   PairTermCollection ptcAllVars ; //list of all variables, including high variables, non-high variables and artificial variables
   PairTermCollection ptcArrays; //list of all array variables, use to resolve for array's elements and array's lengths
   
   List<Term> listArrays; //list of all array terms that is extracted from node's constraints, value's conditions as well as declassification
   
   public FormulaBuilder(ExploitModel eModel,KeYJavaMethod method,VariableClassifier vc, 
         DeclassificationCenter declCenter,
         List<Term> listArtificialVars, List<Term> listArrays, 
         Term nodeConstraint1, Term nodeConstraint2) throws ProofInputException {
      super();
      this.eModel = eModel;
      
      eModel.printModelInfo();
      
     //this.method=method;
      this.vc=vc;
      vc.buildListIdentifiers(eModel);
      this.declCenter = declCenter;
      this.listArtificialVars = listArtificialVars;
      this.listArrays = listArrays;
      System.out.println("list of array terms:" + listArrays);
      this.nodeConstraint1 = nodeConstraint1;
      this.nodeConstraint2 = nodeConstraint2;
      
      System.out.println("artificialVars::\n" + listArtificialVars);
      
      services=method.getServices();
      heapHandler = new HeapHandler(services);
      termBuilder=new TermBuilder(new TermFactory(), services);
      
      mapLowVars=new HashMap<String,ModelVariable>();     
            
      ptcInputHighVars = new PairTermCollection(services);
      ptcInputNotHighVars = new PairTermCollection(services);
      ptcOutputLowPairs = new PairTermCollection(services);      
      ptcOutputLowValues1 = new PairTermCollection(services);      
      ptcOutputLowValues2 = new PairTermCollection(services);    
      ptcArtificalVars = new PairTermCollection(services);    
      ptcArrays = new PairTermCollection(services);         
      shortenListQuantifiedArrays();
    /*  System.out.println("list of quantified array terms:");
      for(Term t: listQuantifiedArrays)
         System.out.println(t);
      System.out.println("-----------");*/
      
      constructPTCArrays();   
      System.out.println("check list arrays:");
      ptcArrays.printListPairTerm();
      
      constructPTCsObj(1);
      constructPTCsObj(2);
      constructPTCArtificalVars();      
      //construct listAllVars
      ptcAllVars = new PairTermCollection(services);
      ptcAllVars.combine(ptcInputHighVars);
      //ptcAllVars.combine(ptcInputNotHighVars);
      ptcAllVars.combine(ptcArtificalVars);
      
      //combine ptcAllVars with ptcResults of list<DelimitedReleaseExtractor>
      resolveOutputLowPairs();
      
      resolvePtcAllVars();
      /*
      System.out.println("check listInputHighVars:");
      ptcInputHighVars.printListPairTerm();      
      System.out.println("check listInputNotHighVars:");
      ptcInputNotHighVars.printListPairTerm();
      System.out.println("check ptcArtificalVars:");
      ptcArtificalVars.printListPairTerm();
      System.out.println("check listAllVars:");      
      ptcAllVars.printListPairTerm();
      System.out.println("check ptcOutputLowValues1:");      
      ptcOutputLowValues1.printListPairTerm();  
      System.out.println("check ptcOutputLowValues2:");      
      ptcOutputLowValues2.printListPairTerm();
      System.out.println();*/
   }
   
   /*
    * shorten list of quantified arrays
    * */
   private void shortenListQuantifiedArrays(){
      for(int i = 0;i<listArrays.size();i++){
         listArrays.set(i, heapHandler.shortenArrayElementTerm(listArrays.get(i), KEGConstant.SEPARATOR));
      }
      //System.out.println("listQuantifiedArrays::::: \n" + listArrays);     
   } 
   
   
   private PairTerm createPairTermFromMV(ModelVariable mv){      
      String varName=mv.getIdentifier();      
      if(unQuantifiedMV(mv)||isQuantifiedArrayTerm(mv)||HeapHandler.isLengthFunction(mv.getSelectForm(), services)){
         /*
          * create two variables which have the same type with this variable and have two different name 
          * (by adding prefix "self_" and suffixes _1 and _2)
         */   
         LocationVariable lv1=new LocationVariable(new ProgramElementName(varName + "_1"),mv.getType());
         LocationVariable lv2=new LocationVariable(new ProgramElementName(varName + "_2"),mv.getType());
         
         //create two terms from two location variables
         Term t1 = termBuilder.var(lv1);
         Term t2 = termBuilder.var(lv2);
         
         return new PairTerm(t1,t2,services);  
         
      }else {
         //Term t1 = heapHandler.shortenArrayElementTerm(mv.getSelectForm(), KEGConfig.SEPARATOR);
         //Term t2 = heapHandler.shortenArrayElementTerm(mv.getSelectForm(), KEGConfig.SEPARATOR);
         //System.out.println("array relevant var: " + varName);
         Term t = heapHandler.shortenArrayElementTerm(mv.getSelectForm(), KEGConstant.SEPARATOR);
         Term t1 = ptcArrays.replacePVByNameAndBranch(t, 1);
         Term t2 = ptcArrays.replacePVByNameAndBranch(t, 2);
         
         return new PairTerm(t1,t2,services);
      }
      
      
   }   
   
   /*construct for pairArrays by collecting all arrays variables in model
    * because two model have the same model variables collection, so we need to work with only one model*/
   private void constructPTCArrays(){
      KTGModel model = eModel.getModel(0);
      for(ModelVariable mv: model.getVariables()){
         if(mv instanceof ModelArrayVariable){
            add2PTCArrays(mv);
         }
      }
      
      for(PairTerm pt: ptcArrays.getPairTerms()){
         pt.setT1(ptcArrays.replacePVByNameAndBranch(pt.getT1(), 1));
         pt.setT2(ptcArrays.replacePVByNameAndBranch(pt.getT2(), 2));
      }
   }
   
   /*
    * construct list of inputs (high, not high and low) from exploit model, use Object variables (except self object)
    * */
   private void constructPTCsObj(int branch) throws ProofInputException{      
      KTGModel model = eModel.getModel(branch);
      for(ModelVariable mv : model.getVariables()){
         if(!mv.isFresh()){
            //TODO: should not base on only name to recognise "result" artificial variable
            if(!mv.getIdentifier().equals("result")){
               if(!mv.getIdentifier().equals("self")){               
                  //We check all variables except self object (object-sensitive analysis)
                  //System.out.println("variable name: " + mv.getIdentifier());
                  if (vc.isHigh(mv.getIdentifier())){
                     //System.out.println("high variable detected: " + mv.getIdentifier());
                     add2PTCInputHighVars(mv);
                  }else{
                     //System.out.println("non-high variable detected: " + mv.getIdentifier());
                     add2ListPTCNotHighVars(mv);
                  }
                  if (vc.isLow(mv.getIdentifier())){
                     add2MapLowVars(mv);
                     add2PTCOutputLowValues(mv,branch);
                  }
                  //add all constraints of mv to corresponding list of constraints
                  //add2ListVarConstraints(mv, branch);
               }
            }else{
               //add "result" into list artificial variable (where it should belong to)s
               if(!TermUtil.inListTerm(mv.getSelectForm(), listArtificialVars)){
                  listArtificialVars.add(mv.getSelectForm());
               }
            }
         }else{
            //if mv is fresh variable, we add it into list artificial variable
            if(!TermUtil.inListTerm(mv.getSelectForm(), listArtificialVars)){
               System.out.println("fresh variable: " + mv.getSelectForm());
               listArtificialVars.add(mv.getSelectForm());
            }
         }
      }
      //System.out.println(" $$$$$$$$ end construct list variable of branch " + branch);
   }
   
   
   //construct collection of pair of artificial vars
   private void constructPTCArtificalVars(){ 
      //System.out.println("****list of artificial variables:");
      for(Term var: listArtificialVars){                
         String varName = var.op().name().toString();            
         ptcArtificalVars.add(varName,new PairTerm(var, services));
         
      }
      //System.out.println("*******************");
   }
   
   /*
    * add to list of input array variables 
    * */
   private void add2PTCArrays(ModelVariable mv) {
      String varName=mv.getIdentifier();           
      //if the list of high variable does not contains the variable, add it into the list
      if(!ptcArrays.contains(varName)){
         ptcArrays.add(varName, createPairTermFromMV(mv));         
      }           
   }
   
   
   /*
    * add to list of input high variables 
    * */
   private void add2PTCInputHighVars(ModelVariable mv){
      String varName=mv.getIdentifier();           
      //if the list of high variable does not contains the variable, add it into the list
      if(!ptcInputHighVars.contains(varName)){
         if(ptcArrays.contains(varName))
            ptcInputHighVars.add(varName, ptcArrays.getPairTerm(varName));
         else
            ptcInputHighVars.add(varName, createPairTermFromMV(mv));         
      }           
   }
   
      
   
   /*
    * add to list of input not high variables 
    * */
   private void add2ListPTCNotHighVars(ModelVariable mv) {
      String varName=mv.getIdentifier();
           
      //if the list of non-high variable does not contains the variable, add it into the list
      if(!ptcInputNotHighVars.contains(varName)){
         if(ptcArrays.contains(varName))
            ptcInputNotHighVars.add(varName, ptcArrays.getPairTerm(varName));
         else                 
            ptcInputNotHighVars.add(varName, createPairTermFromMV(mv));      
      }
   }
   
   /*
    * add to list of input low variables 
    * */
   private void add2MapLowVars(ModelVariable mv) throws ProofInputException{
      String varName=mv.getIdentifier();      //key is the variable name     
      //if the list of high variable does not contains the variable, add it into the list
      if(!mapLowVars.containsKey(varName)){                  
        mapLowVars.put(varName, mv);        //data is the resolved name
      }           
   }
   
   /*
    * add to list of input low variables via branch
    * */
   private void add2PTCOutputLowValues(ModelVariable mv, int branch){
      String varName=mv.getIdentifier();      
      Term value = mv.getSymbolicValue();
      //System.out.println("original value: " + value);
      //value = heapHandler.shortenArrayElementTerm(value, KEGConfig.SEPARATOR);
      //System.out.println("refinement value: " + value);
      if(value==null){
         value = termBuilder.NULL();
      }
      if(branch==1){
         if(!ptcOutputLowValues1.contains(varName)){
            LocationVariable lvo=new LocationVariable(new ProgramElementName(varName + "_out_1"),mv.getType());
            //Term value = new HeapHandler(services).replaceSelectFunctionByItsField(mv.getSymbolicValue());
            
            PairTerm pair=new PairTerm(termBuilder.var(lvo),value,services);
            ptcOutputLowValues1.add(varName, pair);
         }
      }else{
         if(!ptcOutputLowValues2.contains(varName)){
            LocationVariable lvo=new LocationVariable(new ProgramElementName(varName + "_out_2"),mv.getType());
            //Term value = new HeapHandler(services).replaceSelectFunctionByItsField(mv.getSymbolicValue());           
            PairTerm pair=new PairTerm(termBuilder.var(lvo),value,services);
            ptcOutputLowValues2.add(varName, pair);
         }
      }    
      
   }
   
   /*add to list of variable's constraints via branch*/
   /*private void add2ListVarConstraints(ModelVariable var, int branch){
      List<Term> constraints = var.getConstraints();
      if(branch == 1){
         listVarConstraints1.addAll(constraints);
      }else{
         listVarConstraints2.addAll(constraints);
      }
   }*/
      
   /*
    * synthesis listOutputLowPairs from listOutputLowValues1 and listOutputLowValues2
    * as well as replacing the value term by listInputHighVars and listInputNotHighVars 
    * */
   private void resolveOutputLowPairs(){
      System.out.println("ptcOutputLowValues1: ");
      ptcOutputLowValues1.printListPairTerm();
      System.out.println("ptcOutputLowValues2: ");
      ptcOutputLowValues2.printListPairTerm();
      
      //add to ptcOutputLowPairs based on ptcOutputLowValues1
      for(String name: ptcOutputLowValues1.getNameSet()){
         //make pair term of "_out_1" and "_out_2"
         PairTerm pt1=ptcOutputLowValues1.getPairTerm(name);
         PairTerm pt2=ptcOutputLowValues2.getPairTerm(name);
         if(pt2!=null){
            //resolve for symbolic values of two pairterm       
           
            //resolve the value term T2 of pt1
            Term sv1 = pt1.getT2();
            //System.out.println("sv1 ... : " + sv1);
            sv1 = heapHandler.refineTerm(sv1,listArrays);
            //System.out.println("sv1 .... : " + sv1);
            sv1 = ptcAllVars.replacePVByNameAndBranch(sv1, 1);
            //System.out.println("sv1 ..... : " + sv1);
            pt1.setT2(sv1);
            
            //resolve the value term T2 of pt1
            Term sv2 = pt2.getT2();
            //System.out.println("sv2 ... : " + sv2);
            sv2 = heapHandler.refineTerm(sv2,listArrays);
            //System.out.println("sv2 .... : " + sv2);
            sv2 = ptcAllVars.replacePVByNameAndBranch(sv2, 2);
            pt2.setT2(sv2);
            //System.out.println("sv2 ..... : " + sv2);
            //create pair term of pt1.T2 and pt2.T2 and add it into listOutputLowPairs        
            PairTerm pt=new PairTerm(sv1,sv2,services);
            ptcOutputLowPairs.add(name, pt);
         }else{
            /*if pt2 does not contain name, it means that low output value is not equal (attacker can observe this fact)
            so we can simply consider low out as a pair term of TRUE and FALSE term*/
            PairTerm pt=new PairTerm(termBuilder.tt(),termBuilder.ff(),services);
            ptcOutputLowPairs.add(name, pt);
         }
      }
      
      
    //add to ptcOutputLowPairs based on ptcOutputLowValues2
      for(String name: ptcOutputLowValues2.getNameSet()){
         if(!ptcOutputLowPairs.contains(name)){
            //make pair term of "_out_1" and "_out_2"
            PairTerm pt1=ptcOutputLowValues1.getPairTerm(name);
            PairTerm pt2=ptcOutputLowValues2.getPairTerm(name);
            if(pt1!=null){
               //resolve for symbolic values of two pairterm       
              
               //resolve the value term T2 of pt1
               Term sv1 = pt1.getT2();
               sv1 = heapHandler.refineTerm(sv1,listArrays);
               sv1 = ptcAllVars.replacePVByNameAndBranch(sv1, 1);
               pt1.setT2(sv1);
               
               //resolve the value term T2 of pt1
               Term sv2 = pt2.getT2();
               sv2 = heapHandler.refineTerm(sv2,listArrays);
               sv2 = ptcAllVars.replacePVByNameAndBranch(sv2, 2);
               pt2.setT2(sv2);
               
               //create pair term of pt1.T2 and pt2.T2 and add it into listOutputLowPairs        
               PairTerm pt=new PairTerm(sv1,sv2,services);
               ptcOutputLowPairs.add(name, pt);
            }else{
               /*if pt2 does not contain name, it means that low output value is not equal (attacker can observe this fact)
               so we can simply consider low out as a pair term of TRUE and FALSE term*/
               PairTerm pt=new PairTerm(termBuilder.tt(),termBuilder.ff(),services);
               ptcOutputLowPairs.add(name, pt);
            }
         }
      }
   }
   
   /*ptcAllVars might contains some unsolved issues, e.g two terms T1, T2 might have not adapted for two corresponding branches*/   
   private void resolvePtcAllVars(){
      for(PairTerm pt: ptcAllVars.getPairTerms()){
         pt.setT1(ptcAllVars.replacePVByNameAndBranch(pt.getT1(), 1));
         pt.setT2(ptcAllVars.replacePVByNameAndBranch(pt.getT2(), 2));
      }
   }
    
      
   /**
    * create formula to check non-interference property by checking the output value of low variable lowVar
    * the formula will be created from two paths and the collection of high variables and low variables
    * it is based on the idea that one program is non-interference if the output of low variables are different
    * if the input of high variables are changed.
    * 
    * We do it by checking two paths (may be different branches, may be the same)
    * the formula looks like below:
    * (Leak(P,i,j,low) && (!(EscCond(i) && EscCond(j)) || EscExprEqual(i,j)) 
    * We based on assumption that escape conditions must be hold in both two paths, then escape expression is allowed to leak
    * 
    * where:
    *    Leak(P,i,j,low) is the formula checking if information from secret part can be leaked to variable "low" or not 
    *       by comparing the output value of low at the final state of path i and path j. Leak(P,i,j,low) is following formula: 
    *    Leak(P,i,j,low) = PreCond(h_i,l_i) && PreCond(h_j,l_j) && PC_i(h_i,l_i) && PC_j(h_j,l_j) 
    *                      && h_i!=h_j && l_i=l_j && low_out_i!=low_out_j
    *       in which: 
                * PreCond is precondition of the method
                * PC_i and PC2_j are path conditions of two paths i and j, respectively
                * h_i, l_i, h_j, l_j: the collection of the input of high and low variables for two paths i and j, respectively         
                * l1_outs, l2_outs: the collection of the output of low variables for two corresponding paths
                * low_out_i, low_out_j: two output values of low at the final state of two path i and j, respectively
                
    *    EscapeCond: condition of escape
    *   
    */
  
   
   public Map<ModelVariable,Term> getAllInterferenceFormula() throws ProofInputException{      
      Map<ModelVariable,Term> result=new HashMap<ModelVariable,Term>();
      Term notEqualHighInput = ptcInputHighVars.partialNotEqualTerm();
      //Term equalNotHighInput = ptcInputNotHighVars.totalEqualTerm();
      //System.out.println("********************************************");
      System.out.println("notEqualHighInput: " + notEqualHighInput);
      //System.out.println("equalNotHighInput: " + equalNotHighInput);      
      //Term preCond1=getResolvedPrecondition(1); //precondition interpreted in path 1
            
      /*
       * the constraint collection of each nodes already contains precondition and path condition
       * so we don't have to work with them separately 
       * */
      System.out.println("nodeConstraint1: " + nodeConstraint1);
      System.out.println("nodeConstraint2: " + nodeConstraint2);
      
      Term nodeConstraints_1 = heapHandler.refineTerm(nodeConstraint1,listArrays);
      Term nodeConstraints_2 = heapHandler.refineTerm(nodeConstraint2,listArrays) ;    
      
      nodeConstraints_1 = ptcAllVars.replacePVByNameAndBranch(nodeConstraints_1, 1);//constraints of path 1
      nodeConstraints_2 = ptcAllVars.replacePVByNameAndBranch(nodeConstraints_2, 2);//constraints of path 2
      
      System.out.println("nodeConstraint_1: " + nodeConstraints_1);
      System.out.println("nodeConstraint_2: " + nodeConstraints_2);
      
      Term synthesisValueCond_1 = heapHandler.refineTerm(synthesizeValueCondition(1),listArrays);      
      Term synthesisValueCond_2 = heapHandler.refineTerm(synthesizeValueCondition(2),listArrays);
    
      synthesisValueCond_1 = ptcAllVars.replacePVByNameAndBranch(synthesisValueCond_1, 1);
      synthesisValueCond_2 = ptcAllVars.replacePVByNameAndBranch(synthesisValueCond_2, 2);
      
      System.out.println("synthesisValueCond_1 : " + synthesisValueCond_1);
      System.out.println("synthesisValueCond_2 : " + synthesisValueCond_2);
      
      
      //generate interference formula to check if secret infor can be leaked throw lowVar or not
      System.out.println("mapLowVars:::: " + mapLowVars);
      String heapName = eModel.getSELF_NAME();
      //method.printEscapeHatches();
      for(String lowVar: mapLowVars.keySet()){
         //Term valueLowOutput1 = listOutputLowValues1.getPairTerm(lowVar).equalTerm();
         //System.out.println("valueLowOutput1: " + valueLowOutput1);
         //Term valueLowOutput2 = listOutputLowValues2.getPairTerm(lowVar).equalTerm();
         //System.out.println("valueLowOutput2: " + valueLowOutput2);
         
         PairTerm lowOutput = ptcOutputLowPairs.getPairTerm(lowVar);         
         Term notEqualLowOutput = lowOutput.notEqualTerm(0);     
         Term declassification = termBuilder.tt();
         if(declCenter != null)
        	 declassification = declCenter.getAllConditionalEscTerms(heapName, lowVar, ptcAllVars, listArrays);
         System.out.println("\nlow locations: " + lowVar + " ; output values = " + lowOutput.toString());
         System.out.println("notEqualLowOutput: " + notEqualLowOutput);
         System.out.println("declassification: " + declassification);
         Term interferenceTerm = termBuilder.and(
               //preCond1, preCond2, 
               //pathCond1,pathCond2,
               nodeConstraints_1, nodeConstraints_2,
               notEqualHighInput, /*equalNotHighInput,*/
               synthesisValueCond_1, synthesisValueCond_2,
               /*valueLowOutput1,valueLowOutput2,*/notEqualLowOutput,
               declassification);                  
        
         //resolve interferenceTerm before pass it to SMT Solver
         //System.out.println("interferenceTerm BEFORE transforming length::: \n" + interferenceTerm);         
         interferenceTerm = heapHandler.transformLength(interferenceTerm);
         //System.out.println("interferenceTerm AFTER transforming length::: \n" + interferenceTerm);       
         interferenceTerm = new QuantifiableVarUnifier(interferenceTerm, services).unifyQuantifiableVars();
         result.put(mapLowVars.get(lowVar), interferenceTerm);
         
            
         System.out.println("interferenceTerm:^^^: \n" + interferenceTerm);      
         System.out.println("interferenceTerm after resolved:^^^: \n" + TermUtil.resolveJavaIntFunctions(interferenceTerm, services));
            
      }
      
      return result;
   }  
   
   
   /*synthesize all value condition of all model variable by using conjunction (AND)*/
   private Term synthesizeValueCondition(int branch){
      Term result = termBuilder.tt();
      for(ModelVariable mv: eModel.getModel(branch).getVariables()){
         if(!mv.isFresh()){
            if(!mv.getIdentifier().equals("self"))
               result = termBuilder.and(result, mv.getValueCondition());
         }
      }          
      return result;
   }
  /* 
   private Term refineTerm(final Term t){            
      Term result = heapHandler.shortenArrayElementTerm(t, KEGConfig.SEPARATOR);
      result = heapHandler.replaceUnContainArraySelectAndLength(result,listArrays);      
      result = heapHandler.resolveEqualTerm(result, 0);      
      return result;
   }*/
   
   /*check whether mv does not have an ancestor listed in listQuantifiedArray*/
   private boolean unQuantifiedMV(final ModelVariable mv){
      if(TermUtil.inListTerm(mv.getIdentifier(), listArrays))
         return false;
      else if(mv.getParentIdentifier()==null){
         return true;
      }else {
         ModelVariable upVar = eModel.getModel1().getVariable(mv.getParentIdentifier());
         if(upVar == null)
            return true;
         else
            return unQuantifiedMV(upVar);
      }
   }   
   
   private boolean isQuantifiedArrayTerm(final ModelVariable mv){
      return TermUtil.inListTerm(mv.getIdentifier(),listArrays);
   }
   
   
   public Term getSyntheziedFormula(){	   
	      Term notEqualHighInput = ptcInputHighVars.partialNotEqualTerm();	      
	      Term nodeConstraints_1 = heapHandler.refineTerm(nodeConstraint1,listArrays);
	      Term nodeConstraints_2 = heapHandler.refineTerm(nodeConstraint2,listArrays) ;    
	      
	      nodeConstraints_1 = ptcAllVars.replacePVByNameAndBranch(nodeConstraints_1, 1);//constraints of path 1
	      nodeConstraints_2 = ptcAllVars.replacePVByNameAndBranch(nodeConstraints_2, 2);//constraints of path 2
	      
	      Term synthesisValueCond_1 = heapHandler.refineTerm(synthesizeValueCondition(1),listArrays);      
	      Term synthesisValueCond_2 = heapHandler.refineTerm(synthesizeValueCondition(2),listArrays);
	    
	      synthesisValueCond_1 = ptcAllVars.replacePVByNameAndBranch(synthesisValueCond_1, 1);
	      synthesisValueCond_2 = ptcAllVars.replacePVByNameAndBranch(synthesisValueCond_2, 2);
	      
	      //generate interference formula to check if secret information can be leaked throw lowVar or not
	      //String heapName = eModel.getSELF_NAME();
	      //method.printEscapeHatches();
	      Term notEqualLowOutput = ptcOutputLowPairs.partialNotEqualTerm();
	      Term interferenceTerm = termBuilder.and(
	               nodeConstraints_1, nodeConstraints_2,
	               notEqualHighInput, 
	               synthesisValueCond_1, synthesisValueCond_2,
	               notEqualLowOutput);                  
	        
	         //resolve interferenceTerm before pass it to SMT Solver
	         //System.out.println("interferenceTerm BEFORE transforming length::: \n" + interferenceTerm);         
	         interferenceTerm = heapHandler.transformLength(interferenceTerm);
	         //System.out.println("interferenceTerm AFTER transforming length::: \n" + interferenceTerm);       
	         interferenceTerm = new QuantifiableVarUnifier(interferenceTerm, services).unifyQuantifiableVars();
	        return interferenceTerm;
   }
   
}
