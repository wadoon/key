/**
 * this class contains utilized methods for working with Term
 */
package de.tud.exploitgen.util;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.abstraction.PrimitiveType;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;


/**
 * @author Huy Do
 */
public class TermUtil {
   /**
    * return true if Term t already exists in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(Term t, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   /**
    * return true if Term t already exists in array lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(Term t, ImmutableArray<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   /**
    * return true if String identifier already exists in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(String identifier, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(identifier.equals(te.toString()))
               return true;
         }
      }
      return false;
   } /**
    * return true if String identifier already exists in array lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(String identifier, ImmutableArray<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(identifier.equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   
   
   /**
    * return true if t1 and t2 has the same String representation
    * */
   public static boolean sameToString(Term t1, Term t2){
      return (t1.toString().equals(t2.toString()));
   }
   
   /**
    * @param sub
    * @param root 
    * return true if @Term sub is a descendant of root
    * we compare two term based on its String representation 
    * */   
   public static boolean isDescendant(final Term sub, final Term root){
      if(root!=null){
         if(sameToString(sub, root)){
            return true;
         }else if(root.subs()==null){
            return false;
         }else if(root.subs().size()==0){
            return false;
         }else if(inListTerm(sub,root.subs())){
            return true;
         }else{
            boolean result = false;
            for(Term st: root.subs()){
               result = result || isDescendant(sub, st);
            }
            return result;   
         }
      }else{
         return false;
      }
   }
   
   
   /*return true if Term t is ancestor of one of term listed in listSubTerms*/
   public static boolean haveDescendantInList(Term t, List<Term> listSubTerms){
      for(Term sub: listSubTerms){
         if(isDescendant(sub, t))
            return true;
      }
      return false;
   }
   
   /*return true if Term t is descendant of one of term listed in listSubTerms*/
   public static boolean haveAncestorInList(Term t, List<Term> listAncestorTerms){
      for(Term ancestor: listAncestorTerms){
         if(isDescendant(t, ancestor))
            return true;
      }
      return false;
   }
   
   public static List<Term> mergeListTerm(List<Term> lt1, List<Term> lt2){
      if((lt1==null) &&(lt2==null))
         return null;
      else{
         if(lt1!=null){
            List<Term> result = new LinkedList<Term>();
            result.addAll(lt1);
            if(lt2!=null)
               for(Term t: lt2){
                  if(!inListTerm(t, result))
                     result.add(t);
               }
            return result;
         }else{
            List<Term> result = new LinkedList<Term>();
            result.addAll(lt2);            
            return result;
         }
      }
   }
   
   public static boolean containProgramMethod(Term t){
      if(t!=null){
         if(TermParser.isProgramMethod(t)){
            return true;
         }else if(t.subs().size()==0){
            return false;                       
         }else {
            boolean result =false;
            for(Term sub: t.subs()){
               result = result || containProgramMethod(sub);
            }
            return result;
         }
      }
      return false;
   }
   
   public static boolean containQuantifier(Term t){
      if(t!=null){
         if(TermParser.isQuantifier(t)){
            return true;
         }else if(t.subs().size()==0){
            return false;                       
         }else {
            boolean result =false;
            for(Term sub: t.subs()){
               result = result || containQuantifier(sub);
            }
            return result;
         }
      }
      return false;
   }
   
   /*
    * Extract all array terms bounded by quantifier inside Term t
    * */
   public static List<Term> extractQuantifiedArrays(Term t){
      if(!containQuantifier(t))
         return null;
      else if (TermParser.isQuantifier(t)){
         return extractArraysInsideQuantifier(t);
      }else{
         List<Term> result = new LinkedList<Term>();
         for(Term sub: t.subs()){
            result = mergeListTerm(result,extractQuantifiedArrays(sub));
         }
         return result;
      }
   }
   
     
   /*extract all array variables that are quantified*/
   private static List<Term> extractArraysInsideQuantifier(Term t){
      if(t!=null){         
         if(TermParser.isArray(t)){
            List<Term> result = new LinkedList<Term>();
            result.add(t);
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArraysInsideQuantifier(st));
            }
            return result;
               
         }else if(t.subs().size()==0){
            return null;
         }
         else{
            List<Term> result = new LinkedList<Term>();
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArraysInsideQuantifier(st));
            }
            return result;
         }
      }else
         return null;
   }
   
  
   
   
   /*
    * Extract all array's elements in Term t that those array is in listQuantifiedArrays
    * */
   public static List<Term> extractArrayElements(Term t, List<Term> listArrays){
      if(t!=null){         
         if(HeapHandler.isArrayElement(t)){
            //System.out.println("found array element: " + t);
            if(inListTerm(t.sub(1),listArrays)){
               List<Term> result = new LinkedList<Term>();            
               result.add(t);
               return result;
            }else{
               return null;
            }
         }else{
            List<Term> result = new LinkedList<Term>();
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArrayElements(st,listArrays));
            }
            return result;
         }
      }else
         return null;
   }
   
   /*
    * extract all arrays in a term
    * */
   public static List<Term> extractArrays(Term t){
      if(t!=null){
         List<Term> result = new LinkedList<Term>();
         //TODO: how to deal with multi-dimensional array? (select(heap(select...)))
         if(TermParser.isArray(t)){
            result.add(t);
         }
         for(Term st: t.subs()){               
            result = mergeListTerm(result,extractArrays(st));
         }
         return result;          
        
      }else
         return null;
   }
   
   public static Term createIntVarTerm(String varName, Services services){
	   //TODO: there must be a better way to create a term that not use ProgramVariable\
	  
	   LocationVariable lv=new LocationVariable(new ProgramElementName(varName),  services.getJavaInfo().getPrimitiveKeYJavaType(PrimitiveType.JAVA_INT));
	   return services.getTermBuilder().var(lv);
       
   }
   
   /*
	 * compute the value of formula using mapValuesS
	 * */
	public static double computeDouble(Term arithFormula, Map<String, Integer> mapValues){
		if(TermParser.isInteger(arithFormula)||TermParser.isIntegerNegation(arithFormula)){
			return Double.parseDouble(TermParser.resolveNumber(arithFormula));
		}
		else if(TermParser.isProgramVariable(arithFormula)){
			return (double)mapValues.get(arithFormula.toString());
		}
		else if(TermParser.isAddition(arithFormula)){
			return computeDouble(arithFormula.sub(0), mapValues) + computeDouble(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isSubtraction(arithFormula)){
			return computeDouble(arithFormula.sub(0), mapValues) - computeDouble(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isMultiplication(arithFormula)){
			return computeDouble(arithFormula.sub(0), mapValues) *      computeDouble(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isDivision(arithFormula)){
			return computeDouble(arithFormula.sub(0), mapValues) / computeDouble(arithFormula.sub(1),mapValues);
		}	
		else if(TermParser.isPowerFunction(arithFormula)){
			return Math.pow(computeDouble(arithFormula.sub(0), mapValues), computeDouble(arithFormula.sub(1),mapValues));
		}
		//TODO: what should be the default value?
		return 0;
	}
	
	public static long computeLong(Term arithFormula, Map<String, Long> mapValues){
		if(TermParser.isInteger(arithFormula)||TermParser.isIntegerNegation(arithFormula)){
			return TermParser.getIntegerValue(arithFormula);
		}
		else if(TermParser.isProgramVariable(arithFormula)){
			return (long)mapValues.get(arithFormula.toString());
		}
		else if(TermParser.isAddition(arithFormula)){
			return computeLong(arithFormula.sub(0), mapValues) + computeLong(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isSubtraction(arithFormula)){
			return computeLong(arithFormula.sub(0), mapValues) - computeLong(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isMultiplication(arithFormula)){
			return computeLong(arithFormula.sub(0), mapValues) *      computeLong(arithFormula.sub(1),mapValues);
		}
		else if(TermParser.isDivision(arithFormula)){
			return computeLong(arithFormula.sub(0), mapValues) / computeLong(arithFormula.sub(1),mapValues);
		}	
		else if(TermParser.isPowerFunction(arithFormula)){
			return (long)Math.pow(computeLong(arithFormula.sub(0), mapValues), computeLong(arithFormula.sub(1),mapValues));
		}
		//TODO: what should be the default value?
		return 0;
	}
	
	//if t contains a subterm that does not appear in listString then return false
	public static boolean containOnlyVarInListString(List<String> listString, Term t){
		if(TermParser.isProgramVariable(t)|| KeYResourceHandler.isArtificialVariable(t)){
			if(!listString.contains(t.toString()))
				return false;
		}else if(t.subs().size()>0){
			for(Term sub: t.subs()){
				if(!containOnlyVarInListString(listString, sub))
					return false;
			}
		}
		return true;
	}
	
	/*
	 * if there exists sub(t) \in listString, return false
	 * otherwise return true
	 * */
	public static boolean uncontainVarInListString(List<String> listString, Term t){
		if(TermParser.isProgramVariable(t)|| KeYResourceHandler.isArtificialVariable(t)){
			if(listString.contains(t.toString()))
				return false;
		}else if(t.subs().size()>0){
			for(Term sub: t.subs()){
				if(!uncontainVarInListString(listString, sub))
					return false;
			}
		}
		return true;
	}
	
	/*
	 * return the condition that two vector of values can be identical
	 * */
	public static Term notIdenticalCondition(Map<String,Term> mapValue1, Map<String,Term> mapValue2, Services services){
		TermBuilder tb = services.getTermBuilder();
		Term identical = identicalCondition(mapValue1, mapValue2, services);		
		return tb.not(identical);
	}

	/*
	 * return the condition that two vector of values can be identical
	 * */
	public static Term identicalCondition(Map<String,Term> mapValue1, Map<String,Term> mapValue2, Services services){
		TermBuilder tb = services.getTermBuilder();
		Term identical = tb.tt();
		for(String var: mapValue1.keySet()){
			Term value1 = mapValue1.get(var);
			Term value2 = mapValue2.get(var);
			if(TermParser.isIntegerConst(value1) && TermParser.isIntegerConst(value2)){
				if(TermParser.getIntegerValue(value1)!=TermParser.getIntegerValue(value2)){
					identical = tb.ff();
					break;
				}
			}else{
				identical = tb.and(identical, tb.equals(value1, value2));
			}
		}
		return identical;
	}
}
