/**
 * this class contains utilized methods for working with Term
 */
package de.tud.exploitgen.util;

import java.util.LinkedList;
import java.util.List;

import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.Term;


/**
 * @author Huy Do
 */
public class TermUtil {
   /**
    * return true if Term t already exists in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(Term t, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   /**
    * return true if Term t already exists in array lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(Term t, ImmutableArray<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   /**
    * return true if String identifier already exists in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(String identifier, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(identifier.equals(te.toString()))
               return true;
         }
      }
      return false;
   } /**
    * return true if String identifier already exists in array lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(String identifier, ImmutableArray<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(identifier.equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   
   
   /**
    * return true if t1 and t2 has the same String representation
    * */
   public static boolean sameToString(Term t1, Term t2){
      return (t1.toString().equals(t2.toString()));
   }
   
   /**
    * @param sub
    * @param root 
    * return true if @Term sub is a descendant of root
    * we compare two term based on its String representation 
    * */   
   public static boolean isDescendant(final Term sub, final Term root){
      if(root!=null){
         if(sameToString(sub, root)){
            return true;
         }else if(root.subs()==null){
            return false;
         }else if(root.subs().size()==0){
            return false;
         }else if(inListTerm(sub,root.subs())){
            return true;
         }else{
            boolean result = false;
            for(Term st: root.subs()){
               result = result || isDescendant(sub, st);
            }
            return result;   
         }
      }else{
         return false;
      }
   }
   
   
   /*return true if Term t is ancestor of one of term listed in listSubTerms*/
   public static boolean haveDescendantInList(Term t, List<Term> listSubTerms){
      for(Term sub: listSubTerms){
         if(isDescendant(sub, t))
            return true;
      }
      return false;
   }
   
   /*return true if Term t is descendant of one of term listed in listSubTerms*/
   public static boolean haveAncestorInList(Term t, List<Term> listAncestorTerms){
      for(Term ancestor: listAncestorTerms){
         if(isDescendant(t, ancestor))
            return true;
      }
      return false;
   }
   
   public static List<Term> mergeListTerm(List<Term> lt1, List<Term> lt2){
      if((lt1==null) &&(lt2==null))
         return null;
      else{
         if(lt1!=null){
            List<Term> result = new LinkedList<Term>();
            result.addAll(lt1);
            if(lt2!=null)
               for(Term t: lt2){
                  if(!inListTerm(t, result))
                     result.add(t);
               }
            return result;
         }else{
            List<Term> result = new LinkedList<Term>();
            result.addAll(lt2);            
            return result;
         }
      }
   }
   
   public static boolean containProgramMethod(Term t){
      if(t!=null){
         if(TermParser.isProgramMethod(t)){
            return true;
         }else if(t.subs().size()==0){
            return false;                       
         }else {
            boolean result =false;
            for(Term sub: t.subs()){
               result = result || containProgramMethod(sub);
            }
            return result;
         }
      }
      return false;
   }
   
   public static boolean containQuantifier(Term t){
      if(t!=null){
         if(TermParser.isQuantifier(t)){
            return true;
         }else if(t.subs().size()==0){
            return false;                       
         }else {
            boolean result =false;
            for(Term sub: t.subs()){
               result = result || containQuantifier(sub);
            }
            return result;
         }
      }
      return false;
   }
   
   /*
    * Extract all array terms bounded by quantifier inside Term t
    * */
   public static List<Term> extractQuantifiedArrays(Term t){
      if(!containQuantifier(t))
         return null;
      else if (TermParser.isQuantifier(t)){
         return extractArraysInsideQuantifier(t);
      }else{
         List<Term> result = new LinkedList<Term>();
         for(Term sub: t.subs()){
            result = mergeListTerm(result,extractQuantifiedArrays(sub));
         }
         return result;
      }
   }
   
     
   /*extract all array variables that are quantified*/
   private static List<Term> extractArraysInsideQuantifier(Term t){
      if(t!=null){         
         if(TermParser.isArray(t)){
            List<Term> result = new LinkedList<Term>();
            result.add(t);
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArraysInsideQuantifier(st));
            }
            return result;
               
         }else if(t.subs().size()==0){
            return null;
         }
         else{
            List<Term> result = new LinkedList<Term>();
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArraysInsideQuantifier(st));
            }
            return result;
         }
      }else
         return null;
   }
   
  
   
   
   /*
    * Extract all array's elements in Term t that those array is in listQuantifiedArrays
    * */
   public static List<Term> extractArrayElements(Term t, List<Term> listArrays){
      if(t!=null){         
         if(HeapHandler.isArrayElement(t)){
            //System.out.println("found array element: " + t);
            if(inListTerm(t.sub(1),listArrays)){
               List<Term> result = new LinkedList<Term>();            
               result.add(t);
               return result;
            }else{
               return null;
            }
         }else{
            List<Term> result = new LinkedList<Term>();
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArrayElements(st,listArrays));
            }
            return result;
         }
      }else
         return null;
   }
   
   /*
    * extract all arrays in a term
    * */
   public static List<Term> extractArrays(Term t){
      if(t!=null){
         List<Term> result = new LinkedList<Term>();
         //TODO: how to deal with multi-dimensional array? (select(heap(select...)))
         if(TermParser.isArray(t)){
            result.add(t);
         }
         for(Term st: t.subs()){               
            result = mergeListTerm(result,extractArrays(st));
         }
         return result;          
        
      }else
         return null;
   }
   
 
}
