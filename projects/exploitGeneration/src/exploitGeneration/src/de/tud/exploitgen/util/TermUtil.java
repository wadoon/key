/**
 * this class contains utilized methods for working with Term
 */
package de.tud.exploitgen.util;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.key_project.util.collection.DefaultImmutableSet;
import org.key_project.util.collection.ImmutableArray;
import org.key_project.util.collection.ImmutableList;
import org.key_project.util.collection.ImmutableSet;

import de.uka.ilkd.key.control.DefaultUserInterfaceControl;
import de.uka.ilkd.key.control.KeYEnvironment;
import de.uka.ilkd.key.control.ProofControl;
//import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.abstraction.PrimitiveType;
import de.uka.ilkd.key.logic.Choice;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Sequent;
import de.uka.ilkd.key.logic.SequentFormula;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.IObserverFunction;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.proof.ApplyStrategy.ApplyStrategyInfo;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.InitConfig;
import de.uka.ilkd.key.proof.init.JavaProfile;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.proof.io.ProofSaver;
import de.uka.ilkd.key.proof.mgt.AxiomJustification;
import de.uka.ilkd.key.proof.mgt.ProofEnvironment;
import de.uka.ilkd.key.proof.mgt.RuleJustification;
import de.uka.ilkd.key.rule.BuiltInRule;
import de.uka.ilkd.key.rule.OneStepSimplifier;
import de.uka.ilkd.key.rule.Taclet;
import de.uka.ilkd.key.rule.tacletbuilder.TacletBuilder;
import de.uka.ilkd.key.settings.ChoiceSettings;
import de.uka.ilkd.key.settings.ProofSettings;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.strategy.Strategy;
import de.uka.ilkd.key.strategy.StrategyFactory;
import de.uka.ilkd.key.strategy.StrategyProperties;
import de.uka.ilkd.key.symbolic_execution.profile.JavaIntRemovingProfile;
import de.uka.ilkd.key.symbolic_execution.profile.SimplifyTermProfile;
import de.uka.ilkd.key.symbolic_execution.strategy.JavaIntRemovingStrategy;
import de.uka.ilkd.key.symbolic_execution.strategy.SimplifyTermStrategy;
import de.uka.ilkd.key.symbolic_execution.strategy.SymbolicExecutionStrategy;
import de.uka.ilkd.key.symbolic_execution.strategy.JavaIntRemovingStrategy.JavaIntRemovingStrategyFactory;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionSideProofUtil;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionUtil;
import de.uka.ilkd.key.util.KeYTypeUtil;
import de.uka.ilkd.key.util.MiscTools;
import de.uka.ilkd.key.util.ProofStarter;
import de.uka.ilkd.key.util.SideProofUtil;


/**
 * @author Huy Do
 */
public class TermUtil {
	
   /**
    * return true if Term t already exists in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(Term t, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   /**
    * return true if Term t already exists in array lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(final Term t, final ImmutableArray<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   /**
    * return true if String identifier already exists in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(String identifier, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(identifier.equals(te.toString()))
               return true;
         }
      }
      return false;
   } 
   /**
    * return true if String identifier already exists in array lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   public static boolean inListTerm(String identifier, ImmutableArray<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(identifier.equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   
   
   /**
    * return true if t1 and t2 has the same String representation
    * */
   public static boolean sameToString(Term t1, Term t2){
      return (t1.toString().equals(t2.toString()));
   }
   
   /**
    * @param sub
    * @param root 
    * return true if @Term sub is a descendant of root
    * we compare two term based on its String representation 
    * */   
   public static boolean isDescendant(final Term sub, final Term root){
      if(root!=null){
         if(sameToString(sub, root)){
            return true;
         }else if(root.subs()==null){
            return false;
         }else if(root.subs().size()==0){
            return false;
         }else if(inListTerm(sub,root.subs())){
            return true;
         }else{
            boolean result = false;
            for(Term st: root.subs()){
               result = result || isDescendant(sub, st);
            }
            return result;   
         }
      }else{
         return false;
      }
   }
   
   
   /*return true if Term t is ancestor of one of term listed in listSubTerms*/
   public static boolean haveDescendantInList(Term t, List<Term> listSubTerms){
      for(Term sub: listSubTerms){
         if(isDescendant(sub, t))
            return true;
      }
      return false;
   }
   
   /*return true if Term t is descendant of one of term listed in listSubTerms*/
   public static boolean haveAncestorInList(Term t, List<Term> listAncestorTerms){
      for(Term ancestor: listAncestorTerms){
         if(isDescendant(t, ancestor))
            return true;
      }
      return false;
   }
   
   public static List<Term> mergeListTerm(List<Term> lt1, List<Term> lt2){
      if((lt1==null) &&(lt2==null))
         return null;
      else{
         if(lt1!=null){
            List<Term> result = new LinkedList<Term>();
            result.addAll(lt1);
            if(lt2!=null)
               for(Term t: lt2){
                  if(!inListTerm(t, result))
                     result.add(t);
               }
            return result;
         }else{
            List<Term> result = new LinkedList<Term>();
            result.addAll(lt2);            
            return result;
         }
      }
   }
   
   public static boolean containProgramMethod(Term t){
      if(t!=null){
         if(TermParser.isProgramMethod(t)){
            return true;
         }else if(t.subs().size()==0){
            return false;                       
         }else {
            boolean result =false;
            for(Term sub: t.subs()){
               result = result || containProgramMethod(sub);
            }
            return result;
         }
      }
      return false;
   }
   
   public static boolean containQuantifier(Term t){
      if(t!=null){
         if(TermParser.isQuantifier(t)){
            return true;
         }else if(t.subs().size()==0){
            return false;                       
         }else {
            boolean result =false;
            for(Term sub: t.subs()){
               result = result || containQuantifier(sub);
            }
            return result;
         }
      }
      return false;
   }
   
   /*
    * Extract all array terms bounded by quantifier inside Term t
    * */
   public static List<Term> extractQuantifiedArrays(Term t){
      if(!containQuantifier(t))
         return null;
      else if (TermParser.isQuantifier(t)){
         return extractArraysInsideQuantifier(t);
      }else{
         List<Term> result = new LinkedList<Term>();
         for(Term sub: t.subs()){
            result = mergeListTerm(result,extractQuantifiedArrays(sub));
         }
         return result;
      }
   }
   
     
   /*extract all array variables that are quantified*/
   private static List<Term> extractArraysInsideQuantifier(Term t){
      if(t!=null){         
         if(TermParser.isArray(t)){
            List<Term> result = new LinkedList<Term>();
            result.add(t);
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArraysInsideQuantifier(st));
            }
            return result;
               
         }else if(t.subs().size()==0){
            return null;
         }
         else{
            List<Term> result = new LinkedList<Term>();
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArraysInsideQuantifier(st));
            }
            return result;
         }
      }else
         return null;
   }
   
  
   
   
   /*
    * Extract all array's elements in Term t that those array is in listQuantifiedArrays
    * */
   public static List<Term> extractArrayElements(Term t, List<Term> listArrays){
      if(t!=null){         
         if(HeapHandler.isArrayElement(t)){
            //System.out.println("found array element: " + t);
            if(inListTerm(t.sub(1),listArrays)){
               List<Term> result = new LinkedList<Term>();            
               result.add(t);
               return result;
            }else{
               return null;
            }
         }else{
            List<Term> result = new LinkedList<Term>();
            for(Term st: t.subs()){               
               result = mergeListTerm(result,extractArrayElements(st,listArrays));
            }
            return result;
         }
      }else
         return null;
   }
   
   /*
    * extract all arrays in a term
    * */
   public static List<Term> extractArrays(Term t){
      if(t!=null){
         List<Term> result = new LinkedList<Term>();
         //TODO: how to deal with multi-dimensional array? (select(heap(select...)))
         if(TermParser.isArray(t)){
            result.add(t);
         }
         for(Term st: t.subs()){               
            result = mergeListTerm(result,extractArrays(st));
         }
         return result;          
        
      }else
         return null;
   }
   
   public static Term createIntVarTerm(String varName, Services services){
	   //TODO: there must be a better way to create a term that not use ProgramVariable\
	  
	   LocationVariable lv=new LocationVariable(new ProgramElementName(varName),  services.getJavaInfo().getPrimitiveKeYJavaType(PrimitiveType.JAVA_INT));
	   return services.getTermBuilder().var(lv);
       
   }
   
   /*
	 * compute the value of formula using mapValuesS
	 * */
	public static double computeDouble(Term arithFormula, Map<String, Long> mapValues, Services services){
		if(TermParser.isInteger(arithFormula, services)||TermParser.isIntegerNegation(arithFormula, services)){
			return TermParser.getBigIntegerValue(arithFormula, services).doubleValue();
		}
		else if(TermParser.isProgramVariable(arithFormula)){
			return (double)mapValues.get(arithFormula.toString());
		}
		else if(TermParser.isAddition(arithFormula)){
			return computeDouble(arithFormula.sub(0), mapValues, services) + computeDouble(arithFormula.sub(1),mapValues, services);
		}
		else if(TermParser.isSubtraction(arithFormula)){
			return computeDouble(arithFormula.sub(0), mapValues, services) - computeDouble(arithFormula.sub(1),mapValues, services);
		}
		else if(TermParser.isMultiplication(arithFormula)){
			return computeDouble(arithFormula.sub(0), mapValues, services) *      computeDouble(arithFormula.sub(1),mapValues, services);
		}
		else if(TermParser.isDivision(arithFormula)){
			return computeDouble(arithFormula.sub(0), mapValues, services) / computeDouble(arithFormula.sub(1),mapValues, services);
		}	
		else if(TermParser.isPowerFunction(arithFormula, services)){
			return Math.pow(computeDouble(arithFormula.sub(0), mapValues, services), computeDouble(arithFormula.sub(1),mapValues, services));
		}
		//TODO: what should be the default value?
		return 0;
	}
	
	public static long computeLong(Term arithFormula, Map<String, Long> mapValues, Services services){
		if(TermParser.isInteger(arithFormula, services)||TermParser.isIntegerNegation(arithFormula, services)){
			return TermParser.getIntegerValue(arithFormula, services);
		}
		else if(TermParser.isProgramVariable(arithFormula)){
			return (long)mapValues.get(arithFormula.toString());
		}
		else if(TermParser.isAddition(arithFormula)){
			return computeLong(arithFormula.sub(0), mapValues, services) + computeLong(arithFormula.sub(1),mapValues, services);
		}
		else if(TermParser.isSubtraction(arithFormula)){
			return computeLong(arithFormula.sub(0), mapValues, services) - computeLong(arithFormula.sub(1),mapValues, services);
		}
		else if(TermParser.isMultiplication(arithFormula)){
			return computeLong(arithFormula.sub(0), mapValues, services) *      computeLong(arithFormula.sub(1),mapValues, services);
		}
		else if(TermParser.isDivision(arithFormula)){
			return computeLong(arithFormula.sub(0), mapValues, services) / computeLong(arithFormula.sub(1),mapValues, services);
		}	
		else if(TermParser.isPowerFunction(arithFormula, services)){
			return (long)Math.pow(computeLong(arithFormula.sub(0), mapValues, services), computeLong(arithFormula.sub(1),mapValues, services));
		}
		//TODO: what should be the default value?
		return 0;
	}
	
	//if t contains a subterm that does not appear in listString then return false
	public static boolean containOnlyVarInListString(List<String> listString, Term t, Services services){
		if(TermParser.isProgramVariable(t)|| KeYResourceHandler.isArtificialVariable(t, services)){
			if(!listString.contains(t.toString()))
				return false;
		}else if(t.subs().size()>0){
			for(Term sub: t.subs()){
				if(!containOnlyVarInListString(listString, sub, services))
					return false;
			}
		}
		return true;
	}
	
	/*
	 * if there exists sub(t) \in listString, return false
	 * otherwise return true
	 * */
	public static boolean uncontainVarInListString(List<String> listString, Term t, Services services){
		if(TermParser.isProgramVariable(t)|| KeYResourceHandler.isArtificialVariable(t, services)){
			if(listString.contains(t.toString()))
				return false;
		}else if(t.subs().size()>0){
			for(Term sub: t.subs()){
				if(!uncontainVarInListString(listString, sub, services))
					return false;
			}
		}
		return true;
	}
	
	/*
	 * return the condition that two vector of values can be identical
	 * */
	public static Term notIdenticalCondition(Map<String,Term> mapValue1, Map<String,Term> mapValue2, Services services){
		TermBuilder tb = services.getTermBuilder();
		Term identical = identicalCondition(mapValue1, mapValue2, services);		
		return tb.not(identical);
	}

	/*
	 * return the condition that two vector of values can be identical
	 * */
	public static Term identicalCondition(Map<String,Term> mapValue1, Map<String,Term> mapValue2, Services services){
		TermBuilder tb = services.getTermBuilder();
		Term identical = tb.tt();
		for(String var: mapValue1.keySet()){
			Term value1 = mapValue1.get(var);
			Term value2 = mapValue2.get(var);
			if(TermParser.isIntegerConst(value1, services) && TermParser.isIntegerConst(value2, services)){
				if(TermParser.getIntegerValue(value1, services)!=TermParser.getIntegerValue(value2, services)){
					identical = tb.ff();
					break;
				}
			}else{
				identical = tb.and(identical, tb.equals(value1, value2));
			}
		}
		return identical;
	}
	
	    
    public static Term resolveJavaIntFunctions(Term t, Services services){
	   TermBuilder termBuilder = services.getTermBuilder();
	    
	   // List all specifications of all types in the source location (not classPaths and bootClassPath)
		 boolean isSub= false;
	   Term formula=null;
	   if(TermParser.isFormula(t)){
		   //System.out.println("term is formula");
		   formula = t;		   
	   }else{
		   //create a formula from escape hatch expression
		   Name predSymbol = new Name(services.getTermBuilder().newName("SimplificationWrapper"));
		   Function pred=new Function(predSymbol, Sort.FORMULA, t.sort());
		   formula = termBuilder.func(pred, t);
		   isSub= true;
		   
	   }

	   InitConfig	initConfig =	new InitConfig(services.copy(new JavaIntRemovingProfile(), false));
      ImmutableSet<Choice> choices = services.getProof().getInitConfig().getActivatedChoices(); 
      
      initConfig.setActivatedChoices(choices);
      // Initialize InitConfig with settings from the original InitConfig.
      final ProofSettings clonedSettings = services.getProof().getInitConfig().getSettings() != null ? new ProofSettings(services.getProof().getInitConfig().getSettings()) : null;
      initConfig.setSettings(clonedSettings);
      initConfig.setTaclet2Builder((HashMap<Taclet, TacletBuilder<? extends Taclet>>) services.getProof().getInitConfig().getTaclet2Builder().clone());
      initConfig.setTaclets(services.getProof().getInitConfig().getTaclets());
      // Create new ProofEnvironment and initialize it with values from initial one.
      ProofEnvironment env = new ProofEnvironment(initConfig);
      
      for (Taclet taclet : initConfig.activatedTaclets()) {
          initConfig.getJustifInfo().addJustification(taclet, services.getProof().getInitConfig().getJustifInfo().getJustification(taclet));
       }
       for (BuiltInRule rule : initConfig.builtInRules()) {
          RuleJustification origJusti = services.getProof().getInitConfig().getJustifInfo().getJustification(rule);
          if (origJusti == null) {
             assert rule instanceof OneStepSimplifier;
             origJusti = AxiomJustification.INSTANCE;
          }
          initConfig.getJustifInfo().addJustification(rule, origJusti);
       }	  	 
	     // Start auto mode
	     ProofStarter starter = new ProofStarter(false);
	     try {
			starter = SymbolicExecutionSideProofUtil.createSideProof(env, Sequent.EMPTY_SEQUENT.addFormula(new SequentFormula(formula), false, true).sequent(), "resolveJavaInt");
		} catch (ProofInputException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	      starter.setMaxRuleApplications(1000);
	      starter.setStrategy(new JavaIntRemovingStrategy(starter.getProof()));
	      ApplyStrategyInfo result = starter.start();

	      
	      System.out.println(result.getAppliedRuleApps());

	      Proof proof = starter.getProof();
	      // Show proof result
	     boolean closed = proof.openGoals().isEmpty();
	     Term resolvedTerm = proof.openGoals().head().sequent().iterator().next().formula();	
	   if(isSub)
		   resolvedTerm = resolvedTerm.sub(0);			   
	   return resolvedTerm;	         
	}
    
    
    /*
     * simplify Term using SimplifyTermStrategy of Martin
     * */
   public static Term simplifyTerm(Term t, Services services){
  	  Term formula=null;
 	  boolean isSub=false;
 	   /*if(TermParser.isFormula(t)){
 		   //System.out.println("term is formula");
 		   formula = t;		   
 	   }else{
*/ 		   //create a formula from escape hatch expression
 		   Name predSymbol = new Name(services.getTermBuilder().newName("SimplificationWrapper"));
 		   Function pred=new Function(predSymbol, Sort.FORMULA, t.sort());
 		   formula = services.getTermBuilder().func(pred, t);
 		   isSub= true;
 		   
 	   //}
 	  
 	  //System.out.println("term to be simplified ::: " + ProofSaver.printAnything(formula, services));
 	  
 	  InitConfig	initConfig =	new InitConfig(services.copy(new SimplifyTermProfile(), false));
 	  Proof proof = new Proof("resolvePoststate", formula, "header", initConfig);
       ImmutableSet<Choice> choices = services.getProof().getInitConfig().getActivatedChoices(); 
       
       initConfig.setActivatedChoices(choices);
       // Initialize InitConfig with settings from the original InitConfig.
       final ProofSettings clonedSettings = services.getProof().getInitConfig().getSettings() != null ? new ProofSettings(services.getProof().getInitConfig().getSettings()) : null;
       initConfig.setSettings(clonedSettings);
       initConfig.setTaclet2Builder((HashMap<Taclet, TacletBuilder<? extends Taclet>>) services.getProof().getInitConfig().getTaclet2Builder().clone());
       initConfig.setTaclets(services.getProof().getInitConfig().getTaclets());
       // Create new ProofEnvironment and initialize it with values from initial one.
       ProofEnvironment env = new ProofEnvironment(initConfig);
       
       for (Taclet taclet : initConfig.activatedTaclets()) {
           initConfig.getJustifInfo().addJustification(taclet, services.getProof().getInitConfig().getJustifInfo().getJustification(taclet));
        }
        for (BuiltInRule rule : initConfig.builtInRules()) {
           RuleJustification origJusti = services.getProof().getInitConfig().getJustifInfo().getJustification(rule);
           if (origJusti == null) {
              assert rule instanceof OneStepSimplifier;
              origJusti = AxiomJustification.INSTANCE;
           }
           initConfig.getJustifInfo().addJustification(rule, origJusti);
        }	  	 
 	     // Start auto mode
 	     ProofStarter starter = new ProofStarter(false);
 	     try {
 			starter = SymbolicExecutionSideProofUtil.createSideProof(env, Sequent.EMPTY_SEQUENT.addFormula(new SequentFormula(formula), false, true).sequent(), "resolveJavaInt");
 		} catch (ProofInputException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
 	      starter.setMaxRuleApplications(1000);
 	      StrategyProperties strategyProperties = SymbolicExecutionStrategy.getSymbolicExecutionStrategyProperties(true, false, false, false, false, false);
 	      starter.setStrategy(new SimplifyTermStrategy(proof, strategyProperties));
 	      ApplyStrategyInfo result = starter.start();

 	      
 	      //System.out.println(result.getAppliedRuleApps());

 	      Proof finalProof = starter.getProof();
 	      // Show proof result
 	     //boolean closed = finalProof.openGoals().isEmpty();
 	     Term resolvedTerm = finalProof.openGoals().head().sequent().iterator().next().formula();	
 	    //System.out.println(ProofSaver.printAnything(finalProof.openGoals().head().sequent(), services));
 	   //if(isSub)
 	    
 	    //extract result
 	   Iterator<SequentFormula> sucseqFormulas = finalProof.openGoals().head().sequent().succedent().iterator();

	      while(sucseqFormulas.hasNext())  {  	   		    	   
	    	   Term succFormula = sucseqFormulas.next().formula();
	    	   if(succFormula.op().toString().equals("SimplificationWrapper"))
	    		   return succFormula.sub(0);
	    	 		    	   
	       }
 		   return t;         
 	}
 	  
   /*
    * check if there is a sub term of containerTerm that has a form: store(heap, parentObj, checkTerm, ...)
    * which means that checkTerm is changed by store function
    * */
   public static boolean isChangedByStoreFunction(Term checkTerm, Term containerTerm){
	   if(TermParser.isStoreFunction(containerTerm)){
		   if(sameToString(checkTerm, containerTerm.sub(1)))
			   return true;		
		   else if(TermParser.isAllFieldsFunction(containerTerm)){
			   if(sameToString(checkTerm, containerTerm.sub(0)))
				   return true;
		   }
	   }
	   if(containerTerm.subs().size()>0){
		   boolean result = false;
           for(Term st: containerTerm.subs()){
              result = result || isChangedByStoreFunction(checkTerm, st);
           }
           return result;   
	   }else
		   return false;
   }
}
