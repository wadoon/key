package de.tud.exploitgen.findsecret;
/**
 * This class wraps a bad method where leakage can happen.
 * @author: Huy Do
 * */

import java.util.LinkedList;
import java.util.List;

import de.tud.exploitgen.detectleak.specification.noninterference.IFBarrier;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConfig;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;

public class BadMethod {
	private final KeYJavaMethod method; //bad method that the leakage can happen
	private IFBarrier niSpec; // contains corresponding non-interference policy violated by the method
	private List<RiskyPath> listRiskyPaths; //contain all risk nodes (distinguished by conditional value)
	private Term precondition; // precondition will be treated as initial knowledge
	public BadMethod(KeYJavaMethod method, IFBarrier niSpec) {
		super();
		this.method = method;
		this.niSpec = niSpec;
		//this.riskyPaths = new LinkedList<RiskyPath>();
		this.listRiskyPaths = new LinkedList<RiskyPath>();
		
	}
	
	public KeYJavaMethod getMethod() {
		return method;
	}
	

	public IFBarrier getIFBarrier() {
		return niSpec;
	}

	public void setIFBarrier(IFBarrier niSpec) {
		this.niSpec = niSpec;
	}
	
	
	//return a string representing all risky paths for testing purpose only
	public String getStringRiskyPaths() throws ProofInputException{
		String result = "";
		for(RiskyPath node: listRiskyPaths){
			result += "path condition: "  + node.getPathCondition()+ " ; ";
			if(node.isLowIndependent())
				result+="low independent \n";
			else
				result +=  node.categoryName() + "\n";			
		}
		return result;
	}
	

	/**
	 * @return: true if rp has been added in list riskyPaths
	 * */
	public boolean existPath(RiskyPath path){
		for(RiskyPath rn: listRiskyPaths){
			if(rn.sameIdxNumber(path))			
				return true;
		}
		return false;
	}
	
	/**
	 * add a risky path into list riskyPaths
	 * because risk_H is analyzed during checking non-interference, we should avoid analyze it again
	 * */
	public void addRiskyPath(RiskyPath node){
		//System.out.println("model idx: " + node.getModelNode().getIdx());
		//System.out.println("node idx: " + node.getModelNode().getNodeDetail().getIndex());
		if(!existPath(node))
			listRiskyPaths.add(node);
		else{			
			RiskyPath exNode = getRiskyPath(node.getModelNode().getIdx(), node.getModelNode().getNodeDetail().getIndex());
			//update depend_H if there is explicit information flow from H->L
			exNode.setDepend_H(exNode.isDepend_H()||node.isDepend_H());
		}
	}	
	
	public RiskyPath getRiskyPath(int modelIdx, int nodeIdx){
		for(RiskyPath rn: listRiskyPaths){
			if(rn.getModelNode().getIdx() == modelIdx && rn.getModelNode().getNodeDetail().getIndex() == nodeIdx)
				return rn;
		}
		return null;
	}

	public List<RiskyPath> getListRiskyPaths() {
		return listRiskyPaths;
	}
	
	public void resolveRiskyPaths() throws ProofInputException{
		for(RiskyPath node: listRiskyPaths)
			node.selfCategorizeNExtractInfo();
	}
	
	/*
	 * given previous knowledge, return RiskyPath matching with experiment
	 * if it doest not exist, return null
	 * */
	private RiskyPath findMatchPath(Term knowledge, Experiment experiment){
		for(RiskyPath rp: listRiskyPaths){
			if(rp.correspond2ExperimentByLowInput(knowledge, experiment))
				return rp;
		}
		//in case we cannot find what path match with the experiment based on low inputs, we check by output
		//if there is one and only one path that can match with experiment by output, then return it 
		List<RiskyPath> listCandidates = new LinkedList<RiskyPath>();
		for(RiskyPath rp: listRiskyPaths){
			if(rp.canMatchByOutputs(knowledge, experiment))
				listCandidates.add(rp);
			if(listCandidates.size()>1)
				break;
		}
		if(listCandidates.size()==1)
			return listCandidates.get(0);
		else
			return null;
	}
	
	public void updateMatchedPath(Term knowledge, Experiment experiment){
		RiskyPath rp = findMatchPath(knowledge, experiment);
		if(rp!=null)
			rp.setMatched(true);
	}
	
	public boolean allPathsAreLowIndependent(){
		for(RiskyPath rp: listRiskyPaths)
			if(!rp.isLowIndependent())
				return false;
		return true;
	}
	
	public boolean allOutputsAreConst(){
		for(RiskyPath rp: listRiskyPaths)
			if(!rp.outputIsConstant())
				return false;
		return true;
	}
	
	/*
	 * return a list of risky paths statisfying:
	 * output values are const or 
	 * output values depend only on L,
	 * output values depend only on H and has been matched  
	 * */
	public List<RiskyPath> getRiskConst_RiskL_MatchedRiskH(){
		List<RiskyPath> result = new LinkedList<RiskyPath>();
		for(RiskyPath rp: listRiskyPaths){
			String categoryName = rp.categoryName();
			if(categoryName.equals(KEGConfig.RISK_CONSTANT)||categoryName.equals(KEGConfig.RISK_L))
				result.add(rp);
			else if(categoryName.equals(KEGConfig.RISK_H)&& rp.isMatched())
				result.add(rp);
		}			
		return result;
	}
	
	
	public void resolvePrecondition(){
		precondition = method.getPreconditions().get(0);
		precondition = KeYResourceHandler.removeDefaultPrecondition(precondition);
		precondition = new HeapHandler(method.getServices()).refineTerm(precondition, listRiskyPaths.get(0).getModelNode().getNodeDetail().getListArrays());
	}

	public Term getPrecondition() {
		return precondition;
	}
	
	public boolean matchLowIndependentPath(){
		for(RiskyPath rp: listRiskyPaths)
			if(rp.isLowIndependent() && rp.isMatched())
				return true;
		return false;
	}
	
	public void resetMatchedPaths(){
		for(RiskyPath rp: listRiskyPaths){
			rp.setMatched(false);
		}
	}
}
