package de.tud.exploitgen.findsecret;
/**
 * This class wraps a bad method where leakage can happen.
 * @author: Huy Do
 * */
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.proof.init.ProofInputException;

public class BadMethod {
	private final KeYJavaMethod method; //bad method that the leakage can happen
	private VariableClassifier vc; // contains corresponding non-interference policy violated by the method
	private List<RiskyPath> riskyPaths; //contain all risky paths of the method that violate non-interference policy
	
	
	public BadMethod(KeYJavaMethod method, VariableClassifier vc) {
		super();
		this.method = method;
		this.vc = vc;
		this.riskyPaths = new LinkedList<RiskyPath>();				
	}
	
	public BadMethod(KeYJavaMethod method, VariableClassifier vc, List<RiskyPath> riskyPaths) {
		super();
		this.method = method;
		this.vc = vc;
		this.riskyPaths = riskyPaths;
	}

	public KeYJavaMethod getMethod() {
		return method;
	}
	/*public void setMethod(KeYJavaMethod method) {
		this.method = method;
	}*/
	public List<RiskyPath> getRiskyPaths() {
		return riskyPaths;
	}
	public void setRiskyPaths(List<RiskyPath> riskyPaths) {
		this.riskyPaths = riskyPaths;
	} 
	
	/**
	 * @return: true if rp has been added in list riskyPaths
	 * */
	public boolean existPath(RiskyPath rp){
		for(RiskyPath sp: riskyPaths){
			if(rp.getId()==sp.getId())
				return true;
		}
		return false;
	}
	
	/**
	 * add a risky path into list riskyPaths
	 * because risk_H is analyzed during checking non-interference, we should avoid analyze it again
	 * */
	public void addRiskyPath(RiskyPath rp){
		if(!existPath(rp))
			riskyPaths.add(rp);
		else{
			//if(rp.risk_H = 1 then we update it
			RiskyPath exPath = getRiskyPath(rp.getId());
			if(!exPath.isRisk_H()) //if 
				exPath.setRisk_H(rp.isRisk_H());			
		}
	}	
	
	public RiskyPath getRiskyPath(int id){
		for(int i=0;i<riskyPaths.size();i++)
			if(riskyPaths.get(i).getId()==id)
				return riskyPaths.get(i);
		return null;
	}

	public VariableClassifier getVariableClassifier() {
		return vc;
	}

	public void setVc(VariableClassifier vc) {
		this.vc = vc;
	}
	
	/*
	 * because classify and abstract a risky path is heavy task, we save it as late as possible
	 * */	
	public void resolveRiskyPaths() throws ProofInputException{
		for(RiskyPath rp: riskyPaths){
			rp.updateRisk_L();
			rp.updatePathAbstractions();
		}
	}
	
	//return a string representing all risky paths for testing purpose only
	public String getStringRiskyPath(){
		String result = "";
		for(RiskyPath rp: riskyPaths){
			result += rp.getId() + ": " + rp.categoryName() + "\n";
		}
		return result;
	}
	
	//return if all risky paths are constant
	public boolean allRiskyPathsRConst(){
		for(RiskyPath rp: riskyPaths)
			if(!rp.outputIsConstant())
				return false;
		return true;
	}
}
