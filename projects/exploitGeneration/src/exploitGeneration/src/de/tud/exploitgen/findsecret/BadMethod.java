package de.tud.exploitgen.findsecret;
/**
 * This class wraps a bad method where leakage can happen.
 * @author: Huy Do
 * */

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.node.ModelNode;
import de.tud.exploitgen.detectleak.specification.noninterference.IFBarrier;
import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;

public class BadMethod {
	private final KeYJavaMethod method; //bad method that the leakage can happen
	private IFBarrier niSpec; // contains corresponding non-interference policy violated by the method
	private List<RiskyPath> listRiskyPaths; //contain all risk nodes (distinguished by conditional value)
	private Term precondition; // precondition will be treated as initial knowledge
	private Map<String, Term> mapFreshOutputVar; //map of fresh observable output variable (i.e. l_i -> <l_i, l_i_out(@Term)>
	private List<QuantifiableVariable> listQuantifiedHighVar;
	public BadMethod(KeYJavaMethod method, IFBarrier niSpec) {
		super();
		this.method = method;
		this.niSpec = niSpec;
		//this.riskyPaths = new LinkedList<RiskyPath>();
		this.listRiskyPaths = new LinkedList<RiskyPath>();		
	}
	
	
	public KeYJavaMethod getMethod() {
		return method;
	}
	

	public IFBarrier getIFBarrier() {
		return niSpec;
	}

	public void setIFBarrier(IFBarrier niSpec) {
		this.niSpec = niSpec;
	}
	
	
	//return a string representing all risky paths for testing purpose only
	public String getStringRiskyPaths() throws ProofInputException{
		String result = "";
		for(RiskyPath node: listRiskyPaths){
			result += "path condition: "  + node.getPathCondition()+ " ; ";
			if(node.isLowIndependent())
				result+="low independent \n";
			else
				result +=  node.categoryName() + "\n";			
		}
		return result;
	}
	

	/**
	 * @return: true if rp has been added in list riskyPaths
	 * */
	public boolean existPath(RiskyPath path){
		for(RiskyPath rn: listRiskyPaths){
			if(rn.sameIdxNumber(path))			
				return true;
		}
		return false;
	}
	
	/**
	 * add a risky path into list riskyPaths
	 * because risk_H is analyzed during checking non-interference, we should avoid analyze it again
	 * */
	public void addRiskyPath(RiskyPath node){
		//System.out.println("model idx: " + node.getModelNode().getIdx());
		//System.out.println("node idx: " + node.getModelNode().getNodeDetail().getIndex());
		if(!existPath(node))
			listRiskyPaths.add(node);
		else{			
			RiskyPath exNode = getRiskyPath(node.getModelNode().getIdx(), node.getModelNode().getNodeDetail().getIndex());
			//update depend_H if there is explicit information flow from H->L
			exNode.setDepend_H(exNode.isDepend_H()||node.isDepend_H());
		}
	}	
	
	public RiskyPath getRiskyPath(int modelIdx, int nodeIdx){
		for(RiskyPath rn: listRiskyPaths){
			if(rn.getModelNode().getIdx() == modelIdx && rn.getModelNode().getNodeDetail().getIndex() == nodeIdx)
				return rn;
		}
		return null;
	}

	public List<RiskyPath> getListRiskyPaths() {
		return listRiskyPaths;
	}
	
	public void resolveRiskyPaths() throws ProofInputException{
		for(RiskyPath node: listRiskyPaths)
			node.selfCategorizeNExtractInfo(method.getServices());
	}
	
	/*
	 * given previous knowledge, return RiskyPath matching with experiment
	 * if it doest not exist, return null
	 * */
	private RiskyPath findMatchPath(Term knowledge, Experiment experiment){
		for(RiskyPath rp: listRiskyPaths){
			if(rp.isReachable()){
				if(rp.correspond2ExperimentByLowInput(knowledge, experiment))
					return rp;
			}
		}
		//in case we cannot find what path match with the experiment based on low inputs, we check by output
		//if there is one and only one path that can match with experiment by output, then return it 
		List<RiskyPath> listCandidates = new LinkedList<RiskyPath>();
		for(RiskyPath rp: listRiskyPaths){
			if(rp.isReachable()){
				if(rp.canMatchByOutputs(knowledge, experiment))
					listCandidates.add(rp);
			}
			if(listCandidates.size()>1)
				break;
		}
		if(listCandidates.size()==1)
			return listCandidates.get(0);
		else
			return null;
	}
	
	
	/*
	 * basing on lastest knowledge, find unreachable path
	 * */
	private List<RiskyPath> findUnreachablePath(Term knowledge){
		List<RiskyPath> result = new LinkedList<RiskyPath>();
		for(RiskyPath rp: listRiskyPaths){
			if(rp.isReachable()){ //only consider reachable paths
				if(!rp.checkReachable(knowledge))
					result.add(rp);
			}
		}
		return result;
	}
	
	/*public void updateMatchedPath(Term knowledge, Experiment experiment){
		RiskyPath rp = findMatchPath(knowledge, experiment);
		if(rp!=null){
			System.out.println("matched path detected: " + rp.getPathCondition());
			rp.setMatched(true);
		}
	}*/
	
	public void updateUnreachablePath(Term knowledge){
		List<RiskyPath> listRP = findUnreachablePath(knowledge);
		for(RiskyPath rp:listRP){
			System.out.println("Unreachable path detected: " + rp.getPathCondition());
			rp.setReachable(false);
		}
	}
	
	public boolean allPathsAreLowIndependent(){
		for(RiskyPath rp: listRiskyPaths)
			if(!rp.isLowIndependent())
				return false;
		return true;
	}
	
	public boolean allOutputsAreConst(){
		for(RiskyPath rp: listRiskyPaths)
			if(!rp.outputIsConstant()){				
				if(rp.outputDependsOnlyOnH()){
					if(!rp.isMatched()){
						return false;
					}
				}else{
					return false;
				}
			}
		return true;
	}
	
	public boolean hasRisk_LHPath(){
		for(RiskyPath rp: listRiskyPaths)
			if(rp.outputDependsOnBoth())
				return true;
		return false;
	}
	
	public boolean hasRisk_LPath(){
		for(RiskyPath rp:listRiskyPaths)
			if(rp.outputDependsOnlyOnL())
				return true;
		
		return false;
	}
	
	
	
	public boolean hasRisk_HPath(){
		for(RiskyPath rp:listRiskyPaths)
			if(rp.outputDependsOnlyOnH())
				return true;
		
		return false;
	}
	
	/*
	 * return a list of risky paths statisfying:
	 * output values are const or 
	 * output values depend only on L,
	 * output values depend only on H and has been matched  
	 * */
	public List<RiskyPath> getRiskConst_RiskL_MatchedRiskH(){
		List<RiskyPath> result = new LinkedList<RiskyPath>();
		for(RiskyPath rp: listRiskyPaths){
			String categoryName = rp.categoryName();
			if(categoryName.equals(KEGConstant.RISK_CONSTANT)||categoryName.equals(KEGConstant.RISK_L))
				result.add(rp);
			else if(categoryName.equals(KEGConstant.RISK_H)&& rp.isMatched())
				result.add(rp);
		}			
		return result;
	}
	
	
	public void resolvePrecondition(){
		precondition = method.getPreconditions().get(0);
		precondition = KeYResourceHandler.removeDefaultPrecondition(precondition);
		precondition = new HeapHandler(method.getServices()).refineTerm(precondition, listRiskyPaths.get(0).getModelNode().getNodeDetail().getListArrays());
	}

	public Term getPrecondition() {
		return precondition;
	}
	
	public boolean matchLowIndependentPath(){
		for(RiskyPath rp: listRiskyPaths)
			if(rp.isLowIndependent() && rp.isMatched())
				return true;
		return false;
	}
	
	public void resetPaths(){
		for(RiskyPath rp: listRiskyPaths){
			rp.reset();
		}
	}
	
	/*
	 * create new information of high variables from experiment
	 * idx: number of experiment
	 * */
	public Term createSecretInfoFromExperiment(Term knowledge, Experiment experiment, int idx){
		RiskyPath matchedPath = findMatchPath(knowledge, experiment);
		Term infoH;
		if(matchedPath!=null){
			System.out.println("matched path detected: " + matchedPath.getPathCondition());
			infoH = matchedPath.getInfoH(experiment, idx); //only get information from matched path
			//before returning, should update matched path and high-depend-only observable variables
			matchedPath.setMatched(true);
			matchedPath.getObservaleOutputs().updateMapHighDependOutputVars(experiment);
		}else{//otherwise, get aggregated information from all risky paths
			Services services = method.getServices();
			TermBuilder termBuilder = services.getTermBuilder();
			infoH = termBuilder.ff();
			for(RiskyPath rn: listRiskyPaths){					
				//pathTerm is a disjunct of infoH
				if(rn.isReachable())//only take into account reachable paths
					infoH = termBuilder.or(infoH, rn.getInfoH(experiment, idx));			
			}
			if(infoH.equals(termBuilder.ff()))
				infoH = termBuilder.tt();//know nothing about H
		}				
		return infoH;
	}
	
	/*
	 * from list of low inputs (and also is observable outputs) we create map of output Term
	 * (l1,l2,..,l_n)  ->    <l_i,l_i_out>
	 * purpose: to create fresh variables
	 * */
	public void extractMapFreshOutVar(){
		mapFreshOutputVar = new HashMap<String,Term>();
		
		RiskyPath rp = listRiskyPaths.get(0);
		List<String> listObservableVars = rp.getVc().getListLowVars();
		TermBuilder tb = method.getServices().getTermBuilder();
		
		for(String outVarName: listObservableVars){
			ModelVariable mv = rp.getModelNode().getModel().getVariable(outVarName);
			if(mv!=null){
				Term freshOutVarTerm = tb.var(new LocationVariable(new ProgramElementName(outVarName + "_out"),mv.getType()));
				mapFreshOutputVar.put(outVarName, freshOutVarTerm);
			}
		}		
	}

	public void extractListQuantifiedHighVar(){
		listQuantifiedHighVar = new LinkedList<QuantifiableVariable>();
		RiskyPath rp = listRiskyPaths.get(0);
		List<String> listHighVars = rp.getVc().getListHighVars();
	
		for(String varName: listHighVars){
			ModelVariable mv = rp.getModelNode().getModel().getVariable(varName);
			if(mv!=null){
				QuantifiableVariable qv = new LogicVariable(new Name(varName),mv.getSort());	
				listQuantifiedHighVar.add(qv);
			}
		}	
	}
	
	/*
	 * counting term to compute |O_{L_j}|
	 * it looks like: exists H: K(H) && OR_{i}(pc_i(L,H) && (f_i^O(L,H)=O)
	 * */
	public Term getOutputNumberCountingTerm(Term currentKnowledge){
		TermBuilder tb = method.getServices().getTermBuilder();
		Term result = tb.ff();
		for(RiskyPath rp: listRiskyPaths){
			if(rp.isReachable()){
				result = tb.or(result,rp.getCompareFreshOutputTerm(mapFreshOutputVar));
			}
		}
		result = tb.and(result, currentKnowledge);
		result = tb.ex(listQuantifiedHighVar, result);
		return result;
	}


	public Map<String, Term> getMapFreshOutputVar() {
		return mapFreshOutputVar;
	}
	
	/*
	 * return true if mv.identifier is identical to a high variable in niSpec
	 * */
	public boolean isHighVar(ModelVariable mv){
		return listRiskyPaths.get(0).getVc().isHigh(mv);		
	}
	
	public boolean isLowVar(ModelVariable mv){
		return !listRiskyPaths.get(0).getVc().isHigh(mv);
	}
	
	public List<ModelVariable> getListHighVars(){
		VariableClassifier vc = listRiskyPaths.get(0).getVc();
		List<ModelVariable> result= new LinkedList<ModelVariable>();
		ModelNode node = listRiskyPaths.get(0).getModelNode();
		for(ModelVariable mv: node.getModel().getVariables()){
			if(vc.isHigh(mv))
				result.add(mv);
		}
		return result;
	}
	
	public List<ModelVariable> getListLowVars(){
		VariableClassifier vc = listRiskyPaths.get(0).getVc();
		List<ModelVariable> result= new LinkedList<ModelVariable>();
		ModelNode node = listRiskyPaths.get(0).getModelNode();
		for(ModelVariable mv: node.getModel().getVariables()){
			if(vc.isLow(mv))
				result.add(mv);
		}
		return result;
	}

	
}
