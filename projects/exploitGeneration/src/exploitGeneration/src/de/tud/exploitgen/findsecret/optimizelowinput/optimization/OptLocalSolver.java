package de.tud.exploitgen.findsecret.optimizelowinput.optimization;
/*
 * this class make use of commercial tool LocalSolver for optimization task
 * */

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import localsolver.*;//using free academic version of LocalSover

public class OptLocalSolver extends OptimizationSolver {

	Map<String, LSExpression> mapVars;
	
	public OptLocalSolver(MatchableCountingSolution listMatchCountSolutions, Services services, int metric) {
		super(listMatchCountSolutions, services, metric);	
		// TODO Auto-generated constructor stub
	}

	
	private void parseTerm2FindVar(Term term, LSModel model){
		if(KeYResourceHandler.isArtificialVariable(term, services)){ //we only work with integer type 
			mapVars.put(term.toString(), model.intVar(Integer.MIN_VALUE, Integer.MAX_VALUE)); 
		}else if(term.subs().size()>0){
			for(Term t: term.subs())
				parseTerm2FindVar(t, model);
		}
	}	
	
	/*
	 * objective function: maximizing Shanon entropy is equivalent to minimizing 
	 * g_1(x)log(g_1(x)) + g_2(x)log(g_2(x)) + ... + g_n(x)log(g_n(x))
	 * */
	private LSExpression getObjectiveFunction(List<Term> listCountTerms, LSModel model){
		if(metric==KEGConstant.MIN_ENTROPY)
			return transformTerm2LSExpression(listCountTerms.get(0), model); //min entropy: only one count term
		else{
			LSExpression objective = model.sum();		
			for(Term countTerm: listCountTerms){
				/*if(TermParser.isIntegerConst(countTerm)){
					if(TermParser.getIntegerValue(countTerm)==0)
						continue;
				}*/
				
				LSExpression operand = getOperand(countTerm, model);
				objective.addOperand(operand);
			}
			return objective;
		}
	}	
	
	
	private LSExpression getOperand(Term t, LSModel model){
		LSExpression gFunc = transformTerm2LSExpression(t, model);
		if(metric==KEGConstant.SHANNON_ENTROPY){
			LSExpression logGFunc = model.log(gFunc);
			return model.prod(gFunc, logGFunc);
		}else if(metric==KEGConstant.GUESSING_ENTROPY){
			LSExpression gFuncPlus = model.sum(gFunc,model.createConstant(1));
			return model.prod(gFunc, gFuncPlus);
		}else{ //Min entropy
			return gFunc;
		}
			
			
	}
	
	private LSExpression transformTerm2LSExpression(Term term, LSModel model){		
		if(TermParser.isIntegerConst(term, services)){
			//return model.createConstant(TermParser.getIntegerValue(term));
			return model.createConstant(TermParser.getBigIntegerValue(term, services).doubleValue());
		}
		else if(KeYResourceHandler.isArtificialVariable(term, services)){ //we only work with integer type 
			return mapVars.get(term.toString());
		}
		/* ********************************************************
		 * arithmetic expression
		 * ********************************************************/
		else if(TermParser.isAddition(term)){
			LSExpression sum = model.sum();
			sum.addOperand(transformTerm2LSExpression(term.sub(0), model));
			sum.addOperand(transformTerm2LSExpression(term.sub(1), model));
			return sum;
		}
		else if(TermParser.isSubtraction(term)){
			return model.sub(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isMultiplication(term)){
			LSExpression prod = model.prod();
			prod.addOperand(transformTerm2LSExpression(term.sub(0), model));
			prod.addOperand(transformTerm2LSExpression(term.sub(1), model));
			return prod;
		}
		else if(TermParser.isDivision(term)){
			return model.div(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isPowerFunction(term, services)){
			return model.pow(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		/* ********************************************************
		 * logic expression
		 * ********************************************************/
		else if(TermParser.isAnd(term)){
			return model.and(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isOr(term)){
			return model.or(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isNot(term)){
			return model.not(transformTerm2LSExpression(term.sub(0), model));
		}
		else if(TermParser.isGreaterOrEquals(term, services)){
			return model.geq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isGreaterThan(term, services)){
			return model.gt(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isLessOrEquals(term, services)){
			return model.leq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isLessThan(term, services)){
			return model.lt(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isEquals(term)){
			return model.eq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}		
		
		else
			return null;
		
	}

	@Override
	public OptimalSolution findOptimalSolution() {
		LocalSolver localSolver = new LocalSolver();
		
		LSModel model = localSolver.getModel();
		mapVars = new HashMap<String, LSExpression>();
		for(Term countTerm: countSolution.getListCountTerms())
			parseTerm2FindVar(countTerm, model);
		parseTerm2FindVar(countSolution.getConditionTerm(), model);
		
		System.out.println("map variable of LocalSolver: " + mapVars);
		LSExpression objective = getObjectiveFunction(countSolution.getListCountTerms(), model);
		//System.out.println("objective function: " + objective.toString());
		
		LSExpression constraint = transformTerm2LSExpression(countSolution.getConditionTerm(), model);				
		model.addConstraint(constraint);
		/*System.out.println("objective function: " + objective.getInfo());
		System.out.println("constraint: " + constraint.getInfo());*/
		//model.addObjective(objective, LSObjectiveDirection.Minimize);
		model.minimize(objective);
		model.close();
		LSPhase phase = localSolver.createPhase();
        phase.setTimeLimit(1);       //TODO: time limit should be a parameter      
		localSolver.solve();			
		//LSSolution solution = localSolver.getSolution();				
		//System.out.println("solution found by LocalSover: \n");
		Map<String, Long> mapSolution = new HashMap<String, Long>();
		for(String var: mapVars.keySet()){
			//System.out.println(var + ": " + mapVars.get(var).getIntValue());
			try{
				mapSolution.put(var, mapVars.get(var).getIntValue());
			}catch(Exception e){
				return null;
			}
		}
		try{
			double doubleValue = objective.getDoubleValue();
			System.out.println("optimize value calculated by localsolver: " + doubleValue);
			double optimizeValue = computeOptimizeValue(mapSolution);
			System.out.println("optimize value calculated via optimal low input found by localsolver: " + optimizeValue);
			OptimalSolution solution = new OptimalSolution(mapSolution, optimizeValue);
			return solution;
		}catch(Exception e){
			return null;
		}
	}
	
	
}

