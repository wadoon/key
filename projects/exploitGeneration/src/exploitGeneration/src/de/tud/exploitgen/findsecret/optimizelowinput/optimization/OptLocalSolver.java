package de.tud.exploitgen.findsecret.optimizelowinput.optimization;
/*
 * this class make use of commercial tool LocalSolver for optimization task
 * */

import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4NU;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import localsolver.*;//using free academic version of LocalSover


public class OptLocalSolver extends OptimizationSolver {

	Map<String, LSExpression> mapVars;
	
	public OptLocalSolver(MatchableCountingSolution listMatchCountSolutions, Services services, int metric) {
		super(listMatchCountSolutions, services, metric);	
		// TODO Auto-generated constructor stub
	}

	
	
	public OptLocalSolver(MatchableCountingSolution countSolution,
			Services services, int metric, SecretDistribution sDistribution) {
		super(countSolution, services, metric, sDistribution);
		// TODO Auto-generated constructor stub
	}



	private void parseTerm2FindVar(Term term, LSModel model){
		if(KeYResourceHandler.isArtificialVariable(term, services)){ //we only work with integer type 
			mapVars.put(term.toString(), model.intVar(Integer.MIN_VALUE, Integer.MAX_VALUE)); 
		}else if(term.subs().size()>0){
			for(Term t: term.subs())
				parseTerm2FindVar(t, model);
		}
	}	
	
	
	private LSExpression getObjectiveFunction(List<CountingSolution> listCountingSolutions, LSModel model){
		if((sDistribution==null)||(sDistribution.isUniform())){
			/*
			 * for the case of uniform distribution:
			 * objective function: maximizing Shanon entropy is equivalent to minimizing 
			 * g_1(x)log(g_1(x)) + g_2(x)log(g_2(x)) + ... + g_n(x)log(g_n(x))
			 * 
			 * 
			 * */
			if(metric==KEGConstant.MIN_ENTROPY)
				return transformTerm2LSExpression(listCountingSolutions.get(0).getValue(), model); //min entropy: only one count term
			else{
				LSExpression objective = model.sum();		
				for(CountingSolution cs: listCountingSolutions){
					/*if(TermParser.isIntegerConst(countTerm)){
						if(TermParser.getIntegerValue(countTerm)==0)
							continue;
					}*/
					
					LSExpression operand = getOperand(cs.getValue(), model);
					objective.addOperand(operand);
				}
				return objective;
			}
		}else{
			/*
			 * for the case of non-uniform distribution, the metric cannot be min entropy
			 * 
			 * */			
			if(metric == KEGConstant.SHANNON_ENTROPY){
				//resolve for the case of Shannon entropy
				Map<String, LSExpression> mapOutvalueOperands = new HashMap<String, LSExpression>();
				for(CountingSolution cs: listCountingSolutions){
					if(mapOutvalueOperands.containsKey(cs.getOutputValue())){
						LSExpression operand = mapOutvalueOperands.get(cs.getOutputValue());
						LSExpression gFunc = transformTerm2LSExpression(cs.getValue(), model);
						long frequency= sDistribution.getPartitions().get(cs.getPartitionIdx()).getFrequency();
						operand = model.sum(operand, model.prod(gFunc, frequency));
						mapOutvalueOperands.put(cs.getOutputValue(), operand);
					}else{
						LSExpression gFunc = transformTerm2LSExpression(cs.getValue(), model);
						long frequency= sDistribution.getPartitions().get(cs.getPartitionIdx()).getFrequency();
						LSExpression operand = model.prod(gFunc, frequency);
						mapOutvalueOperands.put(cs.getOutputValue(), operand);
					}
				}
				LSExpression objective = model.sum();
				for(String outValue: mapOutvalueOperands.keySet()){
					
					LSExpression operand = mapOutvalueOperands.get(outValue);
					LSExpression add2Sum = model.prod(operand, model.log(operand));
					objective.addOperand(add2Sum);
				}
				return objective;
			}else{
				//resolve for the case of Guessing entropy
				//each out value coresponds to a list of CountingSolution sorted by frequency
				Map<String, List<CountingSolution>> mapByOutValue = 
						GELMaximizerUsingCounting4NU.transformListMatchableCountingSolution2Map(countSolution.getListCountingSolutions());
				
				//create the map of expression
				Map<String, List<LSExpression>> mapExpression = new HashMap<String, List<LSExpression>>();
				for(String outValue: mapByOutValue.keySet()){
					List<CountingSolution> listCS = mapByOutValue.get(outValue);
					List<LSExpression> listExpr = new LinkedList<LSExpression>();
					for(int i=0;i<listCS.size();i++)
						listExpr.add(transformTerm2LSExpression(listCS.get(i).getValue(), model));
					mapExpression.put(outValue, listExpr);
				}
				
				//compose objective
				LSExpression objective = model.sum();
				for(String outValue: mapExpression.keySet()){
					List<LSExpression> listExpr = mapExpression.get(outValue);
					List<CountingSolution> listCS= mapByOutValue.get(outValue);
					
					for(int i=0; i<listExpr.size();i++){
						LSExpression sumOperand = model.sum();
						for(int j=0;j<i;j++){
							sumOperand.addOperand(listExpr.get(j));
						}
						sumOperand.addOperand(model.div(model.sum(listExpr.get(i), 1), 2));
						sumOperand = model.prod(sumOperand, listExpr.get(i));
						sumOperand = model.prod(sumOperand, 
								sDistribution.getPartitions().get(
										listCS.get(i).getPartitionIdx()
										).getFrequency());
						objective.addOperand(sumOperand);
					}
				}
				return objective;
				
			}			
		}
		
	}	
	
	
	private LSExpression getOperand(Term t, LSModel model){
		LSExpression gFunc = transformTerm2LSExpression(t, model);
		if(metric==KEGConstant.SHANNON_ENTROPY){
			LSExpression logGFunc = model.log(gFunc);
			return model.prod(gFunc, logGFunc);
		}else if(metric==KEGConstant.GUESSING_ENTROPY){
			LSExpression gFuncPlus = model.sum(gFunc,model.createConstant(1));
			return model.prod(gFunc, gFuncPlus);
		}else{ //Min entropy
			return gFunc;
		}
			
			
	}
	
	private LSExpression transformTerm2LSExpression(Term term, LSModel model){		
		if(TermParser.isIntegerConst(term, services)){
			//return model.createConstant(TermParser.getIntegerValue(term));
			return model.createConstant(TermParser.getBigIntegerValue(term, services).doubleValue());
		}
		else if(KeYResourceHandler.isArtificialVariable(term, services)){ //we only work with integer type 
			return mapVars.get(term.toString());
		}
		/* ********************************************************
		 * arithmetic expression
		 * ********************************************************/
		else if(TermParser.isAddition(term)){
			LSExpression sum = model.sum();
			sum.addOperand(transformTerm2LSExpression(term.sub(0), model));
			sum.addOperand(transformTerm2LSExpression(term.sub(1), model));
			return sum;
		}
		else if(TermParser.isSubtraction(term)){
			return model.sub(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isMultiplication(term)){
			LSExpression prod = model.prod();
			prod.addOperand(transformTerm2LSExpression(term.sub(0), model));
			prod.addOperand(transformTerm2LSExpression(term.sub(1), model));
			return prod;
		}
		else if(TermParser.isDivision(term)){
			return model.div(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isPowerFunction(term, services)){
			return model.pow(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		/* ********************************************************
		 * logic expression
		 * ********************************************************/
		else if(TermParser.isAnd(term)){
			return model.and(transformTerm2LSExpression(term.sub(0), model), 
							transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isOr(term)){
			return model.or(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isNot(term)){
			return model.not(transformTerm2LSExpression(term.sub(0), model));
		}
		else if(TermParser.isGreaterOrEquals(term, services)){
			return model.geq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isGreaterThan(term, services)){
			return model.gt(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isLessOrEquals(term, services)){
			return model.leq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isLessThan(term, services)){
			return model.lt(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}
		else if(TermParser.isEquals(term)){
			return model.eq(transformTerm2LSExpression(term.sub(0), model), 
					transformTerm2LSExpression(term.sub(1), model));
		}		
		
		else
			return null;
		
	}

	@Override
	public OptimalSolution findOptimalSolution() {
		LocalSolver localSolver = new LocalSolver();
		
		LSModel model = localSolver.getModel();
		mapVars = new HashMap<String, LSExpression>();
		for(CountingSolution cs: countSolution.getListCountingSolutions())
			parseTerm2FindVar(cs.getValue(), model);
		parseTerm2FindVar(countSolution.getConditionTerm(), model);
		
		System.out.println("map variable of LocalSolver: " + mapVars);
		LSExpression objective = getObjectiveFunction(countSolution.getListCountingSolutions(), model);
		//System.out.println("objective function: " + objective.toString());
		
		LSExpression constraint = transformTerm2LSExpression(countSolution.getConditionTerm(), model);				
		model.addConstraint(constraint);
		/*System.out.println("objective function: " + objective.getInfo());
		System.out.println("constraint: " + constraint.getInfo());*/
		//model.addObjective(objective, LSObjectiveDirection.Minimize);
		model.minimize(objective);
		model.close();
		LSPhase phase = localSolver.createPhase();
        phase.setTimeLimit(10);       //TODO: time limit should be a parameter      
		localSolver.solve();			
		//LSSolution solution = localSolver.getSolution();				
		//System.out.println("solution found by LocalSover: \n");
		Map<String, Long> mapSolution = new HashMap<String, Long>();
		for(String var: mapVars.keySet()){
			//System.out.println(var + ": " + mapVars.get(var).getIntValue());
			try{
				mapSolution.put(var, mapVars.get(var).getIntValue());
			}catch(Exception e){
				return null;
			}
		}
		try{
			double doubleValue = objective.getDoubleValue();
			System.out.println("optimize value calculated by localsolver: " + doubleValue);
			/*double optimizeValue = computeOptimizeValue(mapSolution);
			System.out.println("optimize value calculated via optimal low input found by localsolver: " + optimizeValue);*/
			OptimalSolution solution = new OptimalSolution(mapSolution, doubleValue);
			return solution;
		}catch(Exception e){
			return null;
		}
	}
	
	
}

