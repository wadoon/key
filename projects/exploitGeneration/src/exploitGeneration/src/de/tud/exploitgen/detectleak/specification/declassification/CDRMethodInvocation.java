package de.tud.exploitgen.detectleak.specification.declassification;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.util.KEGConfig;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.IProgramMethod;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.speclang.FunctionalOperationContract;

public class CDRMethodInvocation extends CDRExpression{
   private KeYJavaMethod method; //method invoked
   //private List<DeclExpression> parameters; //real parameters passed for this method invocation  
   private Map<String,CDRExpression> mapFormalParams; //map formal parameter(string) with is real-time value (DeclExpression)
   
   public CDRMethodInvocation(Term term, Services services, String id) {
      super(term, services,id);
      this.method = extractMethod(term, services);      
      buildMapFormalParameters();
      //this.parameters = getParameters(term, services);
   }
   
   /*get EmbeddedMethod object from term t representing a method invocation*/
   private KeYJavaMethod extractMethod(Term t, Services services){
      if(TermParser.isProgramMethod(t)){         
         IProgramMethod method = (IProgramMethod)t.op();              
         final KeYJavaType containerClass = method.getContainerType();
         final List<FunctionalOperationContract> contracts = new LinkedList<FunctionalOperationContract>();
         for (final FunctionalOperationContract contract : services.getSpecificationRepository().getOperationContracts(containerClass,
                                                                                                         method)) {
             contracts.add(contract);
                        
         }        
         KeYJavaMethod em = new KeYJavaMethod(null, method, services, contracts);
         return em;
      }else
         return null;
   }
   
   
  /* private List<DeclExpression> getParameters(Term t, Services services){
      if(TermParser.isProgramMethod(t)){
         ImmutableArray<Term> subs = t.subs();        
         List<DeclExpression> params = new LinkedList<DeclExpression>();          
         //omit the first element of subs because it is heap term
         for(int i=1;i<subs.size();i++){
            Term subi= subs.get(i);
            if(TermParser.isProgramMethod(subi)){
               params.add(new MethodInvoke(subi,services));
            }else
               params.add(new DeclExpression(subi,services));
         }           
                    
         return params;
      }else
         return null;
   }*/
   
   /*
    * bind each formal parameter with corresponding real value (DeclExprssion) stored in subExpressions
    * NOTE: 
    *    KeY add heap (and might be self (method in the same class with current class)) as a default real passed value, so we have to ignore them 
    * */
   private void buildMapFormalParameters(){
      mapFormalParams = new HashMap<String, CDRExpression>();
      List<IProgramVariable> formalParams = method.getParameters();
      List<CDRExpression> realParams = getSubExpressions();
      if(realParams.get(0).getTerm().toString().equals("heap") && realParams.get(1).getTerm().toString().equals("self")){
         for(int i=0;i<formalParams.size();i++){
            mapFormalParams.put(formalParams.get(i).toString(), getSubExpressions().get(i+2));
         }
      }else{
         for(int i=0;i<formalParams.size();i++){
            mapFormalParams.put(formalParams.get(i).toString(), getSubExpressions().get(i+1));
         }
      }
   }
   
   /*
    * get result term representing for this method invocation
    * name of result term: result_CDR_methodName_id
    * where CDR stands for Conditional Delimited Release
    * because the id is unique, there are no two method invocation have the same result name
    * */
   public Term makeResultTerm(){
      LocationVariable lv=new LocationVariable(new ProgramElementName("result_CDR"+KEGConfig.SEPARATOR+ method.getName() + KEGConfig.SEPARATOR+getId()),
            method.getReturnType());
      return termBuilder.var(lv);
   }
   
   /*
    * the approach dealing with method invocation to get a integratable term is as below:
    * - replace method invocation by corresponding result (result+id)
    * - add method contractx to the term by conjunction (precondition and post condition)
    * */
   public Term getResolvedTerm(){
      return makeResultTerm();
   }
   
   /*
    * the parameter of method might be also method invocation, therefore we must intgerated its method contract
    * */
   public Term getSynthesisMethodContract(){
      Term contracts = termBuilder.tt();
      Term pre = getPrecondition();
      //System.out.println("pre of " + method.getName() +"::: " + pre);
      contracts = termBuilder.and(contracts, pre);      
    
      Term post = getPostcondition();            
      //System.out.println("post of " + method.getName() +"::: " + post);
      contracts = termBuilder.and(contracts, post);
            
      contracts = resolveContract(contracts);
      //System.out.println("method contract of " + method.getName() +":::" + contracts);
      //get method contract of parameters
      for(CDRExpression param: mapFormalParams.values()){
         contracts = termBuilder.and(contracts, param.getSynthesisMethodContract());
      }
      return contracts;      
   }
   
   /*resolve precondition and post condition:
    *replace formal parameter appeared in precondition and post condition by its corresponding real value
    *replace \result term by corresponding result term (makeResultTerm())
    */ 
   private Term resolveContract(Term t){
      if(t!=null){
       //t is a formal parameter
         if(mapFormalParams.containsKey(t.toString())){ 
            CDRExpression passedValue = mapFormalParams.get(t.toString());
            return passedValue.getResolvedTerm();
         }
         //t is \result value
         else if(TermParser.isResult(t)||t.toString().equals("result")){
            return makeResultTerm();
         }
         else if(t.subs().size()==0 || t.subs()==null){
            return t;
         }else{
            Term[] sts = new Term[t.subs().size()];
            for(int i=0;i<t.subs().size();i++)
               sts[i] = resolveContract(t.sub(i));
            return termBuilder.tf().createTerm(t.op(), sts, t.boundVars(), t.javaBlock());
         } 
      }else
         return null;
   }
   
   /*get postcondition of method after removing unspecified conditions added by KeY*/
   private Term getPostcondition(){      
      List<Term> postconds = method.getPostconditions();   
      Term postcondition = termBuilder.tt();
      for(Term post: postconds){         
         postcondition = termBuilder.and(post, postcondition);
      }     
      /*
       * postcondition usually has this form: and(imp(equal(exc,null),SPECIFIED POSTCONDITION),imp(...)) 
       * */
      return(postcondition.sub(0).sub(1));
   }
   
   /*get precondition of method after removing unspecified conditions added by KeY*/
   private Term getPrecondition(){      
      List<Term> preconds = method.getPreconditions();   
      Term precondition = termBuilder.tt();
      for(Term post: preconds){         
         precondition = termBuilder.and(post, precondition);
      }     
      /*
       * precondition sometimes is added by term not(equals(...,null)), find and replace it by true 
       * */
      return KeYResourceHandler.removeDefaultPrecondition(precondition);
   }
   
   
}
