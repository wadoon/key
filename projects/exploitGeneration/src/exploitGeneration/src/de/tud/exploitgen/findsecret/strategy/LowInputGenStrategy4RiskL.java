package de.tud.exploitgen.findsecret.strategy;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.HybridDomain;
import de.tud.exploitgen.findsecret.ObservableOutput;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GuessLeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.MinLeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShannonLeakageMaximizer;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;

public class LowInputGenStrategy4RiskL extends LowInputGenStrategy{
	private HybridDomain hybridOutDomain; //hybrid domain of observable output values
	
	public LowInputGenStrategy4RiskL(SISupporter siSupporter) {
		super(siSupporter);
		// TODO Auto-generated constructor stub
	}

	@Override
	public Map<String, Long> findBestLowInput() throws IOException {
		BadMethod badMethod = siSupporter.getBadMethod();
		Term currentKnowledge = siSupporter.getCurrentKnowledge();
		List<ParametricPolytope> listPP = new LinkedList<ParametricPolytope>();
		TermBuilder termBuilder = badMethod.getMethod().getServices().getTermBuilder();
		
		VariableClassifier vc = badMethod.getRiskyPath(0, 0).getVc();
		List<String> listParameters = new LinkedList<String>();
		listParameters.addAll(vc.getListLowVars());
		
		List<String> listVariables = vc.getListHighVars();

		
		
		constructHybridDomain(); //re-construct hybrid domain to eliminate values from unreachable path
		hybridOutDomain.printInformation();
		listParameters.addAll(hybridOutDomain.getListSymbols());
		for(Map<String,Term> mapValues: hybridOutDomain.getListMapValues()){
			Term constraint = termBuilder.ff();
			for(RiskyPath rp: badMethod.getListRiskyPaths()){
				if(rp.isReachable()){
					Term pathMatchTerm = rp.getCondition4MatchHybridOutput(mapValues);
					if(!TermParser.isBooleanFalse(pathMatchTerm))
						constraint = termBuilder.or(constraint, pathMatchTerm);
				}
			}
			constraint = termBuilder.and(constraint, hybridOutDomain.getDomainCondition()); 
			constraint = termBuilder.and(constraint, currentKnowledge);
			listPP.add(new ParametricPolytope(constraint, listParameters, listVariables));
		}		
		
		List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
		for(ParametricPolytope pp: listPP){			
			listCountingResults.add(barvinokCount(pp));				
		}		
		//find "best" low input
		LeakageMaximizer inputProducer;
		int metric = siSupporter.getMetric();
		if(metric==KEGConstant.SHANNON_ENTROPY)
			inputProducer = new ShannonLeakageMaximizer(listCountingResults, 
				badMethod.getMethod().getServices(), 
				badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(),siSupporter.findNumberOfPossibleHighValue(currentKnowledge));
		else if(metric== KEGConstant.MIN_ENTROPY)
			inputProducer = new MinLeakageMaximizer(listCountingResults, badMethod.getMethod().getServices(), 
					badMethod.getListRiskyPaths().get(0).getVc().getListLowVars());
		else
			inputProducer = new GuessLeakageMaximizer(listCountingResults, 
					badMethod.getMethod().getServices(), 
					badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(),siSupporter.findNumberOfPossibleHighValue(currentKnowledge));
		return inputProducer.findLowInputMaximizingLeakge().first;
	}
	
	
	private void constructHybridDomain(){	
		BadMethod badMethod = siSupporter.getBadMethod();
		hybridOutDomain = new HybridDomain();
		for(RiskyPath rp: badMethod.getListRiskyPaths()){
			if(rp.isReachable()){
				//System.out.println("path condition of resolving path: " + rp.getPathCondition());
				ObservableOutput outputs = rp.getObservaleOutputs();
				//outputs.constructElement4HybridDomain();
				System.out.println("list map values: " + outputs.getListMapHybridValues());
				hybridOutDomain.addMapValues(outputs.getListMapHybridValues());
				hybridOutDomain.addSymbol(outputs.getListSymbols());
			}
		}
		hybridOutDomain.builDomainCondition(badMethod.getMethod().getServices());
	}	
}
