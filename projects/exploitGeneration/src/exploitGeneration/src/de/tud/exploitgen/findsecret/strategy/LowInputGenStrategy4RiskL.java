package de.tud.exploitgen.findsecret.strategy;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.PairTerm;
import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.HybridDomain;
import de.tud.exploitgen.findsecret.ObservableOutput;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.distribution.Partition;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTProblem;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingMaxSMT;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.MELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShELMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.KEGTermException;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermSimplifier;
import de.tud.exploitgen.util.TermTransformer;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.io.ProofSaver;
import de.uka.ilkd.key.util.Pair;

public class LowInputGenStrategy4RiskL extends LowInputGenStrategy4LimitedOutValue{
	private HybridDomain hybridOutDomain; //hybrid domain of observable output values
	
	public LowInputGenStrategy4RiskL(SISupporter siSupporter) {
		super(siSupporter);
		// TODO Auto-generated constructor stub
	}

	
	private void constructHybridDomain(){	
		BadMethod badMethod = siSupporter.getBadMethod();
		hybridOutDomain = new HybridDomain();
		for(RiskyPath rp: badMethod.getListRiskyPaths()){
			if(rp.isReachable()){
				//System.out.println("path condition of resolving path: " + rp.getPathCondition());
				ObservableOutput outputs = rp.getObservaleOutputs();
				//outputs.constructElement4HybridDomain();
				System.out.println("list map values: " + outputs.getListMapHybridValues());
				hybridOutDomain.addMapValues(outputs.getListMapHybridValues());
				hybridOutDomain.addSymbol(outputs.getListSymbols());
				hybridOutDomain.addListPairFreshVarValue(outputs.getListPairFreshVarValue());
			}
		}
		hybridOutDomain.builDomainCondition(badMethod.getMethod().getServices());
	}	
	
	@Override
	 protected List<PPCountingResult> getListCountingResultForShannonAndGuessingEntropy() throws IOException, KEGTermException{
		 SecretDistribution sDistrubution = siSupporter.getsDistribution();
		 if((sDistrubution==null)||(sDistrubution.isUniform())){
			 BadMethod badMethod = siSupporter.getBadMethod();
				Term currentKnowledge = siSupporter.getCurrentKnowledge();
				List<ParametricPolytope> listPP = new LinkedList<ParametricPolytope>();
				
				
				VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
				List<String> listParameters = new LinkedList<String>();
				listParameters.addAll(vc.getListLowVars());
				Services services = badMethod.getMethod().getServices();
				TermBuilder termBuilder = services.getTermBuilder();
				
				constructHybridDomain(); //re-construct hybrid domain to eliminate values from unreachable path
				hybridOutDomain.printInformation();
				TermTransformer termTransform = new TermTransformer(services);
				
				Term baseConstraint = termBuilder.and(currentKnowledge, avoidUsedInput());
				baseConstraint = termBuilder.and(baseConstraint, hybridOutDomain.getDomainCondition());
				for(RiskyPath rn: badMethod.getListRiskyPaths()){
					if(rn.isReachable()){
						/*
						 * parameters: list of low variables.
						 * vars: list of high variables
						 * */			
						Term constraint = termBuilder.and(baseConstraint, /*rn.getModelNode().getConstraint()*/rn.getPathCondition());
						
						constraint = termTransform.transformBWXORTerm(constraint, 4);
						constraint = TermSimplifier.simplifyITE(constraint, termBuilder);
						constraint = TermSimplifier.simplifyConstant(constraint, services);
						constraint = termTransform.transformITE(constraint);
						//constraint = TermUtil.simplifyTerm(constraint, badMethod.getMethod().getServices());
						listPP.add(new ParametricPolytope(constraint, rn.getVc().getListLowVars(), rn.getVc().getListHighVars()));	
					}
				}
				
				
				List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
				for(ParametricPolytope pp: listPP){			
					listCountingResults.add(barvinokCount(pp));				
				}		
				return listCountingResults;
		 }else{
			 
			 List<Partition> listPartitions = sDistrubution.getPartitions();
				
				BadMethod badMethod = siSupporter.getBadMethod();
				Term currentKnowledge = siSupporter.getCurrentKnowledge();
				Services services = badMethod.getMethod().getServices();
				TermBuilder termBuilder = services.getTermBuilder();
				List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
				
				
				VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
				List<String> listParameters = new LinkedList<String>();
				listParameters.addAll(vc.getListLowVars());
								
				constructHybridDomain(); //re-construct hybrid domain to eliminate values from unreachable path
				hybridOutDomain.printInformation();
				listParameters.addAll(hybridOutDomain.getListSymbols());
				
				TermTransformer termTransform = new TermTransformer(services);
				
				Term baseConstraint = termBuilder.and(currentKnowledge, avoidUsedInput());
				baseConstraint = termBuilder.and(baseConstraint, hybridOutDomain.getDomainCondition());
				
				for(int rpIdx = 0; rpIdx < badMethod.getListRiskyPaths().size(); rpIdx++){
					RiskyPath rn = badMethod.getListRiskyPaths().get(rpIdx);				
					if(rn.isReachable()){
						for(int i=0; i<listPartitions.size();i++){
							Partition partition = listPartitions.get(i);
							/*
							 * parameters: list of low variables.
							 * vars: list of high variables
							 * */			
							Term constraint = termBuilder.and(baseConstraint, /*rn.getModelNode().getConstraint()*/rn.getPathCondition());
							constraint = termBuilder.and(constraint, partition.getFormula());
							constraint = termTransform.transformBWXORTerm(constraint, 4);
							constraint = TermSimplifier.simplifyITE(constraint, termBuilder);
							constraint = TermSimplifier.simplifyConstant(constraint, services);
							constraint = termTransform.transformITE(constraint);
							
							ParametricPolytope pp = new ParametricPolytope(constraint, rn.getVc().getListLowVars(), rn.getVc().getListHighVars());
							PPCountingResult ppCountResult = barvinokCount(pp);
							ppCountResult.setOutputValue(String.valueOf(rpIdx));
							ppCountResult.setPartitionIdx(i);
							listCountingResults.add(ppCountResult);
						}				
					}
				}	
				
				return listCountingResults;
	

		 }
	 }
	
	@Override
	protected Map<String, Long> findLowInputMaximizingMinEntropyLeakage4NU() {
		constructHybridDomain();
		//here we implement Max-SMT approach to find low input maximizing min-entropy leakage
		Map<String, Pair<Term,Long>> mapSMTClause2Weight = new HashMap<String, Pair<Term,Long>>();
		List<Term> listConstraints = new LinkedList<Term>();
		BadMethod badMethod = siSupporter.getBadMethod();
		Term currentKnowledge = siSupporter.getCurrentKnowledge();
		List<ModelVariable> listQuanHighVars = badMethod.getListHighVars();
		Services services= siSupporter.getBadMethod().getMethod().getServices();
		TermBuilder termBuilder = services.getTermBuilder();
		SecretDistribution sDistrubution = siSupporter.getsDistribution();
		List<Partition> listPartitions = sDistrubution.getPartitions();
		
		int valueIdx = 0;
		for(Map<String,Term> mapValues: hybridOutDomain.getListMapValues()){
			
			
			PairTermCollection ptcHighVar= new PairTermCollection(services);
			for(ModelVariable highVar: listQuanHighVars){
				ptcHighVar.add(highVar.getIdentifier(), createPairTermFromMV(highVar, valueIdx));
			}
			Term constraint = ptcHighVar.replacePVByNameAndBranch(currentKnowledge, 1);
			listConstraints.add(constraint);
			for(int i=0; i<listPartitions.size();i++){
				Partition partition = listPartitions.get(i);
				Term maxSMTClause = termBuilder.ff();
				for(RiskyPath rp: badMethod.getListRiskyPaths()){
					if(rp.isReachable()){
						Term pathMatchTerm = rp.getCondition4MatchHybridOutput(mapValues);
						if(!TermParser.isBooleanFalse(pathMatchTerm))
							maxSMTClause = termBuilder.or(maxSMTClause, pathMatchTerm);
					}
				}
				maxSMTClause = termBuilder.and(maxSMTClause, hybridOutDomain.getDomainCondition()); 
				maxSMTClause = termBuilder.and(maxSMTClause, partition.getFormula());						
				maxSMTClause = ptcHighVar.replacePVByNameAndBranch(maxSMTClause, 1);
				maxSMTClause =  new TermTransformer(siSupporter.getBadMethod().getMethod().getServices()).transformBWXORTerm(maxSMTClause, 4);
				String id = "C"+String.valueOf(i)+String.valueOf(valueIdx);
				mapSMTClause2Weight.put(id, new Pair<Term,Long>(maxSMTClause, partition.getFrequency()));
			}
			valueIdx++;					
		}		
		
		MaxSMTProblem postEntropyProblem = new MaxSMTProblem(mapSMTClause2Weight, listConstraints);
		
		Map<String, Pair<Term,Long>> mapPreSMTClause2Weight = new HashMap<String, Pair<Term,Long>>();
		List<Term> listPreConstraints = new LinkedList<Term>();
		listPreConstraints.add(currentKnowledge);
		for(int i=0; i<listPartitions.size();i++){
			Partition partition = listPartitions.get(i);									
			Term maxSMTClause = partition.getFormula();
			String id = "C"+String.valueOf(i);
			mapPreSMTClause2Weight.put(id, new Pair<Term,Long>(maxSMTClause, partition.getFrequency()));
		}				
			
		List<String> listLowVars = new LinkedList<String>();
		for(ModelVariable mv: badMethod.getListLowVars()){
			listLowVars.add(mv.getIdentifier());
		}
		MaxSMTProblem preEntropyProblem= new MaxSMTProblem(mapPreSMTClause2Weight, listPreConstraints);
		LeakageMaximizerUsingMaxSMT inputProducer = new LeakageMaximizerUsingMaxSMT(preEntropyProblem, postEntropyProblem, listLowVars, services);
		Pair<Map<String,Long>,Double> optimizedResult = inputProducer.findLowInputMaximizingLeakge();
		System.out.println("Min-entropy-based leakage: " + optimizedResult.second);
		return optimizedResult.first;	
	}
}
