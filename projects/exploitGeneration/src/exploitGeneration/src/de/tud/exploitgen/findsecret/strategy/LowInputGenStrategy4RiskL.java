package de.tud.exploitgen.findsecret.strategy;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.detectleak.specification.noninterference.VariableClassifier;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.HybridDomain;
import de.tud.exploitgen.findsecret.ObservableOutput;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GuessLeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.MinLeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShannonLeakageMaximizer;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

public class LowInputGenStrategy4RiskL extends LowInputGenStrategy{
	private HybridDomain hybridOutDomain; //hybrid domain of observable output values
	
	public LowInputGenStrategy4RiskL(SISupporter siSupporter) {
		super(siSupporter);
		// TODO Auto-generated constructor stub
	}

	@Override
	public Map<String, Long> findBestLowInput() throws IOException {
		int metric = siSupporter.getMetric();
		if(metric==KEGConstant.MIN_ENTROPY)
			return findLowInputMaximizingNumberOfOutputValue();
		else{
			BadMethod badMethod = siSupporter.getBadMethod();
			Term currentKnowledge = siSupporter.getCurrentKnowledge();
			List<ParametricPolytope> listPP = new LinkedList<ParametricPolytope>();
			TermBuilder termBuilder = badMethod.getMethod().getServices().getTermBuilder();
			
			VariableClassifier vc = badMethod.getListRiskyPaths().get(0).getVc();
			List<String> listParameters = new LinkedList<String>();
			listParameters.addAll(vc.getListLowVars());
			
			List<String> listVariables = vc.getListHighVars();
	
			
			
			constructHybridDomain(); //re-construct hybrid domain to eliminate values from unreachable path
			hybridOutDomain.printInformation();
			listParameters.addAll(hybridOutDomain.getListSymbols());
			for(Map<String,Term> mapValues: hybridOutDomain.getListMapValues()){
				Term constraint = termBuilder.ff();
				for(RiskyPath rp: badMethod.getListRiskyPaths()){
					if(rp.isReachable()){
						Term pathMatchTerm = rp.getCondition4MatchHybridOutput(mapValues);
						if(!TermParser.isBooleanFalse(pathMatchTerm))
							constraint = termBuilder.or(constraint, pathMatchTerm);
					}
				}
				constraint = termBuilder.and(constraint, hybridOutDomain.getDomainCondition()); 
				constraint = termBuilder.and(constraint, currentKnowledge);
				listPP.add(new ParametricPolytope(constraint, listParameters, listVariables));
			}		
			
			List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
			for(ParametricPolytope pp: listPP){			
				listCountingResults.add(barvinokCount(pp));				
			}		
			//find "best" low input
			LeakageMaximizer inputProducer;		
			if(metric==KEGConstant.SHANNON_ENTROPY)
				inputProducer = new ShannonLeakageMaximizer(listCountingResults, 
					badMethod.getMethod().getServices(), 
					badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(),siSupporter.findNumberOfPossibleHighValue(currentKnowledge),siSupporter.getOptSolver());		
			else
				inputProducer = new GuessLeakageMaximizer(listCountingResults, 
						badMethod.getMethod().getServices(), 
						badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(),siSupporter.findNumberOfPossibleHighValue(currentKnowledge),siSupporter.getOptSolver());
			Pair<Map<String,Long>,Double> optimizedResult = inputProducer.findLowInputMaximizingLeakge();
			if(optimizedResult!=null){
				if(metric==KEGConstant.SHANNON_ENTROPY){
					System.out.println("Shannon-entropy-based leakage: " + optimizedResult.second);
				}else{
					System.out.println("Guessing-entropy-based leakage: " + optimizedResult.second);
				}
			}else{
				System.out.println("Cannot find optimal low input, instead we have to avoid bad low input!");
			}
			if((optimizedResult.second>KEGConstant.MINIMUM_LEAK) &&(optimizedResult.first.size()>0))
				return optimizedResult.first;
			else{
				return findUsefulLowInput();
			}
				
		}
	}
	
	
	private void constructHybridDomain(){	
		BadMethod badMethod = siSupporter.getBadMethod();
		hybridOutDomain = new HybridDomain();
		for(RiskyPath rp: badMethod.getListRiskyPaths()){
			if(rp.isReachable()){
				//System.out.println("path condition of resolving path: " + rp.getPathCondition());
				ObservableOutput outputs = rp.getObservaleOutputs();
				//outputs.constructElement4HybridDomain();
				System.out.println("list map values: " + outputs.getListMapHybridValues());
				hybridOutDomain.addMapValues(outputs.getListMapHybridValues());
				hybridOutDomain.addSymbol(outputs.getListSymbols());
			}
		}
		hybridOutDomain.builDomainCondition(badMethod.getMethod().getServices());
	}	
}
