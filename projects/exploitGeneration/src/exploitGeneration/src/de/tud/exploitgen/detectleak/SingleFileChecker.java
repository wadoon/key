/**
 * 
 */
package de.tud.exploitgen.detectleak;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

import de.tud.exploitgen.detectleak.exploit.ExploitTestCases;
import de.tud.exploitgen.detectleak.exploit.ExploitTestSuite;
import de.tud.exploitgen.detectleak.exploit.codegenerator.JUnitExploitGenerator;
import de.tud.exploitgen.detectleak.specification.noninterference.IFBarrier;
import de.tud.exploitgen.detectleak.specification.noninterference.IFSpecParser;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.SICenter;
import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.tud.exploitgen.infrastructure.KeYJavaClassFactory;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.uka.ilkd.key.control.DefaultUserInterfaceControl;
import de.uka.ilkd.key.control.KeYEnvironment;
import de.uka.ilkd.key.macros.ProofMacroFinishedInfo;
import de.uka.ilkd.key.macros.SemanticsBlastingMacro;
import de.uka.ilkd.key.proof.DefaultTaskStartedInfo;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.ProverTaskListener;
import de.uka.ilkd.key.proof.TaskFinishedInfo;
import de.uka.ilkd.key.proof.TaskStartedInfo.TaskKind;
import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.proof.init.ProofOblInput;
import de.uka.ilkd.key.proof.io.ProblemLoaderException;
import de.uka.ilkd.key.proof.io.ProofSaver;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.smt.SMTProblem;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.FunctionalOperationContract;
import de.uka.ilkd.key.symbolic_execution.SymbolicExecutionTreeBuilder;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.po.ProgramMethodPO;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionEnvironment;
import de.uka.ilkd.key.util.Debug;
import de.uka.ilkd.key.util.Pair;


/**
 * @author Huy Do
 *
 */
public class SingleFileChecker {
   private File javaFile; //Java file that will be checked
   private KeYJavaClass javaClass;  //contains all necessary information for checking non-interference property
   //private IFSpecParser ifsParser;
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   private List<String> targetedMethods;
   private ExploitTestSuite exploitTestSuite; //contains exploit test suite showing that the program is nonsecure
   
   private final String TEST_FOLDER = "test"; //the prefix name for test folder, contains JUnit files to check non-interference constraints of program
   private boolean loopInv; //true if using loop invariant, false if unfolding loop
   private boolean methodTreatment=false; //method treatment
   private int depth; //depth of sub-field's sequence being investigated
   
   private List<BadMethod> listBadMethods; //list of all bad method where non-interference policy can be violated
           
   public SingleFileChecker(File javaFile, List<String> methods, boolean loopInv, 
           boolean methodTreatment, int depth) throws IOException, ProblemLoaderException {
      this.javaFile = javaFile;
      //get necessary information into javaClass
      this.targetedMethods= methods;
      javaClass = new KeYJavaClassFactory().createKeYJavaClass(this.javaFile, methods);
      //parse information flow security specifications by IFSpecParser and store in list ifSpecs
      ifSpecs = new IFSpecParser(javaFile).parseSpecification2GetListBarrier(); 
      //initiate for exploit test suite
      exploitTestSuite=new ExploitTestSuite(javaClass);
      this.loopInv=loopInv;
      this.methodTreatment = methodTreatment;
      this.depth = depth;
      
      listBadMethods = new LinkedList<BadMethod>();
   }
   
   //process a method in the Java file
   private void checkMethod(String methodName) throws ProofInputException, IOException, IllegalFormulaException{
      /*measure time for symbolic execution */
      long startTimeSE = System.nanoTime();
      
      KeYEnvironment<DefaultUserInterfaceControl> env=javaClass.getEnvironment();
      //System.out.println("namespcace services: " + env.getServices().getNamespaces().toString());
      KeYJavaMethod method=javaClass.getMethod(methodName);
      ProofOblInput input;
      if(/*false &&*/ method.getFunctionalContract()!=null){
         Contract contract = method.getFunctionalContract().get(0);     
        /* if(method.hasInformationFlowContract()){
            System.out.println("number of declassifications: " + method.getDeclassificationTerms().size());
            for(Term t: method.getDeclassificationTerms())
               System.out.println(t);
         }*/
        
         
         input = new FunctionalOperationContractPO(env.getInitConfig(), (FunctionalOperationContract)contract, true, true);

      }else{
         input = new ProgramMethodPO(env.getInitConfig(),
         method.getProgramMethod().getFullName(),
         method.getProgramMethod(),
         null,
         true,
         true);
      }
      // Create proof
      Proof proof = env.createProof(input);     
      //System.out.println(ProofSaver.printAnything(proof.root().sequent(), proof.getServices()));
      /// Configure proof for symbolic execution      
      SymbolicExecutionEnvironment.configureProofForSymbolicExecution(proof,
                                                                      100000,
                                                                      methodTreatment,
                                                                      loopInv,
                                                                      false,
                                                                      false,
                                                                      true);

      // Create symbolic execution tree which contains only the start node at beginning
      SymbolicExecutionTreeBuilder builder = new SymbolicExecutionTreeBuilder(/*env.getMediator(),*/
                                                                              proof,
                                                                              false,
                                                                              false,
                                                                              false,
                                                                              false,
                                                                              true);
      System.out.println("proof begins!");
      
      // Run proof
      //env.getUi().startAndWaitForAutoMode(proof);
      
      env.getProofControl().startAndWaitForAutoMode(proof);
      System.out.println("proof done!");
      // Update symbolic execution tree
      //============semantics blasting here
      
    /*  final SemanticsBlastingMacro macro = new SemanticsBlastingMacro();
      TaskFinishedInfo info = ProofMacroFinishedInfo.getDefaultInfo(macro, proof);
      final ProverTaskListener ptl = env.getUi().getProofControl().getDefaultProverTaskListener();
      try {
         
         
         //selectProof(env.getUi(), proof);

         ptl.taskStarted(new DefaultTaskStartedInfo(TaskKind.Macro, macro.getName(), 0));
         synchronized(macro) {
                      info = macro.applyTo(env.getUi(), proof, proof.openEnabledGoals(), null, ptl);
         }           
         
      } catch (final InterruptedException e) {
         Debug.out("Semantics blasting interrupted");
         
      } catch (final Exception e) {
          System.err.println(e);
      } finally {
          ptl.taskFinished(info);
      }*/
      //=======================
      /*System.out.println("Proof after:\n");
      for(Goal goal: proof.openGoals()){
    	  System.out.println("GOAL:::::::::: \n");
    	  System.out.println(ProofSaver.printAnything(goal.sequent(), proof.getServices()));
      }
      System.out.println("==============================");*/
      builder.analyse();
      
      //get start node
      IExecutionStart root=builder.getStartNode();
      long endTimeSE = System.nanoTime();
      System.out.println("Time for Symbolic Execution: "+(endTimeSE - startTimeSE)/1000000 + " ms"); 
      //use MethodChecker to check the method            
      method.setServices(proof.getServices());
      //System.out.println("namespcace services: " + method.getServices().getNamespaces().toString());
      
      MethodChecker mp = new MethodChecker(method, ifSpecs, root, depth);
      
      Pair<List<ExploitTestCases>,List<BadMethod>> resultCheckMethod = mp.checkMethod2GetExploitTestCases();
      List<ExploitTestCases> etcs = resultCheckMethod.first;      
      
      exploitTestSuite.addListExploitTestCase(etcs);
      
      /*measure time for model finding*/
      long endTimeMF = System.nanoTime();
      System.out.println("Time for Model Finding: "+(endTimeMF - endTimeSE)/1000000 + " ms"); 
      
      listBadMethods = resultCheckMethod.second;
      
    //free memory
    env.dispose();       
    
   }
      
   //check all methods of java file
   public void checkProgram() throws ProofInputException, IOException, IllegalFormulaException, InterruptedException{
      Set<String> methodNames=javaClass.getMethods();    
      for(String methodName:methodNames){
         System.out.println("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
         System.out.println("checking method " + methodName);
         checkMethod(methodName);        
      }
      //if the exploit test suite is empty, the program is secure
      System.out.println("\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
      if(exploitTestSuite.isEmpty())
         System.out.println("No leakage detected: The program might be safe");
      else{//otherwise, generate JUnit test to verify that the program violates non-interference constraints
    	  int numExploits=exploitTestSuite.getAmouttOfExploits();
         System.out.println("The program is insecure; number of generated exploits: " + 
        		 numExploits+ "; please run generated JUnit tests to verify!\n");
         
         //exploitTestSuite.printStatistics();
         JUnitExploitGenerator jUnitGen=new JUnitExploitGenerator(exploitTestSuite);
         String javaTestExploitCode  = jUnitGen.getExploitTestContent();       
         String className=jUnitGen.getClassName();
         createJUnitTestFile(javaTestExploitCode,className);
         
         /*
          * interface for secret inferring program
          */
         System.out.println("<======================================================>");
         
         System.out.println("Do you want to try secret infering tool? Yes/No (Y/N)?");
    	 Scanner keyboard = new Scanner(System.in);
    	 String input = keyboard.nextLine();
    	 if(input.equalsIgnoreCase("yes")||input.equalsIgnoreCase("y")){
        	 SICenter sic = new SICenter(javaClass, javaFile, listBadMethods);
        	 sic.userInteraction();
    	 }    	 
        
      }
   }
   
   /**
    * return the folder contains JUnit test.
    * at the moment, we place the test folder in the same directory with the folder containing Java source needed be tested
    * the name of the folder is the name of Java source's folder, prefixed by TEST_FOLDER
    * */
   private File createTestFolder(){
      File folder=new File(javaFile.getParentFile().getParent()+File.separator+TEST_FOLDER+javaFile.getParentFile().getName());
      if(!folder.exists())
         folder.mkdir();
      return folder;
   }
   
   /**
    * create JUnit test file
    * */
   private void createJUnitTestFile(String javaTestExploitCode, String className){
      File folder=createTestFolder();
      String javaPackage=folder.getName();
      
      File testFile=new File(folder,className+".java");
      
      try {
         //BufferedWriter writer = new BufferedWriter(new FileWriter(testFile));
         BufferedWriter writer = Files.newBufferedWriter(Paths.get(testFile.getPath()), StandardCharsets.UTF_8);         
         writer.write("package " + javaPackage + ";\n\n");
         writer.write(javaTestExploitCode);
         writer.close();
         System.out.println("JUnit file testing information flow security has been created at:\n" + testFile.toString());
      }
      catch (IOException e) {
         System.out.println("error in creating JUnit test file");
         e.printStackTrace();
      }
   }
   
 
   
}
