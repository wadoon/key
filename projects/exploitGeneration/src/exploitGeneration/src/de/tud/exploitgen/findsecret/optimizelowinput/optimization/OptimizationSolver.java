package de.tud.exploitgen.findsecret.optimizelowinput.optimization;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import localsolver.LSExpression;
import localsolver.LSModel;
import localsolver.LSPhase;
import localsolver.LocalSolver;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;

public abstract class OptimizationSolver {
	//protected CountingResultTree countTree;
	//protected List<MatchableCountingSolution> listMatchCountSolutions;
	protected MatchableCountingSolution countSolution;
	protected Services services; //contain necessary stuffs for handling Term
	protected int metric; //shannon entropy, min entropy or guessing entropy
	protected SecretDistribution sDistribution; //secret distribution for the case of non-uniform distribution
	/*public OptimizationSolver(List<MatchableCountingSolution> listMatchCountSolutions, Services services, int metric) {
		super();
		this.listMatchCountSolutions = listMatchCountSolutions;
		this.services = services;
		this.metric = metric;
	}	*/
	

	public OptimizationSolver(MatchableCountingSolution matchCountSolution,
			Services services, int metric) {
		super();
		this.countSolution = matchCountSolution;
		this.services = services;
		this.metric = metric;
		this.sDistribution = null;
	}
	
	
	
	public OptimizationSolver(MatchableCountingSolution countSolution,
			Services services, int metric, SecretDistribution sDistribution) {
		super();
		this.countSolution = countSolution;
		this.services = services;
		this.metric = metric;
		this.sDistribution = sDistribution;
	}



	/*public double computeOptimizeValue(Map<String,Long> mapValues){
		if((sDistribution==null)||(sDistribution.isUniform())){
			double optimizeValue=0;
			if(metric==KEGConstant.SHANNON_ENTROPY){			
				optimizeValue = 0;
				for(CountingSolution cs: countSolution.getListCountingSolutions()){
					double cG = TermUtil.computeDouble(cs.getValue(), mapValues, services);
					if(cG>0){
						optimizeValue += cG * Math.log(cG);	
					}			
				}
			}else if(metric == KEGConstant.GUESSING_ENTROPY){
				optimizeValue = 0;
				for(CountingSolution cs: countSolution.getListCountingSolutions()){
					double cG = TermUtil.computeDouble(cs.getValue(), mapValues, services);
					if(cG>0){
						optimizeValue += cG * (cG+1);	
					}			
				}
			}else{ //min entropy
				CountingSolution cs= countSolution.getListCountingSolutions().get(0);
				optimizeValue = (double)TermUtil.computeDouble(cs.getValue(), mapValues, services);		
			}
			return optimizeValue;
		}else{
			return 0;//TODO: revise
		}
	}*/
	
	public abstract OptimalSolution findOptimalSolution();
}
