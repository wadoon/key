package de.tud.exploitgen.findsecret.optimizelowinput.optimization;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import localsolver.LSExpression;
import localsolver.LSModel;
import localsolver.LSPhase;
import localsolver.LocalSolver;

import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;

public abstract class OptimizationSolver {
	//protected CountingResultTree countTree;
	//protected List<MatchableCountingSolution> listMatchCountSolutions;
	protected MatchableCountingSolution countSolution;
	protected Services services; //contain necessary stuffs for handling Term
	protected int metric; //shannon entropy, min entropy or guessing entropy
	
	/*public OptimizationSolver(List<MatchableCountingSolution> listMatchCountSolutions, Services services, int metric) {
		super();
		this.listMatchCountSolutions = listMatchCountSolutions;
		this.services = services;
		this.metric = metric;
	}	*/
	

	public OptimizationSolver(MatchableCountingSolution matchCountSolution,
			Services services, int metric) {
		super();
		this.countSolution = matchCountSolution;
		this.services = services;
		this.metric = metric;
	}
	
	
	
	public abstract OptimalSolution findOptimalSolution();
}
