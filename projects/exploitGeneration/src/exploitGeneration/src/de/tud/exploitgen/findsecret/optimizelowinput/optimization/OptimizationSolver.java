package de.tud.exploitgen.findsecret.optimizelowinput.optimization;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import localsolver.LSExpression;
import localsolver.LSModel;
import localsolver.LSPhase;
import localsolver.LocalSolver;

import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;

public abstract class OptimizationSolver {
	//protected CountingResultTree countTree;
	//protected List<MatchableCountingSolution> listMatchCountSolutions;
	protected MatchableCountingSolution countSolution;
	protected Services services; //contain necessary stuffs for handling Term
	protected int metric; //shannon entropy, min entropy or guessing entropy
	
	/*public OptimizationSolver(List<MatchableCountingSolution> listMatchCountSolutions, Services services, int metric) {
		super();
		this.listMatchCountSolutions = listMatchCountSolutions;
		this.services = services;
		this.metric = metric;
	}	*/
	

	public OptimizationSolver(MatchableCountingSolution matchCountSolution,
			Services services, int metric) {
		super();
		this.countSolution = matchCountSolution;
		this.services = services;
		this.metric = metric;
	}
	
	public double computeOptimizeValue(Map<String,Long> mapValues){
		double optimizeValue=0;
		if(metric==KEGConstant.SHANNON_ENTROPY){			
			optimizeValue = 0;
			for(Term countTerm: countSolution.getListCountTerms()){
				double cG = TermUtil.computeDouble(countTerm, mapValues, services);
				if(cG>0){
					optimizeValue += cG * Math.log(cG);	
				}			
			}
		}else if(metric == KEGConstant.GUESSING_ENTROPY){
			optimizeValue = 0;
			for(Term countTerm: countSolution.getListCountTerms()){
				double cG = TermUtil.computeDouble(countTerm, mapValues, services);
				if(cG>0){
					optimizeValue += cG * (cG+1);	
				}			
			}
		}else{ //min entropy
			Term countTerm= countSolution.getListCountTerms().get(0);
			optimizeValue = (double)TermUtil.computeDouble(countTerm, mapValues, services);		
		}
		return optimizeValue;
	}
	
	public abstract OptimalSolution findOptimalSolution();
}
