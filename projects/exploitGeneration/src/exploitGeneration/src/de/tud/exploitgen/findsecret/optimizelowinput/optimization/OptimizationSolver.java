package de.tud.exploitgen.findsecret.optimizelowinput.optimization;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import localsolver.LSExpression;
import localsolver.LSModel;
import localsolver.LSPhase;
import localsolver.LocalSolver;

import de.tud.exploitgen.findsecret.optimizelowinput.MatchableCountingSolution;
import de.tud.exploitgen.findsecret.optimizelowinput.OptimalSolution;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;

public abstract class OptimizationSolver {
	//protected CountingResultTree countTree;
	protected List<MatchableCountingSolution> listMatchCountSolutions;
	protected Services services; //contain necessary stuffs for handling Term
	
	public OptimizationSolver(List<MatchableCountingSolution> listMatchCountSolutions, Services services) {
		super();
		this.listMatchCountSolutions = listMatchCountSolutions;
		this.services = services;
	}	
	
	protected OptimalSolution findSolutionForAllConstantValues(MatchableCountingSolution matchCountSolution){
		/*
		 * calculate scaled shannon entropy
		 * */
		double optimizeValue = 0;
		for(Term value: matchCountSolution.getListCountTerms()){
			long cG = TermParser.getIntegerValue(value);
			if(cG>0)
				optimizeValue += cG * Math.log(cG);			
		}
		
		/*
		 * find solution for this case: it is solution for conditionTerm 
		 * */
		Z3Solver z3 = new Z3Solver(matchCountSolution.getConditionTerm(), services);
		Map<String, Long> solution = z3.solveFormula2GetMapValues();
		return new OptimalSolution(solution, optimizeValue);
	}
	
	protected OptimalSolution resolve4UniqueSolution(MatchableCountingSolution matchCountSolution){
		Map<String,Long> solution = matchCountSolution.getUniqueSolution();
		double optimizeValue = 0;
		for(Term countTerm: matchCountSolution.getListCountTerms()){
			long cG = TermUtil.computeLong(countTerm, solution);
			if(cG>0){
				optimizeValue += cG * Math.log(cG);	
			}			
		}
		return new OptimalSolution(solution, optimizeValue);
	}
	
	public Map<String, Long> findSolution(){
		List<OptimalSolution> listSolution = new LinkedList<OptimalSolution>();
		//for(CountingResultTree leaf: countTree.getAllLeaves()){
		for(MatchableCountingSolution countSolution: listMatchCountSolutions){
			countSolution.printInfo();
			if(countSolution.allCountTermsIsConstant()){
				OptimalSolution constSolution = findSolutionForAllConstantValues(countSolution);				
				listSolution.add(constSolution);
			}else{		
				if(countSolution.isUniqueModel()){//there is only one satisfying model
					OptimalSolution uniqueSolution = resolve4UniqueSolution(countSolution);
					listSolution.add(uniqueSolution);
				}
				else{
					OptimalSolution solution = findOptimalValue(countSolution);
					if(solution!=null)
						listSolution.add(solution);
				}
				
				/*System.out.println("objective value: " + objective.getDoubleValue());
				System.out.println("solution: " + mapSolution);*/
			}				 
		}
		
		//find the best solution:
		if(listSolution.size()>0){
			System.out.println("\n following are found solutions: " + listSolution.size() + "\n");
			
			OptimalSolution bestSolution = listSolution.get(0);	
			bestSolution.printInfo();
			for(int i=1; i<listSolution.size(); i++){
				listSolution.get(i).printInfo();
				if(bestSolution.getOptimizeValue()>listSolution.get(i).getOptimizeValue())
					bestSolution = listSolution.get(i);
			}
			System.out.println("best solution found:");
			bestSolution.printInfo();
			return bestSolution.getSolution();
		}else{
			return null;
		}
	}
	
	public abstract OptimalSolution findOptimalValue(MatchableCountingSolution countSolution);
}
