/**
 * 
 */
package de.tud.exploitgen.processing;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import java.util.Map;



import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.logic.sort.Sort;



/**
 * This class wraps a collection of PairTerm mapped by a name, 
 * which could be used to represent list of high variables, low variables in two branches...
 * @author Huy Do
 * 
 */
public class PairTermCollection {
   private Map<String, PairTerm> listPairTerm;
   private final Services services;
   private final TermFactory tf = new TermFactory();
   private final TermBuilder termBuilder;
   private final Term tt = tf.createTerm(Junctor.TRUE);
   private final Term ff = tf.createTerm(Junctor.FALSE);
   /**
    * @param listPairTerm
    */
   public PairTermCollection(Map<String,PairTerm> listPairTerm, Services services) {
      super();
      this.listPairTerm = listPairTerm;
      this.services=services;
      termBuilder=new TermBuilder(tf,services);
      
   }

   /**
    * @return the listPairTerm
    */
   public Map<String,PairTerm> getListPairTerm() {
      return listPairTerm;
   }

   /**
    * @param listPairTerm the listPairTerm to set
    */
   public void setListPairTerm(Map<String,PairTerm> listPairTerm) {
      this.listPairTerm = listPairTerm;
   }

   public PairTermCollection(Services services){
      this.listPairTerm=new HashMap<String,PairTerm>();
      this.services=services;
      termBuilder=new TermBuilder(tf,services);
   }
   
   //constructor to clone another PairTermCollection
   public PairTermCollection(PairTermCollection ptc){
      listPairTerm=new HashMap<String,PairTerm>();
      for(String key: ptc.getNameSet()){
         add(key,ptc.getPairTerm(key));
      }
      this.services=ptc.getServices();
      termBuilder=new TermBuilder(tf,services);
   }
   
   public void add(String name,PairTerm pt){
      listPairTerm.put(name,pt);
   }
   
   /**
    * make total equal term from PairTermCollection. It looks like that:
    * t11=t21 and t21=t22 and t31=t32 and ....
    * */
   public Term totalEqualTerm(){      
      Term result = tt;
      for(PairTerm pt : listPairTerm.values()) {
          result = termBuilder.and(result,pt.equalTerm());
      }
      return result;
   }
   
   /**
    * make total not equal term from PairTermCollection. It looks like that:
    * t11!=t21 and t21!=t22 and t31!=t32 and ...
    * */
   public Term totalNotEqualTerm(){
      Term result = tt;
      for(PairTerm pt : listPairTerm.values()) {
          result = termBuilder.and(result,pt.notEqualTerm());
      }
      return result;
   }
   
   /**
    * make partial equal term from PairTermCollection. It looks like that:
    * t11=t21 or t21=t22 or t31=t32 or ...
    * */
   public Term partialEqualTerm(){      
      Term result = ff;
      for(PairTerm pt : listPairTerm.values()) {
          result = termBuilder.or(result,pt.equalTerm());
      }
      return result;
   }
   /**
    * make partial not equal term from PairTermCollection. It looks like that:
    * t11!= t21 or t21 != t22 or t31 != t32 ....
    * */
   public Term partialNotEqualTerm(){
      Term result = ff;
      for(PairTerm pt : listPairTerm.values()) {
          result = termBuilder.or(result,pt.notEqualTerm());
      }
      return result;
   }
   
   
   
   /*
    * get Term corresponding with the given name and the number of branch
    * if branch's number is 1, return term 1 in PairTerm, otherwise return term 2
    */
   public Term getTermByNameAndBranch(String name, int branch){
      if(listPairTerm.containsKey(name)){
         if(branch==1)
            return listPairTerm.get(name).getT1();
         else
            return listPairTerm.get(name).getT2();
      }else
         return null;      
   }
   
   /*
    * create a new term from input term by: 
    * find all ProgramVariable subterms of input term which the name is the same with given name
    * replace it by the term  
    * */
   public Term replacePVByNameAndBranch(final Term term, int branch){
   //   OpReplacer replacer = new OpReplacer( msp from originsl prog  vsr to new prog vsr);
   //   Term newTerm = replacer.replace(term);
      
      
      if(term !=null){
         if(TermParser.isLocationVariable(term)|| KeYResourceHandler.isArtificialVariable(term)){
            Term rt=getTermByNameAndBranch(term.op().name().toString(), branch);
            if(rt!=null)
               return rt;
            else return term;
         }else if (TermParser.isForAllQuantifier(term)){
            return tf.createTerm(term.op(), replaceSubTermsByNameAndBranch(term.subs(), branch), 
                  replaceQuantifier(term.boundVars(),branch),term.javaBlock());
         }
         else{
            //return tf.createTerm(term.op(), replaceSubTermsByNameAndBranch(term.subs(), branch), term.boundVars(),term.javaBlock());
            return tf.createTerm(term.op(), replaceSubTermsByNameAndBranch(term.subs(), branch));
         }
      }else return null;
   }
   
   private ImmutableArray<QuantifiableVariable> replaceQuantifier(ImmutableArray<QuantifiableVariable> boundVars, int branch){
      List<QuantifiableVariable> listQV = new LinkedList<QuantifiableVariable>();
      System.out.println("boundVars: " + boundVars.toString());
      for(int i = 0; i<boundVars.size(); i++){
         System.out.println("quantifiable var: " + boundVars.get(i).name().toString());
         Term rt = getTermByNameAndBranch(boundVars.get(i).name().toString(), branch);        
         
         //if(rt!=null){           
            
            LogicVariable lv = new LogicVariable(new Name(rt.toString()), rt.sort());         
            listQV.add(lv);
         //}
      }
      
      return new ImmutableArray<QuantifiableVariable>(listQV);
   }
   
   private Term[] replaceSubTermsByNameAndBranch(final ImmutableArray<Term> subs, int branch){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replacePVByNameAndBranch(subs.get(i), branch);    
      return (result);
   }
   
   /*
    * print list pair term 
    * */
   public void printListPairTerm(){      
      Set<String> names=listPairTerm.keySet();
      for(String name:names){
         System.out.println("name: " + name + "; term 1: " + listPairTerm.get(name).getT1() + 
               "; term 2: " + listPairTerm.get(name).getT2() + "; type: " +  
               listPairTerm.get(name).getT1().sort().declarationString());
      }
   }
   
   /*
    * check if the list of pairterm contains the variable varName 
    * */   
   public boolean contains(String varName){
      if(listPairTerm.containsKey(varName))
         return true;
      else return false;
   }
   
   /*
    * combine with another PairTermCollection
    * */   
   public void combine(PairTermCollection ptc){
      //PairTermCollection result=new PairTermCollection(this);    //clone @this to the result
      
      for(String key:ptc.getNameSet()){
         if(!contains(key))
            add(key,ptc.getPairTerm(key));
      }
      //return result;
   }
   
   public Set<String> getNameSet(){
      return listPairTerm.keySet();
   }
   
   public PairTerm getPairTerm(String name){
      if(contains(name)){
         return listPairTerm.get(name);
      }else return null;
   }   
   
   //get all PairTerm of map listPairTerm
   public List<PairTerm> getPairTerms(){
      List<PairTerm> result=new LinkedList<PairTerm>();
      for(String key: listPairTerm.keySet()){
         result.add(listPairTerm.get(key));
      }
      return result;
   }
   
   public Services getServices(){
	   return services;
   }
 }
