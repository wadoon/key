/**
 * 
 */
package de.tud.exploitgen.processing;

import java.util.HashMap;
import java.util.Set;

import java.util.Map;

import com.csvanefalk.keytestgen.util.parsers.TermParserTools;


import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.LocationVariable;


/**
 * This class wraps a collection of PairTerm mapped by a name, 
 * which could be used to represent list of high variables, low variables in two branches...
 * @author Huy Do
 * 
 */
public class PairTermCollection {
   private Map<String, PairTerm> listPairTerm;
   private static final TermFactory tf = TermFactory.DEFAULT;
   private static final TermBuilder termBuilder = TermBuilder.DF;
   private static final Term tt = TermFactory.DEFAULT.createTerm(Junctor.TRUE);
   private static final Term ff = TermFactory.DEFAULT.createTerm(Junctor.FALSE);
   /**
    * @param listPairTerm
    */
   public PairTermCollection(Map<String,PairTerm> listPairTerm) {
      super();
      this.listPairTerm = listPairTerm;
   }

   /**
    * @return the listPairTerm
    */
   public Map<String,PairTerm> getListPairTerm() {
      return listPairTerm;
   }

   /**
    * @param listPairTerm the listPairTerm to set
    */
   public void setListPairTerm(Map<String,PairTerm> listPairTerm) {
      this.listPairTerm = listPairTerm;
   }

   public PairTermCollection(){
      this.listPairTerm=new HashMap<String,PairTerm>();
   }
   
   //constructor to clone another PairTermCollection
   public PairTermCollection(PairTermCollection ptc){
      listPairTerm=new HashMap<String,PairTerm>();
      for(String key: ptc.getNameSet()){
         add(key,ptc.getPairTerm(key));
      }
   }
   
   public void add(String name,PairTerm pt){
      listPairTerm.put(name,pt);
   }
   
   /*
    * make equal term from PairTermCollection. It looks like that:
    * t11=t21 && t21=t22 && t31=t32 ....
    * */
   public Term equalTerm(){      
      Term result = tt;
      for(PairTerm pt : listPairTerm.values()) {
          result = termBuilder.and(result,pt.equalTerm());
      }
      return result;
   }
   
   /*
    * make not equal term from PairTermCollection. It looks like that:
    * t11!= t21 or t21 != t22 or t31 != t32 ....
    * */
   public Term notEqualTerm(){
      Term result = ff;
      for(PairTerm pt : listPairTerm.values()) {
          result = termBuilder.or(result,pt.notEqualTerm());
      }
      return result;
   }
   
   /*
    * get Term corresponding with the given name and the number of branch
    * if branch's number is 1, return term 1 in PairTerm, otherwise return term 2
    */
   public Term getTermByNameAndBranch(String name, int branch){
      if(listPairTerm.containsKey(name)){
         if(branch==1)
            return listPairTerm.get(name).getT1();
         else
            return listPairTerm.get(name).getT2();
      }else
         return null;      
   }
   
   /*
    * create a new term from input term by: 
    * find all ProgramVariable subterms of input term which the name is the same with given name
    * replace it by the term  
    * */
   public Term replacePVByNameAndBranch(final Term term, int branch){
   //   OpReplacer replacer = new OpReplacer( msp from originsl prog  vsr to new prog vsr);
   //   Term newTerm = replacer.replace(term);
      
      
      if(term !=null){
         if(TermParserTools.isLocationVariable(term)){
            Term rt=getTermByNameAndBranch(term.op().name().toString(), branch);
            if(rt!=null)
               return rt;
            else return term;
         }else{
            return tf.createTerm(term.op(), replaceSubTermsByNameAndBranch(term.subs(), branch));
         }
      }else return null;
   }
   
   private Term[] replaceSubTermsByNameAndBranch(final ImmutableArray<Term> subs, int branch){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replacePVByNameAndBranch(subs.get(i), branch);    
      return (result);
   }
   
   /*
    * print list pair term 
    * */
   public void printListPairTerm(){      
      Set<String> names=listPairTerm.keySet();
      for(String name:names){
         System.out.println("name: " + name + "; term 1: " + listPairTerm.get(name).getT1() + 
               "; term 2: " + listPairTerm.get(name).getT2() + "; type: " + ((LocationVariable)listPairTerm.get(name).getT1().op()).getKeYJavaType());
      }
   }
   
   /*
    * check if the list of pairterm contains the variable varName 
    * */   
   public boolean contains(String varName){
      if(listPairTerm.containsKey(varName))
         return true;
      else return false;
   }
   
   /*
    * combine with another PairTermCollection
    * */   
   public PairTermCollection combine(PairTermCollection ptc){
      PairTermCollection result=new PairTermCollection(this);    //clone @this to the result
      
      for(String key:ptc.getNameSet()){
         if(!result.contains(key))
            result.add(key,ptc.getPairTerm(key));
      }
      return result;
   }
   
   public Set<String> getNameSet(){
      return listPairTerm.keySet();
   }
   
   public PairTerm getPairTerm(String name){
      if(contains(name)){
         return listPairTerm.get(name);
      }else return null;
   }   
   
 }
