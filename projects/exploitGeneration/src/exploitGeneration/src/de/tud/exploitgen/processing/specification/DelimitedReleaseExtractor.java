/**
 * 
 */
package de.tud.exploitgen.processing.specification;

import java.util.LinkedList;
import java.util.List;

import de.tud.exploitgen.processing.PairTerm;
import de.tud.exploitgen.processing.PairTermCollection;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConfig;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.util.DelimitedRelease;

/**
 * @author Huy Do
 * this class supplies methods resolving declassification (conditional delimited release)
 * that can be used in other classes
 *
 */
public class DelimitedReleaseExtractor {
   /*get collection of destination (low variables) of escape hatches expression */
   private DelimitedRelease decl;
   private Services services;
   TermBuilder termBuilder;
   TermFactory tf = new TermFactory();
   
   /**
    * @param decl
    * @param services
    */
   public DelimitedReleaseExtractor(DelimitedRelease decl, Services services) {
      super();
      this.decl = decl;
      this.services = services;
      termBuilder=new TermBuilder(new TermFactory(), services);
   }

   public List<String> getEscDestination(String heapName){
      List<String> result = new LinkedList<String>();      
      for(Term tVar : decl.lowVars){
         result.add(HeapHandler.getFieldNameOfHeapSelectFunction(tVar, KEGConfig.SEPARATOR, heapName));
      }
      return result;
   }
   
   /*if there are more than one conditions in escapes conditions, we use conjunction "or" to combine them*/
   public Term getEscCondition(){
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm=termBuilder.ff();     
         for(Term t: conditions){
            conditionTerm = termBuilder.or(conditionTerm,t);
         }
         return conditionTerm;
      }
      return termBuilder.tt();
   }
   
     
   /**
    * get leak condition of a DelimitedRelease specification (escapes E \if C), based on branch
    * output format: c1(hi,li) or c2(hi,li) or ... (cj \in C)
    * */
   private Term getEscCondition(PairTermCollection listAllVars, String heapName, int branch){
      
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm = getEscCondition();
         
         conditionTerm = new HeapHandler(services).replaceSelectFunctionByItsField(conditionTerm, KEGConfig.SEPARATOR);
         conditionTerm = new HeapHandler(services).replaceLengthFunctionByVar(conditionTerm, KEGConfig.SEPARATOR);
         if(branch==1){          
            conditionTerm = listAllVars.replacePVByNameAndBranch(conditionTerm, 1);
         }else{
            conditionTerm = listAllVars.replacePVByNameAndBranch(conditionTerm, 2);
         }
                  
         return conditionTerm;
      }
      return termBuilder.tt();
   }
   
   
   
   /*get the negative form of escape condition: !(EscCond(h1,l1) && EscCond(h2,l2))*/
   private Term getNegEscConditionByAndConjunction(PairTermCollection listAllVars, String heapName)  {
      
      Term conditionTerm1 = getEscCondition(listAllVars, heapName, 1);
      Term conditionTerm2 = getEscCondition(listAllVars, heapName, 2);
      return termBuilder.not(termBuilder.and(conditionTerm1, conditionTerm2));
   }
   
   
   /*
    * get escape hatches equal term: \forall e \in E: e(h1,l1)=e(h2,l2) <=> (e1(h1,l1)=e1(h2,l2)) && (e2(h1,l1)=e2(h2,l2)) && ...
    * */
   
   private Term getEscapeHatchesEqual(PairTermCollection listAllVars, 
                                    String heapName){
      
      ImmutableList<Term> leaks = decl.escapeHatches;
      /*
       * solve leakable expression, because we have to build equation \forall e \in E: e(h1,l1)=e(h2,l2),
       * we will use PairTermCollection
       * */
      if(leaks.size()>0){
         PairTermCollection pairLeakTerms = new PairTermCollection(services);
         HeapHandler heapHandler = new HeapHandler(services);
         for(Term leakTerm: leaks){
            
            Term declass1 = leakTerm; 
            Term declass2 = leakTerm;
                           
             /* with declassification, the heap name is always "self", 
             * but if a class contains more than one method,
             * the heap object of each method could have another name: "self_0", "self_1",...
             * so we have to use the heap name of the method in resolving declassification
             * */      
            declass1 = heapHandler.replaceSelectFunctionByItsField(declass1,KEGConfig.SEPARATOR,heapName);
            declass1 = heapHandler.replaceLengthFunctionByVar(declass1,KEGConfig.SEPARATOR);
            
            declass2 = heapHandler.replaceSelectFunctionByItsField(declass2,KEGConfig.SEPARATOR,heapName);
            declass2 = heapHandler.replaceLengthFunctionByVar(declass2,KEGConfig.SEPARATOR);
            
            declass1 = listAllVars.replacePVByNameAndBranch(declass1, 1);
                        
            declass2 = listAllVars.replacePVByNameAndBranch(declass2, 2); 
            
            //create new PairTerm (declass1, declass2) and add it into pcd1
            pairLeakTerms.add(leakTerm.toString(), new PairTerm(declass1,declass2,services));
         }
         return pairLeakTerms.totalEqualTerm();
      }
      
      return termBuilder.tt();
   }
   
   
      
   /*
    * return conditional escape term for declare: escapes E \if C
    * it's format is:  (!(C(h1,l1) && C(h2,l2))) || (E(h1,l1)=E(h2,l2))
    * */
   public Term getConditionalEscTerm(PairTermCollection listAllVars, String heapName){
      
      return termBuilder.or(getNegEscConditionByAndConjunction(listAllVars,heapName),
                            getEscapeHatchesEqual(listAllVars,heapName));
   }
   
   
   
   /*check if escape hatches expressions could be applied for specific variable (parameter) or not 
    * return true if escapes destinations (\to clause) is empty, or contains varName
    * */
   public boolean affect2Var(String heapName, String varName){
      List<String> escDests = getEscDestination(heapName);
      if(escDests.isEmpty() || escDests.contains(varName))
         return true;
      else
         return false;
   }
   
}
