/**
 * 
 */
package de.tud.exploitgen.processing.specification;

import java.util.LinkedList;
import java.util.List;

import de.tud.exploitgen.processing.PairTerm;
import de.tud.exploitgen.processing.PairTermCollection;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConfig;
import de.uka.ilkd.key.collection.ImmutableList;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.util.DelimitedRelease;

/**
 * @author Huy Do
 * this class supplies methods resolving declassification (conditional delimited release)
 * that can be used in other classes
 *
 */
public class DelimitedReleaseExtractor {
   /*get collection of destination (low variables) of escape hatches expression */
   private DelimitedRelease decl;
   private Services services;
   TermBuilder termBuilder;
   TermFactory tf = new TermFactory();
   
   /**
    * @param decl
    * @param services
    */
   public DelimitedReleaseExtractor(DelimitedRelease decl, Services services) {
      super();
      this.decl = decl;
      this.services = services;
      termBuilder=new TermBuilder(new TermFactory(), services);
   }

   private List<String> getEscDestination(String selfName){
      List<String> result = new LinkedList<String>();      
      for(Term tVar : decl.lowVars){
         result.add(HeapHandler.getFieldNameOfHeapSelectFunction(tVar, KEGConfig.SEPARATOR, selfName));
      }
      return result;
   }
   
   /*if there are more than one conditions in escapes conditions, we use conjunction "or" to combine them*/
   public Term getEscCondition(){
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm=termBuilder.ff();     
         for(Term t: conditions){
            conditionTerm = termBuilder.or(conditionTerm,t);
         }
         return conditionTerm;
      }
      return termBuilder.tt();
   }
   
     
   /**
    * get leak condition of a DelimitedRelease specification (escapes E \if C), based on branch
    * output format: c1(hi,li) or c2(hi,li) or ... (cj \in C)
    * */
   private Term getEscCondition(PairTermCollection listAllVars, 
         List<Term> listQuantifiedArrayTerm, int branch){
      
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm = getEscCondition();
         
         /*conditionTerm = new HeapHandler(services).replaceSelectFunctionByItsField(conditionTerm, KEGConfig.SEPARATOR);
         conditionTerm = new HeapHandler(services).replaceLengthFunctionByVar(conditionTerm, KEGConfig.SEPARATOR);*/
         conditionTerm = refineTerm(conditionTerm, listQuantifiedArrayTerm);
         if(branch==1){          
            conditionTerm = listAllVars.replacePVByNameAndBranch(conditionTerm, 1);
         }else{
            conditionTerm = listAllVars.replacePVByNameAndBranch(conditionTerm, 2);
         }
                  
         return conditionTerm;
      }
      return termBuilder.tt();
   }
   
   
   /**
    * fresh version
    * get leak condition of a DelimitedRelease specification (escapes E \if C), based on branch
    * output format: c1(hi,li) or c2(hi,li) or ... (cj \in C)
    * */
   private Term getFreshEscCondition(PairTermCollection ptcFoundation, int branch){
      
      ImmutableList<Term> conditions = decl.conditions;       
      if(conditions.size()>0){
         Term conditionTerm = getEscCondition();         
         
         if(branch==1){          
            conditionTerm = ptcFoundation.replacePVByNameAndBranch(conditionTerm, 1);
         }else{
            conditionTerm = ptcFoundation.replacePVByNameAndBranch(conditionTerm, 2);
         }
                  
         return conditionTerm;
      }
      return termBuilder.tt();
   }
   
   
   /*get the negative form of escape condition: !(EscCond(h1,l1) && EscCond(h2,l2))*/
   private Term getNegEscConditionByAndConjunction(PairTermCollection listAllVars,
         List<Term> listQuantifiedArrayTerm)  {
      
      Term conditionTerm1 = getEscCondition(listAllVars, listQuantifiedArrayTerm, 1);
      Term conditionTerm2 = getEscCondition(listAllVars, listQuantifiedArrayTerm, 2);
      return termBuilder.not(termBuilder.and(conditionTerm1, conditionTerm2));
   }
   
   /* fresh version
    * get the negative form of escape condition: !(EscCond(h1,l1) && EscCond(h2,l2))*/
   private Term getFreshNegEscConditionByAndConjunction(PairTermCollection ptcFoundation)  {
      
      Term conditionTerm1 = getFreshEscCondition(ptcFoundation, 1);
      Term conditionTerm2 = getFreshEscCondition(ptcFoundation, 2);
      return termBuilder.not(termBuilder.and(conditionTerm1, conditionTerm2));
   }
   
   
   /*
    * get escape hatches equal term: \forall e \in E: e(h1,l1)=e(h2,l2) <=> (e1(h1,l1)=e1(h2,l2)) && (e2(h1,l1)=e2(h2,l2)) && ...
    * */
   
   private Term getEscapeHatchesEqual(PairTermCollection listAllVars, 
                                    String heapName, List<Term> listQuantifiedArrayTerm){
      
      ImmutableList<Term> leaks = decl.escapeHatches;
      /*
       * solve leakable expression, because we have to build equation \forall e \in E: e(h1,l1)=e(h2,l2),
       * we will use PairTermCollection
       * */
      if(leaks.size()>0){
         PairTermCollection pairLeakTerms = new PairTermCollection(services);
         //HeapHandler heapHandler = new HeapHandler(services);
         for(Term leakTerm: leaks){
            
            Term declass1 = leakTerm; 
            Term declass2 = leakTerm;
                           
             /* with declassification, the heap name is always "self", 
             * but if a class contains more than one method,
             * the heap object of each method could have another name: "self_0", "self_1",...
             * so we have to use the heap name of the method in resolving declassification
             * */      
            /*declass1 = heapHandler.replaceSelectFunctionByItsField(declass1,KEGConfig.SEPARATOR,heapName);
            declass1 = heapHandler.replaceLengthFunctionByVar(declass1,KEGConfig.SEPARATOR);*/
            declass1 = refineTerm(declass1, listQuantifiedArrayTerm);
            /*declass2 = heapHandler.replaceSelectFunctionByItsField(declass2,KEGConfig.SEPARATOR,heapName);
            declass2 = heapHandler.replaceLengthFunctionByVar(declass2,KEGConfig.SEPARATOR);*/
            declass2 = refineTerm(declass2, listQuantifiedArrayTerm);
            
            declass1 = listAllVars.replacePVByNameAndBranch(declass1, 1);
                        
            declass2 = listAllVars.replacePVByNameAndBranch(declass2, 2); 
            
            //create new PairTerm (declass1, declass2) and add it into pcd1
            pairLeakTerms.add(leakTerm.toString(), new PairTerm(declass1,declass2,services));
         }
         return pairLeakTerms.totalEqualTerm();
      }
      
      return termBuilder.tt();
   }
   
   
   /*
    * fresh version
    * get escape hatches equal term: \forall e \in E: e(h1,l1)=e(h2,l2) <=> (e1(h1,l1)=e1(h2,l2)) && (e2(h1,l1)=e2(h2,l2)) && ...
    * */
   
   private Term getFreshEscapeHatchesEqual(PairTermCollection ptcFoundation){
      
      ImmutableList<Term> leaks = decl.escapeHatches;
      /*
       * solve leakable expression, because we have to build equation \forall e \in E: e(h1,l1)=e(h2,l2),
       * we will use PairTermCollection
       * */
      if(leaks.size()>0){
         PairTermCollection pairLeakTerms = new PairTermCollection(services);
         //HeapHandler heapHandler = new HeapHandler(services);
         for(Term leakTerm: leaks){
            
            Term declass1 = leakTerm; 
            Term declass2 = leakTerm;
                       
            declass1 = ptcFoundation.replacePVByNameAndBranch(declass1, 1);
                        
            declass2 = ptcFoundation.replacePVByNameAndBranch(declass2, 2); 
            
            //create new PairTerm (declass1, declass2) and add it into pcd1
            pairLeakTerms.add(leakTerm.toString(), new PairTerm(declass1,declass2,services));
         }
         return pairLeakTerms.freshTotalEqualTerm();
      }
      
      return termBuilder.tt();
   }
      
   /*
    * return conditional escape term for declare: escapes E \if C
    * it's format is:  (!(C(h1,l1) && C(h2,l2))) || (E(h1,l1)=E(h2,l2))
    * */
   public Term getConditionalEscTerm(PairTermCollection listAllVars, String heapName, 
         List<Term> listQuantifiedArrayTerm){
      //System.out.println("NegEscConditionByAndConjunction: " + getNegEscConditionByAndConjunction(listAllVars,heapName,listQuantifiedArrayTerm ));
      //System.out.println("getEscapeHatchesEqual: " + getEscapeHatchesEqual(listAllVars,heapName,listQuantifiedArrayTerm ));
      return termBuilder.or(getNegEscConditionByAndConjunction(listAllVars,listQuantifiedArrayTerm ),
                            getEscapeHatchesEqual(listAllVars,heapName,listQuantifiedArrayTerm));
   }
   
   /*
    * fresh version
    * return conditional escape term for declare: escapes E \if C
    * it's format is:  (!(C(h1,l1) && C(h2,l2))) || (E(h1,l1)=E(h2,l2))
    * */
   public Term getFreshConditionalEscTerm(PairTermCollection ptcFoundation){
      //System.out.println("NegEscConditionByAndConjunction: " + getNegEscConditionByAndConjunction(listAllVars,heapName,listQuantifiedArrayTerm ));
      //System.out.println("getEscapeHatchesEqual: " + getEscapeHatchesEqual(listAllVars,heapName,listQuantifiedArrayTerm ));
      return termBuilder.or(getFreshNegEscConditionByAndConjunction(ptcFoundation),
                            getFreshEscapeHatchesEqual(ptcFoundation));
   }
   
   /*check if escape hatches expressions could be applied for specific variable (parameter) or not 
    * return true if escapes destinations (\to clause) is empty, or contains varName
    * */
   public boolean affect2Var(String heapName, String selfName){
      List<String> escDests = getEscDestination(heapName);
      if(escDests.isEmpty() || escDests.contains(selfName))
         return true;
      else
         return false;
   }
   
   private Term refineTerm(final Term t, List<Term> listQuantifiedArrayTerm ){
      
      /*Term result = heapHandler.replaceLengthFunctionByVar(t, KEGConfig.SEPARATOR);
      result = heapHandler.replaceSelectFunctionByItsField(result, KEGConfig.SEPARATOR);*/
      HeapHandler heapHandler = new HeapHandler(services);
      Term result = heapHandler.shortenArrayElementTerm(t, KEGConfig.SEPARATOR);
      result = heapHandler.replaceUnContainQASelectAndLength(result,listQuantifiedArrayTerm);      
      return result;
   }
   
   
}
