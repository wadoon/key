package de.tud.exploitgen.findsecret.counting;


import java.util.LinkedList;
import java.util.List;

import java.util.Stack;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTreeWalker;


import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultLexer;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser;
import de.tud.exploitgen.findsecret.counting.gensrc.CountingResultParser.ResultContext;

import de.tud.exploitgen.findsecret.optimizelowinput.CountingSolution;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.ldt.IntegerLDT;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;

public class Iscc2TermTransformer {
	private String isccResultString;
	private TermBuilder termBuilder;
	private TermFactory termFactory;
	private Services services;
	private List<CountingSolution> listResults;
	private List<Term> listParameters;
	//private Stack<String> stack4Translate; 
	
	private Stack<Term> stackValueTermTranslation; //stack storing term to translate value
	private Stack<Term> stackConditionTermTranslation; //stack storing term to translate condition
	private Stack<Integer> stackTrioOp; //stack storing comparison operators have been used in an a comparison trio: (i.e. a<=b<=c)
	
	//flag: true if we are resolving stackValueTermTranslation, false if we are resolving stackConditionTermTranslation
	private boolean workWithValue;  
	
	public Iscc2TermTransformer(String isccResult, Services services){
		System.out.println("initiated Iscc2TermTransformer!");

		this.isccResultString = isccResult;
		this.services = services;
		this.termBuilder = services.getTermBuilder();	
		this.termFactory = services.getTermFactory();
		listResults = new LinkedList<CountingSolution>();
		listParameters = new LinkedList<Term>();
		//stack2Translate = new Stack<String>();
	}
	
	
	public void initiateStackTerm(){
		stackValueTermTranslation = new Stack<Term>();
		stackConditionTermTranslation = new Stack<Term>();
	}
	
	public void setWorkWithValue(boolean workWithValue) {
		this.workWithValue = workWithValue;
	}

	

	//resolve stack term basing on matched binary operator
	public void resolveStackTermByBinaryOp(int operator){
		Term factor1, factor2;
		
		if(workWithValue){
			//System.out.println("stackValueTermTranslation: " + stackValueTermTranslation);
			factor2 = stackValueTermTranslation.pop();
			factor1 = stackValueTermTranslation.pop();
		}else{
			//System.out.println("stackConditionTermTranslation: " + stackConditionTermTranslation);
			factor2 = stackConditionTermTranslation.pop();
			factor1 = stackConditionTermTranslation.pop();
		}
		Term synTerm = synthTerm(factor1, factor2, operator);
		if(synTerm!=null){
			if(workWithValue)
				stackValueTermTranslation.push(synTerm);
			else
				stackConditionTermTranslation.push(synTerm);
		}
	}
	
	private Term synthTerm(Term factor1, Term factor2, int operator){
		if (operator==KEGConstant.AND){
			return termBuilder.and(factor1, factor2);			
		}
		else if(operator == KEGConstant.DIV){
			return termBuilder.div(factor1, factor2);			
		}
		else if(operator == KEGConstant.EQ){
			return termBuilder.equals(factor1, factor2);
		}
		else if(operator == KEGConstant.EXISTS){
			if(TermParser.isEquals(factor1)){
				//extract the sub 0
				Term qvTerm = factor1.sub(0);
				QuantifiableVariable qv = new LogicVariable(new Name(qvTerm.toString()),qvTerm.sort());
				return termBuilder.ex(qv, termBuilder.and(factor1, factor2));
			}else{
				QuantifiableVariable qv = new LogicVariable(new Name(factor1.toString()),factor1.sort());
				return termBuilder.ex(qv, factor2);
			}
		}
		else if(operator == KEGConstant.GE){
			return termBuilder.geq(factor1, factor2);
		}
		else if(operator == KEGConstant.GT){
			return termBuilder.gt(factor1, factor2);
		}
		else if(operator == KEGConstant.LE){
			return termBuilder.leq(factor1, factor2);
		}
		else if(operator == KEGConstant.LT){
			return termBuilder.lt(factor1, factor2);
		}
		else if(operator == KEGConstant.MINUS){
			return termBuilder.minus(factor1, factor2);
		}
		else if(operator == KEGConstant.MULT){
			return termBuilder.mul(factor1, factor2);
		}
		else if(operator == KEGConstant.OR){
			return termBuilder.or(factor1, factor2);
		}
		else if(operator == KEGConstant.PLUS){
			return termBuilder.add(factor1, factor2);
		}
		else if(operator == KEGConstant.POWER){
			return getPowerTerm(factor1, factor2);
		}else
			return null;

	}
	
	//resolve stack term basing on matched unary operator
	public void resolveStackTermByUnaryOp(int operator){
		/*
		 * TODO: what should we do with floor and round: 
		 * at the moment we basically do minus operator
		 * */	
		Term factor;
		Term synTerm;
		if(workWithValue){
			factor = stackValueTermTranslation.pop();
		}else{
			factor = stackConditionTermTranslation.pop();
		}
		if(operator==KEGConstant.MINUS){
			//if it is unary minus operator (-a), we translate it to -(0,a)
			synTerm = termBuilder.minus(termBuilder.zero(), factor);
		}else if(operator==KEGConstant.ROUND){
			synTerm = factor; //because Key does not supply round operator, we basically use remain the value
		} else if(operator == KEGConstant.FLOOR){
			synTerm = factor; //because Key does not supply floor operator, we basically use remain the value
		}else
			synTerm = null;
		
		if(synTerm!=null){
			if(workWithValue)
				stackValueTermTranslation.push(synTerm);
			else
				stackConditionTermTranslation.push(synTerm);
		}
	}
	
	/*
	 * with result ={  }, the value = 0 and condition = true
	 * */
	public void resolveEmptyResultPharse(){
		Term value = termBuilder.zero();
		Term condition = termBuilder.tt();
		listResults.add(new CountingSolution(value, condition));
	}
	
	//create a term with terminal text and add it to stack
	public void add2StackTerm(String terminalText, boolean isNumber){
		Term addTerm=null;
		if(isNumber){
			addTerm = termBuilder.zTerm(terminalText);
		}else{
			//first check in list of parameters
			for(int i=0;i< listParameters.size();i++)
				if(terminalText.equals(listParameters.get(i).toString())){
					addTerm = listParameters.get(i);
					break;
				}			
			if(addTerm==null)
				addTerm = TermUtil.createIntVarTerm(terminalText, services);
		}
		
		
		if(workWithValue){
			//System.out.println("add to stackValueTermTranslation: "+ addTerm);
			stackValueTermTranslation.push(addTerm);
		}else{
			//System.out.println("add to stackConditionTermTranslation: "+ addTerm);
			stackConditionTermTranslation.push(addTerm);
		}
	}
	
	//add pair (value: condition) created into map result
	public void add2MapResult(){
		Term value = null;
		Term condition = null;
		if(stackValueTermTranslation!=null)
			if(!stackValueTermTranslation.empty())
				value = stackValueTermTranslation.pop();
		
		if(stackConditionTermTranslation!=null)
			if(!stackConditionTermTranslation.empty())
				condition = stackConditionTermTranslation.pop();

		if(value!=null){
			if(condition==null) //if there is no condition, it means that the condition is true
				condition = services.getTermBuilder().tt();
			listResults.add(new CountingSolution(value, condition)); //condition can be null
		}
	}
	
	
	
	public void add2ListParameters(String paraName){
		Term paraTerm = TermUtil.createIntVarTerm(paraName, services);
		listParameters.add(paraTerm);
	}
	
	public String getIsccResultString() {
		return isccResultString;
	}



	public void setIsccResultString(String isccResultString) {
		this.isccResultString = isccResultString;
	}



	public TermBuilder getTermBuilder() {
		return termBuilder;
	}



	public TermFactory getTermFactory() {
		return termFactory;
	}



	public void translateIsccResult2MapTerm(){
		//Map<Term, Term> resultMap = new HashMap<Term, Term>();
		CountingResultLexer lexer = new CountingResultLexer(new ANTLRInputStream(isccResultString));
		
	    // Get a list of matched tokens
		CommonTokenStream tokens = new CommonTokenStream(lexer);	  
	    // Pass the tokens to the parser
	    CountingResultParser parser = new CountingResultParser(tokens);
	    // Specify our entry point
	    ResultContext resultContex = parser.result();
	    
	    // Walk it and attach our listener
	    
	    ParseTreeWalker walker = new ParseTreeWalker();
	    
	    ANTLRIsccResultListener listener = new ANTLRIsccResultListener();
	    listener.setTransformer(this);
	    
	    //listener.enterResult(result);
	    lexer.reset();
	    walker.walk(listener, resultContex);
	    //System.out.println("list Parameter: " + listParameters);	    
	}


	public List<CountingSolution> getListCountingResult() {
		return listResults;
	}
	
	private Term getPowerTerm(Term base, Term exponent){
		final IntegerLDT integerLDT = services.getTypeConverter().getIntegerLDT();
    	final Term zero = integerLDT.zero();
        final Term one = integerLDT.one();
        if(base.equals(zero))
        	return zero;
        else if(base.equals(one))
        	return one;
        else if(exponent.equals(zero))
        	return one;
        else if(exponent.equals(one))
        	return base;
        else if(TermParser.isIntegerConst(exponent)){
        	long exp = TermParser.getIntegerValue(exponent);
        	Term result = one;
        	for(int i=0;i<exp;i++)
        		result = termBuilder.mul(result, base);
        	return result;
        }else
        	return termBuilder.func(integerLDT.getPower(),base,exponent);
	}

	public void initStackTrioOp(){
		stackTrioOp = new Stack<Integer>();
	}
	
	public void add2StackTrioOp(int operator){
		if(stackTrioOp!=null)
			stackTrioOp.push(operator);
	}
	
	public void resolveTrioComparison(){
		//here it is obvious that we are working with condition
		Term t3 = stackConditionTermTranslation.pop();
		Term t2 = stackConditionTermTranslation.pop();
		Term t1 = stackConditionTermTranslation.pop();
		int op2 = stackTrioOp.pop();
		int op1= stackTrioOp.pop();
		/*
		 * trio comparison term has the form: t1 op1 t2 op2 t3
		 * we translate to and(op1(t1,t2), op2(t2,t3))
		 * */
		Term cp1 = synthTerm(t1, t2, op1);
		Term cp2 = synthTerm(t2, t3, op2);
		Term trioCompTerm = termBuilder.and(cp1, cp2);
		stackConditionTermTranslation.push(trioCompTerm);
		stackTrioOp = null;
	}
	
	
}
