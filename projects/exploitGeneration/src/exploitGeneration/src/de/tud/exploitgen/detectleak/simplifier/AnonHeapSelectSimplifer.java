package de.tud.exploitgen.detectleak.simplifier;

import java.util.Map;

import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConfig;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.logic.sort.SortImpl;

/*
 * this class simplifies all anon heap in the term in order to support for SMT Solver
 * the semantics of heap and anon heaps must be maintained
 * input: anon heap select function: select(anon(...), object, field)
 * solution:
 *    - if object is not changed inside anon(...) then we simplify anon by using default heap -> return select(heap, object, field)
 *    - if object is changed inside anon(...) (function allFields(object) exists) then
 *        + take the name of anon(...) (sub(2))
 *        + create new variable (fresh) from name of anon heap and object anon_object
 *        + return  select(heap, anon_object, field)
 * */
public class AnonHeapSelectSimplifer {
   private Term anonSelect; //is a anon heap select function
   private Services services;
   private TermBuilder termBuilder;
   
   /**
    * @param term
    * @param services
    */
   public AnonHeapSelectSimplifer(Term term, Services services) {
      super();
      this.anonSelect = term;
      this.services = services;
      termBuilder=new TermBuilder(new TermFactory(), services);      
   }
   
   public boolean objectChanged(){
      Term anonFunction = anonSelect.sub(0);
      Term object = anonSelect.sub(1);
      //TODO: how about allFields?
      if(TermUtil.isDescendant(object, anonFunction))
         return true;
      else
         return false;
   }
   
   public String getFreshObjectName(){      
      String anonHeapName = HeapHandler.getAnonHeapName(anonSelect.sub(0));
      String objectName = HeapHandler.getObjectNameOfSelect(anonSelect, KEGConfig.SEPARATOR);
      return anonHeapName + KEGConfig.SEPARATOR + objectName;
   }
   
   public Term resolveAnonHeapSelect(){
      Term object = anonSelect.sub(1);
      if(objectChanged()){         
         KeYJavaType type = services.getJavaInfo().getKeYJavaType(object.sort());
         Term freshObject = termBuilder.var(new LocationVariable(new ProgramElementName(getFreshObjectName()),type));
         return termBuilder.select(anonSelect.sort(), termBuilder.getBaseHeap(), freshObject, anonSelect.sub(2));
      }else{
         return termBuilder.select(anonSelect.sort(), termBuilder.getBaseHeap(), object, anonSelect.sub(2));
      }
   }
   
   
   
}
