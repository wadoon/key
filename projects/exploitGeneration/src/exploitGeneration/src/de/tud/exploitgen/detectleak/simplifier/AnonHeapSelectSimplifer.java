package de.tud.exploitgen.detectleak.simplifier;

import java.util.Map;

import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.tud.exploitgen.util.TermUtil;
//import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.logic.sort.SortImpl;

/*
 * this class simplifies all anon heap in the term in order to support for SMT Solver
 * the semantics of heap and anon heaps must be maintained
 * input: anon heap select function: select(anon(...), object, field)
 * solution:
 *    - if object is not changed inside anon(...) then we simplify anon by using default heap -> return select(heap, object, field)
 *    - if object is changed inside anon(...) (function allFields(object) exists) then
 *        + take the name of anon(...) (sub(2))
 *        + create new variable (fresh) from name of anon heap and object anon_object
 *        + return  select(heap, anon_object, field)
 * */
public class AnonHeapSelectSimplifer {
   private Term anonSelect; //is a anon heap select function
   private Services services;
   private TermBuilder termBuilder;
   
   /**
    * @param term
    * @param services
    */
   public AnonHeapSelectSimplifer(Term term, Services services) {
      super();
      this.anonSelect = term;
      this.services = services;
      termBuilder=new TermBuilder(new TermFactory(), services);      
   }
   
   /*
    * check if selecting object has been changed inside new heap (anon function)
    * it is changed if:
    * 	- there is allFields(object)
    * 	- there is store(heap, parentObj, obj, val)
    * 	
    * */
   public boolean objectChanged(){
      /*Term anonFunction = anonSelect.sub(0);
      Term object = anonSelect.sub(1);
      //TODO: how about allFields?
      if(TermUtil.isDescendant(object, anonFunction))
         return true;
      else
         return false;
*/	   
	   Term anonFunction = anonSelect.sub(0);
	   Term object = anonSelect.sub(1);
	   System.out.println("anonFunction: " + anonFunction);
	   System.out.println("object: " + object);
	      
	   if(TermUtil.isChangedByStoreFunction(object, anonFunction)){
		   System.out.println(object + " is changed inside: " + anonFunction);
	         return true;
	   }else
	         return false;

	   
   }
   
   
   
   
   
   public String getFreshObjectName(){      
      String anonHeapName = HeapHandler.getAnonHeapName(anonSelect.sub(0), services);
      String objectName = HeapHandler.getObjectNameOfSelect(anonSelect, KEGConstant.SEPARATOR, services);
      return anonHeapName + KEGConstant.SEPARATOR + objectName;
   }
   
   public Term resolveAnonHeapSelect(){
      Term object = anonSelect.sub(1);
      if(objectChanged()){         
         KeYJavaType type = services.getJavaInfo().getKeYJavaType(object.sort());
         Term freshObject = termBuilder.var(new LocationVariable(new ProgramElementName(getFreshObjectName()),type));
         return termBuilder.select(anonSelect.sort(), termBuilder.getBaseHeap(), freshObject, anonSelect.sub(2));
      }else{
         return termBuilder.select(anonSelect.sort(), termBuilder.getBaseHeap(), object, anonSelect.sub(2));
      }
   }
   
   public Term freshResolveAnonHeapSelect(){
	      Term object = anonSelect.sub(1);
	      
	      if(objectChanged()){         
	    	  Term anonHeap = anonSelect.sub(0).sub(2);
	         return termBuilder.select(anonSelect.sort(), anonHeap, object, anonSelect.sub(2));
	      }else{
	         return termBuilder.select(anonSelect.sort(), termBuilder.getBaseHeap(), object, anonSelect.sub(2));
	      }
	   }
   
}
