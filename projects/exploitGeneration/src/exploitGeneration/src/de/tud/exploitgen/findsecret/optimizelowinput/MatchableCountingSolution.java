package de.tud.exploitgen.findsecret.optimizelowinput;

import java.util.List;
import java.util.Map;

import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;

public class MatchableCountingSolution {
	private final List<CountingSolution> listCountingSolutions;
	private final Term conditionTerm;
	private final Map<String,Long> oneConcreteModel; //one of concrete model satisfying conditionTerm
	private final boolean uniqueModel; //true if there is only one concrete model satisfying conditionTerm
	
	public MatchableCountingSolution(List<CountingSolution> listCountTerms,
			Term conditionTerm, Map<String,Long> oneSolution, boolean uniqueSolution) {
		super();
		this.listCountingSolutions = listCountTerms;
		this.conditionTerm = conditionTerm;
		this.oneConcreteModel = oneSolution;
		this.uniqueModel = uniqueSolution;
	}
	
	public List<CountingSolution> getListCountingSolutions() {
		return listCountingSolutions;
	}
	public Term getConditionTerm() {
		return conditionTerm;
	}
	
		
	public Map<String, Long> getUniqueSolution() {
		return oneConcreteModel;
	}
	
	public boolean allCountTermsIsConstant(Services services){
		for( CountingSolution cSolution: listCountingSolutions)
			if(!TermParser.isIntegerConst(cSolution.getValue(), services))
				return false;
		
		return true;			
	}
	public void printInfo(){
		System.out.println("+++++");
		System.out.println("listCountTerms: \n");
		for(CountingSolution cs: listCountingSolutions)
			System.out.println("    " + cs.getValue() + " ; partitionIdx: " + cs.getPartitionIdx());
		System.out.println("conditionTerm: " + conditionTerm);
		System.out.println("+++++");
	}

	public Map<String, Long> getOneConcreteModel() {
		return oneConcreteModel;
	}

	public boolean isUniqueModel() {
		return uniqueModel;
	}

	
}
