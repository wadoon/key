package de.tud.exploitgen.findsecret.optimizelowinput;

import java.util.List;
import java.util.Map;

import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.logic.Term;

public class MatchableCountingSolution {
	private final List<Term> listCountTerms;
	private final Term conditionTerm;
	private final Map<String,Long> oneConcreteModel; //one of concrete model satisfying conditionTerm
	private final boolean uniqueModel; //true if there is only one concrete model satisfying conditionTerm
	
	public MatchableCountingSolution(List<Term> listCountTerms,
			Term conditionTerm, Map<String,Long> oneSolution, boolean uniqueSolution) {
		super();
		this.listCountTerms = listCountTerms;
		this.conditionTerm = conditionTerm;
		this.oneConcreteModel = oneSolution;
		this.uniqueModel = uniqueSolution;
	}
	
	public List<Term> getListCountTerms() {
		return listCountTerms;
	}
	public Term getConditionTerm() {
		return conditionTerm;
	}
	
		
	public Map<String, Long> getUniqueSolution() {
		return oneConcreteModel;
	}
	
	public boolean allCountTermsIsConstant(){
		for(Term countTerm: listCountTerms)
			if(!TermParser.isIntegerConst(countTerm))
				return false;
		
		return true;			
	}
	public void printInfo(){
		System.out.println("+++++");
		System.out.println("listCountTerms: \n");
		for(Term t: listCountTerms)
			System.out.println("    " + t);
		System.out.println("conditionTerm: " + conditionTerm);
		System.out.println("+++++");
	}

	public Map<String, Long> getOneConcreteModel() {
		return oneConcreteModel;
	}

	public boolean isUniqueModel() {
		return uniqueModel;
	}

	
}
