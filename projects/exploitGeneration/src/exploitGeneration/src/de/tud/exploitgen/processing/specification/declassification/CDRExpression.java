package de.tud.exploitgen.processing.specification.declassification;

import java.util.LinkedList;
import java.util.List;

import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
/**
 * DeclExpression: Declassification Expression: At the moment we use delimited release approach,
 * so declassification expression could be either escape hatch expression or conditional expression
 * */
public class CDRExpression {
   private final Term term; //an expression basically is a term
   public Services services; //a Services object containing extra information necessary to resolve DeclExpression
   private List<CDRExpression> subExpressions; //sub expression of DeclExpression
   private final String id; //id distinguish each sub expression in all level, useful for create "result" variable 
   public TermBuilder termBuilder;
   /**
    * @param term
    * @param services
    */
   public CDRExpression(Term term, Services services, String id) {
      super();
      this.term = term;
      this.services = services;   
      this.id = id;
      termBuilder = new TermBuilder(new TermFactory(),services);
      subExpressions = new LinkedList<CDRExpression>();      
      if(TermUtil.containProgramMethod(term)){ //we only concern term containing method invocation
         //for(Term sub: term.subs()){
         for(int i=0;i<term.subs().size();i++){
            Term sub = term.sub(i);
            //System.out.println("subs:: " + sub);            
            String idI = id+Integer.toString(i);
            if(TermParser.isProgramMethod(sub)){
               subExpressions.add(new CDRMethodInvocation(sub, services,idI));
            }else{
               subExpressions.add(new CDRExpression(sub,services,idI));
            }
         }
      }
      
   }

   public List<CDRExpression> getSubExpressions() {
      return subExpressions;
   }

   public String getId() {
      return id;
   }

   public Term getTerm() {
      return term;
   }

   
   public Services getServices() {
      return services;
   }

   public void setServices(Services services) {
      this.services = services;
   }
   
     
   /*get term that could be integrated in insecurity formula*/
   public Term getResolvedTerm(){
      if(term!=null){     
         if(subExpressions.size()==0) //this expression does not contain method invocation, simple return it
            return term;
         else{ //if it contains method invocation, we have to resolve method invocation
            Term[] st=new Term[term.subs().size()];         
            for(int i=0;i<st.length;i++){
               st[i] = subExpressions.get(i).getResolvedTerm();                 
            }
            return new TermFactory().createTerm(term.op(), st, term.boundVars(), term.javaBlock());
         }
      }else
         return null;
   }
   
   
   public Term getSynthesisMethodContract(){
      if(term!=null){         
         if(subExpressions.size()==0) //this expression does not contain method invocation, simple return true
            return new TermBuilder(new TermFactory(),services).tt();
         else{ //if it contains method invocation, we have to integrate with its method contract
            Term mc = termBuilder.tt();      
            for(CDRExpression subDE: subExpressions){
               //System.out.println("subDE:: " + subDE.getTerm());
               mc = termBuilder.and(mc,subDE.getSynthesisMethodContract());
            }
            return mc;
         }
      }else
         return null;
   }
}
