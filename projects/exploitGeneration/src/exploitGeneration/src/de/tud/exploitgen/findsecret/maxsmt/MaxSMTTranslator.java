package de.tud.exploitgen.findsecret.maxsmt;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.key_project.util.collection.ImmutableArray;

import de.tud.exploitgen.util.QuantifiedFunctionResolver;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.Equality;
import de.uka.ilkd.key.logic.op.Function;
import de.uka.ilkd.key.logic.op.IfThenElse;
import de.uka.ilkd.key.logic.op.Junctor;
import de.uka.ilkd.key.logic.op.Operator;
import de.uka.ilkd.key.logic.op.ProgramVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.logic.op.Quantifier;
import de.uka.ilkd.key.logic.sort.Sort;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.smt.NumberTranslation;
import de.uka.ilkd.key.smt.SMTComprehensionTranslator.TermUtil;
import de.uka.ilkd.key.smt.lang.SMTComprehensionFunction;
import de.uka.ilkd.key.smt.lang.SMTFunction;
import de.uka.ilkd.key.smt.lang.SMTSort;
import de.uka.ilkd.key.smt.lang.SMTTerm;
import de.uka.ilkd.key.smt.lang.SMTTermCall;
import de.uka.ilkd.key.smt.lang.SMTTermMultOp;
import de.uka.ilkd.key.smt.lang.SMTTermNumber;
import de.uka.ilkd.key.smt.lang.SMTTermVariable;
import de.uka.ilkd.key.util.Debug;
import de.uka.ilkd.key.util.Pair;

public class MaxSMTTranslator {
	//each MaxSMT clause has a weight
	private final MaxSMTProblem problem;
	public Services services;
	
	private Map<String, SMTFunction> functions; // all variables and SMT clauses are stored as function
	private List<QuantifiableVariable> listQVars; // list of all quantifiable variables
	private List<SMTTerm> comprehensionAxioms; //list of all axioms for comprehension operations	
	private List<SMTComprehensionFunction> listComprehensionFunctions;
	private Map<Operator, SMTTermMultOp.Op> opTable;
	/**
	 * List of current quantified variables.
	 */
	private List<SMTTermVariable> quantifiedVariables;
	// some special KeY sorts
	private Sort integerSort;
	private Sort boolSort;
	
	/*private Sort heapSort;
	private Sort fieldSort;
	private Sort locsetSort;
	private Sort seqSort;
	private Sort objectSort;*/
	
	private int funcIdx; //added by Huy
	public MaxSMTTranslator(MaxSMTProblem problem, Services services) {
		super();
		this.problem = problem;
		this.services = services;
		
		functions = new HashMap<String, SMTFunction>();
		listQVars = new LinkedList<QuantifiableVariable>();
		comprehensionAxioms = new LinkedList<SMTTerm>();
		listComprehensionFunctions = new LinkedList<SMTComprehensionFunction>();
		quantifiedVariables = new LinkedList<SMTTermVariable>();
		funcIdx =0;
		initOpTable();
		initSorts();
	} 
	
	

	public MaxSMTFile translateMaxSMTProblem() throws IllegalFormulaException {
		Map<String,Pair<Term,Long>> mapMaxSMTClauses2Weight = problem.getMapMaxSMTClauses2Weight();
		List<Term> listConstraints = problem.getListConstraints();
		MaxSMTFile file = new MaxSMTFile();
		//extract listQvars (added by Huy)
		for(String clauseName: mapMaxSMTClauses2Weight.keySet())			
			extractListQvars(mapMaxSMTClauses2Weight.get(clauseName).first);
		for(Term t: listConstraints)
			extractListQvars(t);
		//translate all constraints to functions
		for(Term constrant: listConstraints){
			SMTTerm smtConstraint= translateTerm(constrant);
			file.addFormula(smtConstraint);
		}
		//translate max-smt clauses to functions
		List<MaxSMTFunction> listTempFunctions = new LinkedList<MaxSMTFunction>();
		for(String clauseName: mapMaxSMTClauses2Weight.keySet()){
			SMTTerm assertion = translateTerm(mapMaxSMTClauses2Weight.get(clauseName).first);
			file.addMaxSMTClauseName(clauseName);
			MaxSMTFunction maxSMT = new MaxSMTFunction(clauseName, SMTSort.BOOL, assertion, mapMaxSMTClauses2Weight.get(clauseName).second);
			listTempFunctions.add(maxSMT);
		}
		
		
	
		//add all functions
		for(String funcId: functions.keySet())
			file.addFunction(functions.get(funcId));
		
		for(MaxSMTFunction maxSMT: listTempFunctions)
			file.addFunction(maxSMT);
		
		
		//add axioms for comprehension operation (bsum, max, min)
		file.addFormulas(comprehensionAxioms);
		
		
		return file;
	}
	
	public SMTTerm translateTerm(Term term) throws IllegalFormulaException {
		//System.err.println("Translate: "+term);
		Operator op = term.op();
		if (opTable.containsKey(op)) {
			SMTTerm left = translateTerm(term.sub(0));
			SMTTerm right = translateTerm(term.sub(1));
			List<SMTTerm> subs = new LinkedList<SMTTerm>();
			subs.add(left); subs.add(right);
			return new SMTTermMultOp(opTable.get(op), subs);
			//return left.multOp(opTable.get(op), right);
		
		} else if (op == Junctor.NOT) {
			SMTTerm sub = translateTerm(term.sub(0));
			return sub.not();
		
		} else if (op == IfThenElse.IF_THEN_ELSE) {
			SMTTerm condition = translateTerm(term.sub(0));
			SMTTerm trueCase = translateTerm(term.sub(1));
			SMTTerm falseCase = translateTerm(term.sub(2));
			return SMTTerm.ite(condition, trueCase, falseCase);
		
		} else if (op == Quantifier.ALL) {
			ImmutableArray<QuantifiableVariable> vars = term.varsBoundHere(0);
			Debug.assertTrue(vars.size() == 1);
			SMTTermVariable var = translateVariable(vars.get(0));
			List<SMTTermVariable> variables = new LinkedList<SMTTermVariable>();
			quantifiedVariables.add(var);
			variables.add(var);
			Sort sort = vars.get(0).sort();
			String sortName = sort.name().toString();
			SMTTerm sub = translateTerm(term.sub(0));
			SMTTerm result = SMTTerm.forall(variables, sub, null);
			quantifiedVariables.remove(quantifiedVariables.size() - 1);
			return result;
		
		} else if (op == Quantifier.EX) {
			ImmutableArray<QuantifiableVariable> vars = term.varsBoundHere(0);
			Debug.assertTrue(vars.size() == 1);
			SMTTermVariable var = translateVariable(vars.get(0));
			List<SMTTermVariable> variables = new LinkedList<SMTTermVariable>();
			quantifiedVariables.add(var);
			variables.add(var);
			Sort sort = vars.get(0).sort();
			String sortName = sort.name().toString();
			SMTTerm sub = translateTerm(term.sub(0));
			SMTTerm result = SMTTerm.exists(variables, sub, null);
			quantifiedVariables.remove(quantifiedVariables.size() - 1);
			return result;
		
		} else if (op == Junctor.TRUE) {
			return SMTTerm.TRUE;
		} else if (op == Junctor.FALSE) {
			return SMTTerm.FALSE;
		
		} else if (op instanceof QuantifiableVariable) {
			// translate as variable or constant
			QuantifiableVariable qop = (QuantifiableVariable) op;
			SMTTermVariable var = translateVariable((QuantifiableVariable) op);
			if (quantifiedVariables.contains(var)) {
				return var;
			} else {
				// System.err.println("Create constant: "+var);
				SMTFunction constant = translateConstant(var.getId(),
				        qop.sort());
				return SMTTerm.call(constant);
			}
		} else if (op instanceof ProgramVariable) {
			ProgramVariable pv = (ProgramVariable) op;
			SMTFunction constant = translateConstant(pv.name().toString(),
			        pv.sort());
			return SMTTerm.call(constant);
		} else if (op == services.getTypeConverter().getIntegerLDT()
		        .getNumberSymbol()) {
			Debug.assertTrue(term.arity() == 1);
			
			long num = NumberTranslation.translate(term.sub(0)).longValue();
			
			return new SMTTermNumber(num, 0, SMTSort.INT);
		}
		/*
		 * added by Huy to resolve comprehension operations (bsum, max, min)
		 * */
		else if(TermUtil.isBSumFunction(term, services)){                                        
         List<QuantifiableVariable> listQVarsInside = extractListQVarInComprehension(term);
       	 System.out.println("listQVarsInSum:: " + listQVarsInside);
       	 SMTTerm result = resolveComprehensionFunction(term, funcIdx, listQVarsInside, TermUtil.BSUM);
       	 System.out.println("bsum function: " + result);
       	 funcIdx++;
       	 return result;
        }
		else if(TermUtil.isMaxFunction(term)){                                        
	         List<QuantifiableVariable> listQVarsInside = extractListQVarInComprehension(term);
	       	 System.out.println("listQVarsInMax:: " + listQVarsInside);
	       	 SMTTerm result = resolveComprehensionFunction(term, funcIdx, listQVarsInside, TermUtil.MAX);
	       	 System.out.println("max function: " + result);
	         funcIdx++;
	         return result;
	     }
		else if(TermUtil.isMinFunction(term)){                                        
	         List<QuantifiableVariable> listQVarsInside = extractListQVarInComprehension(term);
	       	 System.out.println("listQVarsInMin:: " + listQVarsInside);
	       	 SMTTerm result = resolveComprehensionFunction(term, funcIdx, listQVarsInside, TermUtil.MIN);
	       	 System.out.println("min function: " + result);
	            funcIdx++;
	            return result;
	     }
		else if(TermUtil.isJavaBitwiseXOrInt(term)){
			SMTTerm left = translateTerm(term.sub(0));
			SMTTerm right = translateTerm(term.sub(1));
			
			return left.multOp(SMTTermMultOp.Op.BVXOR, right);
		}
		/*-----------------------------------------*/
		else if (op instanceof Function) {			
			Function fun = (Function) op;
			if (isTrueConstant(fun, services)) {
				return SMTTerm.TRUE;
			} else if (isFalseConstant(fun, services)) {
				return SMTTerm.FALSE;
			} else if (fun == services.getTypeConverter().getIntegerLDT()
			        .getNeg() ||(op.name().toString().equals("javaUnaryMinusInt"))) {
				SMTTerm left = new SMTTermNumber(0, 0,
				        SMTSort.INT);
				SMTTerm right = translateTerm(term.sub(0));
				return left.minus(right);
			} else {
				return translateCall(fun, term.subs());
			}
		} else {
			String msg = "Unable to translate " + term + " of type "
			        + term.getClass().getName();
			throw new RuntimeException(msg);
		}
	}
	
	private void add2ListQVars(QuantifiableVariable qv){
		 //add quantifiable variable into listQVars
		   //Term qvTerm = services.getTermBuilder().var(qv);
		   if(!TermUtil.inListQVar(qv, listQVars)){
		    	  listQVars.add(qv);
		      }
	   }
	 
	 /*
    * return true if sum function contains quantifiable variables
    * */
   private List<QuantifiableVariable> extractListQVarInComprehension(Term comprehensionTerm){
	   List<QuantifiableVariable> result = new LinkedList<QuantifiableVariable>();
	   ImmutableArray<QuantifiableVariable> listQuans = comprehensionTerm.boundVars();
	   System.out.println("listQVars:: " + listQVars);
	   System.out.println("listQuans:: " + listQuans);
	   for(QuantifiableVariable qvar: listQVars){
		   if(!TermUtil.inArrayQVar(qvar, listQuans)){
			   if(TermUtil.isDescendantQVar(comprehensionTerm, qvar, services)){
				   result.add(qvar);
			   }
		   }
	   }	   
	   return result;
   }
   
   /*
    * parse all quantifiable variables (except in comprehension operations) to listQvars
    * */
   private void extractListQvars(final Term term) {
      if(term!=null){
    	  if(term.boundVars()!=null){
               if(term.boundVars().size()>0){
                  if(!TermUtil.isComprehension(term, services)){ //TODO: how about comprehension bounded by another comprehension?
                	  for(QuantifiableVariable qv: term.boundVars())
                		  add2ListQVars(qv);
                  }
               }
            }
    	  for(Term t: term.subs()){
    		  extractListQvars(t);
    	  }
         }
      
   }
   
   
   private SMTTerm resolveComprehensionFunction(Term term, int idx, List<QuantifiableVariable> listQVarsInComprehension, String comprehensionName) throws IllegalFormulaException {
	     if(term.boundVars()==null){
            return null;
         }else{
        	System.out.println("comprehension term: "+ term);
            ImmutableArray<QuantifiableVariable> boundVars = term.boundVars();
            if(boundVars.size()>1)      //at the moment we only deal with comprehension that has only one index variable         
               return null;
            else{              
            	Pair<Pair<Term,Term>, Pair<QuantifiableVariable,Term>> basicInfo = extractBoundNCaclInfo(term, comprehensionName)   ;
               Term lowerBoundTerm = basicInfo.first.first;
               Term upperBoundTerm = basicInfo.first.second;
               QuantifiableVariable idxVar = basicInfo.second.first;
               Term calcTerm = basicInfo.second.second;
               
               SMTTerm lowerBound = translateTerm(lowerBoundTerm);
               SMTTerm upperBound = translateTerm(upperBoundTerm);
               SMTTerm calcSMTTerm = translateTerm(calcTerm);
               
   				SMTTermVariable idxTermVar = translateVariable(idxVar);
              
   				List<SMTSort> boundSorts = new LinkedList<SMTSort>();
   				boundSorts.add(lowerBound.sort());
   				boundSorts.add(upperBound.sort());
   				
   				List<SMTTermVariable> outQVarSMTTerms = new LinkedList<SMTTermVariable>();
   				List<SMTSort> outQVarSorts = new LinkedList<SMTSort>();
   				for(QuantifiableVariable qvar: listQVarsInComprehension){
   					SMTTermVariable qvarSMTTerm = translateVariable(qvar);
   					outQVarSMTTerms.add(qvarSMTTerm);
   					outQVarSorts.add(qvarSMTTerm.sort());
   				}
               
   				SMTSort imageSort = translateSort(term.sort());
               /*
                * create comprehension function, calculation function 
                * */               
               SMTComprehensionFunction comprehension = createSMTComprehensionFunction(idx, boundSorts, outQVarSorts, imageSort, comprehensionName, calcTerm, idxVar);	              
               SMTFunction calc = comprehension.getCalcFunction();
               System.out.println("comprehension:" +comprehension);
               System.out.println("calc:" +calc);
               
               List<SMTTerm> allParams = new LinkedList<SMTTerm>();
                  allParams.add(lowerBound);
                  allParams.add(upperBound);	
                  allParams.addAll(outQVarSMTTerms);
                  
               //looking for the identical function in listQFuncsE               
               SMTComprehensionFunction idenFunc = comprehension.searchIdentical(listComprehensionFunctions, services);
               if(idenFunc!=null){
                  //if there is an identical function available in listFuncs, then use it     
                  comprehension = idenFunc;
                  calc = idenFunc.getCalcFunction();
                  
                  //we do not need to add axiom for available comprehension function
                  
                  SMTTerm applyComprehension = SMTTerm.call(comprehension, allParams);	     
                  
                  return applyComprehension;
               }else{
            	   //otherwise, add comprehension into listFuncs
            	   listComprehensionFunctions.add(comprehension);
            	   
            	   //add comprehension and calc into functions
            	   functions.put(comprehension.getId(), comprehension);
            	   functions.put(calc.getId(), calc);
               }
               /*
                * create axiom for calc
                * basically calc's axiom is computational constraint of calc
                * \forall idx,p: calc(idx,p)=calcTerm(idx,p)
                * */
               SMTTerm calcAxiom = buildCalcAxiom(calc, calcSMTTerm, idxTermVar, outQVarSMTTerms,lowerBound, upperBound);
               System.out.println("calcAxiom:: "+calcAxiom);

               //create axioms for comprehension
               SMTTerm bsumAxiom = buildAxioms4Comprehension(comprehension, lowerBound.sort(), outQVarSorts, comprehensionName,lowerBound, upperBound);
              
               
              //make aggrigated axiom
               SMTTerm axiom = calcAxiom.and(bsumAxiom);
               comprehensionAxioms.add(axiom);
               SMTTerm applyComprehension = SMTTerm.call(comprehension, allParams);
              	     
              return applyComprehension;
            }
         }         
	      
   }
   
   private List<SMTTermVariable> createListIntExpr(List<SMTSort> qvarSorts) {
	   List<SMTTermVariable> result = new LinkedList<SMTTermVariable>();
	   for(int i=0;i<qvarSorts.size();i++){
		   SMTTermVariable p = new SMTTermVariable("p_"+i,qvarSorts.get(i));
		   result.add(p);
	   }
	   return result;
   }
   
   /*
   * create axiom for bsum(x,y,p), includes:
   *  - axiom 1: (x>y)=> bsum(x,y,p) = 0 
   *   - axiom 2: (x==y)=> bsum = calc(y,p)
   *   - axiom 3: (x<y)=> bsum = calc(y,p) + bsum(x,y-1,p)
   *   - axiom 4: (x<=k<=y)=> bsum(x,y,p) = bsum(x,k,p) + bsum(k+1,y,p)
   *   - axiom 5: (x<y)=> bsum = calc(x,p) + bsum(x+1,y,p)
   * */

   /*
   * create axiom for max(x,y,p), includes:
   *   - axiom 1: (x>y)=> max(x,y,p) = Long.MIN_VALUE
   *   - axiom 2: (x==y)=> max(x,y,p) = calc(x,p)
   *   - axiom 3: (x<y)=> max(x,y,p) = ite(calc(y,p)>max(x,y-1,p)?calc(y,p);max(x,y-1,p))
   *   - axiom 4: (x<=k<=y)=> max(x,y,p) = ite(max(x,k,p) > max(k+1,y,p)?max(x,k,p);max(k+1,y,p))
   *   - axiom 5: (x<y)=> max(x,y,p) = ite(calc(x,p)>max(x+1,y,p)?calc(x,p);max(x+1,y,p))
   * */
   
   /*
   * create axiom for min(x,y,p), includes:
   *   - axiom 1: (x>y)=> min(x,y,p) = Long.MAX_VALUE
   *   - axiom 2: (x==y)=> min(x,y,p) = calc(y,p)
   *   - axiom 3: (x<y)=> min(x,y,p) = ite(calc(y,p)<min(x,y-1,p)?calc(y,p);min(x,y-1,p))
   *   - axiom 4: (x<=k<=y)=> min(x,y,p) = ite(min(x,k,p) < min(k+1,y,p)?min(x,k,p);min(k+1,y,p))
   *   - axiom 5: (x<y)=> min(x,y,p) = ite(calc(x,p)<max(x+1,y,p)?calc(x,p);min(x+1,y,p))
   * */
   private SMTTerm buildAxioms4Comprehension(SMTComprehensionFunction comprehension, SMTSort boundSort, List<SMTSort> qvarSorts, String comprehensionName, SMTTerm lowerBound, SMTTerm upperBound){
	   SMTFunction calc = comprehension.getCalcFunction();
       SMTTermVariable x = new SMTTermVariable("x", boundSort);
       SMTTermVariable y = new SMTTermVariable("y", boundSort);   

       List<SMTTermVariable> params = createListIntExpr(qvarSorts);
       
       
       List<SMTTerm> xyp = new LinkedList<SMTTerm>();
       xyp.add(x);
       xyp.add(y);
       xyp.addAll(params);
       
       SMTTerm compre_xyp =  SMTTerm.call(comprehension, xyp);
       
       /*  axiom 1:
        * (x>y)=> bsum(x,y,p) = 0 
        * (x>y)=> max(x,y,p) = Long.MIN_VALUE
        * (x>y)=> min(x,y,p) = Long.MAX_VALUE 
        * 
        * */
       SMTTerm axiom1 = (x.gt(y)).implies(compre_xyp.equal(createValue4EmptyRange(comprehensionName)));
       
       /* - axiom 2:  
        * 	(x==y)=> bsum = calc(y,p)
			(x==y)=> max(x,y,p) = calc(y,p) 
			(x==y)=> min(x,y,p) = calc(y,p)
        * */      
       List<SMTTerm> yp = new LinkedList<SMTTerm>();
       yp.add(y);
       yp.addAll(params);
       SMTTerm calc_yp = SMTTerm.call(calc, yp);
       SMTTerm axiom2 = (x.equal(y)).implies(compre_xyp.equal(calc_yp));
       
       
       /*- axiom 3: 
        * (x<y)=> bsum = calc(y,p) + bsum(x,y-1,p)
        * (x<y)=> max(x,y,p) = ite(calc(y,p)>max(x,y-1,p)?calc(y,p);max(x,y-1,p)) 
        * (x<y)=> min(x,y,p) = ite(calc(y,p)<min(x,y-1,p)?calc(y,p);min(x,y-1,p))
        * */
       
       
	   List<SMTTerm> xyminus1p = new LinkedList<SMTTerm>();
       xyminus1p.add(x);
       xyminus1p.add(y.minus(new SMTTermNumber(1,0,SMTSort.INT)));
       xyminus1p.addAll(params);
       SMTTerm compre_xyminus1p = SMTTerm.call(comprehension, xyminus1p);
       SMTTerm axiom3 = (x.lt(y)).implies
    		   (compre_xyp.equal(
    				   createComparingExpr4ComprehensionAxiom(calc_yp, compre_xyminus1p, comprehensionName)));
       
       
       /* - axiom 4: 
        * (x<=k<=y)=> bsum(x,y,p) = bsum(x,k,p) + bsum(k+1,y,p)
        * (x<=k<=y)=> max(x,y,p) = ite(max(x,k,p) > max(k+1,y,p)?max(x,k,p);max(k+1,y,p)) 
        * (x<=k<=y)=> min(x,y,p) = ite(min(x,k,p) < min(k+1,y,p)?min(x,k,p);min(k+1,y,p))
        * */
       SMTTermVariable k = new SMTTermVariable("k", boundSort);
       List<SMTTerm> xkp = new LinkedList<SMTTerm>();
       xkp.add(x);
       xkp.add(k);
       xkp.addAll(params);
       SMTTerm compre_xkp = SMTTerm.call(comprehension, xkp);       
       List<SMTTerm> kplus1yp = new LinkedList<SMTTerm>();
       kplus1yp.add(k.plus(new SMTTermNumber(1,0,SMTSort.INT)));
       kplus1yp.add(y);
       kplus1yp.addAll(params);
       SMTTerm compre_kplus1yp = SMTTerm.call(comprehension, kplus1yp);
       SMTTerm middleTerm = ((x.lte(k)).and(k.lte(y))).implies
    		   (compre_xyp.equal(createComparingExpr4ComprehensionAxiom(compre_xkp, compre_kplus1yp, comprehensionName)));
       
       SMTTerm axiom4 = SMTTerm.forall(k, middleTerm, null);
    		   
       
       /*- axiom 5:
        * (x<y)=> bsum = calc(x,p) + bsum(x+1,y,p) 
        * (x<y)=> max(x,y,p) = ite(calc(x,p)>max(x+1,y,p)?calc(x,p);max(x+1,y,p)) 
        * (x<y)=> min(x,y,p) = ite(calc(x,p)<max(x+1,y,p)?calc(x,p);min(x+1,y,p))
        * */
       List<SMTTerm> xp = new LinkedList<SMTTerm>();
       xp.add(x);
       xp.addAll(params);
       SMTTerm calc_xp = SMTTerm.call(calc, xp);
       List<SMTTerm> xplus1yp = new LinkedList<SMTTerm>();
       xplus1yp.add(x.plus(new SMTTermNumber(1,0,SMTSort.INT)));
       xplus1yp.add(y);
       xplus1yp.addAll(params);
       SMTTerm compre_xplus1yp = SMTTerm.call(comprehension, xplus1yp);
       SMTTerm axiom5 = (x.lt(y)).implies(compre_xyp.equal(createComparingExpr4ComprehensionAxiom(calc_xp, compre_xplus1yp, comprehensionName)));
       
       List<SMTTerm> listAxioms = new LinkedList<SMTTerm>();
       listAxioms.add(axiom1);
       listAxioms.add(axiom2);
       listAxioms.add(axiom3);
       listAxioms.add(axiom4);
       listAxioms.add(axiom5);
       /*List<SMTTermVariable> xy = new LinkedList<SMTTermVariable>();
       xy.add(x);
       xy.add(y);*/
       SMTTerm boundCondition = ((x.gte(lowerBound)).and(x.lt(upperBound))).and((y.gte(lowerBound)).and(y.lt(upperBound)));
       List<SMTTermVariable> boundXYP = new LinkedList<SMTTermVariable>();
       boundXYP.add(x);
       boundXYP.add(y);
       boundXYP.addAll(params);
       SMTTerm comprehensionAxiom = SMTTerm.forall(boundXYP, boundCondition.implies(SMTTerm.and(listAxioms)), null);
       return comprehensionAxiom;
   }

   private SMTTerm buildCalcAxiom(SMTFunction calc, SMTTerm calcTermExpr, SMTTermVariable idx, List<SMTTermVariable> qvarExprs, SMTTerm lowerBound, SMTTerm upperBound) {
	   /*
        * create axiom for calc
        * basically calc's axiom is computational constraint of calc
        * \forall idx,p: lowerBound <= idx < upperBound ; calc(idx,p)=calcTerm(idx,p)
        * */
       List<SMTTerm> paramsOfCalc = new LinkedList<SMTTerm>();
       paramsOfCalc.add(idx);
       paramsOfCalc.addAll(qvarExprs);
       SMTTerm calcApp = SMTTerm.call(calc, paramsOfCalc);
       SMTTerm equalExpr = ((idx.gte(lowerBound)).and(idx.lt(upperBound))).implies(
    		   calcApp.equal(calcTermExpr));
       
       List<SMTTermVariable> quanParamsOfCalc = new LinkedList<SMTTermVariable>();
       quanParamsOfCalc.add(idx);
       quanParamsOfCalc.addAll(qvarExprs);
       SMTTerm calcAxiom = SMTTerm.forall(quanParamsOfCalc, equalExpr, null);
       
       return calcAxiom;
   }
   
   private SMTTerm createComparingExpr4ComprehensionAxiom(SMTTerm p1, SMTTerm p2, String comprehensionName){
	   if(comprehensionName.equals(TermUtil.BSUM))
		   return p1.plus(p2);
	   else if (comprehensionName.equals(TermUtil.MAX))
		   return SMTTerm.ite(p1.gt(p2), p1, p2);
	   else if (comprehensionName.equals(TermUtil.MIN))
		   return SMTTerm.ite(p1.lt(p2), p1, p2);
	   else 
		   return null;
   }
   
   private SMTTerm createValue4EmptyRange(String comprehensionName){

	   if(comprehensionName.equals(TermUtil.BSUM))
		   return new SMTTermNumber(0,0,SMTSort.INT);
	   else if (comprehensionName.equals(TermUtil.MAX))
		   return new SMTTermNumber(Long.MIN_VALUE); 
	   else if (comprehensionName.equals(TermUtil.MIN))
		   return new SMTTermNumber(Long.MAX_VALUE);
	   else 
		   return null;
   }
   
   
   /*
    * extract necessary information from comprehension:
    * @return ((lowerBoundTerm,upperBoundTerm),(idx, calcTerm)) 
    * */
   private Pair<Pair<Term,Term>, Pair<QuantifiableVariable,Term>> extractBoundNCaclInfo(Term term, String comprehensionName){
	   Term lowerBoundTerm, upperBoundTerm, calcTerm;
	   QuantifiableVariable idx;
	   if(comprehensionName.equals(TermUtil.BSUM)){
		   lowerBoundTerm = term.sub(0);
		   upperBoundTerm = term.sub(1);
		   calcTerm = term.sub(2);
		   idx = term.boundVars().get(0); //asume that there is only one quantifiable variable
	   }else{
		   QuantifiedFunctionResolver qfr = new QuantifiedFunctionResolver(term, services);
		   lowerBoundTerm = qfr.getLowerVal();
		   upperBoundTerm = qfr.getUpperVal();
		   calcTerm = qfr.getCalcTerm();
		   idx = qfr.getQuantifiableVariable();
	   }
	   return new Pair<Pair<Term,Term>, Pair<QuantifiableVariable,Term>>(new Pair<Term,Term>(lowerBoundTerm,upperBoundTerm), new Pair<QuantifiableVariable,Term>(idx, calcTerm));
   } 
   
   

   /*
    * each comprehension operator (bsum, max, min) can be translated using two function in Z3: 
    *  - a function describing it
    *  - a function describing how to calculate it
    * */
   
   private SMTComprehensionFunction createSMTComprehensionFunction(int fIdx, List<SMTSort> boundSorts, List<SMTSort> outQVarSorts, SMTSort imageSort, String comprehensionName, Term calcTerm, QuantifiableVariable qvar) {
	   int numParams = outQVarSorts.size();
	   List<SMTSort> calcSorts = new LinkedList<SMTSort>();
	   calcSorts.add(boundSorts.get(0));
	   calcSorts.addAll(outQVarSorts);
	   SMTFunction calc = new SMTFunction(generateComprehensionPrefix(numParams)+comprehensionName+"_calc_" + fIdx, calcSorts, imageSort);
	   calc.setComment("calc function of comprehension operation");
	   
	   List<SMTSort> domainSorts = new LinkedList<SMTSort>();
	   domainSorts.addAll(boundSorts);
	   domainSorts.addAll(outQVarSorts);
	   SMTComprehensionFunction comprehension= new SMTComprehensionFunction(generateComprehensionPrefix(numParams)+comprehensionName+"_" + fIdx, domainSorts, imageSort, calc, calcTerm, qvar, comprehensionName);
	   comprehension.setComment("comprehension operation");
	   return comprehension;
   }

   private String generateComprehensionPrefix(int numOfOutQVars){
	   if(numOfOutQVars==0)
		   return "";
	   else if(numOfOutQVars==1)
		   return "tri_";
	   else if(numOfOutQVars==2)
		   return "quadri_";
	   else if(numOfOutQVars==3)
		   return "penta_";
	   else if(numOfOutQVars==4)
		   return "hexa_";
	   else if(numOfOutQVars==5)
		   return "septa_";
	   else if(numOfOutQVars==6)
		   return "octa_";
	   else if(numOfOutQVars==7)
		   return "nona_";
	   else if(numOfOutQVars==8)
		   return "deca_";
	   else return generateComprehensionPrefix(0);
	   
   }
   
   /*------------finish adding------------*/

   /**
	 * Fills the operator table.
	 */
	private void initOpTable() {
		opTable = new HashMap<Operator, SMTTermMultOp.Op>();
		opTable.put(Junctor.AND, SMTTermMultOp.Op.AND);
		opTable.put(Junctor.OR, SMTTermMultOp.Op.OR);
		opTable.put(Junctor.IMP, SMTTermMultOp.Op.IMPLIES);
		opTable.put(Equality.EQUALS, SMTTermMultOp.Op.EQUALS);
		opTable.put(Equality.EQV, SMTTermMultOp.Op.EQUALS);
		opTable.put(services.getTypeConverter().getIntegerLDT().getLessThan(),
		        SMTTermMultOp.Op.LT);
		opTable.put(services.getTypeConverter().getIntegerLDT()
		        .getLessOrEquals(), SMTTermMultOp.Op.LTE);
		opTable.put(services.getTypeConverter().getIntegerLDT()
		        .getGreaterThan(), SMTTermMultOp.Op.GT);
		opTable.put(services.getTypeConverter().getIntegerLDT()
		        .getGreaterOrEquals(), SMTTermMultOp.Op.GTE);
		opTable.put(services.getTypeConverter().getIntegerLDT().getAdd(),
		        SMTTermMultOp.Op.PLUS);
		opTable.put(services.getTypeConverter().getIntegerLDT().getSub(),
		        SMTTermMultOp.Op.MINUS);
		opTable.put(services.getTypeConverter().getIntegerLDT().getMul(),
		        SMTTermMultOp.Op.MUL);
		opTable.put(services.getTypeConverter().getIntegerLDT().getJavaMulInt(),
		        SMTTermMultOp.Op.MUL);
		opTable.put(services.getTypeConverter().getIntegerLDT().getJavaMulLong(),
		        SMTTermMultOp.Op.MUL);
		opTable.put(services.getTypeConverter().getIntegerLDT().getDiv(),
		        SMTTermMultOp.Op.DIV);
		opTable.put(services.getTypeConverter().getIntegerLDT().getJDivision(),
		        SMTTermMultOp.Op.DIV);
		opTable.put(services.getTypeConverter().getIntegerLDT().getMod(),
				SMTTermMultOp.Op.MOD);
	}
	
	/**
	 * Translates a quantified variable.
	 * 
	 * @param q
	 * @return
	 * @throws IllegalFormulaException 
	 */
	private SMTTermVariable translateVariable(QuantifiableVariable q) throws IllegalFormulaException {
		SMTSort s = translateSort(q.sort());
		SMTTermVariable var = new SMTTermVariable(q.name().toString(), s);
		return var;
	}
	
	/**
	 * Translates a KeY sort to an SMT sort.
	 * 
	 * @param s
	 * @return
	 * @throws IllegalFormulaException 
	 */
	private SMTSort translateSort(Sort s) throws IllegalFormulaException {
		if (s.equals(boolSort)) {
			return SMTSort.BOOL;
		} else if (s.equals(Sort.FORMULA)) {
			return SMTSort.BOOL;
		} else if (s.equals(integerSort)) {
			return SMTSort.INT;
		} else {		
			throw new IllegalFormulaException(
			        "Translation Failed: Unsupported Sort: " + s.name());
		}
	}
	
	/**
	 * Get special KeY sorts that we need.
	 */
	private void initSorts() {
		// KeY Sorts
		boolSort = services.getTypeConverter().getBooleanLDT().targetSort();
		integerSort = services.getTypeConverter().getIntegerLDT().targetSort();
		
		/*seqSort = services.getTypeConverter().getSeqLDT().targetSort();
		heapSort = services.getTypeConverter().getHeapLDT().targetSort();
		fieldSort = services.getTypeConverter().getHeapLDT().getFieldSort();
		locsetSort = services.getTypeConverter().getLocSetLDT().targetSort();
		objectSort = services.getJavaInfo().getJavaLangObject().getSort();		*/
	}

	private SMTFunction translateConstant(String id, Sort s) throws IllegalFormulaException {
		if (functions.containsKey(id)) {
			return functions.get(id);
		}
		SMTSort imageSort = translateSort(s);
		List<SMTSort> domainSorts = new LinkedList<SMTSort>();
		SMTFunction fun = new SMTFunction(id, domainSorts, imageSort);
		functions.put(id, fun);
		return fun;
	}
	
	private boolean isTrueConstant(Operator o, Services s) {
		return o.equals(s.getTypeConverter().getBooleanLDT().getTrueConst());
	}

	private boolean isFalseConstant(Operator o, Services s) {
		return o.equals(s.getTypeConverter().getBooleanLDT().getFalseConst());
	}
	

	/**
	 * Translates a function call of function f with argument subs.
	 * 
	 * @param fun
	 * @param subs
	 * @return
	 * @throws IllegalFormulaException 
	 */
	private SMTTerm translateCall(Function fun, ImmutableArray<Term> subs) throws IllegalFormulaException {
		String name = fun.name().toString();
		SMTFunction function;
		if (functions.containsKey(name)) {
			function = functions.get(name);
		}  
		else {
			System.out.println("nondefined function:" +fun.name().toString());
			List<SMTSort> domainSorts = new LinkedList<SMTSort>();
			for (int i = 0; i < fun.argSorts().size(); ++i) {
				Sort s = fun.argSort(i);
				domainSorts.add(translateSort(s));
			}
			SMTSort imageSort = translateSort(fun.sort());
			function = new SMTFunction(name, domainSorts, imageSort);
			functions.put(name, function);
			// add type assertion if necessary
		}
		if (function == null) {
			System.err.println("Null function " + name);
		}
		return call(function, subs);
	}
	
	/**
	 * Creates an SMTTermCall using the given function and arguments.
	 * 
	 * @param function
	 * @param subs
	 * @return
	 * @throws IllegalFormulaException 
	 */
	private SMTTerm call(SMTFunction function, ImmutableArray<Term> subs) throws IllegalFormulaException {
		List<SMTTerm> subTerms = new LinkedList<SMTTerm>();
		for (Term t : subs) {
			SMTTerm sub = translateTerm(t);
			subTerms.add(sub);
		}
		return SMTTerm.call(function, subTerms);
	}


}
	
