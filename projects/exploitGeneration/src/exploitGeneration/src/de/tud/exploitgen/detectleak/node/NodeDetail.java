/**
 * 
 */
package de.tud.exploitgen.detectleak.node;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.List;

import com.csvanefalk.keytestgen.core.model.implementation.KTGModel;

import de.tud.exploitgen.util.TermParser;
import de.tud.exploitgen.util.TermUtil;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.settings.ProofIndependentSettings;
import de.uka.ilkd.key.settings.SMTSettings;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;

/**
 * this class contains all information that is relevant to a node of symbolic execution tree 
 * all information is collected while parsing symbolic execution tree
 * this information is useful for checking noninterference and creating exploit model
 * @author Huy Do
 *
 */
public class NodeDetail {
   private final IExecutionNode<?> node; //the node that is resolved
   /*
    * model of model variables and artificial variables extracted from node
    * use to check noninterference and create exploit model 
    * */
   private final List<KTGModel> models; //due to conditional values, there might be more than one models corresponding to a node
   private final List<Term> artificialVariables;  
   private final Term constraint; //useful constraint of node, it also contains path condition 
   private final String selfName;
   private final Term allConstraints; //all available constraints of node
   private List<Term> listArrays; //list of all arrays terms detected
   private List<Term> listArrayElements; //list of array's elements
   
   private List<ModelNode> listModelNodes; //list of ModelNode extracted from this NodeDetail

   private int index; //index of node in list node
   private final Term postHeapValue;
   private final List<Term> listFoundationTerms;
   
    /**
    * @param node
    * @param models
    * @param artificialVariable
    * @param constraint
    * @param selfName
    */
   public NodeDetail(IExecutionNode<?> node, List<KTGModel> models,
         List<Term> listArrays, List<Term> listArrayElements,     
         List<Term> artificialVariable, Term constraint, Term allConstraints, String selfName,
         Term postHeap, List<Term> listFoundations) {
      super();
      this.node = node;
      this.models = models;
      this.listArrays = listArrays;
      this.listArrayElements = listArrayElements;
      this.artificialVariables = artificialVariable;
      this.constraint = constraint;
      this.allConstraints = allConstraints;
      this.selfName = selfName;
      this.postHeapValue = postHeap;
      this.listFoundationTerms = listFoundations;
      index = -1;
      extract2ListModelNode();
   }

   



   /**clone constructor*/
   public NodeDetail(NodeDetail nd){
      //System.out.println("original model::: \n" + nd.toString());
      this.node = nd.node;
      this.constraint = nd.constraint;
      this.artificialVariables = nd.artificialVariables;
      this.listArrays = nd.listArrays;
      this.listArrayElements = nd.listArrayElements;
      this.selfName = nd.selfName;
      this.allConstraints = nd.allConstraints;
      //model must be deeply cloned
      this.models = new LinkedList<KTGModel>();
      for(KTGModel model: nd.models)
         this.models.add(KTGModel.constructModel(model));
      //System.out.println("cloned model::: \n" + this.model.toString());
      this.index = nd.index;
      this.listModelNodes = nd.listModelNodes;
      this.postHeapValue = nd.postHeapValue;
      this.listFoundationTerms = nd.listFoundationTerms;
      //this.model.resetPrimitiveValue();
   }
 

	public String getSelfName() {
		return selfName;
	}
	
	
	public Term getPostHeapValue() {
		return postHeapValue;
	}
	
	
	public List<Term> getListFoundationTerms() {
		return listFoundationTerms;
	}

/**
    * @return the node
    */
   public IExecutionNode<?> getNode() {
      return node;
   }

   /**
    * @return the list of model
    */
   public List<KTGModel> getModels() {
      return models;
   }
   
   public KTGModel getModel(int i){
      return models.get(i);
   }

   
   /**
    * @return the artificialVariable
    */
   public List<Term> getArtificialVariables() {
      return artificialVariables;
   }

   /**
    * @return the constraint
    */
   public Term getConstraint() {
      return constraint;
   }

   
   
   /**
    * @return the heapName
    */
   public String getHeapName() {
      return selfName;
   }

   public boolean isDescendantOfMC(){
      return NodeParser.isDescendantOfMethodContract(node);
   }
   
   public boolean isDescendantOfLI(){
      return NodeParser.isDescendantOfLoopInvariant(node);
   }   
   
   public boolean wellLoopInvariantAncestor(){
      if(isDescendantOfLI()){
         return NodeParser.getLoopInvariantAncestor(node).isInitiallyValid();
      }
      return false;
   }   
   
   
   
   public Term getPathCondition() throws ProofInputException{
      return node.getPathCondition();
   }

   public int getIndex() {
      return index;
   }

   public void setIndex(int index) {
      this.index = index;
   }
  
   public Term getAllConstraints() {
      return allConstraints;
   }


   public List<Term> getListArrays() {
      return listArrays;
   }


   public List<Term> getListArrayElements() {
      return listArrayElements;
   }
   
   private void extract2ListModelNode(){
	   listModelNodes = new LinkedList<ModelNode>();
	   for(int i=0;i< models.size();i++){
		   KTGModel model = models.get(i);
		   listModelNodes.add(new ModelNode(model, this,i));
	   }
   }




	
	public List<ModelNode> getListModelNodes() {
		return listModelNodes;
	}  
	  
	public ModelNode getModelNode(int idx){
		return listModelNodes.get(idx);
	}
	
	/*
	 * check if the constant number appearing in constraints is beyond the integer bound (defined in default SMTSettings) or not
	 * it is important for choosing what FormulaSolver is taken: Z3Solver for the case of true and SMTLibSolver vice versa
	 * */
	public boolean nunberExceedIntBound(){
		Services services = node.getServices();
		 
		long intBound = new SMTSettings(services.getProof().getSettings().getSMTSettings(),
	              ProofIndependentSettings.DEFAULT_INSTANCE.getSMTSettings(),services.getProof()).getIntBound();
		List<Term> listNumInConstraint = TermUtil.extractNumber(constraint, services);
		
		for(Term numTerm: listNumInConstraint){
			long num = TermParser.getIntegerValue(numTerm, services);
			
			if(num<0)
				num=0-num;
			if(num>0){
				int numBit = Long.SIZE - Long.numberOfLeadingZeros(num);
				
				if((numBit+1)>intBound)
					return true;
			}
		}
		return false;
		
	}

   
}
