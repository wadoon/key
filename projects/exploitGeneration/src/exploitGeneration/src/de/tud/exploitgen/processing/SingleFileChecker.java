/**
 * 
 */
package de.tud.exploitgen.processing;

import java.io.BufferedWriter;
import java.io.File;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;

import java.util.List;
import java.util.Set;

import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.tud.exploitgen.infrastructure.*;
import de.tud.exploitgen.processing.exploit.ExploitTestCases;
import de.tud.exploitgen.processing.exploit.ExploitTestSuite;
import de.tud.exploitgen.processing.exploit.JUnitExploitGenerator;
import de.tud.exploitgen.util.IFSpecParser;

import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.proof.init.ProofOblInput;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.FunctionalOperationContract;


import de.uka.ilkd.key.symbolic_execution.SymbolicExecutionTreeBuilder;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;


import de.uka.ilkd.key.symbolic_execution.util.KeYEnvironment;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionEnvironment;
import de.uka.ilkd.key.ui.CustomConsoleUserInterface;


/**
 * @author Huy Do
 *
 */
public class SingleFileChecker {
   private File javaFile; //Java file that will be checked
   private KeYJavaClass javaClass;  //contains all necessary information for checking non-interference property
   //private IFSpecParser ifsParser;
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   
   private ExploitTestSuite exploitTestSuite; //contains exploit test suite showing that the program is nonsecure
   
   private final String TEST_FOLDER = "test"; //the prefix name for test folder, contains JUnit files to check non-interference constraints of program
   private boolean loopInv; //true if using loop invariant, false if unfolding loop
   private boolean methodTreatment=false; //method treatment
   
   
   /**
    * @param javaFile
    * @throws IOException 
    */
   public SingleFileChecker(File javaFile) throws IOException {
      super();
      this.javaFile = javaFile;
      //get necessary information into javaClass
      javaClass = new KeYJavaClassFactory().createKeYJavaClass(this.javaFile);
      //parse information flow security specifications by IFSpecParser and store in list ifSpecs
      ifSpecs = new IFSpecParser(javaFile).parseSpecification2GetListBarrier(); 
      //initiate for exploit test suite
      exploitTestSuite=new ExploitTestSuite(javaClass);
      this.loopInv=false;
   }
   
   public SingleFileChecker(File javaFile,boolean loopInv) throws IOException {
      super();
      this.javaFile = javaFile;
      //get necessary information into javaClass
      javaClass = new KeYJavaClassFactory().createKeYJavaClass(this.javaFile);
      //parse information flow security specifications by IFSpecParser and store in list ifSpecs
      ifSpecs = new IFSpecParser(javaFile).parseSpecification2GetListBarrier(); 
      //initiate for exploit test suite
      exploitTestSuite=new ExploitTestSuite(javaClass);
      this.loopInv=loopInv;
   }
   
   //process a method in the Java file
   private void checkMethod(String methodName) throws ProofInputException, TermTransformerException, IOException{
      
      KeYEnvironment<CustomConsoleUserInterface> env=javaClass.getEnvironment();
      KeYJavaMethod method=javaClass.getMethod(methodName);
      
      Contract contract = method.getFunctionalContract();     
     /* if(method.hasInformationFlowContract()){
         System.out.println("number of declassifications: " + method.getDeclassificationTerms().size());
         for(Term t: method.getDeclassificationTerms())
            System.out.println(t);
      }*/
      /*ProofOblInput input = new ProgramMethodPO(env.getInitConfig(),
            method.getProgramMethod().getFullName(),
            method.getProgramMethod(),
            null,
            true,
            true);*/
      
      ProofOblInput input = new FunctionalOperationContractPO(env.getInitConfig(), (FunctionalOperationContract)contract, true, true);
      // Create proof
      Proof proof = env.createProof(input);     
      
      /// Configure proof for symbolic execution      
      SymbolicExecutionEnvironment.configureProofForSymbolicExecution(proof,
                                                                      1000,
                                                                      methodTreatment,
                                                                      loopInv,
                                                                      false,
                                                                      true);

      // Create symbolic execution tree which contains only the start node at beginning
      SymbolicExecutionTreeBuilder builder = new SymbolicExecutionTreeBuilder(env.getMediator(),
                                                                              proof,
                                                                              false,
                                                                              false);
      // Run proof
      env.getUi().startAndWaitForAutoMode(proof);
      // Update symbolic execution tree
      builder.analyse();
      //get start node
      IExecutionStart root=builder.getStartNode();
      //use MethodProcessor to check the method
      MethodChecker mp = new MethodChecker(method, ifSpecs, root);
      List<ExploitTestCases> etcs = mp.checkMethod2GetExploitTestCases();      
      exploitTestSuite.addListExploitTestCase(etcs);
      
    //free memory
    env.dispose();       
    
   }
      
   //check all methods of java file
   public void checkProgram() throws TermTransformerException, ProofInputException, IOException{
      Set<String> methodNames=javaClass.getMethods();    
      for(String methodName:methodNames){
         System.out.println("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
         System.out.println("checking method " + methodName);
         checkMethod(methodName);        
      }
      //if the exploit test suite is empty, the program is secure
      System.out.println("\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
      if(exploitTestSuite.isEmpty())
         System.out.println("The program is secure");
      else{//otherwise, generate JUnit test to verify that the program violates non-interference constraints
    	  int numExploits=exploitTestSuite.getAmouttOfExploits();
         System.out.println("The program is insecure; number of generated exploits: " + 
        		 numExploits+ "; please run generated JUnit tests to verify!\n");
         
         //exploitTestSuite.printStatistics();
         JUnitExploitGenerator jUnitGen=new JUnitExploitGenerator(exploitTestSuite);
         String javaTestExploitCode  = jUnitGen.getExploitTestContent();       
         String className=jUnitGen.getClassName();
         createJUnitTestFile(javaTestExploitCode,className);
        
      }
   }
   
   /**
    * return the folder contains JUnit test.
    * at the moment, we place the test folder in the same directory with the folder containing Java source needed be tested
    * the name of the folder is the name of Java source's folder, prefixed by TEST_FOLDER
    * */
   private File createTestFolder(){
      File folder=new File(javaFile.getParentFile().getParent()+File.separator+TEST_FOLDER+javaFile.getParentFile().getName());
      if(!folder.exists())
         folder.mkdir();
      return folder;
   }
   
   /**
    * create JUnit test file
    * */
   private void createJUnitTestFile(String javaTestExploitCode, String className){
      File folder=createTestFolder();
      String javaPackage=folder.getName();
      
      File testFile=new File(folder,className+".java");
      
      try {
         //BufferedWriter writer = new BufferedWriter(new FileWriter(testFile));
         BufferedWriter writer = Files.newBufferedWriter(Paths.get(testFile.getPath()), StandardCharsets.UTF_8);         
         writer.write("package " + javaPackage + ";\n\n");
         writer.write(javaTestExploitCode);
         writer.close();
         System.out.println("JUnit file testing information flow security has been created at:\n" + testFile.toString());
      }
      catch (IOException e) {
         System.out.println("error in creating JUnit test file");
         e.printStackTrace();
      }
   }
   
 
   
}
