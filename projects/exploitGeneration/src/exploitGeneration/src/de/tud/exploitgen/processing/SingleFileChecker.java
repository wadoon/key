/**
 * 
 */
package de.tud.exploitgen.processing;

import java.io.BufferedWriter;
import java.io.File;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;

import java.util.List;
import java.util.Set;

import de.tud.exploitgen.infrastructure.*;
import de.tud.exploitgen.processing.exploit.ExploitTestCases;
import de.tud.exploitgen.processing.exploit.ExploitTestSuite;
import de.tud.exploitgen.processing.exploit.codegenerator.JUnitExploitGenerator;
import de.tud.exploitgen.processing.specification.noninterference.IFBarrier;
import de.tud.exploitgen.processing.specification.noninterference.IFSpecParser;

import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.proof.init.ProofOblInput;
import de.uka.ilkd.key.proof.io.ProblemLoaderException;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.FunctionalOperationContract;


import de.uka.ilkd.key.symbolic_execution.SymbolicExecutionTreeBuilder;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;


import de.uka.ilkd.key.symbolic_execution.util.KeYEnvironment;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionEnvironment;
import de.uka.ilkd.key.ui.CustomUserInterface;


/**
 * @author Huy Do
 *
 */
public class SingleFileChecker {
   private File javaFile; //Java file that will be checked
   private KeYJavaClass javaClass;  //contains all necessary information for checking non-interference property
   //private IFSpecParser ifsParser;
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   
   private ExploitTestSuite exploitTestSuite; //contains exploit test suite showing that the program is nonsecure
   
   private final String TEST_FOLDER = "test"; //the prefix name for test folder, contains JUnit files to check non-interference constraints of program
   private boolean loopInv; //true if using loop invariant, false if unfolding loop
   private boolean methodTreatment=false; //method treatment
   private int depth; //depth of sub-field's sequence being investigated
   
           
   public SingleFileChecker(File javaFile,boolean loopInv, boolean methodTreatment, int depth) throws IOException, ProblemLoaderException {
      super();
      this.javaFile = javaFile;
      //get necessary information into javaClass
      javaClass = new KeYJavaClassFactory().createKeYJavaClass(this.javaFile);
      //parse information flow security specifications by IFSpecParser and store in list ifSpecs
      ifSpecs = new IFSpecParser(javaFile).parseSpecification2GetListBarrier(); 
      //initiate for exploit test suite
      exploitTestSuite=new ExploitTestSuite(javaClass);
      this.loopInv=loopInv;
      this.methodTreatment = methodTreatment;
      this.depth = depth;
   }
   
   //process a method in the Java file
   private void checkMethod(String methodName) throws ProofInputException, IOException, IllegalFormulaException{
      /*measure time for symbolic execution */
      long startTimeSE = System.nanoTime();
      
      KeYEnvironment<CustomUserInterface> env=javaClass.getEnvironment();
      KeYJavaMethod method=javaClass.getMethod(methodName);
      
      Contract contract = method.getFunctionalContract().get(0);     
     /* if(method.hasInformationFlowContract()){
         System.out.println("number of declassifications: " + method.getDeclassificationTerms().size());
         for(Term t: method.getDeclassificationTerms())
            System.out.println(t);
      }*/
      /*ProofOblInput input = new ProgramMethodPO(env.getInitConfig(),
            method.getProgramMethod().getFullName(),
            method.getProgramMethod(),
            null,
            true,
            true);*/
      
      ProofOblInput input = new FunctionalOperationContractPO(env.getInitConfig(), (FunctionalOperationContract)contract, true, true);
      // Create proof
      Proof proof = env.createProof(input);     
      
      /// Configure proof for symbolic execution      
      SymbolicExecutionEnvironment.configureProofForSymbolicExecution(proof,
                                                                      1000,
                                                                      methodTreatment,
                                                                      loopInv,
                                                                      false,
                                                                      true);

      // Create symbolic execution tree which contains only the start node at beginning
      SymbolicExecutionTreeBuilder builder = new SymbolicExecutionTreeBuilder(env.getMediator(),
                                                                              proof,
                                                                              false,
                                                                              false,
                                                                              false,
                                                                              true);
      // Run proof
      env.getUi().startAndWaitForAutoMode(proof);
      // Update symbolic execution tree
      builder.analyse();
      //get start node
      IExecutionStart root=builder.getStartNode();
      long endTimeSE = System.nanoTime();
      System.out.println("Time for Symbolic Execution: "+(endTimeSE - startTimeSE)/1000000 + " ms"); 
      //use MethodChecker to check the method            
      method.setServices(proof.getServices());
      MethodChecker mp = new MethodChecker(method, ifSpecs, root, depth);
      
      List<ExploitTestCases> etcs = mp.checkMethod2GetExploitTestCases();   
      exploitTestSuite.addListExploitTestCase(etcs);
      
      /*measure time for model finding*/
      long endTimeMF = System.nanoTime();
      System.out.println("Time for Model Finding: "+(endTimeMF - endTimeSE)/1000000 + " ms"); 
    //free memory
    env.dispose();       
    
   }
      
   //check all methods of java file
   public void checkProgram() throws ProofInputException, IOException, IllegalFormulaException{
      Set<String> methodNames=javaClass.getMethods();    
      for(String methodName:methodNames){
         System.out.println("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
         System.out.println("checking method " + methodName);
         checkMethod(methodName);        
      }
      //if the exploit test suite is empty, the program is secure
      System.out.println("\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
      if(exploitTestSuite.isEmpty())
         System.out.println("No leakage detected: The program might be safe");
      else{//otherwise, generate JUnit test to verify that the program violates non-interference constraints
    	  int numExploits=exploitTestSuite.getAmouttOfExploits();
         System.out.println("The program is insecure; number of generated exploits: " + 
        		 numExploits+ "; please run generated JUnit tests to verify!\n");
         
         //exploitTestSuite.printStatistics();
         JUnitExploitGenerator jUnitGen=new JUnitExploitGenerator(exploitTestSuite);
         String javaTestExploitCode  = jUnitGen.getExploitTestContent();       
         String className=jUnitGen.getClassName();
         createJUnitTestFile(javaTestExploitCode,className);
        
      }
   }
   
   /**
    * return the folder contains JUnit test.
    * at the moment, we place the test folder in the same directory with the folder containing Java source needed be tested
    * the name of the folder is the name of Java source's folder, prefixed by TEST_FOLDER
    * */
   private File createTestFolder(){
      File folder=new File(javaFile.getParentFile().getParent()+File.separator+TEST_FOLDER+javaFile.getParentFile().getName());
      if(!folder.exists())
         folder.mkdir();
      return folder;
   }
   
   /**
    * create JUnit test file
    * */
   private void createJUnitTestFile(String javaTestExploitCode, String className){
      File folder=createTestFolder();
      String javaPackage=folder.getName();
      
      File testFile=new File(folder,className+".java");
      
      try {
         //BufferedWriter writer = new BufferedWriter(new FileWriter(testFile));
         BufferedWriter writer = Files.newBufferedWriter(Paths.get(testFile.getPath()), StandardCharsets.UTF_8);         
         writer.write("package " + javaPackage + ";\n\n");
         writer.write(javaTestExploitCode);
         writer.close();
         System.out.println("JUnit file testing information flow security has been created at:\n" + testFile.toString());
      }
      catch (IOException e) {
         System.out.println("error in creating JUnit test file");
         e.printStackTrace();
      }
   }
   
 
   
}
