/**
 * 
 */
package de.tud.exploitgen.processing;

import java.io.BufferedWriter;
import java.io.File;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.tud.exploitgen.infrastructure.*;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.processing.exploit.ExploitTestCases;
import de.tud.exploitgen.processing.exploit.ExploitTestSuite;
import de.tud.exploitgen.processing.exploit.JUnitExploitGenerator;
import de.tud.exploitgen.util.IFSpecParser;
import de.tud.exploitgen.util.VariableClassifier;

import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.proof.init.ProofOblInput;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.FunctionalOperationContract;

import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.SymbolicExecutionTreeBuilder;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination;

import de.uka.ilkd.key.symbolic_execution.util.KeYEnvironment;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionEnvironment;
import de.uka.ilkd.key.ui.CustomConsoleUserInterface;


/**
 * @author Huy Do
 *
 */
public class SingleFileChecker {
   private File javaFile; //Java file that will be checked
   private KeYJavaClass javaClass;  //contains all necessary information for checking non-interference property
   //private IFSpecParser ifsParser;
   private List<IFBarrier> ifSpecs; //contains information flow security specification
   
   private ExploitTestSuite exploitTestSuite; //contains exploit test suite showing that the program is nonsecure
   
   private final String TEST_FOLDER = "test"; //the prefix name for test folder, contains JUnit files to check non-interference constraints of program
   private boolean loopInv; //true if using loop invariant, false if unfolding loop
   private boolean methodTreatment=false; //method treatment
   /**
    * @param javaFile
    * @throws IOException 
    */
   public SingleFileChecker(File javaFile) throws IOException {
      super();
      this.javaFile = javaFile;
      //get necessary information into javaClass
      javaClass = new KeYJavaClassFactory().createKeYJavaClass(this.javaFile);
      //parse information flow security specifications by IFSpecParser and store in list ifSpecs
      ifSpecs = new IFSpecParser(javaFile).parseSpecification2GetListBarrier(); 
      //initiate for exploit test suite
      exploitTestSuite=new ExploitTestSuite(javaClass);
      this.loopInv=false;
   }
   
   public SingleFileChecker(File javaFile,boolean loopInv) throws IOException {
      super();
      this.javaFile = javaFile;
      //get necessary information into javaClass
      javaClass = new KeYJavaClassFactory().createKeYJavaClass(this.javaFile);
      //parse information flow security specifications by IFSpecParser and store in list ifSpecs
      ifSpecs = new IFSpecParser(javaFile).parseSpecification2GetListBarrier(); 
      //initiate for exploit test suite
      exploitTestSuite=new ExploitTestSuite(javaClass);
      this.loopInv=loopInv;
   }
   
   //process a method in the Java file
   public void checkMethod(String methodName) throws ProofInputException, TermTransformerException, IOException{
      
      KeYEnvironment<CustomConsoleUserInterface> env=javaClass.getEnvironment();
      KeYJavaMethod method=javaClass.getMethod(methodName);
      
      Contract contract = method.getFunctionalContract();     
     /* if(method.hasInformationFlowContract()){
         System.out.println("number of declassifications: " + method.getDeclassificationTerms().size());
         for(Term t: method.getDeclassificationTerms())
            System.out.println(t);
      }*/
      /*ProofOblInput input = new ProgramMethodPO(env.getInitConfig(),
            method.getProgramMethod().getFullName(),
            method.getProgramMethod(),
            null,
            true,
            true);*/
      
      ProofOblInput input = new FunctionalOperationContractPO(env.getInitConfig(), (FunctionalOperationContract)contract, true, true);
      // Create proof
      Proof proof = env.createProof(input);     
      
      /// Configure proof for symbolic execution      
      SymbolicExecutionEnvironment.configureProofForSymbolicExecution(proof,
                                                                      1000,
                                                                      methodTreatment,
                                                                      loopInv,
                                                                      false,
                                                                      false);

      // Create symbolic execution tree which contains only the start node at beginning
      SymbolicExecutionTreeBuilder builder = new SymbolicExecutionTreeBuilder(env.getMediator(),
                                                                              proof,
                                                                              false,
                                                                              false);
      // Run proof
      env.getUi().startAndWaitForAutoMode(proof);
      // Update symbolic execution tree
      builder.analyse();
      //get start node
      IExecutionStart root=builder.getStartNode();
      //get leaf nodes
      List<IExecutionNode> leafNodes=getLeafNodes(root);
      System.out.println("number of leaf nodes: " + leafNodes.size());
      //check each declaration in the specification of information flow security
      for(IFBarrier declar: ifSpecs){
         System.out.println("\n==========================================================");
         System.out.println("Checking the IFS declaration: " + declar.getDeclaration());
         //create variable checker via declaration
         VariableClassifier vc=new VariableClassifier(method,declar.getDestination(),declar.getSource());
         
         //create MethodProcessor object to check the method, including leaf nodes, method info and variable checker info
         MethodProcessor mp=new MethodProcessor(leafNodes,method,vc);         
         
         ///check the method
         //nic.checkMethod();
         
         //get list of exploit model by checking the method with current information flow security specification
         List<ExploitModel> listEM=mp.checkMethod2GetExploitModels();
         //add list of exploit model into exploitTestSuite
         if(!listEM.isEmpty()){            
               ExploitTestCases exploitTestCases=new ExploitTestCases(method, declar, listEM);
               exploitTestSuite.addExploitTestCase(exploitTestCases);            
         }         
      }
    
    //free memory
    env.dispose();       
    
   }
      
   //check all methods of java file
   public void checkProgram() throws TermTransformerException, ProofInputException, IOException{
      Set<String> methodNames=javaClass.getMethods();    
      for(String methodName:methodNames){
         System.out.println("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
         System.out.println("checking method " + methodName);
         checkMethod(methodName);        
      }
      //if the exploit test suite is empty, the program is secure
      System.out.println("\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
      if(exploitTestSuite.isEmpty())
         System.out.println("The program is secure");
      else{//otherwise, generate JUnit test to verify that the program violates non-interference constraints
    	  int numExploits=exploitTestSuite.getAmouttOfExploits();
         System.out.println("The program is insecure; number of exploits generated: " + 
        		 numExploits+ "; please run generated JUnit test to verify!\n");
         JUnitExploitGenerator jUnitGen=new JUnitExploitGenerator(exploitTestSuite);
         String javaTestExploitCode  = jUnitGen.getExploitTestContent();       
         String className=jUnitGen.getClassName();
         createJUnitTestFile(javaTestExploitCode,className);
      }
   }
   
   /**
    * return the folder contains JUnit test.
    * at the moment, we place the test folder in the same directory with the folder containing Java source needed be tested
    * the name of the folder is the name of Java source's folder, prefixed by TEST_FOLDER
    * */
   private File createTestFolder(){
      File folder=new File(javaFile.getParentFile().getParent()+File.separator+TEST_FOLDER+javaFile.getParentFile().getName());
      if(!folder.exists())
         folder.mkdir();
      return folder;
   }
   
   /**
    * create JUnit test file
    * */
   private void createJUnitTestFile(String javaTestExploitCode, String className){
      File folder=createTestFolder();
      String javaPackage=folder.getName();
      
      File testFile=new File(folder,className+".java");
      
      try {
         //BufferedWriter writer = new BufferedWriter(new FileWriter(testFile));
         BufferedWriter writer = Files.newBufferedWriter(Paths.get(testFile.getPath()), StandardCharsets.UTF_8);         
         writer.write("package " + javaPackage + ";\n\n");
         writer.write(javaTestExploitCode);
         writer.close();
         System.out.println("JUnit file testing information flow security has been created at:\n" + testFile.toString());
      }
      catch (IOException e) {
         System.out.println("error in creating JUnit test file");
         e.printStackTrace();
      }
   }
   

   
   /**
    * get leaf nodes of symbolic execution tree from root
    */
   private List<IExecutionNode> getLeafNodes(IExecutionStart root){
      List<IExecutionNode> leafNodes = new LinkedList<IExecutionNode>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode node = iterator.next();
         if(isTerminatingNode(node)){
            IExecutionNode parentNode = node.getParent();
            if(parentNode instanceof IExecutionStateNode)
               leafNodes.add(node.getParent());
         }
      } 
      return leafNodes;
   }
   
   /**
    * check if the node is a terminating node
    * */
   private boolean isTerminatingNode(final IExecutionNode node) {
      return node instanceof IExecutionTermination;
   }
   
   
}
