
/* 
*  this class used to check the non-interference of a method
 * it gets all termination nodes of the symbolic execution tree of the method 
 * */


package de.tud.exploitgen.processing;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.processing.exploit.ExploitModel;
import de.tud.exploitgen.solver.AbstractFormulaSolver;
import de.tud.exploitgen.solver.KeyStoneSolver;
import de.tud.exploitgen.solver.Z3Solver;
import de.tud.exploitgen.util.VariableChecker;
//import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;

import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;



import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;


import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class NonInterferenceChecker {
   private KeYJavaMethod method; //contains information of method (maybe needed in variable checker)
   private List<IExecutionNode> leafNodes; //contains leaf nodes of symbolic execution tree of method 
   VariableChecker vc; //check variables in nodes
   
     
   /**
    * @param method
    * @param leafNodes
    * @param vc
    */
   public NonInterferenceChecker(List<IExecutionNode> leafNodes,KeYJavaMethod method, VariableChecker vc) {
      super();
      this.method = method;
      this.leafNodes = leafNodes;
      this.vc = vc;
      
      //initiateExploitModel();
      //exploitModel.printExploitModel(1);
   }


   /**
    * @return the leafNodes
    */
   public List<IExecutionNode> getLeafNodes() {
      return leafNodes;
   }

  
   /**
    * @param leafNodes the leafNodes to set
    */
   public void setLeafNodes(List<IExecutionNode> leafNodes) {
      this.leafNodes = leafNodes;
   }
   
   public Term getInterferenceFormula(int node1,int node2)throws ProofInputException{
      TwoBranchesProcessor tp=new TwoBranchesProcessor(leafNodes.get(node1), leafNodes.get(node2),method,vc); 
      return tp.makeInterferenceFormula(); 
   }
   
   public void printConcreteModel(int node1, int node2) throws ProofInputException, TermTransformerException{          
      Map<String, Integer> counterExample;
      counterExample = getConcreteModel(node1, node2);
      
     
      
      if(counterExample!=null){
        
         
         Set<String> vars = counterExample.keySet();      
         System.out.println("The interference model we got is:");
         for(String var: vars){
            System.out.println(var + " : " + counterExample.get(var).intValue());
         }       
      }   
      System.out.println("----------------------------------------");
   }
   
   /*
    * return concrete values satisfying the interference term generating from two branches.
    * */
   private Map<String,Integer> getConcreteModel(int node1, int node2) throws ProofInputException, TermTransformerException{
      //get interference formula from two nodes
      Term iTerm=getInterferenceFormula(node1, node2);     
      
      
      System.out.println("interference term: "+iTerm.toString());
      
      //Services services=leafNodes.get(node1).getServices();
    
      //FormulaSolver fs=new KeyStoneSolver(iTerm,services);
      AbstractFormulaSolver fs=new Z3Solver(iTerm);
      
      Map<String, Integer> result;
      result = fs.solveFormulaInt();
      return result;
   }
   
   
   /**
    * get {@link}Model based on concrete model returned by getConcreteModel method
    * */
   
   
   /*
    * check all node pairs and print out input values to check non-interference property
    * */
   public void checkMethod()throws ProofInputException, TermTransformerException{
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
            System.out.print("Check branch " + i);
            if (j!=i){
               System.out.print(" and branch " + j);
            }
            System.out.println();
            System.out.println("path condition of branch " + i + " : " + leafNodes.get(i).getPathCondition().toString());
            if (j!=i){
               System.out.println("path condition of branch " + j + " : " + leafNodes.get(j).getPathCondition().toString());
            }                  
            printConcreteModel(i, j);
         }
      }
   }
   
   
    
   /**
    * get exploit model from two node
    * @throws ProofInputException 
    * @throws TermTransformerException 
    * */
   private ExploitModel getExploitModel(int node1, int node2) throws TermTransformerException, ProofInputException{
      //solve two branches to get concrete value
      Map<String,Integer> concreteValues=getConcreteModel(node1, node2);
           
      
      if(concreteValues!=null){ //if there is a counter example, we get and resolve the model
         
         //initiate exploit model
         ExploitModel exploitModel=new ExploitModel();
         exploitModel.initiateExploitModelFromNode(leafNodes.get(node1));
         //instantiate value for exploit model
         exploitModel.instantiateExploitModelInt(concreteValues);  
         exploitModel.printExploitModel(1);
         exploitModel.printExploitModel(2);
         return exploitModel;
      }else
         return null;
   }
 
   /**
    * check the input method to get list of exploit model if the method is insecure 
    * */
   public List<ExploitModel> checkMethod2GetExploitModels(){
      List<ExploitModel> result=new LinkedList<ExploitModel>();
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
            System.out.print("Check branch " + i);
            if (j!=i){
               System.out.print(" and branch " + j);
            }
            System.out.println();
            ExploitModel eModel;
            try {
             //check branch i and branch j to get exploit model if it exists
               eModel=getExploitModel(i, j); 
            }
            catch (TermTransformerException e) {
               eModel=null;
               e.printStackTrace();
            }
            catch (ProofInputException e) {
               eModel=null;
               e.printStackTrace();
            }
            if(eModel!=null){
               result.add(eModel);
            }
         }
      }
      return result;
   }
}

