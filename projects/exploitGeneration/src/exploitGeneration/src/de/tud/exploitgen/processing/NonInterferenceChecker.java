
/* 
*  this class used to process nodes in symbolic execution tree, 
 * that could be accessed via root node.
 * */


package de.tud.exploitgen.processing;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
import de.tud.exploitgen.solver.FormulaSolver;
import de.tud.exploitgen.solver.Z3Solver;
//import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;

import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;


import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class NonInterferenceChecker {
   private IExecutionStart root;
   private KeYJavaMethod method;
   private List<IExecutionNode> leafNodes;
   //private Services services;
   /*
    * constructor: Receive root node and create a collection of leaf nodes
    * */
   public NonInterferenceChecker(IExecutionStart rootNode, KeYJavaMethod method){
      root=rootNode;
      this.method=method;
      leafNodes = new LinkedList<IExecutionNode>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode node = iterator.next();
         if(isTerminatingNode(node))
            leafNodes.add(node.getParent());     
      }
      //services=root.getServices();
      
   }
   
   /*
    * check if the node is a terminating node
    * */
   private boolean isTerminatingNode(final IExecutionNode node) {
      return node instanceof IExecutionTermination;
   }
   
   
   /**
    * @return the root
    */
   public IExecutionStart getRoot() {
      return root;
   }

   /**
    * @return the leafNodes
    */
   public List<IExecutionNode> getLeafNodes() {
      return leafNodes;
   }

   /**
    * @param root the root to set
    */
   public void setRoot(IExecutionStart root) {
      this.root = root;
   }

   /**
    * @param leafNodes the leafNodes to set
    */
   public void setLeafNodes(List<IExecutionNode> leafNodes) {
      this.leafNodes = leafNodes;
   }
   
   public Term getInterferenceFormula(int node1,int node2)throws ProofInputException{
      TwoBranchesProcessor tp=new TwoBranchesProcessor(leafNodes.get(node1), leafNodes.get(node2),method); 
      return tp.makeInterferenceFormula(); 
   }
   
   public void printConcreteModel(int node1, int node2) throws ProofInputException, TermTransformerException{          
      Map<String, Integer> counterExample;
      counterExample = getConcreteModel(node1, node2);
      if(counterExample!=null){
         Set<String> vars = counterExample.keySet();      
         System.out.println("The interference model we got is:");
         for(String var: vars){
            System.out.println(var + " : " + counterExample.get(var).intValue());
         }       
      }   
      System.out.println("----------------------------------------");
   }
   
   /*
    * return concrete values satisfying the interference term generating from two branches.
    * */
   private Map<String,Integer> getConcreteModel(int node1, int node2) throws ProofInputException, TermTransformerException{
      Term iTerm=getInterferenceFormula(node1, node2);
      
      System.out.println(iTerm.toString());
      
      //Services services=leafNodes.get(node1).getServices();
    
      //FormulaSolver fs=new KeyStoneSolver(iTerm,services);
      FormulaSolver fs=new Z3Solver(iTerm);
      
      Map<String, Integer> result;
      result = fs.solveFormula();
      return result;
   }
   
   /*
    * check all node pairs and print out input values to check non-interference property
    * */
   public void checkMethod()throws ProofInputException, TermTransformerException{
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
            System.out.print("Check branch " + i);
            if (j!=i){
               System.out.print(" and branch " + j);
            }
            System.out.println();
            System.out.println("path condition of branch " + i + " : " + leafNodes.get(i).getPathCondition().toString());
            if (j!=i){
               System.out.println("path condition of branch " + j + " : " + leafNodes.get(j).getPathCondition().toString());
            }      
            
            printConcreteModel(i, j);
         }
      }
   }
}

