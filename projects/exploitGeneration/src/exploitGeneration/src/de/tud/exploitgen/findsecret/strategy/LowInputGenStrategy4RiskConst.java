package de.tud.exploitgen.findsecret.strategy;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;

import de.tud.exploitgen.detectleak.PairTerm;
import de.tud.exploitgen.detectleak.PairTermCollection;
import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.distribution.Partition;
import de.tud.exploitgen.findsecret.distribution.SecretDistribution;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTFile;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTProblem;
import de.tud.exploitgen.findsecret.maxsmt.MaxSMTTranslator;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizerUsingMaxSMT;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.MELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShELMaximizerUsingCounting4NU;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShELMaximizerUsingCounting4Uniform;
import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KEGConstant;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;
import de.uka.ilkd.key.smt.IllegalFormulaException;
import de.uka.ilkd.key.util.Pair;

public class LowInputGenStrategy4RiskConst extends LowInputGenStrategy4LimitedOutValue{

	public LowInputGenStrategy4RiskConst(SISupporter siSupporter) {
		super(siSupporter);
		// TODO Auto-generated constructor stub
	}

		@Override
	   protected List<PPCountingResult> getListCountingResultForShannonAndGuessingEntropy() throws IOException{
		   SecretDistribution sDistrubution = siSupporter.getsDistribution();
		   if((sDistrubution==null)||(sDistrubution.isUniform())){
			   List<ParametricPolytope> listPP = new LinkedList<ParametricPolytope>();
				BadMethod badMethod = siSupporter.getBadMethod();
				Term currentKnowledge = siSupporter.getCurrentKnowledge();
				TermBuilder termBuilder = badMethod.getMethod().getServices().getTermBuilder();
				for(RiskyPath rn: badMethod.getListRiskyPaths()){
					if(rn.isReachable()){
						/*
						 * parameters: list of low variables.
						 * vars: list of high variables
						 * */			
						Term constraint = termBuilder.and(currentKnowledge, /*rn.getModelNode().getConstraint()*/rn.getExistPathCondition());
						listPP.add(new ParametricPolytope(constraint, rn.getVc().getListLowVars(), rn.getVc().getListHighVars()));	
					}
				}
				List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
				for(ParametricPolytope pp: listPP){				   
					listCountingResults.add(barvinokCount(pp));				
				}
				return listCountingResults;
		   }else{
			   BadMethod badMethod = siSupporter.getBadMethod();
				Term currentKnowledge = siSupporter.getCurrentKnowledge();
				Services services = badMethod.getMethod().getServices();
				TermBuilder termBuilder = services.getTermBuilder();
				List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
				List<Partition> listPartitions = sDistrubution.getPartitions();
				for(int rpIdx = 0; rpIdx < badMethod.getListRiskyPaths().size(); rpIdx++){
					RiskyPath rn = badMethod.getListRiskyPaths().get(rpIdx);				
					if(rn.isReachable()){				
						for(int i=0; i<listPartitions.size();i++){
							Partition partition = listPartitions.get(i);
							/*
							 * parameters: list of low variables.
							 * vars: list of high variables
							 * */			
							Term constraint = termBuilder.and(currentKnowledge, /*rn.getModelNode().getConstraint()*/rn.getExistPathCondition());
							constraint = termBuilder.and(constraint, partition.getFormula());
							ParametricPolytope pp = new ParametricPolytope(constraint, rn.getVc().getListLowVars(), rn.getVc().getListHighVars());
							PPCountingResult ppCountResult = barvinokCount(pp);
							ppCountResult.setOutputValue(String.valueOf(rpIdx));
							ppCountResult.setPartitionIdx(i);
							listCountingResults.add(ppCountResult);
						}				
					}
				}	
				System.out.println("PRINT COUNTING RESULT FOR THE CASE OF NON-UNIFORM DISTRIBUTION!!!");
				for(PPCountingResult ppc: listCountingResults){
					ppc.printInfo();
				}
				return listCountingResults;
		   }
	   

	}
	  
   @Override
	protected Map<String, Long> findLowInputMaximizingMinEntropyLeakage4NU() {
	 //for non-uniform distribution, we use Max-SMT approach to find maximum min entropy based leakage
		Map<String, Pair<Term,Long>> mapSMTClause2Weight = new HashMap<String, Pair<Term,Long>>();
		List<Term> listConstraints = new LinkedList<Term>();
		BadMethod badMethod = siSupporter.getBadMethod();
		Term currentKnowledge = siSupporter.getCurrentKnowledge();
		List<ModelVariable> listQuanHighVars = badMethod.getListHighVars();
		Services services= siSupporter.getBadMethod().getMethod().getServices();
		TermBuilder termBuilder = services.getTermBuilder();
		SecretDistribution sDistrubution = siSupporter.getsDistribution();
		List<Partition> listPartitions = sDistrubution.getPartitions();
		
		for(int rpIdx = 0; rpIdx < badMethod.getListRiskyPaths().size(); rpIdx++){
			RiskyPath rn = badMethod.getListRiskyPaths().get(rpIdx);	
			
			if(rn.isReachable()){
				PairTermCollection ptcHighVar= new PairTermCollection(services);
				for(ModelVariable highVar: listQuanHighVars){
					ptcHighVar.add(highVar.getIdentifier(), createPairTermFromMV(highVar, rpIdx));
				}
				
				Term constraint = ptcHighVar.replacePVByNameAndBranch(currentKnowledge, 1);
				listConstraints.add(constraint);
				
				for(int i=0; i<listPartitions.size();i++){
					Partition partition = listPartitions.get(i);									
					Term maxSMTClause = termBuilder.and(rn.getExistPathCondition(), partition.getFormula());
					String id = "C"+String.valueOf(i)+String.valueOf(rpIdx);
					maxSMTClause = ptcHighVar.replacePVByNameAndBranch(maxSMTClause, 1);
					mapSMTClause2Weight.put(id, new Pair<Term,Long>(maxSMTClause, partition.getFrequency()));
				}				
			}
		}
		MaxSMTProblem postEntropyProblem = new MaxSMTProblem(mapSMTClause2Weight, listConstraints);
		
		Map<String, Pair<Term,Long>> mapPreSMTClause2Weight = new HashMap<String, Pair<Term,Long>>();
		List<Term> listPreConstraints = new LinkedList<Term>();
		listPreConstraints.add(currentKnowledge);
		for(int i=0; i<listPartitions.size();i++){
			Partition partition = listPartitions.get(i);									
			Term maxSMTClause = partition.getFormula();
			String id = "C"+String.valueOf(i);
			mapPreSMTClause2Weight.put(id, new Pair<Term,Long>(maxSMTClause, partition.getFrequency()));
		}				
			
		List<String> listLowVars = new LinkedList<String>();
		for(ModelVariable mv: badMethod.getListLowVars()){
			listLowVars.add(mv.getIdentifier());
		}
		MaxSMTProblem preEntropyProblem= new MaxSMTProblem(mapPreSMTClause2Weight, listPreConstraints);
		LeakageMaximizerUsingMaxSMT inputProducer = new LeakageMaximizerUsingMaxSMT(preEntropyProblem, postEntropyProblem, listLowVars, services);
		Pair<Map<String,Long>,Double> optimizedResult = inputProducer.findLowInputMaximizingLeakge();
		System.out.println("Min-entropy-based leakage: " + optimizedResult.second);
		return optimizedResult.first;
	}
	
}
