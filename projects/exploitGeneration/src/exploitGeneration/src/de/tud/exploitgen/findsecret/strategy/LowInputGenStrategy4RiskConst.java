package de.tud.exploitgen.findsecret.strategy;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.findsecret.BadMethod;
import de.tud.exploitgen.findsecret.RiskyPath;
import de.tud.exploitgen.findsecret.SISupporter;
import de.tud.exploitgen.findsecret.counting.Iscc2TermTransformer;
import de.tud.exploitgen.findsecret.counting.ParametricPolytope;
import de.tud.exploitgen.findsecret.counting.Term2IsccTransformer;
import de.tud.exploitgen.findsecret.optimizelowinput.PPCountingResult;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.GuessLeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.LeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.MinLeakageMaximizer;
import de.tud.exploitgen.findsecret.optimizelowinput.leakmaximizer.ShannonLeakageMaximizer;
import de.tud.exploitgen.util.KEGConstant;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.util.Pair;

public class LowInputGenStrategy4RiskConst extends LowInputGenStrategy{

	public LowInputGenStrategy4RiskConst(SISupporter siSupporter) {
		super(siSupporter);
		// TODO Auto-generated constructor stub
	}

	@Override
	public Map<String, Long> findBestLowInput() throws IOException {
		int metric = siSupporter.getMetric();
		if(metric==KEGConstant.MIN_ENTROPY)
			return findLowInputMaximizingNumberOfOutputValue();
		else{
			List<ParametricPolytope> listPP = new LinkedList<ParametricPolytope>();
			BadMethod badMethod = siSupporter.getBadMethod();
			Term currentKnowledge = siSupporter.getCurrentKnowledge();
			TermBuilder termBuilder = badMethod.getMethod().getServices().getTermBuilder();
			for(RiskyPath rn: badMethod.getListRiskyPaths()){
				if(rn.isReachable()){
					/*
					 * parameters: list of low variables.
					 * vars: list of high variables
					 * */			
					Term constraint = termBuilder.and(currentKnowledge, /*rn.getModelNode().getConstraint()*/rn.getExistPathCondition());
					listPP.add(new ParametricPolytope(constraint, rn.getVc().getListLowVars(), rn.getVc().getListHighVars()));	
				}
			}
			List<PPCountingResult> listCountingResults = new LinkedList<PPCountingResult>();
			for(ParametricPolytope pp: listPP){				   
				listCountingResults.add(barvinokCount(pp));				
			}
			
			//find "best" low input
			LeakageMaximizer inputProducer;
			
			if(metric==KEGConstant.SHANNON_ENTROPY){
				BigInteger numOfHighValues = siSupporter.findNumberOfPossibleHighValue(currentKnowledge);
				inputProducer = new ShannonLeakageMaximizer(listCountingResults, 
					badMethod.getMethod().getServices(), 
					badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(),numOfHighValues, siSupporter.getOptSolver());
			}	
			else
				inputProducer = new GuessLeakageMaximizer(listCountingResults, 
						badMethod.getMethod().getServices(), 
						badMethod.getListRiskyPaths().get(0).getVc().getListLowVars(),siSupporter.findNumberOfPossibleHighValue(currentKnowledge),siSupporter.getOptSolver());
			Pair<Map<String,Long>,Double> optimizedResult = inputProducer.findLowInputMaximizingLeakge();
			if(optimizedResult!=null){
				if(metric==KEGConstant.SHANNON_ENTROPY){
					System.out.println("Shannon-entropy-based leakage: " + optimizedResult.second);
				}else{
					System.out.println("Guessing-entropy-based leakage: " + optimizedResult.second);
				}
			}
			if((optimizedResult.second>KEGConstant.MINIMUM_LEAK) &&(optimizedResult.first.size()>0))
				return optimizedResult.first;
			else{
				return findUsefulLowInput();
			}
		}
	}
	
}
