/**
 * 
 */
package de.tud.exploitgen.detectleak;


import de.tud.exploitgen.util.TermParser;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.Name;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.logic.op.LogicVariable;
import de.uka.ilkd.key.logic.op.QuantifiableVariable;


/**
 * This class contains a pair of term that could be used to build formula from two different branches
 * in oder to check non-interference property of the method.
 * @author Huy Do
 *
 */
public class PairTerm {   
   private Term t1, t2;
   private final TermBuilder termBuilder;
   private final Services services;
   
   /**
    * @return the name
    */
   
   /**
    * @return the t1
    */
   public Term getT1() {
      return t1;
   }
   /**
    * @param t1 the t1 to set
    */
   public void setT1(Term t1) {
      this.t1 = t1;
   }
   /**
    * @return the t2
    */
   public Term getT2() {
      return t2;
   }
   /**
    * @param t2 the t2 to set
    */
   public void setT2(Term t2) {
      this.t2 = t2;
   }
   /**
    * @param name
    * @param t1
    * @param t2
    */
   public PairTerm(Term t1, Term t2,Services services) {
      super();   
      this.t1 = t1;
      this.t2 = t2;      
      this.services = services;
      termBuilder = new TermBuilder(new TermFactory(), services);
   }
   
  /* public PairTerm(Term t1, Term t2, TermBuilder termBuilder) {
      super();   
      this.t1 = t1;
      this.t2 = t2;      
      this.termBuilder = termBuilder;
   }*/
   
   /**
    * @param t: @Term
    * @param services: @Services
    * create a PairTerm instance from Term t. t1.name = t.name+"_1", so do t2
    */
   public PairTerm(Term t, Services services){
      super();
      this.services = services;
      termBuilder = new TermBuilder(new TermFactory(), services);
      String name = t.op().name().toString();
      /*LocationVariable lv1=new LocationVariable(new ProgramElementName(name + "_1"),t.sort());
      LocationVariable lv2=new LocationVariable(new ProgramElementName(name + "_2"),t.sort());*/ 
      KeYJavaType type = services.getJavaInfo().getKeYJavaType(t.sort());
      LocationVariable lv1=new LocationVariable(new ProgramElementName(name + "_1"),type);
      LocationVariable lv2=new LocationVariable(new ProgramElementName(name + "_2"),type);
      t1 = termBuilder.var(lv1);
      t2 = termBuilder.var(lv2);
   }
   
   /**
   * @param t: @Term
   * @param services: @Services
   * @param idx: int
   * create a PairTerm instance from Term t. t1.name = t.name+"_"+idx, so do t2
   */
   public PairTerm(Term t, Services services, int idx){
	   super();
      this.services = services;
      termBuilder = new TermBuilder(new TermFactory(), services);
      String name = t.op().name().toString();
      /*LocationVariable lv1=new LocationVariable(new ProgramElementName(name + "_1"),t.sort());
      LocationVariable lv2=new LocationVariable(new ProgramElementName(name + "_2"),t.sort());*/ 
      KeYJavaType type = services.getJavaInfo().getKeYJavaType(t.sort());
      LocationVariable lv1=new LocationVariable(new ProgramElementName(name + "_" + idx),type);
      LocationVariable lv2=new LocationVariable(new ProgramElementName(name + "_" + idx),type);
      t1 = termBuilder.var(lv1);
      t2 = termBuilder.var(lv2);
   }
   
   /**
    * @return term t1=t2
    * implement extension for object-sensitive comparison
    * */
   public Term equalTerm(int id){
      if(TermParser.isPrimitiveType(t1)&& TermParser.isPrimitiveType(t2))
         return termBuilder.equals(t1, t2);
      else if(TermParser.isQuantifier(t1)||(TermParser.isQuantifier(t2))){ //serving conditional delimited release
         return termBuilder.equals(t1, t2);
      }
      else if(TermParser.isNullSort(t1)){ //if t1==null
         if(TermParser.isNullSort(t2))
            return termBuilder.tt();
         else
            return termBuilder.ff();
      }else{ //if t1!=null
         if(TermParser.isNullSort(t2))
            return termBuilder.ff();
         else{ //if t1!=null && t2!=null           
            if(t1.sort().toString().equals(t2.sort().toString())){
               /*resolve array
                * two array is considered as equal if their lengths and their corresponding elements are identical
                * the term is given in negation form so that we can avoid forall operator
                * */
               if(TermParser.isArray(t1)&&TermParser.isArray(t2)){
                  /*Term lengthT1 = termBuilder.dotLength(t1);
                  Term lengthT2 = termBuilder.dotLength(t2);
                  Term notEqualLength = termBuilder.not(termBuilder.equals(lengthT1, lengthT2));
                  QuantifiableVariable qv = new LogicVariable(new Name("i"),lengthT1.sort());
                  Term idx = termBuilder.var(qv);
                  //Term notEqualElement = termBuilder.not(termBuilder.equals(termBuilder.dotArr(t1, idx), termBuilder.dotArr(t2, idx)));
                  Term notEqualElement = termBuilder.not(new PairTerm(termBuilder.dotArr(t1, idx), termBuilder.dotArr(t2, idx),termBuilder).equalTerm());
                  Term exitstTerm = termBuilder.and(
                        termBuilder.equals(lengthT1, lengthT2),                       
                        termBuilder.geq(lengthT1, termBuilder.zTerm(0)),
                        termBuilder.ex(
                              qv,
                              termBuilder.and(
                                    termBuilder.geq(idx, termBuilder.zTerm(0)),
                                    termBuilder.lt(idx, lengthT1),
                                    notEqualElement
                              )
                        )                                   
                              
                  );                  
                  return termBuilder.not(termBuilder.or(notEqualLength, exitstTerm));*/
                  
                  /* implement the equality of two not-null arrays a1 and a2:
                   * and(length(a1)=length(a2) && (\forall int i; i>=0 && i<length(a1); equal(a1[i],a2[i])*/
                  
                  Term lengthT1 = termBuilder.dotLength(t1);
                  Term lengthT2 = termBuilder.dotLength(t2);
                  Term equalLength = termBuilder.equals(lengthT1, lengthT2);
                  QuantifiableVariable qv = new LogicVariable(new Name("i"+String.valueOf(id)),lengthT1.sort());
                  Term idx = termBuilder.var(qv);
                  //make equal term recursively 
                  Term equalElement = new PairTerm(termBuilder.dotArr(t1, idx), termBuilder.dotArr(t2, idx),services).equalTerm(id+1);                  
                  Term forallTerm = termBuilder.all(
                              qv,
                              termBuilder.imp(
                                    termBuilder.and(
                                    termBuilder.geq(idx, termBuilder.zTerm(0)),
                                    termBuilder.lt(idx, lengthT1)
                                    ),
                                    equalElement
                              ));                                   
                  Term identicalArrays = termBuilder.and(
                        equalLength, 
                        termBuilder.gt(lengthT1, termBuilder.zTerm(0)),
                        forallTerm
                        );            
                  return termBuilder.or(
                        termBuilder.and(
                              termBuilder.leq(lengthT1, termBuilder.zTerm(0)),
                              termBuilder.leq(lengthT2, termBuilder.zTerm(0))
                        ),
                        identicalArrays);
               }else{ 
                  /*
                   * working with Object type: need to access all reachable fields
                   * get reachable fields: use information get from Sort
                   * */
                 /* Sort s = t1.sort();
                  
//                  ((LocationVariable)t1.op()).getKeYJavaType()
                  System.out.println("t1: " + t1 + " \nt2: " + t2);
                  JavaInfo javaInfor = services.getJavaInfo();
                         
                  System.out.println("fields of class: " + t1.op().toString() + " : " + javaInfor.getTypeDeclaration(javaInfor.getKeYJavaType(s).getFullName()).getAllFields(services));*/                  
                  return termBuilder.tt();
               }
            }               
            else
               return termBuilder.ff();
         }                  
      }         
   }
   
   /**
    * return fresh term t1 = t2
    * */
   public Term freshEqualTerm(){
      return termBuilder.equals(t1, t2);
   }
   /**
    * @return term t1 != t2 based on equalTerm
    * */
   public Term notEqualTerm(int id){
      return termBuilder.not(equalTerm(id));
   }
   
   /**
    * @return term t1 != t2 based on freshEqualTerm
    * */
   public Term freshNotEqualTerm(){
      return termBuilder.not(freshEqualTerm());
   }
   public String toString(){
      return("(" + t1.toString() + ":"+t1.sort().toString() + " ; " + t2.toString()+":"+t2.sort().toString()+")");
   }
}
