package de.tud.exploitgen.findsecret;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.logic.Term;

/**
 * an abstraction of a risky path served for secret inferring that contains basically following properties
 * 	   - the constraint of the path
 * 	   - the symbolic values of observable output.
 * due to the fact that a risky path can have more than one model, then one risky path can have more than one path abstraction 
 * @author Huy Do
 * */
public class RiskyPathAbstraction {
	private Term constraint; //representing for precondition (initial knowledge) and path condition
	private Map<String, Term> observableSymbolicValues;
	List<String> constantOutputVars; //list of all observable variable that have symbolic output value is constant 
	List<String> notConstantOutputVars;
	
	public RiskyPathAbstraction(Term constraint,
			Map<String, Term> observableSymbolicValues) {
		super();
		this.constraint = constraint;
		this.observableSymbolicValues = observableSymbolicValues;
		resolveListConsants();
	}
	public Term getConstraint() {
		return constraint;
	}
	
	public Map<String, Term> getObservableSymbolicValues() {
		return observableSymbolicValues;
	}
	
	/*
	 * return list of name of observable variables that has a constant output value, if it does not exist, return null
	 */
	private void resolveListConsants(){	
		constantOutputVars = new LinkedList<String>();
		notConstantOutputVars = new LinkedList<String>();
		for(String varName: observableSymbolicValues.keySet()){
			Term symbolicValue = observableSymbolicValues.get(varName);
			if(TermParser.isInteger(symbolicValue)|| TermParser.isBooleanConstant(symbolicValue))
				constantOutputVars.add(varName);
			else
				notConstantOutputVars.add(varName);
		}
		
	}
	
	public List<String> getConstantOutputVars() {
		return constantOutputVars;
	}
	public List<String> getNotConstantOutputVars() {
		return notConstantOutputVars;
	}
	
	
}
