/**
 * 
 */
package de.tud.exploitgen.processing.exploit;

import java.security.KeyRep;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.ModelBuilderVisitor;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstanceFactory;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariableFactory;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.declaration.ParameterDeclaration;
import de.uka.ilkd.key.java.declaration.VariableSpecification;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionMethodCall;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
import de.uka.ilkd.key.symbolic_execution.object_model.impl.SymbolicValue;

/**
 * this class collect all program variables (including heap variables) contained in a node of Symbolic execution tree
 * to build exploit model, as well as supply materials for TwoPathProcessor (to create listLowVar, listHighVar)
 * @author Huy Do
 *
 */
public class ExploitModelBuilder {
   private Model model1, model2;
   private String HEAP_NAME="";
   Stack<String> sHeapName; //contains name of object in heap, served for creating name of heap variables during recursively investigating heap
   List<Term> artificialVars; //contains artificial variables created by SED for loop invariant  
   private final Services services;
   /**
    * default constructor
    * */
   public ExploitModelBuilder(Services services){
      model1=Model.constructModel();
      model2=Model.constructModel();
      this.services=services;
      sHeapName=new Stack<String>();      
      artificialVars = new LinkedList<Term>();      
   }
   
     
   /**
    * initiate exploit model from a node in execution tree.
    * All primitive variables will be initiated by default values
    * all fields will be investigated recursively
    * */
   public void initiateExploitModelFromNode(IExecutionNode node, int branch) throws ProofInputException, TermTransformerException{
      
      
      
      /*
       * Create the initial Model, without any concrete values assigned to
       * primitive integer values in it.
       */
       //model1 = new ModelBuilder().createModel(node, pathCondition);
       //model2 = new ModelBuilder().createModel(node, pathCondition);       
       
      // get all parameters of method  
      //addMethodParameters(node, branch);
      //addMethodParameters(node, 2);
       
     
      //System.out.println(node.toString());
      
       //investigate heap to add all fields into model
       
       IExecutionVariable[] vars = ((IExecutionStateNode<?>) node).getVariables(); 
       
       for(IExecutionVariable var: vars){
          System.out.println("variables: " + var.getName());          
          if(HeapHandler.isSelf(var)){
             //addSelfToModel(var, 1);
             //addSelfToModel(var, 2);
             addSelfToModel(var, branch);
             HEAP_NAME=var.getName();             
             //add HEAP_NAME to stack
             //sHeapName.add(HEAP_NAME);
             //add "self" object to model              
             investigateSelf(var,branch);
             //break;
          }else if(HeapHandler.isStatic(var)){
             addStaticVarToModel(var, branch);
             investigateStaticObject(var, branch);           
             
          }else if(HeapHandler.isParameter(var)){
             addParameterToModel(var, branch);
             investigateStaticObject(var, branch);   
          }
       }
       
       
       //manipulate exploit model to indicate the container for static variables
       maniputlateModel2SolveStaticVar(branch);
   }   
   
   private void addMethodParameters(IExecutionNode node,int branch){
      final IExecutionMethodCall methodCall = getMethodCallNode(node);
      final ImmutableArray<ParameterDeclaration> parameterDeclarations = methodCall.getProgramMethod()
            .getParameters();
      
      for (final ParameterDeclaration parameterDeclaration : parameterDeclarations) {
      
         for (final VariableSpecification variableSpecification : parameterDeclaration.getVariables()) {
         
            /*
            * Convert the declaration to a program variable
            * 
            * FIXME: Define common abstraction and stop flipflopping
            * between existing ones.
            */
            final KeYJavaType type = (KeYJavaType) variableSpecification.getType();
            
            final ProgramElementName name = new ProgramElementName(variableSpecification.getName());
            
            final IProgramVariable programVariable = new LocationVariable(name, type);
            
            final ModelVariable modelParameter = ModelVariableFactory.constructModelVariable(programVariable,
                                    name.toString());
            
            modelParameter.setParameter(true);            
            
            
            /*
            * The parameter is primitive.
            */
            Object value = null;
            if (TermParser.isPrimitiveType(modelParameter.getTypeName())) {
               value = ModelBuilderVisitor.resolvePrimitiveType(programVariable);
            } else {
               value = ModelInstanceFactory.constructModelInstance(type);
            }
            if(branch==1)
               model1.add(modelParameter, value);               
            else
               model2.add(modelParameter, value);
         }
      }
      
   }
   
   /**
    * Given an {@link IExecutionNode} somewhere in a symbolic execution tree
    * and below the method call node, backtracks until the method call node is
    * found. Excludes all intermediary method calls.
    *
    * @param node the node
    * @author Christopher
    */
   private IExecutionMethodCall getMethodCallNode(final IExecutionNode node) {

       IExecutionMethodCall methodCall = getMethodCallNode_helper(node);
       while (true) {
           IExecutionMethodCall next = getMethodCallNode_helper(methodCall.getParent());
           if (next == null) {
               break;
           } else {
               methodCall = next;
           }
       }
       return methodCall;
   }

   private IExecutionMethodCall getMethodCallNode_helper(final IExecutionNode node) {
       if (node == null || node instanceof IExecutionMethodCall) {
           return (IExecutionMethodCall) node;
       } else {
           return getMethodCallNode_helper(node.getParent());
       }
   }
   
   
   /**
    * investigate self object to retrieve information of all fields and add it into exploit model
    * */
   private void investigateSelf(IExecutionVariable var, int branch) throws ProofInputException{
      if (var.getProgramVariable() instanceof IProgramVariable){   
         //System.out.println(var.getName());
         //add variable to model1 and model 2
         if(!HeapHandler.isSelf(var)){               
            addVarToModel(var,branch);
            
         }
         //addVarToModel(var,branch);
         sHeapName.push(var.getName());
         //recursively work with child variable of this variable
         IExecutionValue[] values =var.getValues();
         for(IExecutionValue value:values){           
            IExecutionVariable[] vchilds=value.getChildVariables();
            //System.out.println("value of " + var + " : " + value.toString());
            //System.out.println("number of child variables of " + var + " : " + vchilds.length);
            for(IExecutionVariable vchild:vchilds){               
               investigateSelf(vchild,branch) ;               
            }
         }
         sHeapName.pop();      
      }      
   }
   
   
   /**
    * investigate static object to get all of its fields
    * */
   private void investigateStaticObject(IExecutionVariable var, int branch) throws ProofInputException{
      if (var.getProgramVariable() instanceof IProgramVariable){   
         //System.out.println(var.getName());
         //if var has not been added into model, we add it!
         String identifier = KeYResourceHandler.getVarName(var);
         if(!inModel(identifier,branch)){
            addVarToModel(var, branch);
         }                    
         sHeapName.push(identifier);
         //recursively work with child variable of this variable
         IExecutionValue[] values =var.getValues();
         for(IExecutionValue value:values){           
            IExecutionVariable[] vchilds=value.getChildVariables();
            //System.out.println("value of " + var + " : " + value.toString());
            //System.out.println("number of child variables of " + var + " : " + vchilds.length);
            for(IExecutionVariable vchild:vchilds){               
               investigateStaticObject(vchild,branch) ;               
            }
         }
         sHeapName.pop();      
      }      
   }
   
   /**
    * called if var is heap (started by "self")
    * @throws ProofInputException 
    * */
   private void addSelfToModel(IExecutionVariable var, int branch) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
      final ModelInstance selfInstance = ModelInstanceFactory.constructModelInstance(container);
      
      final ModelVariable self = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), var.getName());
      
      if(branch==1)
         model1.add(self, selfInstance);
      else
         model2.add(self, selfInstance);
   }
   
   /**
    * called if var is a static variable of the class
    * @throws ProofInputException
    * */
   private void addStaticVarToModel(IExecutionVariable var, int branch) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
     
      Object instance;
      if (HeapHandler.isPrimitive(var)) {
          //The term is a static variable. Identify and connect it with its parent class.
          instance = ModelBuilderVisitor.resolvePrimitiveType(var.getProgramVariable());
      } else {
          instance = ModelInstanceFactory.constructModelInstance(container);
      }
      final ModelVariable staticVar = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), 
                                                                                  KeYResourceHandler.getVarName(var));
      
      /*
       * basically, the static variable can have an arbitrary value
       * however, we treat static variable as normal variable to simplify the process
       * the side effect of assignment on static variable in self-composition can be eliminate 
       * by re-assigning the value of them after an execution   
       * */
      
      //set the symbolic value of @ModelVariable variable
      Term symbolicValue=var.getValues()[0].getValue();      
      
      symbolicValue=new HeapHandler(services).replaceSelectFunctionByItsField(symbolicValue);
      //System.out.println("value of " + variable.getIdentifier() + " : " + symbolicValue);
      staticVar.setSymbolicValue(symbolicValue);
      
      
      staticVar.setStatic(true);
      staticVar.setDeclareClassName(KeYResourceHandler.getAccessClassNameOfStaticVar(var));
      
      if(branch==1){
         model1.add(staticVar, instance);
         //model1.assignField(staticVar, model1.getVariable(HEAP_NAME));//now self object can treat static variable as a normal field
      }else{
         model2.add(staticVar, instance);
         //model2.assignField(staticVar, model2.getVariable(HEAP_NAME));
      }
   }
   
   /**
    * called if var is a parameter of the method
    * */
   private void addParameterToModel(IExecutionVariable var, int branch) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
      
      Object instance;
      if (HeapHandler.isPrimitive(var)) {
          //The term is a static variable. Identify and connect it with its parent class.
          instance = ModelBuilderVisitor.resolvePrimitiveType(var.getProgramVariable());
      } else {
          instance = ModelInstanceFactory.constructModelInstance(container);
      }
      final ModelVariable staticVar = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), 
                                                                                  KeYResourceHandler.getVarName(var));
      
      /*
       * basically, the static variable can have an arbitrary value
       * however, we treat static variable as normal variable to simplify the process
       * the side effect of assignment on static variable in self-composition can be eliminate 
       * by re-assigning the value of them after an execution   
       * */
      
      //set the symbolic value of @ModelVariable variable
      Term symbolicValue=var.getValues()[0].getValue();      
      
      symbolicValue=new HeapHandler(services).replaceSelectFunctionByItsField(symbolicValue);
      //System.out.println("value of " + variable.getIdentifier() + " : " + symbolicValue);
      staticVar.setSymbolicValue(symbolicValue);
      
      if(branch==1){
         model1.add(staticVar, instance);
         //model1.assignField(staticVar, model1.getVariable(HEAP_NAME));//now self object can treat static variable as a normal field
      }else{
         model2.add(staticVar, instance);
         //model2.assignField(staticVar, model2.getVariable(HEAP_NAME));
      }
   }
   
   /**
    * adds a field of the class to model, links to container object
    * */
   private void addVarToModel(IExecutionVariable var, int branch) throws ProofInputException{
      String identifier = KeYResourceHandler.getVarName(var);
      if(!HeapHandler.isParameter(var))
         identifier=getReferenceName()+"_"+identifier;
      /*if(var.getParentValue()!=null || HeapHandler.isStaticVar(var))
         identifier=getReferenceName()+"_"+identifier;      */
      
      /*
       * 
       * Check that the variable we found is not already present in the model.
       */
     /* 
      ModelVariable currentVariable;
      if(branch==1){
         currentVariable = model1.getVariable(identifier);
      }else{
         currentVariable = model2.getVariable(identifier);
      }
      if ((currentVariable != null)) {
          return;
      }*/
      
      //if var has not been added to model, we add it
      if(!inModel(identifier,branch)){
         //final ModelVariable variable = ModelVariableFactory.constructModelVariable((ProgramVariable)var, identifier);
         final ModelVariable variable=new ModelVariable(var.getProgramVariable(),identifier);
         
         Object instance;
         if (HeapHandler.isPrimitive(var)) {
             //The term is a static variable. Identify and connect it with its parent class.
             instance = ModelBuilderVisitor.resolvePrimitiveType(var.getProgramVariable());
         } else {
             instance = ModelInstanceFactory.constructModelInstance(var.getProgramVariable().getKeYJavaType());
         }
         
         //set the symbolic value of @ModelVariable variable
         Term symbolicValue=var.getValues()[0].getValue();
         //add artificial variables contained in the value (if they exist)
         investigateArtificialVars(symbolicValue); //investigate all artificial variables
    
         
         
         symbolicValue=new HeapHandler(services).replaceSelectFunctionByItsField(symbolicValue);
         //System.out.println("value of " + variable.getIdentifier() + " : " + symbolicValue);
         variable.setSymbolicValue(symbolicValue);
        
         
         
         if(HeapHandler.isParameter(var))  //assign true flag for method's parameter
            variable.setParameter(true);
         
         if(HeapHandler.isStatic(var)){
            variable.setStatic(true);
            variable.setDeclareClassName(KeYResourceHandler.getAccessClassNameOfStaticVar(var));
         }else
            variable.setStatic(false);
         
         
            
         /*
          * Add the variable and its instance to the Model. This might seem
          * premature, but must be done to preserve referential integrity and
          * avoiding extra work.
          */
         if(branch==1){
            model1.add(variable, instance);
            String referenceName = getReferenceName();
            model1.assignField(variable, model1.getVariable(referenceName));
         }else{
            model2.add(variable, instance);
            model2.assignField(variable, model2.getVariable(getReferenceName()));
         }
      }
   }   
   
   /*
    * when resolving loop by using loop invariant, SED (Symbolic Execution Debugger) may create fake variables
    * to represent the value of fields, we have to detect them and add them into model
    * */
   private void investigateArtificialVars(final Term term){
      if(term!=null){
         if(TermParser.isArtificialVariable(term)){
            if(!inListTerm(term, artificialVars)){
               artificialVars.add(term);
            }  
         }
         else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               investigateArtificialVars(st);
            }
         }
      }
   }
   
   
  /**
    * Instantiate values for exploit model from an integer concrete model
    * */
   public void instantiateExploitModelInt(final Map<String,Integer> concreteValues){
      for(String varName: concreteValues.keySet()){         
         if(!isDualVar(concreteValues, varName)){  //if varName is not a high or low value
            final ModelVariable variable1 =model1.getVariable(varName);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(varName));
            
            final ModelVariable variable2 =model2.getVariable(varName);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(varName));
         }else{
            String prefix=varName.substring(0, varName.length()-2);
            //get variable in concrete model corresponding with model1            
            final ModelVariable variable1 = model1.getVariable(prefix);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(prefix+"_1"));
            
            // get variable in concrete model corresponding with model2            
            final ModelVariable variable2 = model2.getVariable(prefix);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(prefix+"_2"));
         }
      }
   }
   
   /**
    * check if a variable is dual value or not
    * dual value: is high or low value (h1, h2) or (l1,l2)
    * */
   private boolean isDualVar(final Map<String,Integer> concreteValues,final String varName){
      //remove the suffix  _1 or _2 of varName
      if((!varName.endsWith("_1"))&&(!varName.endsWith("_2"))){
         return false;
      }else{
         String prefix=varName.substring(0, varName.length()-2);
         if((concreteValues.containsKey(prefix+"_1"))&&(concreteValues.containsKey(prefix+"_2")))
            return true;
         else
            return false;
      }
   }
   
   public ExploitModel getExploitModel(){    
      
      return new ExploitModel(model1,model2,HEAP_NAME);
   }
   
   /*
    * constructs reference name from stack, if object obj is a field of heap self, then the heap name is self_obj
    * */
   private String getReferenceName() {  
      String heapName="";
      if(sHeapName.size()>0){
         heapName=sHeapName.get(0);
         for(int i=1;i<sHeapName.size();i++){
            heapName +="_" + sHeapName.get(i);
         }
      }
      return heapName;
   }
   
      
   public Model getModel(int branch){
      if(branch==1)
         return model1;
      else
         return model2;
   }
   
   public String getHEAP_NAME(){
      return HEAP_NAME;
   }
   
   public List<Term> getArtificialVars(){
      return artificialVars;
   }
   
 
   /**
    * return true if Term t is already in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   private boolean inListTerm(Term t, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   //check if a ModelVariable is added into Model or not, use the identifier of var
   private boolean inModel(String identifier, int branch){
      ModelVariable currentVariable;
      if(branch==1){
         currentVariable = model1.getVariable(identifier);
      }else{
         currentVariable = model2.getVariable(identifier);
      }
      if ((currentVariable != null)) 
         return true;
      else
         return false;
   }
   
   /*
    * basically, all static variable are listed when we look into the array of program variables, not in heap
    * however, we would like to match static variable with some specific variables that their class is the real container of it.
    * so we have to manipulate the model
    * */
   
   private void maniputlateModel2SolveStaticVar(int branch){     
      List<ModelVariable> lMV;
      if(branch==1)
         lMV = model1.getVariables();
      else
         lMV = model2.getVariables();
      
      /*
       * now we resolve lMV in the following way:
       * take all ModelVariable mv in lMV
       * if mv is static then
       * find a ModelVariable container in lMV that its type is same with the type of container class of mv
       * set mv as a field of container
       * */
      
      for(ModelVariable mv: lMV){
         if(mv.isStatic()){
            String containerName = mv.getDeclareClassName();
            for(ModelVariable mvc: lMV){
               if(containerName.equals(mvc.getTypeName())){
                  if(branch==1)
                     model1.assignField(mv, mvc);
                  else
                     model2.assignField(mv, mvc);
               }
            }
         }
      }
   }
   
   
}
