/**
 * 
 */
package de.tud.exploitgen.processing.exploit;

//import java.security.KeyRep;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.ModelBuilderVisitor;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstanceFactory;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariableFactory;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
/*import de.uka.ilkd.key.java.declaration.ParameterDeclaration;
import de.uka.ilkd.key.java.declaration.VariableSpecification;
import de.uka.ilkd.key.logic.ProgramElementName;*/
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.IProgramVariable;
//import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionConstraint;
//import de.uka.ilkd.key.symbolic_execution.model.IExecutionMethodCall;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
//import de.uka.ilkd.key.symbolic_execution.object_model.impl.SymbolicValue;

/**
 * this class collect all program variables (including heap variables) contained in a node of Symbolic execution tree
 * to build exploit model, as well as supply materials for TwoPathProcessor (to create listLowVar, listHighVar)
 * @author Huy Do
 *
 */
public class ExploitModelBuilder {
   private Model model1, model2;
   private String HEAP_NAME="";
   private Stack<String> sHeapName; //contains name of object in heap, served for creating name of heap variables during recursively investigating heap
   private List<Term> artificialVars; //contains artificial variables created by SED for loop invariant  
   private final Services services;
   private HeapHandler heapHandler;
   /**
    * default constructor
    * */
   public ExploitModelBuilder(Services services){
      model1=Model.constructModel();
      model2=Model.constructModel();
      this.services=services;
      sHeapName=new Stack<String>();      
      artificialVars = new LinkedList<Term>();
      heapHandler = new HeapHandler(services);
   }
   
     
   /**
    * initiate exploit model from a node in execution tree.
    * All primitive variables will be initiated by default values
    * all fields will be investigated recursively
    * */
   public void initiateExploitModelFromNode(IExecutionNode node, int branch) throws ProofInputException, TermTransformerException{
      /*
       * Create the initial Model, without any concrete values assigned to
       * primitive integer values in it.
       */
            
       //investigate heap to add all fields, static variables and method parameters into model
       
       IExecutionVariable[] vars = ((IExecutionStateNode<?>) node).getVariables(); 
       
       for(IExecutionVariable var: vars){
          System.out.println("variables: " + var.getName());          
          if(HeapHandler.isSelf(var)){
             //assign the value for HEAP_NAME
             HEAP_NAME=var.getName();   
             addSelfToModel(var, branch);                                           
             investigateProgramVariable(var,branch);
             
          }else if(HeapHandler.isStatic(var) || HeapHandler.isParameter(var)){ //solve static variables and method's parameters
             investigateProgramVariable(var, branch);     
          }else if(!HeapHandler.isExc(var)){             
             for(IExecutionValue iev: var.getValues()){
                Term value = iev.getValue();
                value = KeYResourceHandler.removeEqualNull(value);
                value = KeYResourceHandler.removeEqualTRUE(value);
                value = KeYResourceHandler.removeNotnullDefaultCondition(value);
                investigateArtificialVars(value);
             }
          }
          
       }       
       
       //manipulate exploit model to indicate the container for static variables
       maniputlateModel2SolveStaticVar(branch);
       
       //investigate path condition to find out artificial variables
       Term pathCond = node.getPathCondition();
       investigateArtificialVars(pathCond);
   }     

   /**
    * investigate self object to retrieve information of all fields and add it into exploit model
    * */
   private void investigateProgramVariable(IExecutionVariable var, int branch) throws ProofInputException{
      if (var.getProgramVariable() instanceof IProgramVariable){   
         
         String identifier = KeYResourceHandler.getVarName(var);
         if(!inModel(identifier,branch)){
            addVarToModel(var, branch);
         } 
         
         sHeapName.push(KeYResourceHandler.getVarName(var));
         //recursively work with child variable of this variable
         IExecutionValue[] values =var.getValues();
         
         for(IExecutionValue value:values){                  
            IExecutionVariable[] vchilds=value.getChildVariables();           
            for(IExecutionVariable vchild:vchilds){               
               investigateProgramVariable(vchild,branch) ;               
            }
         }
         sHeapName.pop();      
      }      
   }
      
   /**
    * called if var is heap (started by "self")
    * @throws ProofInputException 
    * */
   private void addSelfToModel(IExecutionVariable var, int branch) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
      final ModelInstance selfInstance = ModelInstanceFactory.constructModelInstance(container);
      
      final ModelVariable self = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), var.getName());
      
      if(branch==1)
         model1.add(self, selfInstance);
      else
         model2.add(self, selfInstance);
   }
     
   /**
    * adds a field of the class to model, links to container object
    * */
   private void addVarToModel(IExecutionVariable var, int branch) throws ProofInputException{
      
      if(HeapHandler.isArray(var)){
         System.out.println(var + " is array!");
      }
      
      String identifier = KeYResourceHandler.getVarName(var);
      
      if(!HeapHandler.isParameter(var)){
         if(!sHeapName.isEmpty())
            identifier=getReferenceName()+"_"+identifier;
      }
           
      final ModelVariable variable=new ModelVariable(var.getProgramVariable(),identifier);
      
      Object instance;
      if (HeapHandler.isPrimitive(var)) {
          //The term is a static variable. Identify and connect it with its parent class.
          instance = ModelBuilderVisitor.resolvePrimitiveType(var.getProgramVariable());
      } else {
          instance = ModelInstanceFactory.constructModelInstance(var.getProgramVariable().getKeYJavaType());
      }
      
      //resolve symbolic value
      IExecutionValue[] values =var.getValues();
      Term symbolicValue = values[0].getValue();
      System.out.println("value of " + variable.getIdentifier() + " : " + symbolicValue + " ; type: " + variable.getType());
      symbolicValue = KeYResourceHandler.removeEqualNull(symbolicValue);
      symbolicValue = KeYResourceHandler.removeEqualTRUE(symbolicValue);
      symbolicValue = KeYResourceHandler.removeNotnullDefaultCondition(symbolicValue);
      symbolicValue = heapHandler.replaceSelectFunctionByItsField(symbolicValue);
      symbolicValue = heapHandler.replaceLengthFunctionByVar(symbolicValue);
      
      variable.setSymbolicValue(symbolicValue);
      //add artificial variables contained in the value (if they exist)
      investigateArtificialVars(symbolicValue); //investigate all artificial variables
      
      //resolve all constraints of var, the constraints is retrieved from value
      List<Term> constraints = new LinkedList<Term>();
      for(IExecutionValue value:values){  
         for(IExecutionConstraint ec: value.getConstraints()){
            //System.out.println(ec.getTerm());
            Term constraint = ec.getTerm();
            if(KeYResourceHandler.isUsefulConstraint(constraint)){
               //System.out.println("useful constraint: " + constraint);
               symbolicValue = KeYResourceHandler.removeEqualNull(symbolicValue);
               symbolicValue = KeYResourceHandler.removeEqualTRUE(symbolicValue);
               symbolicValue = KeYResourceHandler.removeNotnullDefaultCondition(symbolicValue);
               constraint = heapHandler.replaceSelectFunctionByItsField(constraint);
               constraint = heapHandler.replaceLengthFunctionByVar(constraint);
               constraints.add(constraint);
               investigateArtificialVars(constraint); //investigate all artificial variables
            }
         }        
      }
      variable.setConstraints(constraints);
      
      if(HeapHandler.isParameter(var))  //assign true flag for method's parameter
         variable.setParameter(true);
      
      if(HeapHandler.isStatic(var)){
         variable.setStatic(true);
         variable.setDeclareClassName(KeYResourceHandler.getAccessClassNameOfStaticVar(var));
      }else
         variable.setStatic(false);         
      
         
      /*
       * Add the variable and its instance to the Model. This might seem
       * premature, but must be done to preserve referential integrity and
       * avoiding extra work.
       */
      if(branch==1){
         model1.add(variable, instance);
         if(!sHeapName.isEmpty()){
            String referenceName = getReferenceName();
            model1.assignField(variable, model1.getVariable(referenceName));
         }
      }else{
         model2.add(variable, instance);
         if(!sHeapName.isEmpty()){
            String referenceName = getReferenceName();
            model2.assignField(variable, model2.getVariable(referenceName));
         }
      }
     
        
   }   
   
   /*
    * when resolving loop by using loop invariant, SED (Symbolic Execution Debugger) may create fake variables
    * to represent the value of fields, we have to detect them and add them into model
    * */
   private void investigateArtificialVars(final Term term){
      if(term!=null){              
         if(TermParser.isArtificialVariable(term)){
            //System.out.println("artificial detected!::: " + term);
            //we have to check if term has been added into model or not
            //if true, it is parameter and we do not add it into list of artificial variables
            if(!inModel(term.toString(),1) &&!inModel(term.toString(),2)){
               Term addTerm;
               if(HeapHandler.isLoopHeap(term))
                  addTerm = new HeapHandler(services).getReplacedTermForSelect(term);
               else
                  addTerm = term;            
               if(!inListTerm(addTerm, artificialVars)){               
                  artificialVars.add(addTerm);
               }  
            }
         }
         else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               investigateArtificialVars(st);
            }
         }
      }
   }
   
   /*
    * constructs reference name from stack, if object obj is a field of heap self, then the heap name is self_obj
    * */
   private String getReferenceName() {  
      String heapName="";
      if(sHeapName.size()>0){
         heapName=sHeapName.get(0);
         for(int i=1;i<sHeapName.size();i++){
            heapName +="_" + sHeapName.get(i);
         }
      }
      return heapName;
   }
   
      
     
 
   /**
    * return true if Term t is already in list lt (lt contains a Term that has the same name with t)
    * otherwise return false
    * */
   private boolean inListTerm(Term t, List<Term> lt){
      if(!lt.isEmpty()){
         for(Term te: lt){
            if(t.toString().equals(te.toString()))
               return true;
         }
      }
      return false;
   }
   
   //check if a ModelVariable is added into Model or not, use the identifier of var
   private boolean inModel(String identifier, int branch){
      ModelVariable currentVariable;
      if(branch==1){
         currentVariable = model1.getVariable(identifier);
      }else{
         currentVariable = model2.getVariable(identifier);
      }
      if ((currentVariable != null)) 
         return true;
      else
         return false;
   }
   
   /*
    * basically, all static variable are listed when we look into the array of program variables, not in heap
    * however, we would like to match static variable with some specific variables that their class is the real container of it.
    * so we have to manipulate the model
    * */
   
   private void maniputlateModel2SolveStaticVar(int branch){     
      List<ModelVariable> lMV;
      if(branch==1)
         lMV = model1.getVariables();
      else
         lMV = model2.getVariables();
      
      /*
       * now we resolve lMV in the following way:
       * take all ModelVariable mv in lMV
       * if mv is static then
       * find a ModelVariable container in lMV that its type is same with the type of container class of mv
       * set mv as a field of container
       * */
      //System.out.println("+++ BEGIN static resolving");
      for(ModelVariable mv: lMV){       
         if(mv.isStatic()){
          //System.out.println(mv.getIdentifier() + " : " + mv.getVariableName());
            String containerName = mv.getDeclareClassName();
            for(ModelVariable mvc: lMV){
               if(containerName.equals(mvc.getTypeName())){
                  if(branch==1)
                     model1.assignField(mv, mvc);
                  else
                     model2.assignField(mv, mvc);
               }
            }
         }        
      }
      //System.out.println("+++ END static resolving");
   }
   
  /**
    * Instantiate values for exploit model from an integer concrete model
    * */
   public void instantiateExploitModelInt(final Map<String,Integer> concreteValues){
      for(String varName: concreteValues.keySet()){         
         if(!isDualVar(concreteValues, varName)){  //if varName is not a high or low value
            final ModelVariable variable1 =model1.getVariable(varName);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(varName));
            
            final ModelVariable variable2 =model2.getVariable(varName);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(varName));
         }else{
            String prefix=varName.substring(0, varName.length()-2);
            //get variable in concrete model corresponding with model1            
            final ModelVariable variable1 = model1.getVariable(prefix);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(prefix+"_1"));
            
            // get variable in concrete model corresponding with model2            
            final ModelVariable variable2 = model2.getVariable(prefix);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(prefix+"_2"));
         }
      }
   }
   
   /**
    * check if a variable is dual value or not
    * dual value: is high or low value (h1, h2) or (l1,l2)
    * */
   private boolean isDualVar(final Map<String,Integer> concreteValues,final String varName){
      //remove the suffix  _1 or _2 of varName
      if((!varName.endsWith("_1"))&&(!varName.endsWith("_2"))){
         return false;
      }else{
         String prefix=varName.substring(0, varName.length()-2);
         if((concreteValues.containsKey(prefix+"_1"))&&(concreteValues.containsKey(prefix+"_2")))
            return true;
         else
            return false;
      }
   }
   
   
   public ExploitModel getExploitModel(){          
      return new ExploitModel(model1,model2,HEAP_NAME);
   }
   
   public Model getModel(int branch){
      if(branch==1)
         return model1;
      else
         return model2;
   }
   
   public String getHEAP_NAME(){
      return HEAP_NAME;
   }
   
   public List<Term> getArtificialVars(){
      return artificialVars;
   }
   
   
   
}
