/**
 * 
 */
package de.tud.exploitgen.processing.exploit;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import com.csvanefalk.keytestgen.core.model.implementation.Model;
import com.csvanefalk.keytestgen.core.model.implementation.ModelBuilderVisitor;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstance;
import com.csvanefalk.keytestgen.core.model.implementation.instance.ModelInstanceFactory;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariableFactory;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;

import de.tud.exploitgen.util.HeapHandler;
import de.tud.exploitgen.util.KeYResourceHandler;
import de.tud.exploitgen.util.TermParser;
import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.java.declaration.ParameterDeclaration;
import de.uka.ilkd.key.java.declaration.VariableSpecification;
import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.op.IProgramVariable;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionMethodCall;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
import de.uka.ilkd.key.symbolic_execution.object_model.impl.SymbolicValue;

/**
 * this class collect all program variables (including heap variables) contained in a node of Symbolic execution tree
 * to build exploit model, as well as supply materials for TwoPathProcessor (to create listLowVar, listHighVar)
 * @author Huy Do
 *
 */
public class ExploitModelBuilder {
   private Model model1, model2;
   private String HEAP_NAME="";
   Stack<String> sHeapName; //contains name of object in heap, served for creating name of heap variables during recursively investigating heap
   Stack<String> sStaticFieldName; //contains name of object in memory of static fields. Name of the root is "null".
   List<Term> artificialVars; //contains artificial variables created by SED for loop invariant
   List<Term> staticVars; //store all static variables investigated
   private final Services services;
   /**
    * default constructor
    * */
   public ExploitModelBuilder(Services services){
      model1=Model.constructModel();
      model2=Model.constructModel();
      this.services=services;
      sHeapName=new Stack<String>();      
      artificialVars = new LinkedList<Term>();
      staticVars = new LinkedList<Term>();
      sStaticFieldName = new Stack<String>();
   }
   
   /**
    * initiate exploit model from a node in execution tree.
    * All primitive variables will be initiated by default values
    * all fields will be investigated recursively
    * */
   public void initiateExploitModelFromNode(IExecutionNode node, int branch) throws ProofInputException, TermTransformerException{
      
      
      
      /*
       * Create the initial Model, without any concrete values assigned to
       * primitive integer values in it.
       */
       //model1 = new ModelBuilder().createModel(node, pathCondition);
       //model2 = new ModelBuilder().createModel(node, pathCondition);       
       
      // get all parameters of method  
      addMethodParameters(node, branch);
      //addMethodParameters(node, 2);
       
     
      //System.out.println(node.toString());
      
       //investigate heap to add all fields into model
       
       IExecutionVariable[] vars = ((IExecutionStateNode) node).getVariables(); 
       
       for(IExecutionVariable var: vars){
          System.out.println("variables: " + var.getName());
          //System.out.println(var.getName());
          if(HeapHandler.isSelf(var)){
             //addSelfToModel(var, 1);
             //addSelfToModel(var, 2);
             addSelfToModel(var, branch);
             HEAP_NAME=var.getName();             
             //add HEAP_NAME to stack
             //sHeapName.add(HEAP_NAME);
             //add "self" object to model              
             investigateSelf(var,branch);
             break;
          }else if(!HeapHandler.isExc(var)){ //if var is not self and exc, then var is parameter
             addFieldToModel(var, branch);
          }
       }
       
   }   
   
   private void addMethodParameters(IExecutionNode node,int branch){
      final IExecutionMethodCall methodCall = getMethodCallNode(node);
      final ImmutableArray<ParameterDeclaration> parameterDeclarations = methodCall.getProgramMethod()
            .getParameters();
      
      for (final ParameterDeclaration parameterDeclaration : parameterDeclarations) {
      
         for (final VariableSpecification variableSpecification : parameterDeclaration.getVariables()) {
         
            /*
            * Convert the declaration to a program variable
            * 
            * FIXME: Define common abstraction and stop flipflopping
            * between existing ones.
            */
            final KeYJavaType type = (KeYJavaType) variableSpecification.getType();
            
            final ProgramElementName name = new ProgramElementName(variableSpecification.getName());
            
            final IProgramVariable programVariable = new LocationVariable(name, type);
            
            final ModelVariable modelParameter = ModelVariableFactory.constructModelVariable(programVariable,
                                    name.toString());
            
            modelParameter.setParameter(true);            
            
            
            /*
            * The parameter is primitive.
            */
            Object value = null;
            if (TermParser.isPrimitiveType(modelParameter.getTypeName())) {
               value = ModelBuilderVisitor.resolvePrimitiveType(programVariable);
            } else {
               value = ModelInstanceFactory.constructModelInstance(type);
            }
            if(branch==1)
               model1.add(modelParameter, value);               
            else
               model2.add(modelParameter, value);
         }
      }
      
   }
   
   /**
    * Given an {@link IExecutionNode} somewhere in a symbolic execution tree
    * and below the method call node, backtracks until the method call node is
    * found. Excludes all intermediary method calls.
    *
    * @param node the node
    * @author Christopher
    */
   private IExecutionMethodCall getMethodCallNode(final IExecutionNode node) {

       IExecutionMethodCall methodCall = getMethodCallNode_helper(node);
       while (true) {
           IExecutionMethodCall next = getMethodCallNode_helper(methodCall.getParent());
           if (next == null) {
               break;
           } else {
               methodCall = next;
           }
       }
       return methodCall;
   }

   private IExecutionMethodCall getMethodCallNode_helper(final IExecutionNode node) {
       if (node == null || node instanceof IExecutionMethodCall) {
           return (IExecutionMethodCall) node;
       } else {
           return getMethodCallNode_helper(node.getParent());
       }
   }
   
   
   /**
    * investigate self object to retrieve information of all fields and add it into exploit model
    * */
   private void investigateSelf(IExecutionVariable var, int branch) throws ProofInputException{
      if (var.getProgramVariable() instanceof IProgramVariable){   
         //System.out.println(var.getName());
         //add variable to model1 and model 2
         if(!HeapHandler.isSelf(var)){               
            addFieldToModel(var,branch);
            
         }
         sHeapName.push(var.getName());
         //recursively work with child variable of this variable
         IExecutionValue[] values =var.getValues();
         for(IExecutionValue value:values){
           
            IExecutionVariable[] vchilds=value.getChildVariables();
            //System.out.println("value of " + var + " : " + value.toString());
            //System.out.println("number of child variables of " + var + " : " + vchilds.length);
            for(IExecutionVariable vchild:vchilds){               
               investigateSelf(vchild,branch) ;
               
            }
         }
         sHeapName.pop();      
      }      
   }
   
   /**
    * called if var is heap (started by "self")
    * @throws ProofInputException 
    * */
   private void addSelfToModel(IExecutionVariable var, int branch) throws ProofInputException{
      KeYJavaType container = var.getProgramVariable().getKeYJavaType();
      final ModelInstance selfInstance = ModelInstanceFactory.constructModelInstance(container);
      
      final ModelVariable self = ModelVariableFactory.constructModelVariable(var.getProgramVariable(), var.getName());
      
      if(branch==1)
         model1.add(self, selfInstance);
      else
         model2.add(self, selfInstance);
   }
   
   /**
    * adds a field of the class to model, links to container object
    * */
   private void addFieldToModel(IExecutionVariable var, int branch) throws ProofInputException{
      String identifier;
      if(var.getParentValue()==null){ //if var is a parameter, we have to remove prefix "_"
         identifier=KeYResourceHandler.getVarName(var);
      }else{         
         identifier=getReferenceName()+"_"+var.getName();; //reference name is used as prefix
      }      
     
      /*
       * 
       * Check that the variable we found is not already present in the model.
       */
      ModelVariable currentVariable;
      if(branch==1){
         currentVariable = model1.getVariable(identifier);
      }else{
         currentVariable = model2.getVariable(identifier);
      }
      if ((currentVariable != null) && currentVariable.isParameter()) {
          return;
      }

      //final ModelVariable variable = ModelVariableFactory.constructModelVariable((ProgramVariable)var, identifier);
      final ModelVariable variable=new ModelVariable(var.getProgramVariable(),identifier);
      Object instance;
      if (TermParser.isPrimitiveType(var.getProgramVariable().sort().name().toString())) {
          //The term is a static variable. Identify and connect it with its parent class.
          instance = ModelBuilderVisitor.resolvePrimitiveType(var.getProgramVariable());
      } else {
          instance = ModelInstanceFactory.constructModelInstance(var.getProgramVariable().getKeYJavaType());
      }
      
      //set the symbolic value of @ModelVariable variable
      Term symbolicValue=var.getValues()[0].getValue();
      //add artificial variables contained in the value (if they exist)
      investigateArtificialVars(symbolicValue); //investigate all artificial variables
      investigateStaticVars(symbolicValue);
      
      symbolicValue=new HeapHandler(services).replaceSelectFunctionByItsField(symbolicValue);
      variable.setSymbolicValue(symbolicValue);
     
      
      
      if(var.getParentValue()==null)  //assign true flag for method's parameter
         variable.setParameter(true);
      /*
       * Add the variable and its instance to the Model. This might seem
       * premature, but must be done to preserve referential integrity and
       * avoiding extra work.
       */
      if(branch==1){
         model1.add(variable, instance);
         model1.assignField(variable, model1.getVariable(getReferenceName()));
      }else{
         model2.add(variable, instance);
         model2.assignField(variable, model2.getVariable(getReferenceName()));
      }
   }   
   
   /*
    * when resolving loop by using loop invariant, SED (Symbolic Execution Debugger) may create fake variables
    * to represent the value of fields, we have to detect them and add them into model
    * */
   private void investigateArtificialVars(final Term term){
      if(term!=null){
         if(TermParser.isArtificialVariable(term)){
            if(!artificialVars.contains(term)){
               artificialVars.add(term);
            }  
         }
         else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               investigateArtificialVars(st);
            }
         }
      }
   }
   
   
   /**investigate all static variables apprearing in the term*/
   private void investigateStaticVars(final Term term){
      if(term!=null){
         if(TermParser.isStaticField(term))
            if(!staticVars.contains(term)){
               staticVars.add(term);
            }         
         else{ //recursively call to subterms.
            ImmutableArray<Term> subterms=term.subs();
            for(Term st:subterms){
               investigateStaticVars(st);
            }
         }
      }
   }
   
   /**
    * Instantiate values for exploit model from an integer concrete model
    * */
   public void instantiateExploitModelInt(final Map<String,Integer> concreteValues){
      for(String varName: concreteValues.keySet()){         
         if(!isDualVar(concreteValues, varName)){  //if varName is not a high or low value
            final ModelVariable variable1 =model1.getVariable(varName);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(varName));
            
            final ModelVariable variable2 =model2.getVariable(varName);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(varName));
         }else{
            String prefix=varName.substring(0, varName.length()-2);
            //get variable in concrete model corresponding with model1            
            final ModelVariable variable1 = model1.getVariable(prefix);
            if(variable1!=null)
               variable1.setValue(concreteValues.get(prefix+"_1"));
            
            // get variable in concrete model corresponding with model2            
            final ModelVariable variable2 = model2.getVariable(prefix);
            if(variable2!=null)
               variable2.setValue(concreteValues.get(prefix+"_2"));
         }
      }
   }
   
   /**
    * check if a variable is dual value or not
    * dual value: is high or low value (h1, h2) or (l1,l2)
    * */
   private boolean isDualVar(final Map<String,Integer> concreteValues,final String varName){
      //remove the suffix  _1 or _2 of varName
      if((!varName.endsWith("_1"))&&(!varName.endsWith("_2"))){
         return false;
      }else{
         String prefix=varName.substring(0, varName.length()-2);
         if((concreteValues.containsKey(prefix+"_1"))&&(concreteValues.containsKey(prefix+"_2")))
            return true;
         else
            return false;
      }
   }
   
   public ExploitModel getExploitModel(){    
      
      return new ExploitModel(model1,model2,HEAP_NAME);
   }
   
   /*
    * constructs reference name from stack, if object obj is a field of heap self, then the heap name is self_obj
    * */
   private String getReferenceName() {  
      String heapName="";
      if(sHeapName.size()>0){
         heapName=sHeapName.get(0);
         for(int i=1;i<sHeapName.size();i++){
            heapName +="_" + sHeapName.get(i);
         }
      }
      return heapName;
   }
   
   /*
    * constructs reference name from stack of static fields, if object obj is a field of static memory, then the object's name is null_obj
    * */
   private String getReferenceStaticName() {  
      String staticFieldName="";
      if(sStaticFieldName.size()>0){
         staticFieldName=sStaticFieldName.get(0);
         for(int i=1;i<sStaticFieldName.size();i++){
            staticFieldName +="_" + sStaticFieldName.get(i);
         }
      }
      return staticFieldName;
   }
   
   public Model getModel(int branch){
      if(branch==1)
         return model1;
      else
         return model2;
   }
   
   public String getHEAP_NAME(){
      return HEAP_NAME;
   }
   
   public List<Term> getArtificialVars(){
      return artificialVars;
   }
   
   public List<Term> getStaticVars(){
      return staticVars;
   }
}
