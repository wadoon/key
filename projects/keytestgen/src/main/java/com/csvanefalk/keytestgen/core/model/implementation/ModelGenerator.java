package com.csvanefalk.keytestgen.core.model.implementation;

import com.csvanefalk.keytestgen.StringConstants;
import com.csvanefalk.keytestgen.core.model.IModelGenerator;
import com.csvanefalk.keytestgen.core.model.ModelGeneratorException;
import com.csvanefalk.keytestgen.core.model.implementation.variable.ModelVariable;
import com.csvanefalk.keytestgen.keystone.KeYStone;
import com.csvanefalk.keytestgen.keystone.KeYStoneException;
import com.csvanefalk.keytestgen.util.transformers.*;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;

import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;

/**
 * Given that a client does not specify anything else, KeYTestGen2 will default
 * to this implementation of {@link IModelGenerator} for the purpose of
 * instantiating path conditions.
 * <p/>
 * This particular implementation makes use of SMT solvers in order to
 * facilitate model generation. The pathcondition to be instantiated is
 * translated into the SMT-LIB2 language, and the KeY SMT interface is
 * subsequently invoked in order to find an assignment of variables that satisfy
 * the pathcondition (if such an assignment exits).
 * <p/>
 * The set of assignments found are further processed into an instance of
 * {@link Model}, which constitutes the final representaiton of the model.
 */
public class ModelGenerator implements IModelGenerator {

    private static ModelGenerator instance = null;

    public static ModelGenerator getInstance() {
        if (ModelGenerator.instance == null) {
            ModelGenerator.instance = new ModelGenerator();
        }
        return ModelGenerator.instance;
    }

    KeYStone keYStone = KeYStone.getInstance();

    private ModelGenerator() {

    }

    /**
     * generates a {@link Model} for the pathcondition of a single
     * {@link IExecutionNode}, i.e. a single program statement.
     *
     * @param node the node for which to generate a Model
     * @return the Model instance for the node
     * @throws ModelGeneratorException in the event that there was a failure to generate the Model
     */
    @Override
    public Model generateModel(final IExecutionNode node) throws ModelGeneratorException {

        try {

            /*
             * Extract the path condition with related KeY services.
             */
            Term pathCondition = node.getPathCondition();
            final Services services = node.getServices();
            System.out.println(node.getFormatedPathCondition());

            /*
             * Catch the special case where the precondition is trivial or
             * autogenerated - "true".
             */
            if (pathCondition.toString().equals(StringConstants.TRUE)) {
                return Model.EMPTY_MODEL;
            }

            /*
             * Bring the pathcondition into a simplified form suitable for model generation.
             */
            pathCondition = configurePathConditionForModelGeneration(pathCondition);

            /*
             * Create the initial Model, without any concrete values assigned to
             * primitive integer values in it.
             */
            final Model model = new ModelBuilder().createModel(node, pathCondition);

            /*
             * Complete the model with concrete integer values.
             */
            final Map<String, Integer> concreteValues = getConcreteValues(pathCondition, services);

            instantiateModel(model, concreteValues);

            return model;

        } catch (final ProofInputException e) {
            throw new ModelGeneratorException(e.getMessage());
        } catch (final TermTransformerException e) {
            throw new ModelGeneratorException(e.getMessage());
        } catch (final Exception e) {
            throw new ModelGeneratorException(e.getMessage());
        }
    }

    /**
     * Brings a pathcondition into a state which is suitable for model generation.
     *
     * @param pathCondition
     * @return
     * @throws TermTransformerException
     */
    private Term configurePathConditionForModelGeneration(Term pathCondition) throws TermTransformerException {

        /*
         * Remove all axiomatic expressions
         */
        pathCondition = RemoveAxiomaticExpressionsTransformer.getInstance().transform(pathCondition);

        /*
         * Remove all implications from the path condition.
         */
        pathCondition = RemoveImplicationsTransformer.getInstance().transform(pathCondition);

        /*
         * Remove if-then-else assertions from the path condition.
         */
        pathCondition = RemoveIfThenElseTransformer.getInstance().transform(pathCondition);

        return pathCondition;
    }

    /**
     * Configures a path condition for generating concrete integer values.
     *
     * @param pathCondition
     * @return
     */
    private Term configurePathConditionForIntegerGeneration(Term pathCondition,
                                                            Services services) throws TermTransformerException {

        pathCondition = RemoveObserverFunctionsTransformer.getInstance().transform(pathCondition);

        pathCondition = RemoveAxiomaticExpressionsTransformer.getInstance().transform(pathCondition);

        pathCondition = TermSimplificationTransformer.getInstance().transform(pathCondition);

        pathCondition = NormalizeArithmeticComparatorsTransformer.getInstance(services)
                                                                 .transform(pathCondition);

        return pathCondition;
    }

    /**
     * Uses KeYStone in order to retrieve a set of concrete values for any integers found in the path condition.
     *
     * @param pathCondition the pathcondition.
     * @param services      services associated with the pathcondition
     * @return a map of variable names to their concrete values
     * @throws ModelGeneratorException
     */
    private Map<String, Integer> getConcreteValues(final Term pathCondition,
                                                   final Services services) throws ModelGeneratorException {

        try {

            Term simplifiedPathCondition = configurePathConditionForIntegerGeneration(pathCondition, services);

            long time = Calendar.getInstance().getTimeInMillis();

            Map<String, Integer> result;
            if (simplifiedPathCondition == null) {
                result = new HashMap<String, Integer>();
            } else {
                result = keYStone.solveConstraint(simplifiedPathCondition);
            }
            /*
            PaperTest.addResult(pathCondition + "_KEYSTONE",
                    Calendar.getInstance().getTimeInMillis() - time);
              */
            return result;

        } catch (final TermTransformerException e) {
            throw new ModelGeneratorException(e.getMessage());
        } catch (final KeYStoneException e) {
            throw new ModelGeneratorException(e.getMessage());
        }
    }

    /**
     * Binds a set of concerete values to the variables in th model.
     *
     * @param model
     * @param concreteValues
     */
    private void instantiateModel(final Model model, final Map<String, Integer> concreteValues) {

        for (final String variableName : concreteValues.keySet()) {

            final ModelVariable variable = model.getVariable(variableName);

            if (variable != null) {
                variable.setValue(concreteValues.get(variableName));
            }
        }
    }
}