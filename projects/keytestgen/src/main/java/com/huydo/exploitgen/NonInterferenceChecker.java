
/* 
*  this class used to process nodes in symbolic execution tree, 
 * that could be accessed via root node.
 * */


package com.huydo.exploitgen;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;

import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.csvanefalk.keytestgen.core.model.ModelGeneratorException;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class NonInterferenceChecker {
   private IExecutionStart root;
   private List<IExecutionNode> leafNodes;
   //private Services services;
   /*
    * constructor: Receive root node and create a collection of leaf nodes
    * */
   public NonInterferenceChecker(IExecutionStart rootNode){
      root=rootNode;
      leafNodes = new LinkedList<IExecutionNode>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode node = iterator.next();
         if(isTerminatingNode(node))
            leafNodes.add(node.getParent());     
      }
      //services=root.getServices();
   }
   
   /*
    * check if the node is a terminating node
    * */
   private boolean isTerminatingNode(final IExecutionNode node) {
      return node instanceof IExecutionTermination;
   }
   
   
   /**
    * @return the root
    */
   public IExecutionStart getRoot() {
      return root;
   }

   /**
    * @return the leafNodes
    */
   public List<IExecutionNode> getLeafNodes() {
      return leafNodes;
   }

   /**
    * @param root the root to set
    */
   public void setRoot(IExecutionStart root) {
      this.root = root;
   }

   /**
    * @param leafNodes the leafNodes to set
    */
   public void setLeafNodes(List<IExecutionNode> leafNodes) {
      this.leafNodes = leafNodes;
   }
   
   public Term getInterferenceTerm(int node1,int node2)throws ProofInputException{
      TwoBranchesProcessor tp=new TwoBranchesProcessor(leafNodes.get(node1), leafNodes.get(node2));      
      InterferenceTermBuilder itb=tp.getInterferenceTermBuilder();      
      return itb.createInterferenceTerm(); 
   }
   
   public void printConcreteModel(int node1, int node2) throws ProofInputException, TermTransformerException, ModelGeneratorException{          
      Map<String, Integer> counterExample;
      counterExample = getConcreteModel(node1, node2);
      Set<String> vars = counterExample.keySet();      
      System.out.println("The interference model we got is:");
      for(String var: vars){
         System.out.println(var + " : " + counterExample.get(var).intValue());
      }           
      System.out.println("----------------------------------------");
   }
   
   /*
    * return concrete values satisfying the interference term generating from two branches.
    * */
   private Map<String,Integer> getConcreteModel(int node1, int node2) throws ProofInputException, TermTransformerException, ModelGeneratorException{
      Term iTerm=getInterferenceTerm(node1, node2);
      System.out.println(iTerm.toString());
      
      Services services=leafNodes.get(node1).getServices();
    
      FormulaSolver fs=new KeyStoneSolver(iTerm,services);
      
      Map<String, Integer> result;
      result = fs.solveFormula();
      return result;
   }
   
   /*
    * check all node pairs and print out input values to check non-interference property
    * */
   public void checkProgram()throws ProofInputException, TermTransformerException, ModelGeneratorException{
      for(int i=0;i<leafNodes.size();i++){
         for(int j=i;j<leafNodes.size();j++){
            System.out.print("Check branch " + i);
            if (j!=i){
               System.out.print(" and branch " + j);
            }
            System.out.println();
            printConcreteModel(i, j);
         }
      }
   }
}

