
/* 
*  this class used to process nodes in symbolic execution tree, 
 * that could be accessed via root node.
 * */


package com.huydo.exploitgen;
import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStart;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;


import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.csvanefalk.keytestgen.core.model.ModelGeneratorException;
import com.csvanefalk.keytestgen.keystone.KeYStoneException;
import com.csvanefalk.keytestgen.util.transformers.TermTransformerException;


public class NINodeProcessor {
   private IExecutionStart root;
   private List<IExecutionNode> leafNodes;
   //private Services services;
   /*
    * constructor: Receive root node and create a collection of leaf nodes
    * */
   public NINodeProcessor(IExecutionStart rootNode){
      root=rootNode;
      leafNodes = new LinkedList<IExecutionNode>();
      /*
       * Iterator for walking the symbolic execution tree.
       */
      final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(root);

      /*
       * Iteratively construct the execution paths.
       */
      while (iterator.hasNext()) {
         final IExecutionNode node = iterator.next();
         if(isTerminatingNode(node))
            leafNodes.add(node.getParent());     
      }
      //services=root.getServices();
   }
   
   /*
    * check if the node is a terminating node
    * */
   private boolean isTerminatingNode(final IExecutionNode node) {
      return node instanceof IExecutionTermination;
   }
   
   
   /**
    * @return the root
    */
   public IExecutionStart getRoot() {
      return root;
   }

   /**
    * @return the leafNodes
    */
   public List<IExecutionNode> getLeafNodes() {
      return leafNodes;
   }

   /**
    * @param root the root to set
    */
   public void setRoot(IExecutionStart root) {
      this.root = root;
   }

   /**
    * @param leafNodes the leafNodes to set
    */
   public void setLeafNodes(List<IExecutionNode> leafNodes) {
      this.leafNodes = leafNodes;
   }
   
   public Term getInterferenceTerm(int node1,int node2)throws ProofInputException{
      TwoBranchesProcessor tp=new TwoBranchesProcessor(leafNodes.get(node1), leafNodes.get(node2));      
      InterferenceTermBuilder itb=tp.getInterferenceTermBuilder();      
      return itb.createInterferenceTerm(); 
   }
   
   public void printInterferenceTerm(int node1, int node2) throws ProofInputException, TermTransformerException, ModelGeneratorException{
      Term iTerm=getInterferenceTerm(node1, node2);
      System.out.println(iTerm.toString());
      
      Services services=leafNodes.get(node1).getServices();
    
      FormulaSolver fs=new KeyStoneSolver(iTerm,services);
      
      Map<String, Integer> counterExample;
      counterExample = fs.solveFormula();
      Set<String> vars = counterExample.keySet();
      System.out.println("----------------------------------------");
      System.out.println("The interference model we got is:");
      for(String var: vars){
         System.out.println(var + " : " + counterExample.get(var).intValue());
      }     
      
      System.out.println("----------------------------------------");
   }
   
   
   
   /*
    * try to print out information get from leaf nodes
    * */
   public void printLeafInfo(){
      IExecutionNode pNode;
      for(IExecutionNode node: leafNodes){
         System.out.println("-----------------------------------------");
         System.out.println("Element types: " + node.getElementType());   
         try {
            System.out.println("path conditon: "+node.getPathCondition().toString());   
            System.out.println("program variables are:");            
            
         }catch (ProofInputException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
         }
         pNode=node.getParent();
         if (pNode instanceof IExecutionStateNode) {
            IExecutionVariable[] vars = ((IExecutionStateNode) pNode).getVariables();
            System.out.println("Variables details:");
            for(IExecutionVariable var: vars){
               try {
                  System.out.println("name: "+var.getName());
                  System.out.println("value: " + var.getValues().length);
                  for(IExecutionValue val : var.getValues()){                   
                     System.out.println(val.getValueString());
                  }                     
               }
               catch (Exception e) {
                  // TODO Auto-generated catch block
                  e.printStackTrace();
               }               
            }
         }
                  
         System.out.println("-----------------------------------------");         
      }
   }
   
   
  
}

