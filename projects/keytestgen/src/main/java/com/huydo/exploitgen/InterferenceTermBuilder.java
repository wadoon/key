/**
 * 
 */
package com.huydo.exploitgen;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;

/**
 * @author Huy Do
 *
 */
public class InterferenceTermBuilder {
   private PairTermCollection listHighVars; //list of high variables represented as a Term
   private PairTermCollection listLowVars; //list of low variables represented as a Term   
   private PairTermCollection listTerminatedLowVars; //list of low variables at terminated nodes, represented as a Term
   private Term pathCondition1,pathCondition2; //two path conditions
   
   private static final TermBuilder termBuilder = TermBuilder.DF;   
   /**
    * @return the listVars
    */
  
   /**
    * @return the pathCondition1
    */
   public Term getPathCondition1() {
      return pathCondition1;
   }
   /**
    * @return the listHighVars
    */
   public PairTermCollection getListHighVars() {
      return listHighVars;
   }
   /**
    * @param listHighVars the listHighVars to set
    */
   public void setListHighVars(PairTermCollection listHighVars) {
      this.listHighVars = listHighVars;
   }
   /**
    * @return the listLowVars
    */
   public PairTermCollection getListLowVars() {
      return listLowVars;
   }
   /**
    * @param listLowVars the listLowVars to set
    */
   public void setListLowVars(PairTermCollection listLowVars) {
      this.listLowVars = listLowVars;
   }
   /**
    * @param pathCondition1 the pathCondition1 to set
    */
   public void setPathCondition1(Term pathCondition1) {
      this.pathCondition1 = pathCondition1;
   }
   /**
    * @return the pathCondition2
    */
   public Term getPathCondition2() {
      return pathCondition2;
   }
   /**
    * @param pathCondition2 the pathCondition2 to set
    */
   public void setPathCondition2(Term pathCondition2) {
      this.pathCondition2 = pathCondition2;
   }
   /**
    * @return the listTerminatedLowVars
    */
   public PairTermCollection getListTerminatedLowVars() {
      return listTerminatedLowVars;
   }
   /**
    * @param listTerminatedLowVars the listTerminatedLowVars to set
    */
   public void setListTerminatedLowVars(PairTermCollection listTerminatedLowVars) {
      this.listTerminatedLowVars = listTerminatedLowVars;
   }
   /**
    * @param listHighVars
    * @param listLowVars
    * @param listTerminatedLowVars
    * @param pathCondition1
    * @param pathCondition2
    */
   public InterferenceTermBuilder(PairTermCollection listHighVars,
         PairTermCollection listLowVars,
         PairTermCollection listTerminatedLowVars, Term pathCondition1,
         Term pathCondition2) {
      super();
      this.listHighVars = listHighVars;
      this.listLowVars = listLowVars;
      this.listTerminatedLowVars = listTerminatedLowVars;
      this.pathCondition1 = pathCondition1;
      this.pathCondition2 = pathCondition2;
   }  
   
   /*
    * replace all l, h in low output by l1,h1 and l2,h2.
    *   
    * */
   public PairTermCollection getReplacedTerminatedLowVars(){
      PairTermCollection result=new PairTermCollection();
      
      //get all names of low variables
      Set<String> names = listTerminatedLowVars.getListPairTerm().keySet();
      for(String name:names){
         PairTerm lowTValue=listTerminatedLowVars.getListPairTerm().get(name);
         //process two corresponding low values (term) in two branches 
         Term replacedLowTValue1 =listHighVars.replacePVByNameAndBranch(lowTValue.getT1(), 1);
         replacedLowTValue1 =listLowVars.replacePVByNameAndBranch(replacedLowTValue1, 1);
         Term replacedLowTValue2 =listHighVars.replacePVByNameAndBranch(lowTValue.getT2(), 2);
         replacedLowTValue2 =listLowVars.replacePVByNameAndBranch(replacedLowTValue2, 2);
         
         //add the low output values which have been replaced into result 
         result.add(name, new PairTerm(replacedLowTValue1,replacedLowTValue2));
      }
      
      return result;
   }
   
   
  /*
   * create formula to check non-interference property.
   * the formula will be created from two branches and the collection of high variables and low variables
   * it is based on the idea that one program is non-interference if the output of low variables are different
   * if the input of high variables are changed.
   * We do it by checking two branches (may be different branches, may be the same)
   * the formula looks like below:
   * PC1(h1,l1)&& PC2(h2,l2) && (h1!=h2) && (l1==l2) && (l1_out!=l2_out)
   * in which: 
   * PC1 and PC2 are path conditions of two corresponding branches.
   * h1, h2: the collection of the input of high variables for two corresponding branches
   * l1, l2: the collection of the input of low variables for two corresponding branches
   * l1_out, l2_out: the collection of the output of low variables for two corresponding branches
   *   
   */
  public Term createInterferenceTerm(){     
     //create pc1(h1,l1) by replacing variables h,l by h1,l1
     Term pc1=listHighVars.replacePVByNameAndBranch(pathCondition1, 1);          
     pc1=listLowVars.replacePVByNameAndBranch(pc1, 1);     
     
     //create pc2(h2,l2) by replacing variables h,l by h2,l2
     Term pc2=listHighVars.replacePVByNameAndBranch(pathCondition2, 2);
     pc2=listLowVars.replacePVByNameAndBranch(pc2, 2);
     
     //get output low variables after processing
     PairTermCollection listRTerminatedLowVars=getReplacedTerminatedLowVars();
     
     Term equalLowInput=listLowVars.equalTerm();
     Term notEqualHighInput=listHighVars.notEqualTerm();
     Term notEqualLowOutput=listRTerminatedLowVars.notEqualTerm();
     /*
      * return the result
      * result = PC1(h1,l1)&& PC2(h2,l2) && (h1!=h2) && (l1==l2) && (l1_out!=l2_out)
      */
     return termBuilder.and(pc1,pc2,equalLowInput,notEqualHighInput,notEqualLowOutput);     
  } 
  
}
