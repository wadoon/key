/**
 * 
 */
package com.huydo.exploitgen;

import java.util.HashMap;

import java.util.Map;

import com.csvanefalk.keytestgen.util.parsers.TermParserTools;


import de.uka.ilkd.key.collection.ImmutableArray;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.TermFactory;
import de.uka.ilkd.key.logic.op.Junctor;

/**
 * This class represents how to make Term
 * @author Huy Do
 * 
 */
public class PairTermCollection {
   private Map<String, PairTerm> listPairTerm;
   private static final TermFactory tf = TermFactory.DEFAULT;
   private static final TermBuilder termBuilder = TermBuilder.DF;
   private static final Term tt = TermFactory.DEFAULT.createTerm(Junctor.TRUE);
   private static final Term ff = TermFactory.DEFAULT.createTerm(Junctor.FALSE);
   /**
    * @param listPairTerm
    */
   public PairTermCollection(Map<String,PairTerm> listPairTerm) {
      super();
      this.listPairTerm = listPairTerm;
   }

   /**
    * @return the listPairTerm
    */
   public Map<String,PairTerm> getListPairTerm() {
      return listPairTerm;
   }

   /**
    * @param listPairTerm the listPairTerm to set
    */
   public void setListPairTerm(Map<String,PairTerm> listPairTerm) {
      this.listPairTerm = listPairTerm;
   }

   public PairTermCollection(){
      listPairTerm=new HashMap<String,PairTerm>();
   }
   
   public void add(String name,PairTerm pt){
      listPairTerm.put(name,pt);
   }
   
   /*
    * make equal term from PairTermCollection. It looks like that:
    * t11=t21 && t21=t22 && t31=t32 ....
    * */
   public Term equalTerm(){      
      Term result = tt;
      for(PairTerm pt : listPairTerm.values()) {
          result = termBuilder.and(result,pt.equalTerm());
      }
      return result;
   }
   
   /*
    * make not equal term from PairTermCollection. It looks like that:
    * t11!= t21 or t21 != t22 or t31 != t32 ....
    * */
   public Term notEqualTerm(){
      Term result = ff;
      for(PairTerm pt : listPairTerm.values()) {
          result = termBuilder.or(result,pt.notEqualTerm());
      }
      return result;
   }
   
   /*
    * get Term corresponding with the given name and the number of branch
    * if branch's number is 1, return term 1 in PairTerm, otherwise return term 2
    */
   public Term getTermByNameAndBranch(String name, int branch){
      if(listPairTerm.containsKey(name)){
         if(branch==1)
            return listPairTerm.get(name).getT1();
         else
            return listPairTerm.get(name).getT2();
      }else
         return null;      
   }
   
   /*
    * create a new term from input term by: 
    * find all ProgramVariable subterms of input term which the name is the same with given name
    * replace it by the term  
    * */
   public Term replacePVByNameAndBranch(final Term term, int branch){
      if(term !=null){
         if(TermParserTools.isLocationVariable(term)){
            Term rt=getTermByNameAndBranch(term.op().name().toString(), branch);
            if(rt!=null)
               return getTermByNameAndBranch(term.op().name().toString(), branch);
            else return term;
         }else{
            return tf.createTerm(term.op(), replaceSubTermsByNameAndBranch(term.subs(), branch));
         }
      }else return null;
   }
   
   public Term[] replaceSubTermsByNameAndBranch(final ImmutableArray<Term> subs, int branch){
      Term[] result =new Term[subs.size()];
      for(int i=0;i<subs.size();i++)
         result[i]=replacePVByNameAndBranch(subs.get(i), branch);    
      return (result);
   }
   
  }
