/**
 * 
 */
package com.huydo.exploitgen;

import de.uka.ilkd.key.logic.ProgramElementName;
import de.uka.ilkd.key.logic.Term;
import de.uka.ilkd.key.logic.TermBuilder;
import de.uka.ilkd.key.logic.op.LocationVariable;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStateNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;

/**
 * this class process two branches (two termination nodes) to extract information needed to build interference formula
 * @author Huy Do
 *
 */
public class TwoBranchesProcessor {
   private IExecutionNode node1,node2; //two termination nodes representing two branches.
   private static final TermBuilder termBuilder = TermBuilder.DF;
   /**
    * @return the node1
    */
   public IExecutionNode getNode1() {
      return node1;
   }

   /**
    * @param node1 the node1 to set
    */
   public void setNode1(IExecutionNode node1) {
      this.node1 = node1;
   }

   /**
    * @return the node2
    */
   public IExecutionNode getNode2() {
      return node2;
   }

   /**
    * @param node2 the node2 to set
    */
   public void setNode2(IExecutionNode node2) {
      this.node2 = node2;
   }

   /**
    * @param node1
    * @param node2
    */
   public TwoBranchesProcessor(IExecutionNode node1, IExecutionNode node2) {
      super();
      this.node1 = node1;
      this.node2 = node2;
   }
   
   /*
    * get path condition based on branch
    * if branch is 1 then return path condition of node1, otherwise return path condition of  node2.
    * */
   public Term getPathCondition(int branch) throws ProofInputException {
      if(branch==1)
         return node1.getPathCondition();
      else
         return node2.getPathCondition();
   }
   
   /*
    * get list of input high variables of two branches.    *  
    * */
   public PairTermCollection getListHighVars() throws ProofInputException{
      PairTermCollection result=new PairTermCollection();
      IExecutionVariable[] vars = ((IExecutionStateNode) node1).getVariables();
      for(IExecutionVariable var: vars){
         if(VariableChecker.isHigh(var)){
            String name=var.getName();
            /*
             * create two variables which have the same type with this variable and have two different name 
             * (by adding suffixes _1 and _2)
            */
            LocationVariable lv1=new LocationVariable(new ProgramElementName(name + "_1"),var.getProgramVariable().getKeYJavaType());
            LocationVariable lv2=new LocationVariable(new ProgramElementName(name + "_2"),var.getProgramVariable().getKeYJavaType());
           
            PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2));
            result.add(name, pair);
         }
      }
      return result;
   } 
   
   /*
    * get list of input low variables of two branches.    *  
    * */
   public PairTermCollection getListLowVars() throws ProofInputException{
      PairTermCollection result=new PairTermCollection();
      IExecutionVariable[] vars = ((IExecutionStateNode) node1).getVariables();
      for(IExecutionVariable var: vars){
         if(VariableChecker.isLow(var)){
            String name=var.getName();
            /*
             * create two variables which have the same type with this variable and have two different name 
             * (by adding suffixes _1 and _2)
            */
            LocationVariable lv1=new LocationVariable(new ProgramElementName(name + "_1"),var.getProgramVariable().getKeYJavaType());
            LocationVariable lv2=new LocationVariable(new ProgramElementName(name + "_2"),var.getProgramVariable().getKeYJavaType());          
            PairTerm pair=new PairTerm(termBuilder.var(lv1),termBuilder.var(lv2));
            result.add(name, pair);
         }
      }
      return result;
   } 
   
   /*
    * get list of low variables of two branches at the termination nodes  
    * */
   public PairTermCollection getListTerminatedLowVars() throws ProofInputException{
      PairTermCollection result=new PairTermCollection();
      IExecutionVariable[] vars1 = ((IExecutionStateNode) node1).getVariables();
      IExecutionVariable[] vars2 = ((IExecutionStateNode) node2).getVariables();
      for(IExecutionVariable var1: vars1){
         if(VariableChecker.isLow(var1)){
            String name=var1.getName();
            for(IExecutionVariable var2: vars2){               
               if(name.equalsIgnoreCase(var2.getName())){ //find corresponding low variable in branch 2                   
                  PairTerm pair=new PairTerm(var1.getValues()[0].getValue(),var2.getValues()[0].getValue());
                  result.add(name, pair);
               }
            }
         }
      }
      return result;
   }   
  
  //return InterferenceTermBuilder object to create formula 
  public InterferenceTermBuilder getInterferenceTermBuilder() throws ProofInputException{
     Term pathCondition1=getPathCondition(1);  
     Term pathCondition2=getPathCondition(2); 
     PairTermCollection listHighVars=getListHighVars();     
     PairTermCollection listLowVars=getListLowVars();        
     PairTermCollection listTerminatedLowVars=getListTerminatedLowVars();
     return new InterferenceTermBuilder(listHighVars, listLowVars, listTerminatedLowVars, pathCondition1, pathCondition2);
  } 
}
