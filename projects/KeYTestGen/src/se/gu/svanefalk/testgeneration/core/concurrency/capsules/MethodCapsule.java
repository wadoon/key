package se.gu.svanefalk.testgeneration.core.concurrency.capsules;

import java.util.LinkedList;
import java.util.List;

import se.gu.svanefalk.testgeneration.core.CoreException;
import se.gu.svanefalk.testgeneration.core.classabstraction.KeYJavaMethod;
import se.gu.svanefalk.testgeneration.core.codecoverage.ICodeCoverageParser;
import se.gu.svanefalk.testgeneration.core.concurrency.monitor.CaughtException;
import se.gu.svanefalk.testgeneration.core.concurrency.monitor.ICapsuleMonitor;
import se.gu.svanefalk.testgeneration.core.concurrency.monitor.IMonitorEvent;
import se.gu.svanefalk.testgeneration.core.keyinterface.KeYInterface;
import se.gu.svanefalk.testgeneration.core.keyinterface.KeYInterfaceException;
import se.gu.svanefalk.testgeneration.core.model.implementation.Model;
import se.gu.svanefalk.testgeneration.core.oracle.abstraction.Oracle;
import se.gu.svanefalk.testgeneration.core.testsuiteabstraction.TestCase;
import se.gu.svanefalk.testgeneration.core.testsuiteabstraction.TestSuite;
import se.gu.svanefalk.testgeneration.util.Benchmark;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStartNode;

/**
 * Instances of this capsule enables KeYTestGen2 to concurrently generate test
 * suites for multiple Java methods.
 * 
 * @author christopher
 * 
 */
public class MethodCapsule extends AbstractCapsule implements ICapsuleMonitor {

    /**
     * Parser for achieving the desired level of code coverage.
     */
    private final ICodeCoverageParser codeCoverageParser;

    /**
     * Reference to the {@link KeYInterface}, whenever this capsule needs
     * services from the KeY runtime.
     */
    private final KeYInterface keYInterface = KeYInterface.getInstance();

    /**
     * The method which the test suite will be generated for.
     */
    private final KeYJavaMethod targetMethod;

    /**
     * The test suite generated by this capsule
     */
    private TestSuite testSuite = null;

    public MethodCapsule(final ICodeCoverageParser codeCoverageParser,
            final KeYJavaMethod targetMethod) {
        super();
        this.codeCoverageParser = codeCoverageParser;
        this.targetMethod = targetMethod;
    }

    /**
     * Executes the test generation procedure.
     */
    @Override
    public void doWork() {

        /*
         * The generated models.
         */
        final List<Model> models = new LinkedList<Model>();

        /*
         * The oracle for the method which the test cases are being generated
         * for.
         */
        Oracle oracle = null;

        try {

            /*
             * Retrieve the symbolic execution tree for the method, and extract
             * from it the nodes needed in order to reach the desired level of
             * code coverage.
             */
            Benchmark.startBenchmarking("2. [KeY] Create symbolic execution tree");
            final IExecutionStartNode root = keYInterface.getSymbolicExecutionTree(targetMethod);

            final List<IExecutionNode> nodes = codeCoverageParser.retrieveNodes(root);

            Benchmark.finishBenchmarking("2. [KeY] Create symbolic execution tree");

            Benchmark.startBenchmarking("3. generating models");

            /*
             * Begin preparing the capsules to be executed
             */
            CapsuleController<OracleCapsule> oracleController = new CapsuleController<>();
            CapsuleController<ModelCapsule> modelController = new CapsuleController<>();

            /*
             * Setup the model generation capsules for each node.
             */
            for (final IExecutionNode node : nodes) {
                final ModelCapsule modelGenerationCapsule = new ModelCapsule(
                        node);
                modelGenerationCapsule.addMonitor(this);
                modelController.addChild(modelGenerationCapsule);
            }

            /*
             * Setup the Oracle generation capsule for this method
             */
            final OracleCapsule oracleGenerationCapsule = new OracleCapsule(
                    targetMethod);
            oracleController.addChild(oracleGenerationCapsule);

            /*
             * Dispatch and wait for the capsules.
             */
            oracleController.executeAndWait();
            modelController.executeAndWait();

            /*
             * Collect the results
             */
            oracle = oracleGenerationCapsule.getResult();
            for (final ModelCapsule capsule : modelController.getCapsules()) {
                models.add(capsule.getResult());
            }

            /*
             * Construct the test cases.
             */
            final List<TestCase> testCases = new LinkedList<TestCase>();
            for (final Model model : models) {
                final TestCase testCase = TestCase.constructTestCase(
                        targetMethod, model, oracle);
                testCases.add(testCase);
            }
            Benchmark.finishBenchmarking("3. generating models");

            /*
             * Construct the test suite.
             */
            testSuite = TestSuite.constructTestSuite(
                    targetMethod.getDeclaringClass(), targetMethod, testCases);

            /*
             * Finish execution.
             */
            setSucceeded();

        } catch (final KeYInterfaceException e) {
            setThrownException(e);
        } catch (final CoreException e) {
            setThrownException(e);
        }
    }

    public TestSuite getResult() {
        return testSuite;
    }

    @Override
    public void doNotify(ICapsule source, IMonitorEvent event) {

        /*
         * The signalling capsule caught an exception
         */
        if (event instanceof CaughtException) {

            /*
             * Notify monitors about the exceptioon
             */
            CaughtException caughtException = (CaughtException) event;
            Throwable payload = caughtException.getPayload();
            notifyMonitors(event);

            /*
             * Terminate all children
             */
            source.getController().stopChildren();
        }
    }
}
