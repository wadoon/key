package se.gu.svanefalk.testgeneration.core.concurrency;

import se.gu.svanefalk.testgeneration.core.classabstraction.KeYJavaMethod;
import se.gu.svanefalk.testgeneration.core.oracle.OracleGenerator;
import se.gu.svanefalk.testgeneration.core.oracle.OracleGeneratorException;
import se.gu.svanefalk.testgeneration.core.oracle.abstraction.Oracle;

/**
 * Instances of this capsule enables KeYTestGen2 to to concurrently generate
 * oracles for multiple methods.
 * 
 * @author christopher
 * 
 */
public class OracleGenerationCapsule extends Capsule {

    /**
     * The method for which an Oracle will be generated by this capsule.
     */
    private final KeYJavaMethod method;

    /**
     * The resulting {@link Oracle} instance.
     */
    private Oracle oracle = null;

    /**
     * The OracleGenerator, used in order to turn the postcondition of a method,
     * together with related metadata, into a test oracle.
     */
    private final OracleGenerator oracleGenerator = OracleGenerator.INSTANCE;

    /**
     * Initiate the Capsule for a given method.
     * 
     * @param method
     */
    public OracleGenerationCapsule(final KeYJavaMethod method) {
        super();
        this.method = method;
    }

    /**
     * Run the Oracle generation process.
     */
    @Override
    public void doWork() {

        /*
         * Attempt to generate an Oracle. Any exception thrown in this process
         * indicates permanent failure on the part of the OracleGenerator, and
         * we hence just kill the Capsule.
         */
        try {
            this.oracle = this.oracleGenerator.generateOracle(this.method);
        } catch (final OracleGeneratorException e) {
            this.setThrownException(e);
            return;
        }

        /*
         * The oracle generation process was succesful.
         */
        this.setSucceeded();
    }

    /**
     * @return the result of the Oracle generation process, if succesful.
     */
    public Oracle getResult() {
        return this.oracle;
    }
}
