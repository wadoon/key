package se.gu.svanefalk.testgeneration.core.concurrency;

import java.util.LinkedList;
import java.util.List;

import se.gu.svanefalk.testgeneration.core.CoreException;
import se.gu.svanefalk.testgeneration.core.classabstraction.KeYJavaMethod;
import se.gu.svanefalk.testgeneration.core.codecoverage.ICodeCoverageParser;
import se.gu.svanefalk.testgeneration.core.codecoverage.executionpath.ExecutionPathContext;
import se.gu.svanefalk.testgeneration.core.keyinterface.KeYInterface;
import se.gu.svanefalk.testgeneration.core.keyinterface.KeYInterfaceException;
import se.gu.svanefalk.testgeneration.core.model.implementation.Model;
import se.gu.svanefalk.testgeneration.core.oracle.abstraction.Oracle;
import se.gu.svanefalk.testgeneration.core.testsuiteabstraction.TestCase;
import se.gu.svanefalk.testgeneration.core.testsuiteabstraction.TestSuite;
import se.gu.svanefalk.testgeneration.util.Benchmark;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStartNode;

/**
 * Instances of this capsule enables KeYTestGen2 to concurrently generate test
 * suites for multiple Java methods.
 * 
 * @author christopher
 * 
 */
public class TestGenerationCapsule extends Capsule {

    /**
     * Global thread pool for dispatching other capsules.
     */
    CapsuleExecutor threadPool = CapsuleExecutor.INSTANCE;

    /**
     * Parser for achieving the desired level of code coverage.
     */
    private final ICodeCoverageParser codeCoverageParser;

    /**
     * Reference to the {@link KeYInterface}, whenever this capsule needs
     * services from the KeY runtime.
     */
    private final KeYInterface keYInterface = KeYInterface.INSTANCE;

    /**
     * The method which the test suite will be generated for.
     */
    private final KeYJavaMethod targetMethod;

    /**
     * The test suite generated by this capsule
     */
    private TestSuite testSuite = null;

    public TestGenerationCapsule(final ICodeCoverageParser codeCoverageParser,
            final KeYJavaMethod targetMethod) {
        super();
        this.codeCoverageParser = codeCoverageParser;
        this.targetMethod = targetMethod;
    }

    public TestSuite getResult() {
        return this.testSuite;
    }

    /**
     * Executes the test generation procedure.
     */
    @Override
    public void doWork() {

        /*
         * The generated models.
         */
        final List<Model> models = new LinkedList<Model>();

        /*
         * The oracle for the method which the test cases are being generated
         * for.
         */
        Oracle oracle = null;

        try {

            /*
             * Retrieve the symbolic execution tree for the method, and extract
             * from it the nodes needed in order to reach the desired level of
             * code coverage.
             */
            Benchmark.startBenchmarking("2. [KeY] Create symbolic execution tree");
            final IExecutionStartNode root = this.keYInterface.getSymbolicExecutionTree(this.targetMethod);

            final List<IExecutionNode> nodes = this.codeCoverageParser.retrieveNodes(root);

            Benchmark.finishBenchmarking("2. [KeY] Create symbolic execution tree");

            Benchmark.startBenchmarking("3. generating models");

            /*
             * Begin preparing the capsules to be executed
             */
            final List<Capsule> toExecute = new LinkedList<Capsule>();

            /*
             * Setup the module generation capsules for each node.
             */
            final List<ModelGenerationCapsule> modelGenerationCapsules = new LinkedList<ModelGenerationCapsule>();
            for (final IExecutionNode node : nodes) {
                ModelGenerationCapsule modelGenerationCapsule = new ModelGenerationCapsule(
                        node);
                modelGenerationCapsules.add(modelGenerationCapsule);
                toExecute.add(modelGenerationCapsule);
            }

            /*
             * Setup the Oracle generation capsule for this method
             */
            final OracleGenerationCapsule oracleGenerationCapsule = new OracleGenerationCapsule(
                    this.targetMethod);
            toExecute.add(oracleGenerationCapsule);

            /*
             * Dispatch and wait for the capsules.
             */
            threadPool.executeCapsulesAndWait(toExecute);

            /*
             * Collect the results
             */
            oracle = oracleGenerationCapsule.getResult();
            for (final ModelGenerationCapsule capsule : modelGenerationCapsules) {
                models.add(capsule.getResult());
            }

            /*
             * Construct the test cases.
             */
            final List<TestCase> testCases = new LinkedList<TestCase>();
            for (final Model model : models) {
                final TestCase testCase = TestCase.constructTestCase(
                        this.targetMethod, model, oracle);
                testCases.add(testCase);
            }
            Benchmark.finishBenchmarking("3. generating models");

            /*
             * Construct the test suite.
             */
            this.testSuite = TestSuite.constructTestSuite(
                    this.targetMethod.getDeclaringClass(), this.targetMethod,
                    testCases);

            /*
             * Finish execution.
             */
            this.setSucceeded();

        } catch (final KeYInterfaceException e) {
            this.setThrownException(e);
        } catch (final CoreException e) {
            this.setThrownException(e);
        }
    }
}
