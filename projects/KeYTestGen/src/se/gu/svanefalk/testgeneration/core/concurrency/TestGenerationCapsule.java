package se.gu.svanefalk.testgeneration.core.concurrency;

import java.util.LinkedList;
import java.util.List;
import se.gu.svanefalk.testgeneration.backend.TestGeneratorException;
import se.gu.svanefalk.testgeneration.backend.junit.JUnitConverter;
import se.gu.svanefalk.testgeneration.core.CoreException;
import se.gu.svanefalk.testgeneration.core.NodeTestGenerator;
import se.gu.svanefalk.testgeneration.core.classabstraction.KeYJavaMethod;
import se.gu.svanefalk.testgeneration.core.codecoverage.ICodeCoverageParser;
import se.gu.svanefalk.testgeneration.core.keyinterface.KeYInterface;
import se.gu.svanefalk.testgeneration.core.keyinterface.KeYInterfaceException;
import se.gu.svanefalk.testgeneration.core.model.implementation.Model;
import se.gu.svanefalk.testgeneration.core.oracle.abstraction.Oracle;
import se.gu.svanefalk.testgeneration.core.testsuiteabstraction.TestCase;
import se.gu.svanefalk.testgeneration.core.testsuiteabstraction.TestSuite;
import se.gu.svanefalk.testgeneration.util.Benchmark;
import de.uka.ilkd.key.proof.init.ProofInputException;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.SymbolicConfigurationExtractor;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStartNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
import de.uka.ilkd.key.symbolic_execution.model.impl.ExecutionBranchNode;
import de.uka.ilkd.key.symbolic_execution.object_model.ISymbolicConfiguration;
import de.uka.ilkd.key.symbolic_execution.object_model.impl.SymbolicConfiguration;

/**
 * Instances of this capsule enables KeYTestGen2 to concurrently generate test
 * suites for multiple Java methods.
 * 
 * @author christopher
 * 
 */
public class TestGenerationCapsule extends Capsule {

    /**
     * Reference to the {@link KeYInterface}, whenever this capsule needs
     * services from the KeY runtime.
     */
    private final KeYInterface keYInterface = KeYInterface.INSTANCE;

    /**
     * Parser for achieving the desired level of code coverage.
     */
    private final ICodeCoverageParser codeCoverageParser;

    /**
     * The method which the test suite will be generated for.
     */
    private final KeYJavaMethod targetMethod;

    /**
     * The test suite generated by this capsule
     */
    private TestSuite testSuite = null;

    public TestGenerationCapsule(ICodeCoverageParser codeCoverageParser,
            KeYJavaMethod targetMethod) {
        super();
        this.codeCoverageParser = codeCoverageParser;
        this.targetMethod = targetMethod;
    }

    /**
     * Executes the test generation procedure.
     */
    @Override
    public void run() {

        /*
         * The generated models.
         */
        final List<Model> models = new LinkedList<Model>();

        /*
         * The oracle for the method which the test cases are being generated
         * for.
         */
        Oracle oracle = null;

        try {

            /*
             * Retrieve the symbolic execution tree for the method, and extract
             * from it the nodes needed in order to reach the desired level of
             * code coverage.
             */
            Benchmark
                    .startBenchmarking("2. [KeY] Create symbolic execution tree");
            final IExecutionStartNode root = this.keYInterface
                    .getSymbolicExecutionTree(targetMethod);

            final ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(
                    root);

            while (iterator.hasNext()) {
                IExecutionNode node = iterator.next();
                if (node instanceof ExecutionBranchNode) {
                    ExecutionBranchNode executionBranchNode = (ExecutionBranchNode) node;
                    IExecutionVariable[] vars = executionBranchNode
                            .getVariables();
                    try {
                        SymbolicConfigurationExtractor sym = executionBranchNode.getConfigurationExtractor();
                        ISymbolicConfiguration first = sym.getCurrentConfiguration(0);
                    } catch (ProofInputException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    int x = 1;
                }
            }

            final List<IExecutionNode> nodes = codeCoverageParser
                    .retrieveNodes(root);
            Benchmark
                    .finishBenchmarking("2. [KeY] Create symbolic execution tree");

            Benchmark.startBenchmarking("3. generating models");

            /*
             * for(IExecutionNode node : nodes) {
             * 
             * try { String suite =
             * NodeTestGenerator.INSTANCE.constructTestSuiteFromNode(node, new
             * JUnitConverter()); int x = 1; } catch (TestGeneratorException e)
             * { // TODO Auto-generated catch block e.printStackTrace(); } }
             */

            /*
             * Setup the module generation capsules for each node.
             */
            final List<ModelGenerationCapsule> modelGenerationCapsules = new LinkedList<ModelGenerationCapsule>();
            for (final IExecutionNode node : nodes) {
                modelGenerationCapsules.add(new ModelGenerationCapsule(node));
            }

            /*
             * Setup the Oracle generation capsule for this method
             */
            OracleGenerationCapsule oracleGenerationCapsule = new OracleGenerationCapsule(
                    targetMethod);

            /*
             * Dispatch and wait for the capsules.
             */
            oracleGenerationCapsule.start();
            for (final ModelGenerationCapsule capsule : modelGenerationCapsules) {
                capsule.start();
            }
            while (true) {
                try {
                    oracleGenerationCapsule.join();
                    for (ModelGenerationCapsule capsule : modelGenerationCapsules) {
                        capsule.join();
                    }
                    break;
                } catch (InterruptedException e) {
                    continue;
                }
            }

            /*
             * Collect the results
             */
            oracle = oracleGenerationCapsule.getResult();
            for (final ModelGenerationCapsule capsule : modelGenerationCapsules) {
                models.add(capsule.getResult());
            }

            /*
             * Construct the test cases.
             */
            List<TestCase> testCases = new LinkedList<TestCase>();
            for (final Model model : models) {
                final TestCase testCase = TestCase.constructTestCase(
                        targetMethod, model, oracle);
                testCases.add(testCase);
            }
            Benchmark.finishBenchmarking("3. generating models");

            /*
             * Construct the test suite.
             */
            testSuite = TestSuite.constructTestSuite(
                    targetMethod.getDeclaringClass(), targetMethod, testCases);

            /*
             * Finish execution.
             */
            setSucceeded();

        } catch (KeYInterfaceException e) {
            setThrownException(e);
        } catch (CoreException e) {
            setThrownException(e);
        }
    }

    public TestSuite getResult() {
        return testSuite;
    }
}
