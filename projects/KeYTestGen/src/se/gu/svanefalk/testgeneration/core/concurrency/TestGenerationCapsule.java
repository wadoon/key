package se.gu.svanefalk.testgeneration.core.concurrency;

import java.util.LinkedList;
import java.util.List;

import se.gu.svanefalk.testgeneration.core.CoreException;
import se.gu.svanefalk.testgeneration.core.classabstraction.KeYJavaMethod;
import se.gu.svanefalk.testgeneration.core.codecoverage.ICodeCoverageParser;
import se.gu.svanefalk.testgeneration.core.codecoverage.pathcontext.ExecutionPathContext;
import se.gu.svanefalk.testgeneration.core.keyinterface.KeYInterface;
import se.gu.svanefalk.testgeneration.core.keyinterface.KeYInterfaceException;
import se.gu.svanefalk.testgeneration.core.model.implementation.Model;
import se.gu.svanefalk.testgeneration.core.oracle.abstraction.Oracle;
import se.gu.svanefalk.testgeneration.core.testsuiteabstraction.TestCase;
import se.gu.svanefalk.testgeneration.core.testsuiteabstraction.TestSuite;
import se.gu.svanefalk.testgeneration.util.Benchmark;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionStartNode;

/**
 * Instances of this capsule enables KeYTestGen2 to concurrently generate test
 * suites for multiple Java methods.
 * 
 * @author christopher
 * 
 */
public class TestGenerationCapsule extends Capsule {

    /**
     * Reference to the {@link KeYInterface}, whenever this capsule needs
     * services from the KeY runtime.
     */
    private final KeYInterface keYInterface = KeYInterface.INSTANCE;

    /**
     * Parser for achieving the desired level of code coverage.
     */
    private final ICodeCoverageParser codeCoverageParser;

    /**
     * The method which the test suite will be generated for.
     */
    private final KeYJavaMethod targetMethod;

    /**
     * The test suite generated by this capsule
     */
    private TestSuite testSuite = null;

    public TestGenerationCapsule(ICodeCoverageParser codeCoverageParser,
            KeYJavaMethod targetMethod) {
        super();
        this.codeCoverageParser = codeCoverageParser;
        this.targetMethod = targetMethod;
    }

    /**
     * Executes the test generation procedure.
     */
    @Override
    public void run() {

        /*
         * The generated models.
         */
        final List<Model> models = new LinkedList<Model>();

        /*
         * The oracle for the method which the test cases are being generated
         * for.
         */
        Oracle oracle = null;

        try {

            /*
             * Retrieve the symbolic execution tree for the method, and extract
             * from it the nodes needed in order to reach the desired level of
             * code coverage.
             */
            Benchmark
                    .startBenchmarking("2. [KeY] Create symbolic execution tree");
            final IExecutionStartNode root = this.keYInterface
                    .getSymbolicExecutionTree(targetMethod);

            ExecutionPathContext.constructExecutionContext(root);

            final List<IExecutionNode> nodes = codeCoverageParser
                    .retrieveNodes(root);

            Benchmark
                    .finishBenchmarking("2. [KeY] Create symbolic execution tree");

            Benchmark.startBenchmarking("3. generating models");

            /*
             * Setup the module generation capsules for each node.
             */
            final List<ModelGenerationCapsule> modelGenerationCapsules = new LinkedList<ModelGenerationCapsule>();
            for (final IExecutionNode node : nodes) {
                modelGenerationCapsules.add(new ModelGenerationCapsule(node));
            }

            /*
             * Setup the Oracle generation capsule for this method
             */
            OracleGenerationCapsule oracleGenerationCapsule = new OracleGenerationCapsule(
                    targetMethod);

            /*
             * Dispatch and wait for the capsules.
             */
            oracleGenerationCapsule.start();
            for (final ModelGenerationCapsule capsule : modelGenerationCapsules) {
                capsule.start();
            }
            while (true) {
                try {
                    oracleGenerationCapsule.join();
                    for (ModelGenerationCapsule capsule : modelGenerationCapsules) {
                        capsule.join();
                    }
                    break;
                } catch (InterruptedException e) {
                    continue;
                }
            }

            /*
             * Collect the results
             */
            oracle = oracleGenerationCapsule.getResult();
            for (final ModelGenerationCapsule capsule : modelGenerationCapsules) {
                models.add(capsule.getResult());
            }

            /*
             * Construct the test cases.
             */
            List<TestCase> testCases = new LinkedList<TestCase>();
            for (final Model model : models) {
                final TestCase testCase = TestCase.constructTestCase(
                        targetMethod, model, oracle);
                testCases.add(testCase);
            }
            Benchmark.finishBenchmarking("3. generating models");

            /*
             * Construct the test suite.
             */
            testSuite = TestSuite.constructTestSuite(
                    targetMethod.getDeclaringClass(), targetMethod, testCases);

            /*
             * Finish execution.
             */
            setSucceeded();

        } catch (KeYInterfaceException e) {
            setThrownException(e);
        } catch (CoreException e) {
            setThrownException(e);
        }
    }

    public TestSuite getResult() {
        return testSuite;
    }
}
