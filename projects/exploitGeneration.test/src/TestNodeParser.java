import java.io.File;
import java.util.LinkedList;
import java.util.List;

import org.junit.Test;
import org.key_project.util.collection.ImmutableList;
import org.key_project.util.collection.ImmutableSet;
import org.key_project.util.java.ArrayUtil;
import org.key_project.util.java.IFilter;

import de.tud.exploitgen.detectleak.exploit.ExploitModelCreator;
import de.tud.exploitgen.detectleak.node.NodeDetail;
import de.tud.exploitgen.detectleak.node.NodeInvestigator;
import de.tud.exploitgen.detectleak.node.NodeParser;
import de.tud.exploitgen.infrastructure.KeYJavaClass;
import de.tud.exploitgen.infrastructure.KeYJavaClassFactory;
import de.tud.exploitgen.infrastructure.KeYJavaMethod;
//import de.uka.ilkd.key.collection.ImmutableList;
//import de.uka.ilkd.key.collection.ImmutableSet;
import de.uka.ilkd.key.java.abstraction.KeYJavaType;
import de.uka.ilkd.key.logic.op.IProgramMethod;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
import de.uka.ilkd.key.proof.init.ProofOblInput;
import de.uka.ilkd.key.speclang.Contract;
import de.uka.ilkd.key.speclang.FunctionalOperationContract;
import de.uka.ilkd.key.symbolic_execution.ExecutionNodePreorderIterator;
import de.uka.ilkd.key.symbolic_execution.SymbolicExecutionTreeBuilder;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionNode;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionTermination;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionValue;
import de.uka.ilkd.key.symbolic_execution.model.IExecutionVariable;
import de.uka.ilkd.key.symbolic_execution.profile.SymbolicExecutionJavaProfile;
//import de.uka.ilkd.key.symbolic_execution.util.IFilter;
//import de.uka.ilkd.key.symbolic_execution.util.JavaUtil;
//import de.uka.ilkd.key.symbolic_execution.util.KeYEnvironment;
import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionEnvironment;
//import de.uka.ilkd.key.ui.CustomUserInterface;
import de.uka.ilkd.key.control.DefaultUserInterfaceControl;
import de.uka.ilkd.key.control.KeYEnvironment;
import junit.framework.TestCase;

/**
 * 
 */

/**
 * @author Huy Do
 *
 */
public class TestNodeParser extends TestCase {
   @Test
   public void testSymbolicExecutionExperimentation() throws Exception {
      // Load source code
      //KeYEnvironment<CustomUserInterface> env = KeYEnvironment.load(SymbolicExecutionJavaProfile.getDefaultInstance(), new File("C:\\Implementation\\Development\\KeY\\eclipse_workspace\\exploitGenExperiment\\src\\demo\\ArrayType.java"), null, null);
      KeYEnvironment<DefaultUserInterfaceControl> env = KeYEnvironment.load(new File("/home/huy/Working/workspace/KEG_experiment/src/integer/Simplest.java"), null, null,null);
      try {
         // Find type
         KeYJavaType type = env.getJavaInfo().getKeYJavaType("integer.Simplest");
         KeYJavaClass javaClass = new KeYJavaClass(type,env); 
         assertNotNull(type);
         // Find method
         ImmutableList<IProgramMethod> methods = env.getJavaInfo().getAllProgramMethods(type);
         KeYJavaMethod method=javaClass.getMethod("miracle");
         IProgramMethod pm = ArrayUtil.search(methods.toArray(IProgramMethod.class), new IFilter<IProgramMethod>() {
            @Override
            public boolean select(IProgramMethod element) {
               return "demo.ArrayType::miracle".equals(element.name().toString());
            }
         });
         assertNotNull(pm);
         // Find contract
         ImmutableSet<Contract> contracts = env.getServices().getSpecificationRepository().getContracts(pm.getContainerType(), pm);         
         Contract contract = contracts.iterator().next(); // TODO; In case of also you have multiple contracts. Select the one you need         
         ProofOblInput input = new FunctionalOperationContractPO(env.getInitConfig(), (FunctionalOperationContract)contract, true, true);
         // Create proof
         Proof proof = env.createProof(input);
         assert (proof != null);
         
         /// Configure proof for symbolic execution
         SymbolicExecutionEnvironment.configureProofForSymbolicExecution(proof,
                                                                         1000,
                                                                         true,
                                                                         true,
                                                                         false,
                                                                         false,false);

         // Create symbolic execution tree which contains only the start node at beginning
         SymbolicExecutionTreeBuilder builder = new SymbolicExecutionTreeBuilder(
                                                                                 proof,
                                                                                 false,
                                                                                 false,false,false,false);
         // Run proof
         env.getProofControl().startAndWaitForAutoMode(proof);
         // Update symbolic execution tree
         builder.analyse();
         List<IExecutionNode> listNodes=new LinkedList<IExecutionNode>();
         // Print symbolic execution tree
         ExecutionNodePreorderIterator iterator = new ExecutionNodePreorderIterator(builder.getStartNode());
         while (iterator.hasNext()) {
            IExecutionNode next = iterator.next();
            //System.out.println(next);
            if(NodeParser.isNormalTerminationNode(next)){
               listNodes.add(next.getParent());
               //print(next.getParent().getVariables(), 1);               
            }
         }
         
         //check properties of leaf nodes
         for(IExecutionNode node: listNodes){
            if(NodeParser.isDescendantOfLoopInvariant(node))
               System.out.println("isDescendantOfLoopInvariant detected!");
            else if(NodeParser.isDescendantOfMethodContract(node))
               System.out.println("isDescendantOfMethodContract detected!");
            else
               System.out.println("normal node");           
            
         }
         
         List<NodeDetail> nodeDetails = new LinkedList<NodeDetail>();
         for(IExecutionNode node: listNodes){
            
            NodeDetail nd = new NodeInvestigator(node,method,10).extractNodeDetail();
            nodeDetails.add(nd);
            System.out.println("\n============Model information=================\n");
            System.out.println(nd.getModels().toString());
            System.out.println("\n============Artificial varibales information=================\n");
            System.out.println(nd.getArtificialVariable());
            System.out.println("\n=============================\n");
         }
         
         //print out to test exploit model generated by the new way
         for(int i = 0; i<nodeDetails.size(); i ++)
            for(int j = i+1; j<nodeDetails.size(); j ++){
               System.out.println(" working on two nodes " + i + " and " + j);
               ExploitModelCreator emc = new ExploitModelCreator(nodeDetails.get(i),nodeDetails.get(j));
               emc.getMergedExploitModel(0,0).printModelInfo();               
            }
        
      }
      finally {
         if (env != null) {
            env.dispose();
         }
      }
   }
   
   private void print(IExecutionVariable[] variables, int level) throws Exception {
      for (IExecutionVariable var : variables) {
         for (int i = 0; i < level; i++) {
            System.out.print('\t');
         }
         System.out.println(var.getName());
         IExecutionValue[] values = var.getValues();
         for (IExecutionValue value : values) {
            print(value.getChildVariables(), level + 1);
         }
      }
   }
}
