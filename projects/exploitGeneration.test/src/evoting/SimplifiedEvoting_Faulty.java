package evoting;
public class SimplifiedEvoting_Faulty {
	private boolean secret;
	   public Result result;
	   int n; //number of candidates
	   int[] votesX, votesY;
	   /*! result | secret ; !*/
	   
	   protected /*@ spec_public @*/ Result compute(int[] votes){
		Result rs = new Result(n);
	

//@ghost int iter = 0;// AUTO_GENERATED BY KeY
/*@ // AUTO_GENERATED BY KeY
   loop_invariant
    rs.bulletin == rs.bulletin
&& i >  0
&& i == 1 + (\sum int q; 0 <= q & q <iter;1 + 0)
&&( \forall int j_20;
    (   0 <= j_20 & j_20 < rs.bulletin.length
     ==>   (\sum int q_1; 0 <= q_1 & q_1 <iter; (votes[q_1] == j_20)
                             ? (1 + 0)
                             : (0))
        == rs.bulletin[j_20]))
&& (iter >= 0 & 1 + iter * 1 == i)
;
   assignable
   rs.bulletin[*],i;
   @decreases votes.length-i;
@*/

		for(int i = 1; i< votes.length; i++){
//@set iter = iter + 1;// AUTO_GENERATED BY KeY
	             if(votes[i]>=0 && votes[i]<n)
	            	rs.bulletin[votes[i]] = rs.bulletin[votes[i]] + 1;
	   	}
	      return rs;
	   }


  	   /*@requires
		 (votesX.length == votesY.length) && (votesX.length>3) && n>=2 && n<=4 && (votesX.length<8)
	         && (\forall int j; j>=0 && j<votesX.length; votesX[j]>=0 && votesX[j]<n && votesY[j]>=0 && votesY[j]<n)
	         && (\forall int i; i>=0 && i<n; (\sum int j; 0 <= j && j < votesX.length; (votesX[j]==i ? 1 : 0))==(\sum int j; 0 <= j && j < votesY.length; (votesY[j]==i ? 1 : 0)) );
	    @ diverges true;
	    @*/
	   public void magic(/*int[] votes1, int[] votes2*/){
	      if(secret)
	         result = compute(votesX);
	      else
	         result = compute(votesY);
	   }
}
