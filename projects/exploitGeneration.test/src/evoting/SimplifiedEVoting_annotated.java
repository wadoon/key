package evoting;

public final class SimplifiedEVoting_annotated {
   private boolean secret;
   public Result result;
   int n; //number of candidates
   int[] votesX, votesY;
   /*! result | secret ; !*/
   
   protected /*@ spec_public @*/ Result compute(int[] votes){
	Result rs = new Result(n);
//@ghost int iter = 0;// AUTO_GENERATED BY KeY
/*@ // AUTO_GENERATED BY KeY
   loop_invariant
    rs.bulletin == rs.bulletin
&& i >= 0
&& i == (\sum int q; 0 <= q & q <iter;1 + 0)
&&( \forall int j_27;
    (   0 <= j_27 & j_27 < rs.bulletin.length
     ==>   (\sum int q_1; 0 <= q_1 & q_1 <iter; (votes[q_1] == j_27)
                             ? (1 + 0)
                             : (0))
        == rs.bulletin[j_27]))
&& (iter >= 0 & iter * 1 == i)
&& i - votes.length <= 0
&&( \forall int j_28;
    (j_28 < i & 0 <= j_28 ==> votes[j_28] >= 0)
);
   assignable
   rs.bulletin[*],i;
@*/

	for(int i = 0; i< votes.length; i++){
//@set iter = iter + 1;// AUTO_GENERATED BY KeY
             if(votes[i]>=0 && votes[i]<n)
            	rs.bulletin[votes[i]] = rs.bulletin[votes[i]] + 1;
   	}
      return rs;
   }


   /*@requires 
	(votesX.length == votesY.length) && (votesX.length>5) && n>=2 && n<=4 && (votesX.length<10)
         && (\forall int j; j>=0 && j<votesX.length; votesX[j]>=0 && votesX[j]<n && votesY[j]>=0 && votesY[j]<n)
         && (\forall int i; i>=0 && i<n; (\sum int j; 0 <= j && j < votesX.length; (votesX[j]==i ? 1 : 0))==(\sum int j; 0 <= j && j < votesY.length; (votesY[j]==i ? 1 : 0)) );
    @ diverges true;
    @*/
   public void magic(/*int[] votes1, int[] votes2*/){
      if(secret)
         result = compute(votesX);
      else
         result = compute(votesY);
   }
}

