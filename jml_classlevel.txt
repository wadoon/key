/*@ public normal_behavior
      @   assignable \nothing;
      @   assignable<permissions> \nothing;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//    public AssertionError(double detailMessage) {}
//    public AssertionError(float detailMessage)  {}


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Tue Apr 15 10:18:21 CEST 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/*@ public normal_behaviour
      @ requires true;
      @ ensures \result == (val != val);
      @ assignable \strictly_nothing;
      @ accessible \nothing;
      @*/


/*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isNaN(double val) {
      @     return val != val;
      @ }
      @*/

    /*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isSame(double a, double b) {
      @     return Double._isNaN(a) ? Double._isNaN(b) : a == b;
      @ }
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


// the following is needed for in some examples to static initialisation:


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/*@ public normal_behaviour
      @ requires true;
      @ ensures \result == Float._isNaN(val);
      @ assignable \strictly_nothing;
      @*/


/*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isNaN(float val) {
      @     return val != val;
      @ }
      @*/

    /*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isSame(float a, float b) {
      @     return Float._isNaN(a) ? Float._isNaN(b) : a == b;
      @ }
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//   public float floatValue();
//   public double doubleValue();


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Tue Apr 15 10:18:21 CEST 2008
 */


/*@ public normal_behavior
      @ requires y != 0;
      @ ensures (\exists int r; r * y + \result == x);
      @ ensures y < 0 ==> (0 >= \result && \result > y);
      @ ensures y > 0 ==> (0 <= \result && \result < y);
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behaviour
      @  ensures a <= 0.0d ==> \result == 0.0d - a;
      @  ensures a > 0.0d ==> \result == a;
      @  assignable \strictly_nothing;
      @  // no_state  // for future use
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Tue Apr 15 10:17:24 CEST 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/*@ public normal_behavior
     @   ensures message == null && cause == null;
     @   assignable message, cause;
     @*/


/*@ public normal_behavior
     @   ensures message == arg0 && cause == null;
     @   assignable message, cause;
     @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//   public abstract float floatValue();
//   public abstract double doubleValue();


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:16:59 CET 2014
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


// public final static java.util.Comparator CASE_INSENSITIVE_ORDER;

   /*@ normal_behavior
       ensures \result == \dl_seqLen(\dl_strContent(this));
    */


/*@
   public normal_behavior
      requires true;
      ensures \dl_strContent(this)==\dl_seqEmpty();
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires other != null;
      ensures \dl_strContent(this)==\dl_strContent(other);
      assignable \nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires v != null;
      ensures \dl_seqLen ( \dl_strContent(this)) == v.length
          && (\forall int i; i >= 0 && i < v.length;
               (int) \dl_strContent(this)[i] == v[i]);
      assignable \nothing;
   also
   public exceptional_behavior
      requires v == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires v != null;
      requires offset >= 0 && count >= 0 && offset + count <= v.length;
      ensures \dl_seqLen(\dl_strContent(this))==count;
      ensures (\forall int i; i >= 0 && i < count;
                     v[offset+i] == (int) \dl_strContent(this)[i]);
      assignable \nothing;
   also
   public exceptional_behavior
      requires v != null;
      requires (offset < 0 || count < 0 || offset + count > v.length);
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires v == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


// public String(byte[] arg0, int arg1, int arg2, java.lang.String arg3) throws java.io.UnsupportedEncodingException;
// public String(byte[] arg0, int arg1, int arg2, java.nio.charset.Charset arg3);
// public String(byte[] arg0, java.lang.String arg1) throws java.io.UnsupportedEncodingException;
// public String(byte[] arg0, java.nio.charset.Charset arg1);


// public String(java.lang.StringBuffer arg0);
// public String(java.lang.StringBuilder arg0);

   /*@
   public normal_behavior
      requires true;
      ensures \result==\dl_seqLen(\dl_strContent(this));
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result <==> \dl_strContent(this) == \dl_seqEmpty();
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires charIdx >= 0 && charIdx < \dl_strContent(this).length;
      ensures \result==(int) \dl_strContent(this)[charIdx];
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires charIdx < 0 || charIdx >= \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires dst != null && srcBegin >= 0 && srcBegin <= srcEnd
               && srcEnd <= \dl_seqLen(\dl_strContent(this))
               && dstBegin >= 0
               && dstBegin + (srcEnd - srcBegin) <= dst.length;
      ensures (\forall int i;
                     0 <= i < (srcEnd - srcBegin)
                  && (int) \dl_strContent(this)[srcBegin + i] == dst[dstBegin + i]
                  && (0 <= i  && i < dstBegin ==> dst[i] == \old(dst[i]))
                  && (dstBegin + (srcEnd - srcBegin) <= i < dst.length);
			    dst[i] == \old(dst[i]));
      assignable dst[*];
   also
   public exceptional_behavior
      requires dst != null && (  srcBegin < 0
             || srcBegin > srcEnd
             || srcEnd > \dl_seqLen(\dl_strContent(this))
             || dstBegin < 0
             || dstBegin + (srcEnd - srcBegin) > dst.length);
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires dst == null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
    */


// public byte[] getBytes(java.lang.String arg0) throws java.io.UnsupportedEncodingException;
// public byte[] getBytes(java.nio.charset.Charset arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(byte[]);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result[*] \by \dl_strContent(this);
     @*/


/*@
   public normal_behavior
   requires true;
   ensures \result <==> obj != null
          && obj instanceof java.lang.String
          && \dl_strContent(this)==\dl_strContent((java.lang.String)obj);
   assignable \strictly_nothing;
   */


// public boolean contentEquals(java.lang.StringBuffer arg0);
// public boolean contentEquals(java.lang.CharSequence arg0);


/*@
   public normal_behavior
      requires other != null;
      ensures \result <==>
                              startIdx >= 0
                           && (startIdx <= \dl_seqLen(\dl_strContent(this)))
                           && \dl_clStartsWith(
                                 \dl_seqSub(
                                    \dl_strContent(other), startIdx,
                                    \dl_seqLen(\dl_strContent(this))
                                 ),
                                 \dl_strContent(other)
                             );
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result <==> \dl_clStartsWith(\dl_strContent(this), \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires other  != null;
      ensures \result <==> \dl_clEndsWith(\dl_strContent(this), \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result == \dl_clHashCode(\dl_strContent(this));
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires true;
      ensures \result==\dl_clIndexOfChar( \dl_strContent(this), charVal, 0);
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires true;
      ensures \result == \dl_clIndexOfChar(\dl_strContent(this), charVal, from);
      assignable \strictly_nothing;
   */


/* @
   public normal_behavior
      requires true;
      ensures \result == \dl_clLastIndexOfChar(
                  \dl_strContent(this), charVal,
                  \dl_seqLen(\dl_strContent(this)) - 1));
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires t != null;
      ensures \result == \dl_clIndexOfCl(\dl_strContent(this), from, \dl_strContent(t));
      assignable \strictly_nothing;
   also
      public exceptional_behavior
      requires t==null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result ==
                  \dl_clLastIndexOfCl(
                     \dl_strContent(this),
                     \dl_seqLen(\dl_strContent(this)) - 1,
                     \dl_strContent(other));

      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result ==
                  \dl_clLastIndexOfCl(\dl_strContent(this), from, \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires startIdx >= 0 && startIdx < \dl_seqLen(\dl_strContent(this));
      //boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqSub(\dl_strContent(this), startIdx, \dl_seqLen(\dl_strContent(this)));
      assignable \nothing;
   also
   public exceptional_behavior
      requires startIdx < 0 || startIdx > \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires endIdx >= startIdx && startIdx >= 0
           && endIdx <= \dl_seqLen(\dl_strContent(this));
      //boolean::select(heapAtPre, result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqSub(\dl_strContent(this), startIdx, endIdx);
      assignable \nothing;
   also
   public exceptional_behavior
      requires startIdx > endIdx || startIdx < 0 || endIdx > \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
    */


// public java.lang.CharSequence subSequence(int arg0, int arg1);

   /*@
   public normal_behavior
      requires    other != null;
      requires \dl_seqLen(\dl_strContent(other)) > 0;
      //ensures boolean::select(heapAtPre, result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqConcat(\dl_strContent(this), \dl_strContent(other));
      assignable \nothing;
    also
    public normal_behavior
      requires    other != null;
      requires \dl_seqLen(\dl_strContent(other))==0;
      ensures \result == this;
      assignable \nothing;
    also
    public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures
         (\exists int i;
            i >= 0 && i < \dl_seqLen(\dl_strContent(this));
            (int) \dl_strContent(this)[i] == c1)
         ? \result != null && \dl_strContent(\result) == \dl_clReplace(\dl_strContent(this), c1, c2)
         : \result == this;
      assignable \nothing;
   */


// public boolean contains(java.lang.CharSequence arg0);


// public java.lang.String replace(java.lang.CharSequence arg0, java.lang.CharSequence arg1);


// public java.lang.String toLowerCase(java.util.Locale arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(String);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \dl_strContent(\result) \by \dl_strContent(this);
     @*/


// public java.lang.String toUpperCase(java.util.Locale arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(String);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \dl_strContent(\result) \by \dl_strContent(this);
     @*/


/*@
   public normal_behavior
      requires true;
      ensures \result != null;
      ensures \dl_strContent(\result).length <= \dl_strContent(this).length;
      assignable \nothing;
   also
      public normal_behavior
      requires (\exists int i;
               (0 <= i & i < \dl_strContent(this).length
                     && ((char)\dl_strContent(this)[i]) > ' '));
      ensures \result != null;
      ensures \dl_strContent(\result).length <= \dl_strContent(this).length;
      ensures \dl_strContent(\result).length >= 1;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result == this;
      assignable \strictly_nothing;
   */


/*@ public normal_behavior
     @ ensures \result.length == \dl_strContent(this).length;
     @ ensures (\forall \bigint i; 0 <= i && i < \result.length; \dl_inChar(\result[i]));
     @ ensures \fresh(\result) && \typeof(\result) == \type(char[]);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result[*] \by \dl_strContent(this);
     @*/


// public static java.lang.String format(java.util.Locale arg0, java.lang.String arg1, java.lang.Object[] arg2);

   /*@
   public normal_behavior
      requires obj == null;
      ensures \dl_strContent(\result) == "null";
      ensures \result != null;
      //       && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      assignable \nothing;
   also
   public normal_behavior
      requires obj != null;
      ensures \result==obj.toString();
      assignable \nothing;
   //also
   //public normal_behavior
   //   requires obj != null && obj instanceof Boolean;
   //   ensures \dl_strContent(\result) == (obj == true ? "true" : "false");
   //   ensures \result != null;
   //   assignable \strictly_nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Character;
      ensures \dl_strContent(\result) == \dl_seqSingleton((char) obj);
      ensures \result != null;
      assignable \nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Integer;
      ensures \dl_strContent(\result)==\dl_clRemoveZeros(\dl_clTranslateInt((int) obj));
      ensures \result != null;
      assignable \nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Long;
      ensures \dl_strContent(\result)==\dl_clRemoveZeros(\dl_clTranslateInt((long) obj));
      ensures \result != null;
      assignable \nothing;
  */


/*@
   public normal_behavior
      requires (data != null);
      ensures (\forall int i; 0<= i < data.length;
                  (int) \dl_strContent(\result)[i]==data[i]);
      ensures \dl_seqLen(\dl_strContent(\result))==data.length;
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires data != null && offset >= 0 && count >= 0
               && offset + count <= data.length;
      ensures (\forall int i; 0<= i && i < count;
                  (int) \dl_strContent(\result)[i] == data[offset + i]);
      ensures \dl_seqLen(\dl_strContent(\result)) == count;
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data != null;
      requires offset < 0 || count < 0 || offset+count > data.length;
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
    public normal_behavior
      requires data != null;
      requires offset >= 0 && count >= 0 && offset+count <= data.length;
      ensures \dl_seqLen(\dl_strContent(\result)) == count;
      ensures (\forall int i; 0 <= i < count;
                         (int) \dl_strContent(\result)[i] == data[i+offset]);
      //    && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data != null;
      requires offset < 0 || count < 0 || offset+count > data.length;
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires data != null;
      ensures \dl_seqLen(\dl_strContent(\result)) == data.length;
      ensures (\forall int i; 0 <= i < data.length;
                  (int) \dl_strContent(\result)[i] == data[i]);
      ensures \result != null;
      //    && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      assignable \nothing;
   also exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


//   public static java.lang.String valueOf(float arg0);
//   public static java.lang.String valueOf(double arg0);

   /*@
   public normal_behavior
      requires true;
      ensures \result != null;
      ensures \result==\dl_strPool(\dl_strContent(this));
      assignable \nothing;
   */


/*@
   public normal_behavior
     requires other != null && other instanceof java.lang.String;
     ensures
         (\forall int i; 0 <= i < \dl_strContent(this).length
                         && i<\dl_strContent(other).length;
           \dl_strContent(this)[i] == \dl_strContent(other)[i])
         ? \result == \dl_strContent(this).length - \dl_strContent(other).length
         : (\exists int j; (\forall int i; 0 <= i < j; \dl_strContent(this)[i] == \dl_strContent(other)[i])
                           && \result != 0 && \result == (int) \dl_strContent(other)[j] - (int)\dl_strContent(this)[j]);
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


//, CharSequence


//    public StringBuffer	append(char[] str);
    //    public StringBuffer	append(char[] str, int offset, int len);
    //    public StringBuffer	append(double d);
    //    public StringBuffer	append(float f);


//    public CharSequence subSequence(int start, int end);


// Remarks: Currently the specifications assumes src and dest to be int[].
    //          This is incomplete, and should be amended when needed
    // added by Mattias Ulbrich in Jan 19.
    /*@ public exceptional_behavior
      @   requires src == null || dest == null;
      @   signals_only NullPointerException;
      @   assignable \nothing;
      @ also
      @ public exceptional_behavior
      @   requires src instanceof int[] && dest instanceof int[];
      @   requires src != null && dest != null;
      @   requires (srcPos < 0 || destPos < 0 || length < 0
      @                  || srcPos + length > ((int[])src).length
      @                  || destPos + length > ((int[])dest).length);
      @    assignable \nothing;
      @    signals_only ArrayIndexOutOfBoundsException;
      @ also
      @ public normal_behavior
      @   requires src instanceof int[] && dest instanceof int[];
      @   requires src != null && dest != null;
      @   requires srcPos >= 0 && destPos >= 0;
      @   requires length >= 0;
      @   requires srcPos + length <= ((int[])src).length
      @         && destPos + length <= ((int[])dest).length;
      @   ensures (\forall int i; 0 <= i && i < length;
      @             ((int[])dest)[destPos + i] == \old(((int[])src)[srcPos + i]));
      @   assignable ((int[])dest)[destPos .. destPos + length - 1];
      @*/
    /*@ helper @*/


// This implementation has been used to verify the above contracts
    // {
    //     if(src == null || dest == null) {
    //         throw new NullPointerException();
    //     }
    //     int[] isrc = (int[])src;
    //     int[] idest = (int[])dest;
    //     if(length < 0) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     int[] tmp = new int[length];
    //     if(srcPos < 0 || srcPos + length > isrc.length) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     /*@ loop_invariant 0 <= i && i <= length;
    //       @ loop_invariant (\forall int j; 0<=j && j < i; tmp[j] == isrc[srcPos + j]);
    //       @ loop_invariant \fresh(tmp);
    //       @ decreases length - i;
    //       @ assignable tmp[*];
    //       @*/
    //     for(int i = 0; i < length; i++) {
    //         tmp[i] = isrc[srcPos + i];
    //     }
    //     if(destPos < 0 || destPos + length > idest.length) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     /*@ loop_invariant 0 <= k && k <= length;
    //       @ loop_invariant (\forall int j; 0<=j && j < k; idest[destPos + j] == tmp[j]);
    //       @ decreases length - k;
    //       @ assignable idest[destPos .. destPos + length - 1];
    //       @*/
    //     for(int k = 0; k < length; k++) {
    //         idest[destPos + k] = tmp[k];
    //     }
    // }

    /*@ public behavior
      @ ensures false;
      @ signals_only \nothing;
      @ diverges true;
      @*/


//@ protected nullable ghost String message = null;
   //@ protected nullable ghost Throwable cause = null;

   /*@ public normal_behavior
     @    requires true;
     @    ensures message == null && cause == null;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == arg0 && cause == null;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == arg0 && cause == arg1;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == null && cause == arg0;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    ensures \result == message;
     @*/


/*@ public normal_behavior
     @    ensures \result == cause;
     @*/


//TODO: fix the contract to match Java's behavior (e.g. arg0 != this or exception)
   /*@ public normal_behavior
     @    requires cause == null;
     @    ensures \result == this && cause == arg0;
     @    assignable cause;
     @ helper // needs to be helper because called in constructor
     @*/


// public void printStackTrace(java.io.PrintStream arg0);
// public void printStackTrace(java.io.PrintWriter arg0);


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 *
 * Enriched by JML specifications by MU
 *
 */


//@ public instance ghost \seq seq;

   /*@ public normal_behavior
     @ ensures \result == seq.length;
     @ assignable \nothing;
     @ determines \result \by seq.length;
     @ */


/*@ public normal_behavior
     @ ensures \result == (size() == 0);
     @ assignable \nothing;
     @ determines \result \by seq.length;
     @*/


/*@ public normal_behavior
     @ ensures seq == \seq_concat(\old(seq), \seq_singleton(arg0));
     @ assignable seq;
     @ determines seq \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ ensures seq == \seq_concat(\old(seq), arg0.seq);
     @ assignable seq;
     @ determines seq \by seq, arg0.seq;
     @*/


/*@ public normal_behavior
     @ ensures \result == (\exists \bigint i; 0 <= i && i < seq.length; ((String)seq[i]) == arg0);
     @ assignable \nothing;
     @ determines \result \by seq, arg0;
     @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/*@ public normal_behavior
     @ requires arg0 == 0;
     @ ensures seq == \seq_concat(\seq_singleton(arg0), \old(seq));
     @ assignable seq;
     @ determines seq \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ requires 0 <= arg0 && arg0 < seq.length;
     @ ensures ((Object)seq[arg0]) == \result;
     @ assignable \nothing;
     @ determines \result \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ ensures \result.index == 0;
     @ ensures \result.seq == seq;
     @ ensures \fresh(\result) && \fresh(\result.*);
     @ ensures \result instanceof ListIteratorImpl;
     @ assignable \nothing;
     @ determines \result.seq \by seq;
     @ determines \result.index \by \nothing;
     @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//@ public instance ghost \seq seq;
    //@ public instance ghost \bigint index;

    //@ public instance invariant 0 <= index && index <= seq.length;

    /*@ public normal_behavior
      @ ensures \result == true <==> index < seq.length;
      @ assignable \strictly_nothing;
      @ determines \result \by seq.length, index;
      @*/


/*@ public behavior
      @ requires index < seq.length;
      @ ensures \result == ((Object)seq[\old(index)]);
      @ ensures index == \old(index) + 1;
      @ assignable index;
      @ signals_only java.lang.RuntimeException;
      @ determines \result \by seq, index;
      @ determines index \by \itself;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


//@ public instance ghost \seq key_seq;
    //@ public instance ghost \seq value_seq;

    //@ public instance invariant key_seq.length == value_seq.length;
    //@ public instance invariant (\forall \bigint i; 0 <= i && i < key_seq.length; ((Object)key_seq[i]) != null);
    //@ public instance invariant (\forall \bigint i; 0 <= i && i < value_seq.length; ((Object)value_seq[i]) != null);

    /*@ public normal_behavior
      @ ensures \result.seq == key_seq;
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


// public void print(float f);
    // public void print(double d);


// public void println(float x);
    // public void println(double x);


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//@ public final ghost \bigint value;

   //@ public static invariant java.math.BigInteger.ZERO.value == (\bigint) 0;


/*@ public normal_behavior
     @ requires true;
     @ ensures (\result <= 0) <==> (this.value - param0.value <= 0);
     @ ensures (\result >= 0) <==> (this.value - param0.value >= 0);
     @ assignable \strictly_nothing;
     @ determines \result \by this.value, param0.value;
     @*/


/*@ public normal_behavior
     @ requires true;
     @ ensures \result.value == this.value % param0.value;
     @ ensures \fresh(\result) && \fresh(\result.*) && \typeof(\result) == \type(BigInteger);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result.value \by this.value, param0.value;
     @*/


/*@ public normal_behavior
      @ ensures seq.length == 0;
      @ ensures \fresh(this) && \fresh(this.*);
      @ determines seq \by \nothing;
      @*/


/*@ public normal_behavior
      @ ensures seq == c.seq;
      @ ensures \fresh(this) && \fresh(this.*) && \typeof(this) == \type(ArrayList);
      @ determines this, seq \by c.seq \new_objects this;
      @*/


/*@ public normal_behavior
      @ ensures \invariant_for(\result);
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \invariant_for(\result);
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \fresh(\result) && \fresh(\result.*);
      @ ensures \invariant_for(\result);
      @ ensures (\forall \bigint i; 0 <= i && i < \result.seq.length; ((String)\result.seq[i]) != null);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \fresh(\result) && \fresh(\result.*);
      @ ensures \invariant_for(\result);
      @ ensures (\forall \bigint i; 0 <= i && i < \result.seq.length; ((String)\result.seq[i]) != null);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : false)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @     i < original.length ?
      @         Float._isSame(\result[i], original[i]) :
      @         \result[i] == 0.0f
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @     i < original.length ?
      @         Double._isSame(\result[i], original[i]) :
      @         \result[i] == 0.0d
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : false)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @     i < original.length ?
      @         Float._isSame(\result[i - from], original[i]) :
      @         \result[i - from] == 0.0f
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @     i < original.length ?
      @         Double._isSame(\result[i], original[i - from]) :
      @         \result[i - from] == 0.0d
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


// Double and float equals are left out since they use *bitwise* equality

    /*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length;
      @     Double._isSame(a[i], val)
      @ );
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex;
      @     Double._isSame(a[i], val)
      @ );
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length;
      @     Float._isSame(a[i], val)
      @ );
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex;
      @     Float._isSame(a[i], val)
      @ );
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public behavior
     @ requires true;
     @ ensures true;
     @ assignable \everything;
     @*/


/*@ public normal_behavior
      @ ensures key_seq.length == 0;
      @ ensures value_seq.length == 0;
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
	  @ ensures seq == param0.seq;
      @*/


/*@ public normal_behavior
      @ requires true;
      @*/


/*@ public normal_behaviour
      @   requires (\forall int x; (\forall int y; 0 <= x && x < y && y < a.length; a[x] <= a[y]));
      @   ensures ((\exists int x; 0 <= x && x < a.length; a[x] == v) ? a[\result] == v : \result == -1);
      @*/


/*@ public normal_behaviour
      @   requires (\forall int x; (\forall int y; 0 <= x && x < y && y < a.length; a[x] <= a[y]));
      @   ensures ((\exists int x; 0 <= x && x < a.length; a[x] == v) ? a[\result] == v : \result == -1);
      @*/


/*@ public normal_behaviour
      @   requires (\forall int x; (\forall int y; 0 <= x && x < y && y < a.length; a[x] <= a[y]));
      @   ensures ((\exists int x; 0 <= x && x < a.length; a[x] == v) ? a[\result] == v : \result == -1);
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


// public void print(float f);
    // public void print(double d);


// public void println(float x);
    // public void println(double x);


// public void print(float f);
    // public void print(double d);


// public void println(float x);
    // public void println(double x);


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//    public AssertionError(double detailMessage) {}
//    public AssertionError(float detailMessage)  {}


//    public AssertionError(double detailMessage) {}
//    public AssertionError(float detailMessage)  {}


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Tue Apr 15 10:18:21 CEST 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/*@ public normal_behaviour
      @ requires true;
      @ ensures \result == (val != val);
      @ assignable \strictly_nothing;
      @ accessible \nothing;
      @*/


/*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isNaN(double val) {
      @     return val != val;
      @ }
      @*/

    /*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isSame(double a, double b) {
      @     return Double._isNaN(a) ? Double._isNaN(b) : a == b;
      @ }
      @*/


/*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isNaN(double val) {
      @     return val != val;
      @ }
      @*/

    /*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isSame(double a, double b) {
      @     return Double._isNaN(a) ? Double._isNaN(b) : a == b;
      @ }
      @*//*@model @*/


/*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isNaN(double val) {
      @     return val != val;
      @ }
      @*/

    /*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isSame(double a, double b) {
      @     return Double._isNaN(a) ? Double._isNaN(b) : a == b;
      @ }
      @*//*@model @*/


/*@ public normal_behaviour
      @ requires true;
      @ ensures \result == (val != val);
      @ assignable \strictly_nothing;
      @ accessible \nothing;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


// the following is needed for in some examples to static initialisation:


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


// the following is needed for in some examples to static initialisation:


/*@ public normal_behaviour
      @ requires true;
      @ ensures \result == Float._isNaN(val);
      @ assignable \strictly_nothing;
      @*/


/*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isNaN(float val) {
      @     return val != val;
      @ }
      @*/

    /*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isSame(float a, float b) {
      @     return Float._isNaN(a) ? Float._isNaN(b) : a == b;
      @ }
      @*/


/*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isNaN(float val) {
      @     return val != val;
      @ }
      @*/

    /*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isSame(float a, float b) {
      @     return Float._isNaN(a) ? Float._isNaN(b) : a == b;
      @ }
      @*//*@model @*/


/*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isNaN(float val) {
      @     return val != val;
      @ }
      @*/

    /*@ public model_behaviour
      @ requires true;
      @ accessible \nothing;
      @ static model boolean _isSame(float a, float b) {
      @     return Float._isNaN(a) ? Float._isNaN(b) : a == b;
      @ }
      @*//*@model @*/


/*@ public normal_behaviour
      @ requires true;
      @ ensures \result == Float._isNaN(val);
      @ assignable \strictly_nothing;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//   public float floatValue();
//   public double doubleValue();


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


//   public float floatValue();
//   public double doubleValue();


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Tue Apr 15 10:18:21 CEST 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


/*@ public normal_behavior
      @ requires y != 0;
      @ ensures (\exists int r; r * y + \result == x);
      @ ensures y < 0 ==> (0 >= \result && \result > y);
      @ ensures y > 0 ==> (0 <= \result && \result < y);
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behaviour
      @  ensures a <= 0.0d ==> \result == 0.0d - a;
      @  ensures a > 0.0d ==> \result == a;
      @  assignable \strictly_nothing;
      @  // no_state  // for future use
      @*/


/*@ public normal_behavior
      @ requires y != 0;
      @ ensures (\exists int r; r * y + \result == x);
      @ ensures y < 0 ==> (0 >= \result && \result > y);
      @ ensures y > 0 ==> (0 <= \result && \result < y);
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behaviour
      @  ensures a <= 0.0d ==> \result == 0.0d - a;
      @  ensures a > 0.0d ==> \result == a;
      @  assignable \strictly_nothing;
      @  // no_state  // for future use
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Tue Apr 15 10:17:24 CEST 2008
 */


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/*@ public normal_behavior
     @   ensures message == null && cause == null;
     @   assignable message, cause;
     @*/


/*@ public normal_behavior
     @   ensures message == arg0 && cause == null;
     @   assignable message, cause;
     @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/*@ public normal_behavior
     @   ensures message == null && cause == null;
     @   assignable message, cause;
     @*/


/*@ public normal_behavior
     @   ensures message == arg0 && cause == null;
     @   assignable message, cause;
     @*/


//   public abstract float floatValue();
//   public abstract double doubleValue();


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:16:59 CET 2014
 */


//   public abstract float floatValue();
//   public abstract double doubleValue();


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


/*@ public normal_behavior
      @   assignable \nothing;
      @   assignable<permissions> \nothing;
      @*/


/*@ public normal_behavior
      @   assignable \nothing;
      @   assignable<permissions> \nothing;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


// public final static java.util.Comparator CASE_INSENSITIVE_ORDER;

   /*@ normal_behavior
       ensures \result == \dl_seqLen(\dl_strContent(this));
    */


/*@
   public normal_behavior
      requires true;
      ensures \dl_strContent(this)==\dl_seqEmpty();
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires other != null;
      ensures \dl_strContent(this)==\dl_strContent(other);
      assignable \nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires v != null;
      ensures \dl_seqLen ( \dl_strContent(this)) == v.length
          && (\forall int i; i >= 0 && i < v.length;
               (int) \dl_strContent(this)[i] == v[i]);
      assignable \nothing;
   also
   public exceptional_behavior
      requires v == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires v != null;
      requires offset >= 0 && count >= 0 && offset + count <= v.length;
      ensures \dl_seqLen(\dl_strContent(this))==count;
      ensures (\forall int i; i >= 0 && i < count;
                     v[offset+i] == (int) \dl_strContent(this)[i]);
      assignable \nothing;
   also
   public exceptional_behavior
      requires v != null;
      requires (offset < 0 || count < 0 || offset + count > v.length);
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires v == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


// public String(byte[] arg0, int arg1, int arg2, java.lang.String arg3) throws java.io.UnsupportedEncodingException;
// public String(byte[] arg0, int arg1, int arg2, java.nio.charset.Charset arg3);
// public String(byte[] arg0, java.lang.String arg1) throws java.io.UnsupportedEncodingException;
// public String(byte[] arg0, java.nio.charset.Charset arg1);


// public String(java.lang.StringBuffer arg0);
// public String(java.lang.StringBuilder arg0);

   /*@
   public normal_behavior
      requires true;
      ensures \result==\dl_seqLen(\dl_strContent(this));
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result <==> \dl_strContent(this) == \dl_seqEmpty();
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires charIdx >= 0 && charIdx < \dl_strContent(this).length;
      ensures \result==(int) \dl_strContent(this)[charIdx];
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires charIdx < 0 || charIdx >= \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires dst != null && srcBegin >= 0 && srcBegin <= srcEnd
               && srcEnd <= \dl_seqLen(\dl_strContent(this))
               && dstBegin >= 0
               && dstBegin + (srcEnd - srcBegin) <= dst.length;
      ensures (\forall int i;
                     0 <= i < (srcEnd - srcBegin)
                  && (int) \dl_strContent(this)[srcBegin + i] == dst[dstBegin + i]
                  && (0 <= i  && i < dstBegin ==> dst[i] == \old(dst[i]))
                  && (dstBegin + (srcEnd - srcBegin) <= i < dst.length);
			    dst[i] == \old(dst[i]));
      assignable dst[*];
   also
   public exceptional_behavior
      requires dst != null && (  srcBegin < 0
             || srcBegin > srcEnd
             || srcEnd > \dl_seqLen(\dl_strContent(this))
             || dstBegin < 0
             || dstBegin + (srcEnd - srcBegin) > dst.length);
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires dst == null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
    */


// public byte[] getBytes(java.lang.String arg0) throws java.io.UnsupportedEncodingException;
// public byte[] getBytes(java.nio.charset.Charset arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(byte[]);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result[*] \by \dl_strContent(this);
     @*/


/*@
   public normal_behavior
   requires true;
   ensures \result <==> obj != null
          && obj instanceof java.lang.String
          && \dl_strContent(this)==\dl_strContent((java.lang.String)obj);
   assignable \strictly_nothing;
   */


// public boolean contentEquals(java.lang.StringBuffer arg0);
// public boolean contentEquals(java.lang.CharSequence arg0);


/*@
   public normal_behavior
      requires other != null;
      ensures \result <==>
                              startIdx >= 0
                           && (startIdx <= \dl_seqLen(\dl_strContent(this)))
                           && \dl_clStartsWith(
                                 \dl_seqSub(
                                    \dl_strContent(other), startIdx,
                                    \dl_seqLen(\dl_strContent(this))
                                 ),
                                 \dl_strContent(other)
                             );
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result <==> \dl_clStartsWith(\dl_strContent(this), \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires other  != null;
      ensures \result <==> \dl_clEndsWith(\dl_strContent(this), \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result == \dl_clHashCode(\dl_strContent(this));
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires true;
      ensures \result==\dl_clIndexOfChar( \dl_strContent(this), charVal, 0);
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires true;
      ensures \result == \dl_clIndexOfChar(\dl_strContent(this), charVal, from);
      assignable \strictly_nothing;
   */


/* @
   public normal_behavior
      requires true;
      ensures \result == \dl_clLastIndexOfChar(
                  \dl_strContent(this), charVal,
                  \dl_seqLen(\dl_strContent(this)) - 1));
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires t != null;
      ensures \result == \dl_clIndexOfCl(\dl_strContent(this), from, \dl_strContent(t));
      assignable \strictly_nothing;
   also
      public exceptional_behavior
      requires t==null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result ==
                  \dl_clLastIndexOfCl(
                     \dl_strContent(this),
                     \dl_seqLen(\dl_strContent(this)) - 1,
                     \dl_strContent(other));

      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result ==
                  \dl_clLastIndexOfCl(\dl_strContent(this), from, \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires startIdx >= 0 && startIdx < \dl_seqLen(\dl_strContent(this));
      //boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqSub(\dl_strContent(this), startIdx, \dl_seqLen(\dl_strContent(this)));
      assignable \nothing;
   also
   public exceptional_behavior
      requires startIdx < 0 || startIdx > \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires endIdx >= startIdx && startIdx >= 0
           && endIdx <= \dl_seqLen(\dl_strContent(this));
      //boolean::select(heapAtPre, result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqSub(\dl_strContent(this), startIdx, endIdx);
      assignable \nothing;
   also
   public exceptional_behavior
      requires startIdx > endIdx || startIdx < 0 || endIdx > \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
    */


// public java.lang.CharSequence subSequence(int arg0, int arg1);

   /*@
   public normal_behavior
      requires    other != null;
      requires \dl_seqLen(\dl_strContent(other)) > 0;
      //ensures boolean::select(heapAtPre, result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqConcat(\dl_strContent(this), \dl_strContent(other));
      assignable \nothing;
    also
    public normal_behavior
      requires    other != null;
      requires \dl_seqLen(\dl_strContent(other))==0;
      ensures \result == this;
      assignable \nothing;
    also
    public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures
         (\exists int i;
            i >= 0 && i < \dl_seqLen(\dl_strContent(this));
            (int) \dl_strContent(this)[i] == c1)
         ? \result != null && \dl_strContent(\result) == \dl_clReplace(\dl_strContent(this), c1, c2)
         : \result == this;
      assignable \nothing;
   */


// public boolean contains(java.lang.CharSequence arg0);


// public java.lang.String replace(java.lang.CharSequence arg0, java.lang.CharSequence arg1);


// public java.lang.String toLowerCase(java.util.Locale arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(String);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \dl_strContent(\result) \by \dl_strContent(this);
     @*/


// public java.lang.String toUpperCase(java.util.Locale arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(String);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \dl_strContent(\result) \by \dl_strContent(this);
     @*/


/*@
   public normal_behavior
      requires true;
      ensures \result != null;
      ensures \dl_strContent(\result).length <= \dl_strContent(this).length;
      assignable \nothing;
   also
      public normal_behavior
      requires (\exists int i;
               (0 <= i & i < \dl_strContent(this).length
                     && ((char)\dl_strContent(this)[i]) > ' '));
      ensures \result != null;
      ensures \dl_strContent(\result).length <= \dl_strContent(this).length;
      ensures \dl_strContent(\result).length >= 1;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result == this;
      assignable \strictly_nothing;
   */


/*@ public normal_behavior
     @ ensures \result.length == \dl_strContent(this).length;
     @ ensures (\forall \bigint i; 0 <= i && i < \result.length; \dl_inChar(\result[i]));
     @ ensures \fresh(\result) && \typeof(\result) == \type(char[]);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result[*] \by \dl_strContent(this);
     @*/


// public static java.lang.String format(java.util.Locale arg0, java.lang.String arg1, java.lang.Object[] arg2);

   /*@
   public normal_behavior
      requires obj == null;
      ensures \dl_strContent(\result) == "null";
      ensures \result != null;
      //       && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      assignable \nothing;
   also
   public normal_behavior
      requires obj != null;
      ensures \result==obj.toString();
      assignable \nothing;
   //also
   //public normal_behavior
   //   requires obj != null && obj instanceof Boolean;
   //   ensures \dl_strContent(\result) == (obj == true ? "true" : "false");
   //   ensures \result != null;
   //   assignable \strictly_nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Character;
      ensures \dl_strContent(\result) == \dl_seqSingleton((char) obj);
      ensures \result != null;
      assignable \nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Integer;
      ensures \dl_strContent(\result)==\dl_clRemoveZeros(\dl_clTranslateInt((int) obj));
      ensures \result != null;
      assignable \nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Long;
      ensures \dl_strContent(\result)==\dl_clRemoveZeros(\dl_clTranslateInt((long) obj));
      ensures \result != null;
      assignable \nothing;
  */


/*@
   public normal_behavior
      requires (data != null);
      ensures (\forall int i; 0<= i < data.length;
                  (int) \dl_strContent(\result)[i]==data[i]);
      ensures \dl_seqLen(\dl_strContent(\result))==data.length;
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires data != null && offset >= 0 && count >= 0
               && offset + count <= data.length;
      ensures (\forall int i; 0<= i && i < count;
                  (int) \dl_strContent(\result)[i] == data[offset + i]);
      ensures \dl_seqLen(\dl_strContent(\result)) == count;
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data != null;
      requires offset < 0 || count < 0 || offset+count > data.length;
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
    public normal_behavior
      requires data != null;
      requires offset >= 0 && count >= 0 && offset+count <= data.length;
      ensures \dl_seqLen(\dl_strContent(\result)) == count;
      ensures (\forall int i; 0 <= i < count;
                         (int) \dl_strContent(\result)[i] == data[i+offset]);
      //    && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data != null;
      requires offset < 0 || count < 0 || offset+count > data.length;
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires data != null;
      ensures \dl_seqLen(\dl_strContent(\result)) == data.length;
      ensures (\forall int i; 0 <= i < data.length;
                  (int) \dl_strContent(\result)[i] == data[i]);
      ensures \result != null;
      //    && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      assignable \nothing;
   also exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


//   public static java.lang.String valueOf(float arg0);
//   public static java.lang.String valueOf(double arg0);

   /*@
   public normal_behavior
      requires true;
      ensures \result != null;
      ensures \result==\dl_strPool(\dl_strContent(this));
      assignable \nothing;
   */


/*@
   public normal_behavior
     requires other != null && other instanceof java.lang.String;
     ensures
         (\forall int i; 0 <= i < \dl_strContent(this).length
                         && i<\dl_strContent(other).length;
           \dl_strContent(this)[i] == \dl_strContent(other)[i])
         ? \result == \dl_strContent(this).length - \dl_strContent(other).length
         : (\exists int j; (\forall int i; 0 <= i < j; \dl_strContent(this)[i] == \dl_strContent(other)[i])
                           && \result != 0 && \result == (int) \dl_strContent(other)[j] - (int)\dl_strContent(this)[j]);
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


// public final static java.util.Comparator CASE_INSENSITIVE_ORDER;

   /*@ normal_behavior
       ensures \result == \dl_seqLen(\dl_strContent(this));
    */


// public String(java.lang.StringBuffer arg0);
// public String(java.lang.StringBuilder arg0);

   /*@
   public normal_behavior
      requires true;
      ensures \result==\dl_seqLen(\dl_strContent(this));
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result <==> \dl_strContent(this) == \dl_seqEmpty();
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires charIdx >= 0 && charIdx < \dl_strContent(this).length;
      ensures \result==(int) \dl_strContent(this)[charIdx];
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires charIdx < 0 || charIdx >= \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires dst != null && srcBegin >= 0 && srcBegin <= srcEnd
               && srcEnd <= \dl_seqLen(\dl_strContent(this))
               && dstBegin >= 0
               && dstBegin + (srcEnd - srcBegin) <= dst.length;
      ensures (\forall int i;
                     0 <= i < (srcEnd - srcBegin)
                  && (int) \dl_strContent(this)[srcBegin + i] == dst[dstBegin + i]
                  && (0 <= i  && i < dstBegin ==> dst[i] == \old(dst[i]))
                  && (dstBegin + (srcEnd - srcBegin) <= i < dst.length);
			    dst[i] == \old(dst[i]));
      assignable dst[*];
   also
   public exceptional_behavior
      requires dst != null && (  srcBegin < 0
             || srcBegin > srcEnd
             || srcEnd > \dl_seqLen(\dl_strContent(this))
             || dstBegin < 0
             || dstBegin + (srcEnd - srcBegin) > dst.length);
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires dst == null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
    */


// public byte[] getBytes(java.lang.String arg0) throws java.io.UnsupportedEncodingException;
// public byte[] getBytes(java.nio.charset.Charset arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(byte[]);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result[*] \by \dl_strContent(this);
     @*/


/*@
   public normal_behavior
   requires true;
   ensures \result <==> obj != null
          && obj instanceof java.lang.String
          && \dl_strContent(this)==\dl_strContent((java.lang.String)obj);
   assignable \strictly_nothing;
   */


// public boolean contentEquals(java.lang.StringBuffer arg0);
// public boolean contentEquals(java.lang.CharSequence arg0);


/*@
   public normal_behavior
      requires other != null;
      ensures \result <==>
                              startIdx >= 0
                           && (startIdx <= \dl_seqLen(\dl_strContent(this)))
                           && \dl_clStartsWith(
                                 \dl_seqSub(
                                    \dl_strContent(other), startIdx,
                                    \dl_seqLen(\dl_strContent(this))
                                 ),
                                 \dl_strContent(other)
                             );
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result <==> \dl_clStartsWith(\dl_strContent(this), \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires other  != null;
      ensures \result <==> \dl_clEndsWith(\dl_strContent(this), \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result == \dl_clHashCode(\dl_strContent(this));
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires true;
      ensures \result==\dl_clIndexOfChar( \dl_strContent(this), charVal, 0);
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires true;
      ensures \result == \dl_clIndexOfChar(\dl_strContent(this), charVal, from);
      assignable \strictly_nothing;
   */


/* @
   public normal_behavior
      requires true;
      ensures \result == \dl_clLastIndexOfChar(
                  \dl_strContent(this), charVal,
                  \dl_seqLen(\dl_strContent(this)) - 1));
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires t != null;
      ensures \result == \dl_clIndexOfCl(\dl_strContent(this), from, \dl_strContent(t));
      assignable \strictly_nothing;
   also
      public exceptional_behavior
      requires t==null;
      signals (java.lang.NullPointerException) true;
      assignable \strictly_nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result ==
                  \dl_clLastIndexOfCl(
                     \dl_strContent(this),
                     \dl_seqLen(\dl_strContent(this)) - 1,
                     \dl_strContent(other));

      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires other != null;
      ensures \result ==
                  \dl_clLastIndexOfCl(\dl_strContent(this), from, \dl_strContent(other));
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires startIdx >= 0 && startIdx < \dl_seqLen(\dl_strContent(this));
      //boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqSub(\dl_strContent(this), startIdx, \dl_seqLen(\dl_strContent(this)));
      assignable \nothing;
   also
   public exceptional_behavior
      requires startIdx < 0 || startIdx > \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires endIdx >= startIdx && startIdx >= 0
           && endIdx <= \dl_seqLen(\dl_strContent(this));
      //boolean::select(heapAtPre, result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqSub(\dl_strContent(this), startIdx, endIdx);
      assignable \nothing;
   also
   public exceptional_behavior
      requires startIdx > endIdx || startIdx < 0 || endIdx > \dl_seqLen(\dl_strContent(this));
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
    */


// public java.lang.CharSequence subSequence(int arg0, int arg1);

   /*@
   public normal_behavior
      requires    other != null;
      requires \dl_seqLen(\dl_strContent(other)) > 0;
      //ensures boolean::select(heapAtPre, result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      ensures \dl_strContent(\result)==\dl_seqConcat(\dl_strContent(this), \dl_strContent(other));
      assignable \nothing;
    also
    public normal_behavior
      requires    other != null;
      requires \dl_seqLen(\dl_strContent(other))==0;
      ensures \result == this;
      assignable \nothing;
    also
    public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures
         (\exists int i;
            i >= 0 && i < \dl_seqLen(\dl_strContent(this));
            (int) \dl_strContent(this)[i] == c1)
         ? \result != null && \dl_strContent(\result) == \dl_clReplace(\dl_strContent(this), c1, c2)
         : \result == this;
      assignable \nothing;
   */


// public boolean contains(java.lang.CharSequence arg0);


// public java.lang.String replace(java.lang.CharSequence arg0, java.lang.CharSequence arg1);


// public java.lang.String toLowerCase(java.util.Locale arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(String);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \dl_strContent(\result) \by \dl_strContent(this);
     @*/


// public java.lang.String toUpperCase(java.util.Locale arg0);

   /*@ public normal_behavior
     @ ensures \fresh(\result) && \typeof(\result) == \type(String);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \dl_strContent(\result) \by \dl_strContent(this);
     @*/


/*@
   public normal_behavior
      requires true;
      ensures \result != null;
      ensures \dl_strContent(\result).length <= \dl_strContent(this).length;
      assignable \nothing;
   also
      public normal_behavior
      requires (\exists int i;
               (0 <= i & i < \dl_strContent(this).length
                     && ((char)\dl_strContent(this)[i]) > ' '));
      ensures \result != null;
      ensures \dl_strContent(\result).length <= \dl_strContent(this).length;
      ensures \dl_strContent(\result).length >= 1;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \result == this;
      assignable \strictly_nothing;
   */


/*@ public normal_behavior
     @ ensures \result.length == \dl_strContent(this).length;
     @ ensures (\forall \bigint i; 0 <= i && i < \result.length; \dl_inChar(\result[i]));
     @ ensures \fresh(\result) && \typeof(\result) == \type(char[]);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result[*] \by \dl_strContent(this);
     @*/


// public static java.lang.String format(java.util.Locale arg0, java.lang.String arg1, java.lang.Object[] arg2);

   /*@
   public normal_behavior
      requires obj == null;
      ensures \dl_strContent(\result) == "null";
      ensures \result != null;
      //       && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      assignable \nothing;
   also
   public normal_behavior
      requires obj != null;
      ensures \result==obj.toString();
      assignable \nothing;
   //also
   //public normal_behavior
   //   requires obj != null && obj instanceof Boolean;
   //   ensures \dl_strContent(\result) == (obj == true ? "true" : "false");
   //   ensures \result != null;
   //   assignable \strictly_nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Character;
      ensures \dl_strContent(\result) == \dl_seqSingleton((char) obj);
      ensures \result != null;
      assignable \nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Integer;
      ensures \dl_strContent(\result)==\dl_clRemoveZeros(\dl_clTranslateInt((int) obj));
      ensures \result != null;
      assignable \nothing;
   also
   public normal_behavior
      requires obj!=null && obj instanceof java.lang.Long;
      ensures \dl_strContent(\result)==\dl_clRemoveZeros(\dl_clTranslateInt((long) obj));
      ensures \result != null;
      assignable \nothing;
  */


/*@
   public normal_behavior
      requires (data != null);
      ensures (\forall int i; 0<= i < data.length;
                  (int) \dl_strContent(\result)[i]==data[i]);
      ensures \dl_seqLen(\dl_strContent(\result))==data.length;
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires data != null && offset >= 0 && count >= 0
               && offset + count <= data.length;
      ensures (\forall int i; 0<= i && i < count;
                  (int) \dl_strContent(\result)[i] == data[offset + i]);
      ensures \dl_seqLen(\dl_strContent(\result)) == count;
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data != null;
      requires offset < 0 || count < 0 || offset+count > data.length;
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
    public normal_behavior
      requires data != null;
      requires offset >= 0 && count >= 0 && offset+count <= data.length;
      ensures \dl_seqLen(\dl_strContent(\result)) == count;
      ensures (\forall int i; 0 <= i < count;
                         (int) \dl_strContent(\result)[i] == data[i+offset]);
      //    && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      ensures \result != null;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data != null;
      requires offset < 0 || count < 0 || offset+count > data.length;
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires data != null;
      ensures \dl_seqLen(\dl_strContent(\result)) == data.length;
      ensures (\forall int i; 0 <= i < data.length;
                  (int) \dl_strContent(\result)[i] == data[i]);
      ensures \result != null;
      //    && boolean::select(heapAtPre, \result, java.lang.Object::<created>)==FALSE
      assignable \nothing;
   also exceptional_behavior
      requires data == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


//   public static java.lang.String valueOf(float arg0);
//   public static java.lang.String valueOf(double arg0);

   /*@
   public normal_behavior
      requires true;
      ensures \result != null;
      ensures \result==\dl_strPool(\dl_strContent(this));
      assignable \nothing;
   */


/*@
   public normal_behavior
     requires other != null && other instanceof java.lang.String;
     ensures
         (\forall int i; 0 <= i < \dl_strContent(this).length
                         && i<\dl_strContent(other).length;
           \dl_strContent(this)[i] == \dl_strContent(other)[i])
         ? \result == \dl_strContent(this).length - \dl_strContent(other).length
         : (\exists int j; (\forall int i; 0 <= i < j; \dl_strContent(this)[i] == \dl_strContent(other)[i])
                           && \result != 0 && \result == (int) \dl_strContent(other)[j] - (int)\dl_strContent(this)[j]);
      assignable \strictly_nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires true;
      ensures \dl_strContent(this)==\dl_seqEmpty();
      assignable \nothing;
    */


/*@
   public normal_behavior
      requires other != null;
      ensures \dl_strContent(this)==\dl_strContent(other);
      assignable \nothing;
   also
   public exceptional_behavior
      requires other == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires v != null;
      ensures \dl_seqLen ( \dl_strContent(this)) == v.length
          && (\forall int i; i >= 0 && i < v.length;
               (int) \dl_strContent(this)[i] == v[i]);
      assignable \nothing;
   also
   public exceptional_behavior
      requires v == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


/*@
   public normal_behavior
      requires v != null;
      requires offset >= 0 && count >= 0 && offset + count <= v.length;
      ensures \dl_seqLen(\dl_strContent(this))==count;
      ensures (\forall int i; i >= 0 && i < count;
                     v[offset+i] == (int) \dl_strContent(this)[i]);
      assignable \nothing;
   also
   public exceptional_behavior
      requires v != null;
      requires (offset < 0 || count < 0 || offset + count > v.length);
      signals (java.lang.IndexOutOfBoundsException) true;
      assignable \nothing;
   also
   public exceptional_behavior
      requires v == null;
      signals (java.lang.NullPointerException) true;
      assignable \nothing;
   */


// public String(byte[] arg0, int arg1, int arg2, java.lang.String arg3) throws java.io.UnsupportedEncodingException;
// public String(byte[] arg0, int arg1, int arg2, java.nio.charset.Charset arg3);
// public String(byte[] arg0, java.lang.String arg1) throws java.io.UnsupportedEncodingException;
// public String(byte[] arg0, java.nio.charset.Charset arg1);


//, CharSequence


//    public StringBuffer	append(char[] str);
    //    public StringBuffer	append(char[] str, int offset, int len);
    //    public StringBuffer	append(double d);
    //    public StringBuffer	append(float f);


//    public CharSequence subSequence(int start, int end);


//    public StringBuffer	append(char[] str);
    //    public StringBuffer	append(char[] str, int offset, int len);
    //    public StringBuffer	append(double d);
    //    public StringBuffer	append(float f);


//    public CharSequence subSequence(int start, int end);


//, CharSequence


// Remarks: Currently the specifications assumes src and dest to be int[].
    //          This is incomplete, and should be amended when needed
    // added by Mattias Ulbrich in Jan 19.
    /*@ public exceptional_behavior
      @   requires src == null || dest == null;
      @   signals_only NullPointerException;
      @   assignable \nothing;
      @ also
      @ public exceptional_behavior
      @   requires src instanceof int[] && dest instanceof int[];
      @   requires src != null && dest != null;
      @   requires (srcPos < 0 || destPos < 0 || length < 0
      @                  || srcPos + length > ((int[])src).length
      @                  || destPos + length > ((int[])dest).length);
      @    assignable \nothing;
      @    signals_only ArrayIndexOutOfBoundsException;
      @ also
      @ public normal_behavior
      @   requires src instanceof int[] && dest instanceof int[];
      @   requires src != null && dest != null;
      @   requires srcPos >= 0 && destPos >= 0;
      @   requires length >= 0;
      @   requires srcPos + length <= ((int[])src).length
      @         && destPos + length <= ((int[])dest).length;
      @   ensures (\forall int i; 0 <= i && i < length;
      @             ((int[])dest)[destPos + i] == \old(((int[])src)[srcPos + i]));
      @   assignable ((int[])dest)[destPos .. destPos + length - 1];
      @*/
    /*@ helper @*/


// This implementation has been used to verify the above contracts
    // {
    //     if(src == null || dest == null) {
    //         throw new NullPointerException();
    //     }
    //     int[] isrc = (int[])src;
    //     int[] idest = (int[])dest;
    //     if(length < 0) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     int[] tmp = new int[length];
    //     if(srcPos < 0 || srcPos + length > isrc.length) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     /*@ loop_invariant 0 <= i && i <= length;
    //       @ loop_invariant (\forall int j; 0<=j && j < i; tmp[j] == isrc[srcPos + j]);
    //       @ loop_invariant \fresh(tmp);
    //       @ decreases length - i;
    //       @ assignable tmp[*];
    //       @*/
    //     for(int i = 0; i < length; i++) {
    //         tmp[i] = isrc[srcPos + i];
    //     }
    //     if(destPos < 0 || destPos + length > idest.length) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     /*@ loop_invariant 0 <= k && k <= length;
    //       @ loop_invariant (\forall int j; 0<=j && j < k; idest[destPos + j] == tmp[j]);
    //       @ decreases length - k;
    //       @ assignable idest[destPos .. destPos + length - 1];
    //       @*/
    //     for(int k = 0; k < length; k++) {
    //         idest[destPos + k] = tmp[k];
    //     }
    // }

    /*@ public behavior
      @ ensures false;
      @ signals_only \nothing;
      @ diverges true;
      @*/


// Remarks: Currently the specifications assumes src and dest to be int[].
    //          This is incomplete, and should be amended when needed
    // added by Mattias Ulbrich in Jan 19.
    /*@ public exceptional_behavior
      @   requires src == null || dest == null;
      @   signals_only NullPointerException;
      @   assignable \nothing;
      @ also
      @ public exceptional_behavior
      @   requires src instanceof int[] && dest instanceof int[];
      @   requires src != null && dest != null;
      @   requires (srcPos < 0 || destPos < 0 || length < 0
      @                  || srcPos + length > ((int[])src).length
      @                  || destPos + length > ((int[])dest).length);
      @    assignable \nothing;
      @    signals_only ArrayIndexOutOfBoundsException;
      @ also
      @ public normal_behavior
      @   requires src instanceof int[] && dest instanceof int[];
      @   requires src != null && dest != null;
      @   requires srcPos >= 0 && destPos >= 0;
      @   requires length >= 0;
      @   requires srcPos + length <= ((int[])src).length
      @         && destPos + length <= ((int[])dest).length;
      @   ensures (\forall int i; 0 <= i && i < length;
      @             ((int[])dest)[destPos + i] == \old(((int[])src)[srcPos + i]));
      @   assignable ((int[])dest)[destPos .. destPos + length - 1];
      @*/
    /*@ helper @*/


// This implementation has been used to verify the above contracts
    // {
    //     if(src == null || dest == null) {
    //         throw new NullPointerException();
    //     }
    //     int[] isrc = (int[])src;
    //     int[] idest = (int[])dest;
    //     if(length < 0) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     int[] tmp = new int[length];
    //     if(srcPos < 0 || srcPos + length > isrc.length) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     /*@ loop_invariant 0 <= i && i <= length;
    //       @ loop_invariant (\forall int j; 0<=j && j < i; tmp[j] == isrc[srcPos + j]);
    //       @ loop_invariant \fresh(tmp);
    //       @ decreases length - i;
    //       @ assignable tmp[*];
    //       @*/
    //     for(int i = 0; i < length; i++) {
    //         tmp[i] = isrc[srcPos + i];
    //     }
    //     if(destPos < 0 || destPos + length > idest.length) {
    //         throw new ArrayIndexOutOfBoundsException();
    //     }
    //     /*@ loop_invariant 0 <= k && k <= length;
    //       @ loop_invariant (\forall int j; 0<=j && j < k; idest[destPos + j] == tmp[j]);
    //       @ decreases length - k;
    //       @ assignable idest[destPos .. destPos + length - 1];
    //       @*/
    //     for(int k = 0; k < length; k++) {
    //         idest[destPos + k] = tmp[k];
    //     }
    // }

    /*@ public behavior
      @ ensures false;
      @ signals_only \nothing;
      @ diverges true;
      @*/


//@ protected nullable ghost String message = null;
   //@ protected nullable ghost Throwable cause = null;

   /*@ public normal_behavior
     @    requires true;
     @    ensures message == null && cause == null;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == arg0 && cause == null;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == arg0 && cause == arg1;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == null && cause == arg0;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    ensures \result == message;
     @*/


/*@ public normal_behavior
     @    ensures \result == cause;
     @*/


//TODO: fix the contract to match Java's behavior (e.g. arg0 != this or exception)
   /*@ public normal_behavior
     @    requires cause == null;
     @    ensures \result == this && cause == arg0;
     @    assignable cause;
     @ helper // needs to be helper because called in constructor
     @*/


// public void printStackTrace(java.io.PrintStream arg0);
// public void printStackTrace(java.io.PrintWriter arg0);


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 *
 * Enriched by JML specifications by MU
 *
 */


/*@ public normal_behavior
     @    ensures \result == message;
     @*/


/*@ public normal_behavior
     @    ensures \result == cause;
     @*/


//TODO: fix the contract to match Java's behavior (e.g. arg0 != this or exception)
   /*@ public normal_behavior
     @    requires cause == null;
     @    ensures \result == this && cause == arg0;
     @    assignable cause;
     @ helper // needs to be helper because called in constructor
     @*/


// public void printStackTrace(java.io.PrintStream arg0);
// public void printStackTrace(java.io.PrintWriter arg0);


//@ protected nullable ghost String message = null;
   //@ protected nullable ghost Throwable cause = null;

   /*@ public normal_behavior
     @    requires true;
     @    ensures message == null && cause == null;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == arg0 && cause == null;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == arg0 && cause == arg1;
     @    assignable message, cause;
     @*/


/*@ public normal_behavior
     @    requires true;
     @    ensures message == null && cause == arg0;
     @    assignable message, cause;
     @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Jan 31 13:24:50 CET 2014
 */


//@ public final ghost \bigint value;

   //@ public static invariant java.math.BigInteger.ZERO.value == (\bigint) 0;


/*@ public normal_behavior
     @ requires true;
     @ ensures (\result <= 0) <==> (this.value - param0.value <= 0);
     @ ensures (\result >= 0) <==> (this.value - param0.value >= 0);
     @ assignable \strictly_nothing;
     @ determines \result \by this.value, param0.value;
     @*/


/*@ public normal_behavior
     @ requires true;
     @ ensures \result.value == this.value % param0.value;
     @ ensures \fresh(\result) && \fresh(\result.*) && \typeof(\result) == \type(BigInteger);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result.value \by this.value, param0.value;
     @*/


/*@ public normal_behavior
     @ requires true;
     @ ensures (\result <= 0) <==> (this.value - param0.value <= 0);
     @ ensures (\result >= 0) <==> (this.value - param0.value >= 0);
     @ assignable \strictly_nothing;
     @ determines \result \by this.value, param0.value;
     @*/


/*@ public normal_behavior
     @ requires true;
     @ ensures \result.value == this.value % param0.value;
     @ ensures \fresh(\result) && \fresh(\result.*) && \typeof(\result) == \type(BigInteger);
     @ assignable \nothing;
     @ determines \result \by \nothing \new_objects \result;
     @ determines \result.value \by this.value, param0.value;
     @*/


/*@ public normal_behavior
      @ ensures seq.length == 0;
      @ ensures \fresh(this) && \fresh(this.*);
      @ determines seq \by \nothing;
      @*/


/*@ public normal_behavior
      @ ensures seq == c.seq;
      @ ensures \fresh(this) && \fresh(this.*) && \typeof(this) == \type(ArrayList);
      @ determines this, seq \by c.seq \new_objects this;
      @*/


/*@ public normal_behavior
      @ ensures seq.length == 0;
      @ ensures \fresh(this) && \fresh(this.*);
      @ determines seq \by \nothing;
      @*/


/*@ public normal_behavior
      @ ensures seq == c.seq;
      @ ensures \fresh(this) && \fresh(this.*) && \typeof(this) == \type(ArrayList);
      @ determines this, seq \by c.seq \new_objects this;
      @*/


/*@ public normal_behavior
      @ ensures \invariant_for(\result);
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \invariant_for(\result);
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \fresh(\result) && \fresh(\result.*);
      @ ensures \invariant_for(\result);
      @ ensures (\forall \bigint i; 0 <= i && i < \result.seq.length; ((String)\result.seq[i]) != null);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \fresh(\result) && \fresh(\result.*);
      @ ensures \invariant_for(\result);
      @ ensures (\forall \bigint i; 0 <= i && i < \result.seq.length; ((String)\result.seq[i]) != null);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : false)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @     i < original.length ?
      @         Float._isSame(\result[i], original[i]) :
      @         \result[i] == 0.0f
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @     i < original.length ?
      @         Double._isSame(\result[i], original[i]) :
      @         \result[i] == 0.0d
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : false)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @     i < original.length ?
      @         Float._isSame(\result[i - from], original[i]) :
      @         \result[i - from] == 0.0f
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @     i < original.length ?
      @         Double._isSame(\result[i], original[i - from]) :
      @         \result[i - from] == 0.0d
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


// Double and float equals are left out since they use *bitwise* equality

    /*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length;
      @     Double._isSame(a[i], val)
      @ );
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex;
      @     Double._isSame(a[i], val)
      @ );
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length;
      @     Float._isSame(a[i], val)
      @ );
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex;
      @     Float._isSame(a[i], val)
      @ );
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures \invariant_for(\result);
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \invariant_for(\result);
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \fresh(\result) && \fresh(\result.*);
      @ ensures \invariant_for(\result);
      @ ensures (\forall \bigint i; 0 <= i && i < \result.seq.length; ((String)\result.seq[i]) != null);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \fresh(\result) && \fresh(\result.*);
      @ ensures \invariant_for(\result);
      @ ensures (\forall \bigint i; 0 <= i && i < \result.seq.length; ((String)\result.seq[i]) != null);
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : false)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @ 	\result[i] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @     i < original.length ?
      @         Float._isSame(\result[i], original[i]) :
      @         \result[i] == 0.0f
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= newLength;
      @ ensures \fresh(\result) && \result.length == newLength;
      @ ensures (\forall \bigint i; 0 <= i && i < newLength;
      @     i < original.length ?
      @         Double._isSame(\result[i], original[i]) :
      @         \result[i] == 0.0d
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : false)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @ 	\result[i - from] == (i < original.length ? original[i] : 0)
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @     i < original.length ?
      @         Float._isSame(\result[i - from], original[i]) :
      @         \result[i - from] == 0.0f
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ requires 0 <= from <= to && from <= original.length;
      @ ensures \fresh(\result) && \result.length == to - from;
      @ ensures (\forall \bigint i; from <= i && i < to;
      @     i < original.length ?
      @         Double._isSame(\result[i], original[i - from]) :
      @         \result[i - from] == 0.0d
      @ );
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


/*@ public normal_behavior
      @ ensures \result <==> (
      @     a == a2 ||
      @     (a != null && a2 != null && a.length == a2.length &&
      @         (\forall \bigint j; 0 <= j && j < a.length; a[j] == a2[j]))
      @ );
      @ assignable \strictly_nothing;
      @*/


// Double and float equals are left out since they use *bitwise* equality

    /*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length; a[i] == val);
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex; a[i] == val);
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length;
      @     Double._isSame(a[i], val)
      @ );
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex;
      @     Double._isSame(a[i], val)
      @ );
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ ensures (\forall \bigint i; 0 <= i && i < a.length;
      @     Float._isSame(a[i], val)
      @ );
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ ensures (\forall \bigint i; fromIndex <= i && i < toIndex;
      @     Float._isSame(a[i], val)
      @ );
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


/*@ public normal_behavior
      @ // Sorted ascending
      @ ensures (\forall \bigint i; 0 <= i < a.length - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; 0 <= i < a.length;
      @     (\forall \bigint j; i <= j < a.length; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; 0 <= i < a.length; a[i] == e) ==
      @         (\num_of \bigint i; 0 <= i < a.length; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(0, a.length, a), \old(\dl_seq_def_workaround(0, a.length, a)));
      @ assignable a[*];
      @*/


/*@ public normal_behavior
      @ requires 0 <= fromIndex <= toIndex <= a.length;
      @ // Sorted ascending
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex - 1;
      @     a[i] <= a[i + 1]
      @ );
      @ // Sorted ascending (transitive)
      @ ensures (\forall \bigint i; fromIndex <= i < toIndex;
      @     (\forall \bigint j; i <= j < toIndex; a[i] <= a[j])
      @ );
      @ // Permutation property (num_of)
      @ ensures (\forall int e; true;
      @     (\num_of \bigint i; fromIndex <= i < toIndex; a[i] == e) ==
      @         (\num_of \bigint i; fromIndex <= i < toIndex; \old(a[i]) == e)
      @ );
      @ // Permutation property (seqPerm)
      @ ensures \dl_seqPerm(\dl_seq_def_workaround(fromIndex, toIndex, a), \old(\dl_seq_def_workaround(fromIndex, toIndex, a)));
      @ assignable a[fromIndex..toIndex - 1];
      @*/


//@ public instance ghost \seq seq;

   /*@ public normal_behavior
     @ ensures \result == seq.length;
     @ assignable \nothing;
     @ determines \result \by seq.length;
     @ */


/*@ public normal_behavior
     @ ensures \result == (size() == 0);
     @ assignable \nothing;
     @ determines \result \by seq.length;
     @*/


/*@ public normal_behavior
     @ ensures seq == \seq_concat(\old(seq), \seq_singleton(arg0));
     @ assignable seq;
     @ determines seq \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ ensures seq == \seq_concat(\old(seq), arg0.seq);
     @ assignable seq;
     @ determines seq \by seq, arg0.seq;
     @*/


/*@ public normal_behavior
     @ ensures \result == (\exists \bigint i; 0 <= i && i < seq.length; ((String)seq[i]) == arg0);
     @ assignable \nothing;
     @ determines \result \by seq, arg0;
     @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//@ public instance ghost \seq seq;

   /*@ public normal_behavior
     @ ensures \result == seq.length;
     @ assignable \nothing;
     @ determines \result \by seq.length;
     @ */


/*@ public normal_behavior
     @ ensures \result == (size() == 0);
     @ assignable \nothing;
     @ determines \result \by seq.length;
     @*/


/*@ public normal_behavior
     @ ensures seq == \seq_concat(\old(seq), \seq_singleton(arg0));
     @ assignable seq;
     @ determines seq \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ ensures seq == \seq_concat(\old(seq), arg0.seq);
     @ assignable seq;
     @ determines seq \by seq, arg0.seq;
     @*/


/*@ public normal_behavior
     @ ensures \result == (\exists \bigint i; 0 <= i && i < seq.length; ((String)seq[i]) == arg0);
     @ assignable \nothing;
     @ determines \result \by seq, arg0;
     @*/


/*@ public behavior
     @ requires true;
     @ ensures true;
     @ assignable \everything;
     @*/


/*@ public behavior
     @ requires true;
     @ ensures true;
     @ assignable \everything;
     @*/


/*@ public normal_behavior
      @ ensures key_seq.length == 0;
      @ ensures value_seq.length == 0;
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
      @ ensures key_seq.length == 0;
      @ ensures value_seq.length == 0;
      @ assignable \nothing;
      @*/


/*@ public normal_behavior
	  @ ensures seq == param0.seq;
      @*/


/*@ public normal_behavior
      @ requires true;
      @*/


/*@ public normal_behavior
      @ requires true;
      @*/


/*@ public normal_behavior
	  @ ensures seq == param0.seq;
      @*/


/*@ public normal_behavior
     @ requires arg0 == 0;
     @ ensures seq == \seq_concat(\seq_singleton(arg0), \old(seq));
     @ assignable seq;
     @ determines seq \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ requires 0 <= arg0 && arg0 < seq.length;
     @ ensures ((Object)seq[arg0]) == \result;
     @ assignable \nothing;
     @ determines \result \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ ensures \result.index == 0;
     @ ensures \result.seq == seq;
     @ ensures \fresh(\result) && \fresh(\result.*);
     @ ensures \result instanceof ListIteratorImpl;
     @ assignable \nothing;
     @ determines \result.seq \by seq;
     @ determines \result.index \by \nothing;
     @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


/*@ public normal_behavior
     @ requires arg0 == 0;
     @ ensures seq == \seq_concat(\seq_singleton(arg0), \old(seq));
     @ assignable seq;
     @ determines seq \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ requires 0 <= arg0 && arg0 < seq.length;
     @ ensures ((Object)seq[arg0]) == \result;
     @ assignable \nothing;
     @ determines \result \by seq, arg0;
     @*/


/*@ public normal_behavior
     @ ensures \result.index == 0;
     @ ensures \result.seq == seq;
     @ ensures \fresh(\result) && \fresh(\result.*);
     @ ensures \result instanceof ListIteratorImpl;
     @ assignable \nothing;
     @ determines \result.seq \by seq;
     @ determines \result.index \by \nothing;
     @*/


//@ public instance ghost \seq seq;
    //@ public instance ghost \bigint index;

    //@ public instance invariant 0 <= index && index <= seq.length;

    /*@ public normal_behavior
      @ ensures \result == true <==> index < seq.length;
      @ assignable \strictly_nothing;
      @ determines \result \by seq.length, index;
      @*/


/*@ public behavior
      @ requires index < seq.length;
      @ ensures \result == ((Object)seq[\old(index)]);
      @ ensures index == \old(index) + 1;
      @ assignable index;
      @ signals_only java.lang.RuntimeException;
      @ determines \result \by seq, index;
      @ determines index \by \itself;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//@ public instance ghost \seq seq;
    //@ public instance ghost \bigint index;

    //@ public instance invariant 0 <= index && index <= seq.length;

    /*@ public normal_behavior
      @ ensures \result == true <==> index < seq.length;
      @ assignable \strictly_nothing;
      @ determines \result \by seq.length, index;
      @*/


/*@ public behavior
      @ requires index < seq.length;
      @ ensures \result == ((Object)seq[\old(index)]);
      @ ensures index == \old(index) + 1;
      @ assignable index;
      @ signals_only java.lang.RuntimeException;
      @ determines \result \by seq, index;
      @ determines index \by \itself;
      @*/


//@ public instance ghost \seq key_seq;
    //@ public instance ghost \seq value_seq;

    //@ public instance invariant key_seq.length == value_seq.length;
    //@ public instance invariant (\forall \bigint i; 0 <= i && i < key_seq.length; ((Object)key_seq[i]) != null);
    //@ public instance invariant (\forall \bigint i; 0 <= i && i < value_seq.length; ((Object)value_seq[i]) != null);

    /*@ public normal_behavior
      @ ensures \result.seq == key_seq;
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */


//@ public instance ghost \seq key_seq;
    //@ public instance ghost \seq value_seq;

    //@ public instance invariant key_seq.length == value_seq.length;
    //@ public instance invariant (\forall \bigint i; 0 <= i && i < key_seq.length; ((Object)key_seq[i]) != null);
    //@ public instance invariant (\forall \bigint i; 0 <= i && i < value_seq.length; ((Object)value_seq[i]) != null);

    /*@ public normal_behavior
      @ ensures \result.seq == key_seq;
      @ ensures \fresh(\result);
      @ assignable \nothing;
      @*/


/* This file has been generated by Stubmaker (de.uka.ilkd.stubmaker)
 * Date: Fri Mar 28 13:47:08 CET 2008
 */
