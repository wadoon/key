diff --git a/KeY4Eclipse/src/tests/org.key_project.util.test/META-INF/MANIFEST.MF b/KeY4Eclipse/src/tests/org.key_project.util.test/META-INF/MANIFEST.MF
index fa0b6c5e7f..e9a9e8cf77 100644
--- a/KeY4Eclipse/src/tests/org.key_project.util.test/META-INF/MANIFEST.MF
+++ b/KeY4Eclipse/src/tests/org.key_project.util.test/META-INF/MANIFEST.MF
@@ -15,14 +15,14 @@ Require-Bundle: org.eclipse.core.runtime,
  org.eclipse.swtbot.go;bundle-version="2.0.4",
  org.key_project.swtbot.swing;bundle-version="1.0.0",
  org.key_project.util;bundle-version="1.0.0",
- org.eclipse.graphiti;bundle-version="[0.11.0,0.14.0)",
- org.eclipse.graphiti.ui;bundle-version="[0.11.0,0.14.0)",
+ org.eclipse.graphiti;bundle-version="[0.11.0,0.15.0]",
+ org.eclipse.graphiti.ui;bundle-version="[0.11.0,0.15.0]",
  org.eclipse.emf.transaction;bundle-version="1.4.0",
  org.eclipse.ui.views.properties.tabbed;bundle-version="3.5.200",
  org.eclipse.gef;bundle-version="3.7.1",
  org.eclipse.e4.ui.workbench.renderers.swt
 Bundle-ActivationPolicy: lazy
-Bundle-RequiredExecutionEnvironment: JavaSE-1.7
+Bundle-RequiredExecutionEnvironment: JavaSE-1.8
 Bundle-Vendor: KeY Project
 Export-Package: org.key_project.util.helper,
  org.key_project.util.model,
diff --git a/KeYIDE/src/tests/org.key_project.keyide.ui.test/META-INF/MANIFEST.MF b/KeYIDE/src/tests/org.key_project.keyide.ui.test/META-INF/MANIFEST.MF
index 1f3f895f0d..a341a9bd5d 100644
--- a/KeYIDE/src/tests/org.key_project.keyide.ui.test/META-INF/MANIFEST.MF
+++ b/KeYIDE/src/tests/org.key_project.keyide.ui.test/META-INF/MANIFEST.MF
@@ -9,7 +9,6 @@ Require-Bundle: org.eclipse.core.runtime,
  org.eclipse.ui,
  org.eclipse.ui.editors;bundle-version="3.7.0",
  org.eclipse.jdt.core;bundle-version="3.7.3",
- org.eclipse.emf.ecoretools.tabbedproperties,
  org.junit;bundle-version="4.8.1",
  org.eclipse.swtbot.go;bundle-version="2.0.4",
  org.key_project.util;bundle-version="1.0.0",
@@ -24,7 +23,8 @@ Require-Bundle: org.eclipse.core.runtime,
  org.key_project.key4eclipse.common.ui;bundle-version="1.0.0",
  org.key_project.keyide.ui;bundle-version="1.0.0",
  org.eclipse.swtbot.eclipse.finder,
- org.key_project.swtbot.swing;bundle-version="1.0.0"
+ org.key_project.swtbot.swing;bundle-version="1.0.0",
+ org.eclipse.ui.views.properties.tabbed;bundle-version="3.8.0"
 Bundle-ActivationPolicy: lazy
 Bundle-RequiredExecutionEnvironment: JavaSE-1.7
 Export-Package: org.key_project.keyide.ui.test.suite,
diff --git a/SymbolicExecutionDebugger/src/plugins/org.key_project.sed.key.ui/META-INF/MANIFEST.MF b/SymbolicExecutionDebugger/src/plugins/org.key_project.sed.key.ui/META-INF/MANIFEST.MF
index 16a72a5c00..be7f043a96 100644
--- a/SymbolicExecutionDebugger/src/plugins/org.key_project.sed.key.ui/META-INF/MANIFEST.MF
+++ b/SymbolicExecutionDebugger/src/plugins/org.key_project.sed.key.ui/META-INF/MANIFEST.MF
@@ -25,8 +25,8 @@ Require-Bundle: org.eclipse.core.runtime,
  org.key_project.sed.ui;bundle-version="1.0.0",
  org.eclipse.emf.transaction;bundle-version="1.4.0";resolution:=optional,
  org.eclipse.gef;bundle-version="3.7.2";resolution:=optional,
- org.eclipse.graphiti;bundle-version="[0.11.0,0.14.0)";resolution:=optional,
- org.eclipse.graphiti.ui;bundle-version="[0.11.0,0.14.0)";resolution:=optional,
+ org.eclipse.graphiti;bundle-version="[0.11.0,0.15.0]";resolution:=optional,
+ org.eclipse.graphiti.ui;bundle-version="[0.11.0,0.15.0]";resolution:=optional,
  org.key_project.sed.ui.visualization;bundle-version="1.0.0";resolution:=optional,
  org.key_project.sed.ui.visualization.model;bundle-version="1.0.0";resolution:=optional,
  org.key_project.key4eclipse.resources;bundle-version="1.0.0";resolution:=optional,
@@ -36,10 +36,15 @@ Require-Bundle: org.eclipse.core.runtime,
  org.key_project.core.testgen;bundle-version="1.0.0",
  org.key_project.keyide.ui;bundle-version="1.0.0"
 Bundle-ActivationPolicy: lazy
-Bundle-RequiredExecutionEnvironment: JavaSE-1.7
+Bundle-RequiredExecutionEnvironment: JavaSE-1.8
 Bundle-Vendor: KeY Project
 Export-Package: org.key_project.sed.key.ui.jdt,
  org.key_project.sed.key.ui.launch,
  org.key_project.sed.key.ui.presentation,
  org.key_project.sed.key.ui.util,
  org.key_project.sed.key.ui.view
+Import-Package: org.eclipse.graphiti.dt;version="0.14.0",
+ org.eclipse.graphiti.features;version="0.14.0",
+ org.eclipse.graphiti.features.context;version="0.14.0",
+ org.eclipse.graphiti.features.context.impl;version="0.14.0",
+ org.eclipse.graphiti.features.custom
diff --git a/SymbolicExecutionDebugger/src/plugins/org.key_project.sed.ui.visualization/META-INF/MANIFEST.MF b/SymbolicExecutionDebugger/src/plugins/org.key_project.sed.ui.visualization/META-INF/MANIFEST.MF
index da8e5ee9b0..d37f52cf4d 100644
--- a/SymbolicExecutionDebugger/src/plugins/org.key_project.sed.ui.visualization/META-INF/MANIFEST.MF
+++ b/SymbolicExecutionDebugger/src/plugins/org.key_project.sed.ui.visualization/META-INF/MANIFEST.MF
@@ -19,10 +19,10 @@ Require-Bundle: org.eclipse.core.runtime,
  org.key_project.sed.core;bundle-version="1.0.0",
  org.key_project.sed.ui;bundle-version="1.0.0",
  org.key_project.sed.ui.visualization.model;bundle-version="1.0.0",
- org.eclipse.graphiti;bundle-version="[0.11.0,0.14.0)",
- org.eclipse.graphiti.ui;bundle-version="[0.11.0,0.14.0)"
+ org.eclipse.graphiti;bundle-version="[0.11.0,0.15.0]",
+ org.eclipse.graphiti.ui;bundle-version="[0.11.0,0.15.0]"
 Bundle-ActivationPolicy: lazy
-Bundle-RequiredExecutionEnvironment: JavaSE-1.7
+Bundle-RequiredExecutionEnvironment: JavaSE-1.8
 Bundle-Vendor: KeY Project
 Export-Package: org.key_project.sed.ui.visualization,
  org.key_project.sed.ui.visualization.action,
diff --git a/SymbolicExecutionDebugger/src/tests/org.key_project.sed.ui.visualization.test/META-INF/MANIFEST.MF b/SymbolicExecutionDebugger/src/tests/org.key_project.sed.ui.visualization.test/META-INF/MANIFEST.MF
index d22f1c617d..777c3dee69 100644
--- a/SymbolicExecutionDebugger/src/tests/org.key_project.sed.ui.visualization.test/META-INF/MANIFEST.MF
+++ b/SymbolicExecutionDebugger/src/tests/org.key_project.sed.ui.visualization.test/META-INF/MANIFEST.MF
@@ -13,8 +13,8 @@ Require-Bundle: org.eclipse.core.runtime,
  org.eclipse.debug.ui;bundle-version="3.7.0",
  org.eclipse.emf.transaction;bundle-version="1.4.0",
  org.eclipse.emf.workspace;bundle-version="1.5.1",
- org.eclipse.graphiti;bundle-version="[0.11.0,0.14.0)",
- org.eclipse.graphiti.ui;bundle-version="[0.11.0,0.14.0)",
+ org.eclipse.graphiti;bundle-version="[0.11.0,0.15.0]",
+ org.eclipse.graphiti.ui;bundle-version="[0.11.0,0.15.0]",
  org.junit;bundle-version="4.8.1",
  org.eclipse.swtbot.go;bundle-version="2.0.4",
  org.eclipse.swtbot.eclipse.gef.finder;bundle-version="2.0.4",
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/FormulaTermLabelRefactoring.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/FormulaTermLabelRefactoring.java
index 2b0ea1706f..7ae6be3424 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/FormulaTermLabelRefactoring.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/FormulaTermLabelRefactoring.java
@@ -25,6 +25,7 @@ import de.uka.ilkd.key.proof.Proof;
 import de.uka.ilkd.key.proof.init.AbstractOperationPO;
 import de.uka.ilkd.key.proof.init.ProofOblInput;
 import de.uka.ilkd.key.rule.BlockContractRule;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
 import de.uka.ilkd.key.rule.Rule;
 import de.uka.ilkd.key.rule.SyntacticalReplaceVisitor;
 import de.uka.ilkd.key.rule.UseOperationContractRule;
@@ -160,6 +161,16 @@ public class FormulaTermLabelRefactoring implements TermLabelRefactoring {
          Proof proof = goal.proof();
          if ((rule instanceof WhileInvariantRule && WhileInvariantRule.INITIAL_INVARIANT_ONLY_HINT.equals(hint)) ||
              (rule instanceof WhileInvariantRule && WhileInvariantRule.FULL_INVARIANT_TERM_HINT.equals(hint)) ||
+             // The following is a bit ugly, but we cannot directly access these rules without cyclic dependences
+             // between the packages. We could add ad custom FormulaTermLabelRefactoring in the strength analysis
+             // package, or switch to a ServiceLoader infrastructure -- for now, this hack suffices.
+             // DS, June 9th, 2017
+             (((rule.displayName().equals("AnalyzeInvImpliesLoopEffects") ||
+                     (rule.displayName().equals("AnalyzePostCondImpliesMethodEffects")))) &&
+                     (hint.equals("factToAnalyze") || hint.equals("factPremiseHint"))) ||
+             (rule instanceof LoopScopeInvariantRule && LoopScopeInvariantRule.INITIAL_INVARIANT_ONLY_HINT.equals(hint)) ||
+             (rule instanceof LoopScopeInvariantRule && LoopScopeInvariantRule.FULL_INVARIANT_TERM_HINT.equals(hint)) ||
+             (rule instanceof LoopScopeInvariantRule && LoopScopeInvariantRule.ANON_INVARIANT_TERM_HINT.equals(hint)) ||
              (rule instanceof UseOperationContractRule && UseOperationContractRule.FINAL_PRE_TERM_HINT.equals(hint)) ||
              (rule instanceof BlockContractRule && BlockContractRule.FULL_PRECONDITION_TERM_HINT.equals(hint)) ||
              (rule instanceof BlockContractRule && BlockContractRule.NEW_POSTCONDITION_TERM_HINT.equals(hint)) ||
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/LoopBodyTermLabelUpdate.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/LoopBodyTermLabelUpdate.java
index 3c871e360e..aa4611959e 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/LoopBodyTermLabelUpdate.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/LoopBodyTermLabelUpdate.java
@@ -29,6 +29,7 @@ import de.uka.ilkd.key.logic.label.TermLabelState;
 import de.uka.ilkd.key.logic.op.Operator;
 import de.uka.ilkd.key.logic.op.QuantifiableVariable;
 import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
 import de.uka.ilkd.key.rule.Rule;
 import de.uka.ilkd.key.rule.RuleApp;
 import de.uka.ilkd.key.rule.WhileInvariantRule;
@@ -45,7 +46,7 @@ public class LoopBodyTermLabelUpdate implements TermLabelUpdate {
     */
    @Override
    public ImmutableList<Name> getSupportedRuleNames() {
-      return ImmutableSLList.<Name>nil().append(WhileInvariantRule.INSTANCE.name());
+      return ImmutableSLList.<Name>nil().prepend(WhileInvariantRule.INSTANCE.name()).prepend(LoopScopeInvariantRule.INSTANCE.name());
    }
 
    /**
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/LoopInvariantNormalBehaviorTermLabelUpdate.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/LoopInvariantNormalBehaviorTermLabelUpdate.java
index fe570c11de..256f198877 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/LoopInvariantNormalBehaviorTermLabelUpdate.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/LoopInvariantNormalBehaviorTermLabelUpdate.java
@@ -29,6 +29,7 @@ import de.uka.ilkd.key.logic.label.TermLabelState;
 import de.uka.ilkd.key.logic.op.Operator;
 import de.uka.ilkd.key.logic.op.QuantifiableVariable;
 import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
 import de.uka.ilkd.key.rule.Rule;
 import de.uka.ilkd.key.rule.RuleApp;
 import de.uka.ilkd.key.rule.WhileInvariantRule;
@@ -45,7 +46,7 @@ public class LoopInvariantNormalBehaviorTermLabelUpdate implements TermLabelUpda
     */
    @Override
    public ImmutableList<Name> getSupportedRuleNames() {
-      return ImmutableSLList.<Name>nil().append(WhileInvariantRule.INSTANCE.name());
+      return ImmutableSLList.<Name>nil().prepend(WhileInvariantRule.INSTANCE.name()).prepend(LoopScopeInvariantRule.INSTANCE.name());
    }
 
    /**
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/RemoveInCheckBranchesTermLabelRefactoring.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/RemoveInCheckBranchesTermLabelRefactoring.java
index f8f4a1a8f9..fdf131a51d 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/RemoveInCheckBranchesTermLabelRefactoring.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/RemoveInCheckBranchesTermLabelRefactoring.java
@@ -27,6 +27,7 @@ import de.uka.ilkd.key.logic.label.TermLabel;
 import de.uka.ilkd.key.logic.label.TermLabelState;
 import de.uka.ilkd.key.proof.Goal;
 import de.uka.ilkd.key.rule.BlockContractRule;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
 import de.uka.ilkd.key.rule.Rule;
 import de.uka.ilkd.key.rule.UseOperationContractRule;
 import de.uka.ilkd.key.rule.WhileInvariantRule;
@@ -64,6 +65,7 @@ public class RemoveInCheckBranchesTermLabelRefactoring implements TermLabelRefac
    public ImmutableList<Name> getSupportedRuleNames() {
       return ImmutableSLList.<Name>nil().prepend(UseOperationContractRule.INSTANCE.name())
                                         .prepend(WhileInvariantRule.INSTANCE.name())
+                                        .prepend(LoopScopeInvariantRule.INSTANCE.name())
                                         .prepend(BlockContractRule.INSTANCE.name());
    }
 
@@ -85,7 +87,7 @@ public class RemoveInCheckBranchesTermLabelRefactoring implements TermLabelRefac
                 goal.node().getNodeInfo().getBranchLabel().startsWith("Null reference"))) {
             return RefactoringScope.SEQUENT;
          }
-         else if (rule instanceof WhileInvariantRule &&
+         else if ((rule instanceof WhileInvariantRule || rule instanceof LoopScopeInvariantRule) &&
                   goal.node().getNodeInfo().getBranchLabel().startsWith("Invariant Initially Valid")) {
             return RefactoringScope.SEQUENT;
          }
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/StayOnFormulaTermLabelPolicy.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/StayOnFormulaTermLabelPolicy.java
index f527c0373f..7fc2986974 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/StayOnFormulaTermLabelPolicy.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/StayOnFormulaTermLabelPolicy.java
@@ -20,6 +20,7 @@ import de.uka.ilkd.key.logic.op.Operator;
 import de.uka.ilkd.key.logic.op.QuantifiableVariable;
 import de.uka.ilkd.key.logic.op.SubstOp;
 import de.uka.ilkd.key.logic.op.UpdateApplication;
+import de.uka.ilkd.key.pp.LogicPrinter;
 import de.uka.ilkd.key.proof.Goal;
 import de.uka.ilkd.key.rule.Rule;
 import de.uka.ilkd.key.rule.Taclet.TacletLabelHint;
@@ -55,7 +56,7 @@ public class StayOnFormulaTermLabelPolicy implements TermLabelPolicy {
          assert label instanceof FormulaTermLabel;
          FormulaTermLabel formulaLabel = (FormulaTermLabel) label;
          FormulaTermLabel originalLabel = searchFormulaTermLabel(newTermOriginalLabels);
-         FormulaTermLabel mostImportantLabel = originalLabel != null ? originalLabel : formulaLabel;
+         FormulaTermLabel mostImportantLabel = originalLabel != null ? originalLabel : formulaLabel;// System.out.println(String.format("Goal %s, Term %s, Label %s\n", goal.node().serialNr(), LogicPrinter.quickPrintTerm(applicationTerm, services).replaceAll("\\n", "").trim(), mostImportantLabel));
          // May change sub ID if logical operators like junctors are used
          boolean newLabelIdRequired = false;
          Set<String> originalLabelIds = new LinkedHashSet<String>();
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/SymbolicExecutionTermLabelUpdate.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/SymbolicExecutionTermLabelUpdate.java
index 8ee4e5bbc0..8a25f02776 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/SymbolicExecutionTermLabelUpdate.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/rule/label/SymbolicExecutionTermLabelUpdate.java
@@ -30,10 +30,10 @@ import de.uka.ilkd.key.logic.label.SymbolicExecutionTermLabel;
 import de.uka.ilkd.key.logic.label.TermLabel;
 import de.uka.ilkd.key.logic.label.TermLabelState;
 import de.uka.ilkd.key.logic.op.Operator;
-import de.uka.ilkd.key.logic.op.ProgramVariable;
 import de.uka.ilkd.key.logic.op.QuantifiableVariable;
 import de.uka.ilkd.key.proof.Goal;
 import de.uka.ilkd.key.rule.BlockContractRule;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
 import de.uka.ilkd.key.rule.Rule;
 import de.uka.ilkd.key.rule.RuleApp;
 import de.uka.ilkd.key.rule.WhileInvariantRule;
@@ -51,6 +51,7 @@ public class SymbolicExecutionTermLabelUpdate implements TermLabelUpdate {
    public ImmutableList<Name> getSupportedRuleNames() {
       return ImmutableSLList.<Name>nil()
                             .prepend(WhileInvariantRule.INSTANCE.name())
+                            .prepend(LoopScopeInvariantRule.INSTANCE.name())
                             .prepend(BlockContractRule.INSTANCE.name());
    }
 
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/AbstractUpdateExtractor.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/AbstractUpdateExtractor.java
index 15d19ec103..292a89c110 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/AbstractUpdateExtractor.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/AbstractUpdateExtractor.java
@@ -1461,7 +1461,7 @@ public abstract class AbstractUpdateExtractor {
                                          boolean simplifyConditions) throws ProofInputException {
       Term result = branchConditionCache.get(node);
       if (result == null) {
-         result = SymbolicExecutionUtil.computeBranchCondition(node, simplifyConditions, true);
+         result = SymbolicExecutionUtil.computeBranchCondition(node, simplifyConditions, true, true);
          branchConditionCache.put(node, result);
       }
       return result;
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/ExecutionVariableExtractor.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/ExecutionVariableExtractor.java
index feba754fa5..1c6bcf97c3 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/ExecutionVariableExtractor.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/ExecutionVariableExtractor.java
@@ -90,7 +90,7 @@ public class ExecutionVariableExtractor extends AbstractUpdateExtractor {
       // Get path condition
       Term pathCondition = SymbolicExecutionUtil.computePathCondition(executionNode.getProofNode(), 
                                                                       true, // Path condition needs always to be simplified, because otherwise additinal symbolic values might be introduced. 
-                                                                      false);
+                                                                      false, true);
       pathCondition = removeImplicitSubTermsFromPathCondition(pathCondition);
       // Extract locations from updates
       Set<ExtractLocationParameter> temporaryCurrentLocations = new LinkedHashSet<ExtractLocationParameter>();
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/SymbolicLayoutExtractor.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/SymbolicLayoutExtractor.java
index f9fcba129a..abd400a540 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/SymbolicLayoutExtractor.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/SymbolicLayoutExtractor.java
@@ -251,7 +251,7 @@ public class SymbolicLayoutExtractor extends AbstractUpdateExtractor {
             // Get path condition
             Term pathCondition = SymbolicExecutionUtil.computePathCondition(node, 
                                                                             true, // Path condition needs always to be simplified, because otherwise additinal symbolic values might be introduced.
-                                                                            false);
+                                                                            false, true);
             pathCondition = removeImplicitSubTermsFromPathCondition(pathCondition);
             // Compute all locations used in path conditions and updates. The values of the locations will be later computed in the state computation (and finally shown in a memory layout).
             Set<ExtractLocationParameter> temporaryCurrentLocations = new LinkedHashSet<ExtractLocationParameter>();
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/TruthValueTracingUtil.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/TruthValueTracingUtil.java
index 7d9bcd594a..23dc0a5ea6 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/TruthValueTracingUtil.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/TruthValueTracingUtil.java
@@ -287,7 +287,7 @@ public final class TruthValueTracingUtil {
       // If goal reached, update final result
       int childCount = child.childrenCount();
       if (childCount == 0) {
-         Term condition = SymbolicExecutionUtil.computePathCondition(evaluationNode, child, false, true);
+         Term condition = SymbolicExecutionUtil.computePathCondition(evaluationNode, child, false, true, true);
          String conditionString = SymbolicExecutionUtil.formatTerm(condition, services, useUnicode, usePrettyPrinting);
          result.addBranchResult(new BranchResult(child, nodeResult, condition, conditionString, termLabelName));
       }
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionBranchCondition.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionBranchCondition.java
index cfd6b767b9..285020b267 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionBranchCondition.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionBranchCondition.java
@@ -153,7 +153,7 @@ public class ExecutionBranchCondition extends AbstractExecutionNode<SourceElemen
             }
          }
          else {
-            branchCondition = SymbolicExecutionUtil.computeBranchCondition(getProofNode(), getSettings().isSimplifyConditions(), true);
+            branchCondition = SymbolicExecutionUtil.computeBranchCondition(getProofNode(), getSettings().isSimplifyConditions(), true, true);
          }
          // Format branch condition
          formatedBranchCondition = formatTerm(branchCondition, services);
@@ -264,7 +264,7 @@ public class ExecutionBranchCondition extends AbstractExecutionNode<SourceElemen
          Term[] result = new Term[mergedProofNodes.size()];
          Iterator<Node> iter = mergedProofNodes.iterator();
          for (int i = 0; i < result.length; i++) {
-            result[i] = SymbolicExecutionUtil.computeBranchCondition(iter.next(), getSettings().isSimplifyConditions(), true);
+            result[i] = SymbolicExecutionUtil.computeBranchCondition(iter.next(), getSettings().isSimplifyConditions(), true, true);
          }
          return result;
       }
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionMethodReturn.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionMethodReturn.java
index f0ac75fcda..24a5a16f5e 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionMethodReturn.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionMethodReturn.java
@@ -303,7 +303,7 @@ public class ExecutionMethodReturn extends AbstractExecutionMethodReturn<SourceE
                         for (Entry<Term, List<Node>> entry : valueNodeMap.entrySet()) {
                            List<Term> conditions = new LinkedList<Term>();
                            for (Node node : entry.getValue()) {
-                              Term condition = SymbolicExecutionUtil.computePathCondition(node, getSettings().isSimplifyConditions(), false);
+                              Term condition = SymbolicExecutionUtil.computePathCondition(node, getSettings().isSimplifyConditions(), false, true);
                               conditions.add(condition);
                            }
                            Term condition = services.getTermBuilder().or(conditions);
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionVariable.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionVariable.java
index 37d82b617b..b5ea933eee 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionVariable.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/model/impl/ExecutionVariable.java
@@ -342,7 +342,7 @@ public class ExecutionVariable extends AbstractExecutionVariable {
          List<Term> pathConditions = new LinkedList<Term>();
          Proof proof = null;
          for (Goal valueGoal : valueGoals) {
-            pathConditions.add(SymbolicExecutionUtil.computePathCondition(valueGoal.node(), getSettings().isSimplifyConditions(), false));
+            pathConditions.add(SymbolicExecutionUtil.computePathCondition(valueGoal.node(), getSettings().isSimplifyConditions(), false, true));
             proof = valueGoal.node().proof();
          }
          Term comboundPathCondition = tb.or(pathConditions);
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/po/ProgramMethodSubsetPO.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/po/ProgramMethodSubsetPO.java
index 02621ebe87..22b8f76454 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/po/ProgramMethodSubsetPO.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/po/ProgramMethodSubsetPO.java
@@ -258,11 +258,11 @@ public class ProgramMethodSubsetPO extends ProgramMethodPO {
    @Override
    protected Term ensureUninterpretedPredicateExists(ImmutableList<ProgramVariable> paramVars,
                                               ImmutableList<LocationVariable> formalParamVars,
+                                              ProgramVariable resultVar,
                                               ProgramVariable exceptionVar,
-                                              String name,
-                                              Services proofServices) {
+                                              String name, Services proofServices) {
       ImmutableList<ProgramVariable> paramVarsList = convert(undeclaredVariableCollector.result());
-      return super.ensureUninterpretedPredicateExists(paramVarsList, formalParamVars, exceptionVar, name, proofServices);
+      return super.ensureUninterpretedPredicateExists(paramVarsList, formalParamVars, resultVar, exceptionVar, name, proofServices);
    }
 
    /**
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/strategy/SymbolicExecutionStrategy.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/strategy/SymbolicExecutionStrategy.java
index 8ad0895760..a8065f827a 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/strategy/SymbolicExecutionStrategy.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/strategy/SymbolicExecutionStrategy.java
@@ -67,7 +67,7 @@ public class SymbolicExecutionStrategy extends JavaCardDLStrategy {
     * @param proof The proof.
     * @param sp The {@link StrategyProperties} to use.
     */
-   private SymbolicExecutionStrategy(Proof proof, StrategyProperties sp) {
+   protected SymbolicExecutionStrategy(Proof proof, StrategyProperties sp) {
       super(proof, sp);
       // Update cost dispatcher
       RuleSetDispatchFeature costRsd = getCostComputationDispatcher();
diff --git a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/util/SymbolicExecutionUtil.java b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/util/SymbolicExecutionUtil.java
index bbd0d926ec..82d8c77adb 100644
--- a/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/util/SymbolicExecutionUtil.java
+++ b/key/key.core.symbolic_execution/src/de/uka/ilkd/key/symbolic_execution/util/SymbolicExecutionUtil.java
@@ -121,12 +121,14 @@ import de.uka.ilkd.key.rule.AbstractContractRuleApp;
 import de.uka.ilkd.key.rule.BlockContractBuiltInRuleApp;
 import de.uka.ilkd.key.rule.ContractRuleApp;
 import de.uka.ilkd.key.rule.LoopInvariantBuiltInRuleApp;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
 import de.uka.ilkd.key.rule.OneStepSimplifierRuleApp;
 import de.uka.ilkd.key.rule.PosTacletApp;
 import de.uka.ilkd.key.rule.Rule;
 import de.uka.ilkd.key.rule.RuleApp;
 import de.uka.ilkd.key.rule.SyntacticalReplaceVisitor;
 import de.uka.ilkd.key.rule.TacletApp;
+import de.uka.ilkd.key.rule.WhileInvariantRule;
 import de.uka.ilkd.key.rule.merge.CloseAfterMerge;
 import de.uka.ilkd.key.rule.merge.CloseAfterMergeRuleBuiltInRuleApp;
 import de.uka.ilkd.key.rule.merge.MergeRuleBuiltInRuleApp;
@@ -1765,17 +1767,29 @@ public final class SymbolicExecutionUtil {
       }
    }
    
-   /**
-    * Computes the branch condition of the given {@link Node}.
-    * @param node The {@link Node} to compute its branch condition.
-    * @param simplify {@code true} simplify condition in a side proof, {@code false} do not simplify condition.
-    * @param improveReadability {@code true} improve readability, {@code false} do not improve readability.
-    * @return The computed branch condition.
-    * @throws ProofInputException Occurred Exception.
-    */
+    /**
+     * Computes the branch condition of the given {@link Node}.
+     * 
+     * @param node
+     *            The {@link Node} to compute its branch condition.
+     * @param simplify
+     *            {@code true} simplify condition in a side proof, {@code false}
+     *            do not simplify condition.
+     * @param improveReadability
+     *            {@code true} improve readability, {@code false} do not improve
+     *            readability.
+     * @param includeInvariants
+     *            Set to true iff you want to have loop invariants included in
+     *            the result.
+     * @return The computed branch condition.
+     * @throws ProofInputException
+     *             Occurred Exception.
+     */
    public static Term computeBranchCondition(Node node,
                                              boolean simplify,
-                                             boolean improveReadability) throws ProofInputException {
+                                             boolean improveReadability,
+                                             boolean includeInvariants) throws ProofInputException {
+      final Term tt = node.proof().getServices().getTermBuilder().tt(); 
       // Get applied taclet on parent proof node
       Node parent = node.parent();
       if (parent.getAppliedRuleApp() instanceof TacletApp) {
@@ -1784,12 +1798,22 @@ public final class SymbolicExecutionUtil {
       else if (parent.getAppliedRuleApp() instanceof ContractRuleApp) {
         return computeContractRuleAppBranchCondition(parent, node, simplify, improveReadability);
       }
-      else if (parent.getAppliedRuleApp() instanceof LoopInvariantBuiltInRuleApp) {
-         return computeLoopInvariantBuiltInRuleAppBranchCondition(parent, node, simplify, improveReadability);
+      else if (parent.getAppliedRuleApp().rule() == WhileInvariantRule.INSTANCE) {
+         return computeLoopInvariantBuiltInRuleAppBranchCondition(parent, node, simplify, improveReadability, includeInvariants);
       }
+      else if (parent.getAppliedRuleApp().rule() == LoopScopeInvariantRule.INSTANCE) {
+         return includeInvariants
+                 ? computeLoopScopeInvariantBuiltInRuleBranchCondition(
+                         parent, node, simplify, improveReadability)
+                 : tt;
+       }
       else if (parent.getAppliedRuleApp() instanceof BlockContractBuiltInRuleApp) {
          return computeBlockContractBuiltInRuleAppBranchCondition(parent, node, simplify, improveReadability);
       }
+      else if (parent.getAppliedRuleApp().rule().name().toString().equals("AnalyzePostCondImpliesMethodEffects") ||
+              parent.getAppliedRuleApp().rule().name().toString().equals("AnalyzeInvImpliesLoopEffects")) {
+          return tt;
+      }
       else {
          throw new ProofInputException("Unsupported RuleApp in branch computation \"" + parent.getAppliedRuleApp() + "\".");
       }
@@ -2172,28 +2196,125 @@ public final class SymbolicExecutionUtil {
       }
    }
    
-   /**
-    * <p>
-    * Computes the branch condition of the given {@link Node} which was constructed by a {@link LoopInvariantBuiltInRuleApp}.
-    * </p>
-    * <p>
-    * The branch conditions are:
-    * <ul>
-    *    <li>Preserves Branch: Invariant + LoopCondition</li>
-    *    <li>Use Branch: Invariant + !LoopCondition</li>
-    * </ul>
-    * </p>
-    * @param parent The parent {@link Node} of the given one.
-    * @param node The {@link Node} to compute its branch condition.
-    * @param simplify {@code true} simplify condition in a side proof, {@code false} do not simplify condition.
-    * @param improveReadability {@code true} improve readability, {@code false} do not improve readability.
-    * @return The computed branch condition.
-    * @throws ProofInputException Occurred Exception.
-    */
+    /**
+     * <p>
+     * Computes the branch condition of the given {@link Node} which was
+     * constructed by a {@link LoopScopeInvariantRule} app.
+     * </p>
+     * <p>
+     * The branch conditions are:
+     * <ul>
+     * <li>Preserves / Use Case Branch: Invariant</li>
+     * </ul>
+     * </p>
+     * 
+     * @param parent
+     *            The parent {@link Node} of the given one.
+     * @param node
+     *            The {@link Node} to compute its branch condition.
+     * @param simplify
+     *            {@code true} simplify condition in a side proof, {@code false}
+     *            do not simplify condition.
+     * @param improveReadability
+     *            {@code true} improve readability, {@code false} do not improve
+     *            readability.
+     * @return The computed branch condition.
+     * @throws ProofInputException
+     *             Occurred Exception.
+     */
+    private static Term computeLoopScopeInvariantBuiltInRuleBranchCondition(
+            Node parent,
+            Node node,
+            boolean simplify,
+            boolean improveReadability) throws ProofInputException {
+        // Make sure that a computation is possible
+        if (!(parent.getAppliedRuleApp()
+                .rule() instanceof LoopScopeInvariantRule)) {
+            throw new ProofInputException(
+                    "Only LoopScopeInvariantRule is allowed in branch computation but rule \""
+                            + parent.getAppliedRuleApp().rule()
+                            + "\" was found.");
+        }
+
+        // Make sure that branch is supported
+        final int childIndex =
+                CollectionUtil.indexOf(parent.childrenIterator(), node);
+
+        if (childIndex != 1) {
+            throw new ProofInputException(
+                    "Branch condition of initially valid check is not supported.");
+        }
+
+        // Compute invariant (last antecedent formula of the preserved / use
+        // case branch)
+        final Semisequent antecedent = parent.child(1).sequent().antecedent();
+        Term invTerm = antecedent.get(antecedent.size() - 1).formula();
+
+        // Create formula which contains the value interested in.
+        Term condition;
+        if (simplify) {
+            final ProofEnvironment sideProofEnv = SymbolicExecutionSideProofUtil
+                    .cloneProofEnvironmentWithOwnOneStepSimplifier(
+                            parent.proof(), true);
+            Sequent newSequent = createSequentToProveWithNewSuccedent(parent,
+                    (Term) null, invTerm, null, true);
+            condition = evaluateInSideProof(parent.proof().getServices(),
+                    parent.proof(),
+                    sideProofEnv,
+                    newSequent,
+                    RESULT_LABEL,
+                    "Loop invariant branch condition computation on node "
+                            + parent.serialNr() + " for branch "
+                            + node.serialNr() + ".",
+                    StrategyProperties.SPLITTING_OFF);
+        }
+        else {
+            condition = TermBuilder.goBelowUpdates(invTerm);
+        }
+
+        if (improveReadability) {
+            condition =
+                    improveReadability(condition, parent.proof().getServices());
+        }
+
+        return condition;
+    }
+   
+    /**
+     * <p>
+     *   Computes the branch condition of the given {@link Node} which was
+     *   constructed by a {@link LoopInvariantBuiltInRuleApp}.
+     * </p>
+     * <p>
+     *   The branch conditions are:
+     *   <ul>
+     *     <li>Preserves Branch: Invariant + LoopCondition</li>
+     *     <li>Use Branch: Invariant + !LoopCondition</li>
+     *   </ul>
+     * </p>
+     * 
+     * @param parent
+     *            The parent {@link Node} of the given one.
+     * @param node
+     *            The {@link Node} to compute its branch condition.
+     * @param simplify
+     *            {@code true} simplify condition in a side proof, {@code false}
+     *            do not simplify condition.
+     * @param improveReadability
+     *            {@code true} improve readability, {@code false} do not improve
+     *            readability.
+     * @param includeInvariants
+     *            Set to true iff you want to have loop invariants included in
+     *            the result.
+     * @return The computed branch condition.
+     * @throws ProofInputException
+     *             Occurred Exception.
+     */
    private static Term computeLoopInvariantBuiltInRuleAppBranchCondition(Node parent,
                                                                          Node node,
                                                                          boolean simplify,
-                                                                         boolean improveReadability) throws ProofInputException {
+                                                                         boolean improveReadability,
+                                                                         boolean includeInvariants) throws ProofInputException {
       // Make sure that a computation is possible
       if (!(parent.getAppliedRuleApp() instanceof LoopInvariantBuiltInRuleApp)) {
          throw new ProofInputException("Only LoopInvariantBuiltInRuleApp is allowed in branch computation but rule \"" + parent.getAppliedRuleApp() + "\" was found.");
@@ -2235,7 +2356,7 @@ public final class SymbolicExecutionUtil {
          }
          // Create formula which contains the value interested in.
          invTerm = TermBuilder.goBelowUpdates(invTerm);
-         Term loopCondAndInv = services.getTermBuilder().and(loopConditionModalityTerm.sub(0), invTerm);
+         Term loopCondAndInv = includeInvariants ? services.getTermBuilder().and(loopConditionModalityTerm.sub(0), invTerm) : loopConditionModalityTerm.sub(0);
          Term newTerm = loopCondAndInv;
          Term modalityTerm = childIndex == 1 ?
                              services.getTermBuilder().box(loopConditionModalityTerm.javaBlock(), newTerm) :
@@ -3354,47 +3475,80 @@ public final class SymbolicExecutionUtil {
       return result;
    }
 
-   /**
-    * Computes the path condition of the given {@link Node}.
-    * @param node The {@link Node} to compute its path condition.
-    * @param simplify {@code true} simplify each branch condition in a side proof, {@code false} do not simplify branch conditions.
-    * @param improveReadability {@code true} improve readability, {@code false} do not improve readability.
-    * @return The computed path condition.
-    * @throws ProofInputException Occurred Exception.
-    */
+    /**
+     * Computes the path condition of the given {@link Node}.
+     * 
+     * @param node
+     *            The {@link Node} to compute its path condition.
+     * @param simplify
+     *            {@code true} simplify each branch condition in a side proof,
+     *            {@code false} do not simplify branch conditions.
+     * @param improveReadability
+     *            {@code true} improve readability, {@code false} do not improve
+     *            readability.
+     * @param includeInvariants
+     *            Set to true iff you want to have loop invariants included in
+     *            the result.
+     * @return The computed path condition.
+     * @throws ProofInputException
+     *             Occurred Exception.
+     */
    public static Term computePathCondition(Node node,
                                            boolean simplify,
-                                           boolean improveReadability) throws ProofInputException {
-      return computePathCondition(null, node, simplify, improveReadability);
+                                           boolean improveReadability,
+                                           boolean includeInvariants) throws ProofInputException {
+      return computePathCondition(null, node, simplify, improveReadability, includeInvariants);
    }
 
-   /**
-    * Computes the path condition between the given {@link Node}s.
-    * @param parentNode The {@link Node} to stop path condition computation at.
-    * @param childNode The {@link Node} to compute its path condition back to the parent.
-    * @param simplify {@code true} simplify each branch condition in a side proof, {@code false} do not simplify branch conditions.
-    * @param improveReadability {@code true} improve readability, {@code false} do not improve readability.
-    * @return The computed path condition.
-    * @throws ProofInputException Occurred Exception.
-    */
+    /**
+     * Computes the path condition between the given {@link Node}s.
+     * 
+     * @param parentNode
+     *            The {@link Node} to stop path condition computation at.
+     * @param childNode
+     *            The {@link Node} to compute its path condition back to the
+     *            parent.
+     * @param simplify
+     *            {@code true} simplify each branch condition in a side proof,
+     *            {@code false} do not simplify branch conditions.
+     * @param improveReadability
+     *            {@code true} improve readability, {@code false} do not improve
+     *            readability.
+     * @param includeInvariants
+     *            Set to true iff you want to have loop invariants included in
+     *            the result.
+     * @return The computed path condition.
+     * @throws ProofInputException
+     *             Occurred Exception.
+     */
    public static Term computePathCondition(Node parentNode,
                                            Node childNode,
                                            boolean simplify,
-                                           boolean improveReadability) throws ProofInputException {
+                                           boolean improveReadability,
+                                           boolean includeInvariants) throws ProofInputException {
       if (childNode != null) {
-         final Services services = childNode.proof().getServices();
+        final Node origNode = childNode;
+        final Proof proof = childNode.proof();
+        final Services services = proof.getServices();
+        
          Term pathCondition = services.getTermBuilder().tt();
          while (childNode != null && childNode != parentNode) {
+             
             Node parent = childNode.parent();
             if (parent != null && parent.childrenCount() >= 2) {
-               Term branchCondition = computeBranchCondition(childNode, simplify, improveReadability);
+               Term branchCondition = computeBranchCondition(childNode, simplify, improveReadability, includeInvariants);
                pathCondition = services.getTermBuilder().and(branchCondition, pathCondition);
             }
             childNode = parent;
          }
+         
          if (services.getTermBuilder().ff().equals(pathCondition)) {
             throw new ProofInputException("Path condition computation failed because the result is false.");
          }
+         
+         pathCondition = simplifyAndImproveReadability(simplify,
+                improveReadability, origNode, pathCondition);
+         
          return pathCondition;
       }
       else {
@@ -3402,6 +3556,68 @@ public final class SymbolicExecutionUtil {
       }
    }
 
+    /**
+     * Simplifies and / or improves the readability of the {@link Term}
+     * termToSimplify in the given {@link Node}.<br>
+     * TODO: This should make the other simplification steps superfluous, i.e.
+     * those dedicated to special {@link RuleApp}s. Check whether they can be
+     * removed.
+     *
+     * @param simplify
+     *            true iff side-proof based simplification should be applied.
+     * @param improveReadability
+     *            true iff readabiltiy should be improved (syntactical
+     *            transformations).
+     * @param node
+     *            The {@link Node} to start with.
+     * @param termToSimplify
+     *            The {@link Term} to simplify.
+     * @return A simplified version of termToSimplify.
+     * @throws ProofInputException
+     *             Hopefully not.
+     */
+    public static Term simplifyAndImproveReadability(boolean simplify,
+            boolean improveReadability, final Node node,
+            final Term termToSimplify)
+            throws ProofInputException {
+        assert node != null && termToSimplify != null;
+
+        Term result = termToSimplify;
+
+        final Proof proof = node.proof();
+        final Services services = proof.getServices();
+
+        if (simplify) {
+            final ProofEnvironment sideProofEnv = SymbolicExecutionSideProofUtil
+                    .cloneProofEnvironmentWithOwnOneStepSimplifier(
+                            proof, true);
+
+            TermFactory factory = services.getTermFactory();
+            result = addLabelRecursiveToNonSkolem(factory, termToSimplify,
+                    RESULT_LABEL);
+
+            Sequent newSequent = Sequent.createSuccSequent(
+                    new Semisequent(new SequentFormula(termToSimplify)));
+            result = evaluateInSideProof(proof.getServices(),
+                    proof,
+                    sideProofEnv,
+                    newSequent,
+                    RESULT_LABEL,
+                    "Branch condition simplification.",
+                    StrategyProperties.SPLITTING_OFF);
+        }
+        else {
+            result = TermBuilder.goBelowUpdates(termToSimplify);
+        }
+
+        if (improveReadability) {
+            result =
+                    improveReadability(termToSimplify, services);
+        }
+        
+        return result;
+    }
+
    /**
     * Checks if the {@link Sort} of the given {@link Term} is a reference type.
     * @param services The {@link Services} to use.
@@ -4083,7 +4299,7 @@ public final class SymbolicExecutionUtil {
     * @param variable The {@link IProgramVariable} for that the value is needed.
     * @return The found value or {@code null} if it is not defined in the given update term.
     */
-	protected static ImmutableArray<Term> extractValueFromUpdate(Term term, IProgramVariable variable) {
+	public static ImmutableArray<Term> extractValueFromUpdate(Term term, IProgramVariable variable) {
 		ImmutableArray<Term> result = null;
 		if (term.op() instanceof ElementaryUpdate) {
 			ElementaryUpdate update = (ElementaryUpdate) term.op();
diff --git a/key/key.core.test/src/de/uka/ilkd/key/logic/TestLocalSymbols.java b/key/key.core.test/src/de/uka/ilkd/key/logic/TestLocalSymbols.java
index c355b2275a..21f7908637 100644
--- a/key/key.core.test/src/de/uka/ilkd/key/logic/TestLocalSymbols.java
+++ b/key/key.core.test/src/de/uka/ilkd/key/logic/TestLocalSymbols.java
@@ -50,7 +50,7 @@ public class TestLocalSymbols extends TestCase {
         }
 
         @Override
-        protected Set<String> getAdmittedRuleNames() {
+        protected Set<String> getAdmittedRuleNames(Proof proof) {
             return asSet("andRight", "orRight", "forallRight");
         }
 
diff --git a/key/key.core/META-INF/services/de.uka.ilkd.key.macros.ProofMacro b/key/key.core/META-INF/services/de.uka.ilkd.key.macros.ProofMacro
index 273f26a2a4..49c53f255b 100644
--- a/key/key.core/META-INF/services/de.uka.ilkd.key.macros.ProofMacro
+++ b/key/key.core/META-INF/services/de.uka.ilkd.key.macros.ProofMacro
@@ -26,3 +26,4 @@ de.uka.ilkd.key.macros.IntegerSimplificationMacro
 de.uka.ilkd.key.macros.OneStepProofMacro
 de.uka.ilkd.key.macros.WellDefinednessMacro
 de.uka.ilkd.key.macros.UpdateSimplificationMacro
+de.uka.ilkd.key.macros.GeneralSimplificationMacro
diff --git a/key/key.core/META-INF/services/de.uka.ilkd.key.proof.init.DefaultProfileResolver b/key/key.core/META-INF/services/de.uka.ilkd.key.proof.init.DefaultProfileResolver
index 04aa29c4e0..41f59e7a9d 100644
--- a/key/key.core/META-INF/services/de.uka.ilkd.key.proof.init.DefaultProfileResolver
+++ b/key/key.core/META-INF/services/de.uka.ilkd.key.proof.init.DefaultProfileResolver
@@ -4,4 +4,5 @@
 
 de.uka.ilkd.key.proof.init.JavaProfileDefaultProfileResolver
 de.uka.ilkd.key.proof.init.JavaProfileWithPermissionsDefaultProfileResolver
-de.uka.ilkd.key.symbolic_execution.profile.SymbolicExecutionJavaProfileDefaultProfileResolver
\ No newline at end of file
+de.uka.ilkd.key.symbolic_execution.profile.SymbolicExecutionJavaProfileDefaultProfileResolver
+de.tud.cs.se.ds.specstr.profile.StrengthAnalysisSEProfileDefaultProfileResolver
\ No newline at end of file
diff --git a/key/key.core/src/de/uka/ilkd/key/informationflow/macros/SelfcompositionStateExpansionMacro.java b/key/key.core/src/de/uka/ilkd/key/informationflow/macros/SelfcompositionStateExpansionMacro.java
index e0e74cdd68..486f6aa425 100644
--- a/key/key.core/src/de/uka/ilkd/key/informationflow/macros/SelfcompositionStateExpansionMacro.java
+++ b/key/key.core/src/de/uka/ilkd/key/informationflow/macros/SelfcompositionStateExpansionMacro.java
@@ -56,13 +56,13 @@ public class SelfcompositionStateExpansionMacro extends AbstractPropositionalExp
     private static final Set<String> ADMITTED_RULES_SET = asSet(ADMITTED_RULES);
 
     @Override
-    protected Set<String> getAdmittedRuleNames() {
+    protected Set<String> getAdmittedRuleNames(Proof proof) {
         return ADMITTED_RULES_SET;
     }
 
     @Override
     protected Strategy createStrategy(Proof proof, PosInOccurrence posInOcc) {
-        return new SelfCompExpansionStrategy(getAdmittedRuleNames());
+        return new SelfCompExpansionStrategy(getAdmittedRuleNames(proof));
     }
 
     @Override
diff --git a/key/key.core/src/de/uka/ilkd/key/java/PrettyPrinter.java b/key/key.core/src/de/uka/ilkd/key/java/PrettyPrinter.java
index e4aa126233..1ab2733b37 100644
--- a/key/key.core/src/de/uka/ilkd/key/java/PrettyPrinter.java
+++ b/key/key.core/src/de/uka/ilkd/key/java/PrettyPrinter.java
@@ -15,31 +15,12 @@ package de.uka.ilkd.key.java;
 
 import java.io.IOException;
 import java.io.Writer;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.Stack;
+import java.util.*;
 
 import org.key_project.util.collection.ImmutableArray;
 
 import de.uka.ilkd.key.java.abstraction.Type;
-import de.uka.ilkd.key.java.declaration.ArrayDeclaration;
-import de.uka.ilkd.key.java.declaration.ClassDeclaration;
-import de.uka.ilkd.key.java.declaration.ClassInitializer;
-import de.uka.ilkd.key.java.declaration.ConstructorDeclaration;
-import de.uka.ilkd.key.java.declaration.Extends;
-import de.uka.ilkd.key.java.declaration.FieldDeclaration;
-import de.uka.ilkd.key.java.declaration.Implements;
-import de.uka.ilkd.key.java.declaration.InterfaceDeclaration;
-import de.uka.ilkd.key.java.declaration.LocalVariableDeclaration;
-import de.uka.ilkd.key.java.declaration.MemberDeclaration;
-import de.uka.ilkd.key.java.declaration.MethodDeclaration;
-import de.uka.ilkd.key.java.declaration.Modifier;
-import de.uka.ilkd.key.java.declaration.ParameterDeclaration;
-import de.uka.ilkd.key.java.declaration.Throws;
-import de.uka.ilkd.key.java.declaration.VariableDeclaration;
-import de.uka.ilkd.key.java.declaration.VariableSpecification;
+import de.uka.ilkd.key.java.declaration.*;
 import de.uka.ilkd.key.java.declaration.modifier.Final;
 import de.uka.ilkd.key.java.declaration.modifier.Private;
 import de.uka.ilkd.key.java.declaration.modifier.Protected;
@@ -49,114 +30,14 @@ import de.uka.ilkd.key.java.expression.Assignment;
 import de.uka.ilkd.key.java.expression.Operator;
 import de.uka.ilkd.key.java.expression.ParenthesizedExpression;
 import de.uka.ilkd.key.java.expression.PassiveExpression;
-import de.uka.ilkd.key.java.expression.literal.BigintLiteral;
-import de.uka.ilkd.key.java.expression.literal.BooleanLiteral;
-import de.uka.ilkd.key.java.expression.literal.CharLiteral;
-import de.uka.ilkd.key.java.expression.literal.DoubleLiteral;
-import de.uka.ilkd.key.java.expression.literal.EmptyMapLiteral;
-import de.uka.ilkd.key.java.expression.literal.EmptySeqLiteral;
-import de.uka.ilkd.key.java.expression.literal.EmptySetLiteral;
-import de.uka.ilkd.key.java.expression.literal.FloatLiteral;
-import de.uka.ilkd.key.java.expression.literal.IntLiteral;
-import de.uka.ilkd.key.java.expression.literal.LongLiteral;
-import de.uka.ilkd.key.java.expression.literal.NullLiteral;
-import de.uka.ilkd.key.java.expression.literal.StringLiteral;
-import de.uka.ilkd.key.java.expression.operator.BinaryAnd;
-import de.uka.ilkd.key.java.expression.operator.BinaryAndAssignment;
-import de.uka.ilkd.key.java.expression.operator.BinaryNot;
-import de.uka.ilkd.key.java.expression.operator.BinaryOr;
-import de.uka.ilkd.key.java.expression.operator.BinaryOrAssignment;
-import de.uka.ilkd.key.java.expression.operator.BinaryXOr;
-import de.uka.ilkd.key.java.expression.operator.BinaryXOrAssignment;
-import de.uka.ilkd.key.java.expression.operator.Conditional;
-import de.uka.ilkd.key.java.expression.operator.CopyAssignment;
-import de.uka.ilkd.key.java.expression.operator.DLEmbeddedExpression;
-import de.uka.ilkd.key.java.expression.operator.Divide;
-import de.uka.ilkd.key.java.expression.operator.DivideAssignment;
-import de.uka.ilkd.key.java.expression.operator.Equals;
-import de.uka.ilkd.key.java.expression.operator.ExactInstanceof;
-import de.uka.ilkd.key.java.expression.operator.GreaterOrEquals;
-import de.uka.ilkd.key.java.expression.operator.GreaterThan;
-import de.uka.ilkd.key.java.expression.operator.Instanceof;
-import de.uka.ilkd.key.java.expression.operator.LessOrEquals;
-import de.uka.ilkd.key.java.expression.operator.LessThan;
-import de.uka.ilkd.key.java.expression.operator.LogicalAnd;
-import de.uka.ilkd.key.java.expression.operator.LogicalNot;
-import de.uka.ilkd.key.java.expression.operator.LogicalOr;
-import de.uka.ilkd.key.java.expression.operator.Minus;
-import de.uka.ilkd.key.java.expression.operator.MinusAssignment;
-import de.uka.ilkd.key.java.expression.operator.Modulo;
-import de.uka.ilkd.key.java.expression.operator.ModuloAssignment;
-import de.uka.ilkd.key.java.expression.operator.Negative;
-import de.uka.ilkd.key.java.expression.operator.New;
-import de.uka.ilkd.key.java.expression.operator.NewArray;
-import de.uka.ilkd.key.java.expression.operator.NotEquals;
-import de.uka.ilkd.key.java.expression.operator.Plus;
-import de.uka.ilkd.key.java.expression.operator.PlusAssignment;
-import de.uka.ilkd.key.java.expression.operator.Positive;
-import de.uka.ilkd.key.java.expression.operator.PostDecrement;
-import de.uka.ilkd.key.java.expression.operator.PostIncrement;
-import de.uka.ilkd.key.java.expression.operator.PreDecrement;
-import de.uka.ilkd.key.java.expression.operator.PreIncrement;
-import de.uka.ilkd.key.java.expression.operator.ShiftLeft;
-import de.uka.ilkd.key.java.expression.operator.ShiftLeftAssignment;
-import de.uka.ilkd.key.java.expression.operator.ShiftRight;
-import de.uka.ilkd.key.java.expression.operator.ShiftRightAssignment;
-import de.uka.ilkd.key.java.expression.operator.Times;
-import de.uka.ilkd.key.java.expression.operator.TimesAssignment;
-import de.uka.ilkd.key.java.expression.operator.TypeCast;
-import de.uka.ilkd.key.java.expression.operator.UnsignedShiftRight;
-import de.uka.ilkd.key.java.expression.operator.UnsignedShiftRightAssignment;
+import de.uka.ilkd.key.java.expression.literal.*;
+import de.uka.ilkd.key.java.expression.operator.*;
 import de.uka.ilkd.key.java.expression.operator.adt.SeqGet;
 import de.uka.ilkd.key.java.expression.operator.adt.SeqLength;
-import de.uka.ilkd.key.java.reference.ArrayLengthReference;
-import de.uka.ilkd.key.java.reference.ArrayReference;
-import de.uka.ilkd.key.java.reference.ExecutionContext;
-import de.uka.ilkd.key.java.reference.FieldReference;
-import de.uka.ilkd.key.java.reference.MetaClassReference;
-import de.uka.ilkd.key.java.reference.MethodReference;
-import de.uka.ilkd.key.java.reference.PackageReference;
-import de.uka.ilkd.key.java.reference.SchemaTypeReference;
-import de.uka.ilkd.key.java.reference.SuperConstructorReference;
-import de.uka.ilkd.key.java.reference.SuperReference;
-import de.uka.ilkd.key.java.reference.ThisConstructorReference;
-import de.uka.ilkd.key.java.reference.ThisReference;
-import de.uka.ilkd.key.java.reference.TypeReference;
-import de.uka.ilkd.key.java.statement.Assert;
-import de.uka.ilkd.key.java.statement.Break;
-import de.uka.ilkd.key.java.statement.Case;
-import de.uka.ilkd.key.java.statement.Catch;
-import de.uka.ilkd.key.java.statement.CatchAllStatement;
-import de.uka.ilkd.key.java.statement.Continue;
-import de.uka.ilkd.key.java.statement.Default;
-import de.uka.ilkd.key.java.statement.Do;
-import de.uka.ilkd.key.java.statement.Else;
-import de.uka.ilkd.key.java.statement.EmptyStatement;
-import de.uka.ilkd.key.java.statement.EnhancedFor;
-import de.uka.ilkd.key.java.statement.Finally;
-import de.uka.ilkd.key.java.statement.For;
-import de.uka.ilkd.key.java.statement.IForUpdates;
-import de.uka.ilkd.key.java.statement.ILoopInit;
-import de.uka.ilkd.key.java.statement.If;
-import de.uka.ilkd.key.java.statement.LabeledStatement;
-import de.uka.ilkd.key.java.statement.MergePointStatement;
-import de.uka.ilkd.key.java.statement.LoopScopeBlock;
-import de.uka.ilkd.key.java.statement.MethodBodyStatement;
-import de.uka.ilkd.key.java.statement.MethodFrame;
-import de.uka.ilkd.key.java.statement.Return;
-import de.uka.ilkd.key.java.statement.Switch;
-import de.uka.ilkd.key.java.statement.SynchronizedBlock;
-import de.uka.ilkd.key.java.statement.Then;
-import de.uka.ilkd.key.java.statement.Throw;
-import de.uka.ilkd.key.java.statement.TransactionStatement;
-import de.uka.ilkd.key.java.statement.Try;
-import de.uka.ilkd.key.java.statement.While;
+import de.uka.ilkd.key.java.reference.*;
+import de.uka.ilkd.key.java.statement.*;
 import de.uka.ilkd.key.logic.ProgramElementName;
-import de.uka.ilkd.key.logic.op.IProgramMethod;
-import de.uka.ilkd.key.logic.op.IProgramVariable;
-import de.uka.ilkd.key.logic.op.ProgramSV;
-import de.uka.ilkd.key.logic.op.ProgramVariable;
-import de.uka.ilkd.key.logic.op.SchemaVariable;
+import de.uka.ilkd.key.logic.op.*;
 import de.uka.ilkd.key.pp.Range;
 import de.uka.ilkd.key.rule.inst.SVInstantiations;
 import de.uka.ilkd.key.rule.metaconstruct.ProgramTransformer;
@@ -204,10 +85,14 @@ public class PrettyPrinter {
     /** Contains the java keyword ranges. */
     private ArrayList<Range> keywordRanges = new ArrayList<Range>();
 
+    /** Flag for printing all comments */
+    private boolean printComments;
+
     /** creates a new PrettyPrinter */
     public PrettyPrinter(Writer o) {
-	setWriter(o);
-	outBuf = new StringBuffer();
+        setWriter(o);
+        outBuf = new StringBuffer();
+        printComments = false;
     }
 
     public PrettyPrinter(Writer o, SVInstantiations svi) {
@@ -220,6 +105,18 @@ public class PrettyPrinter {
         this.noLinefeed = noLinefeed;
     }
 
+    /**
+     * Constructor.
+     *
+     * @param o The {@link Writer} to write to.
+     * @param noLinefeed Flag for adding / not adding line feed.
+     * @param printComments Flag for printing all existing comments before statements.
+     */
+    public PrettyPrinter(Writer o, boolean noLinefeed, boolean printComments) {
+        this(o, noLinefeed);
+        this.printComments = printComments;
+    }
+
     public PrettyPrinter(Writer o, boolean noLinefeed, SVInstantiations svi) {
         this(o, noLinefeed);
         this.instantiations = svi;
@@ -916,6 +813,13 @@ public class PrettyPrinter {
             }
         }
         indentMap.put(first, indent);
+
+        if (printComments) {
+            Comment[] c = x.getComments();
+            for (Comment aC : c) {
+                printComment(aC);
+            }
+        }
     }
 
 
@@ -1714,11 +1618,16 @@ public class PrettyPrinter {
     public void printMethodDeclaration(MethodDeclaration x)
 	    throws java.io.IOException {
 	printHeader(x);
-	Comment[] c = x.getComments();
-	int m = c.length;
+        Comment[] c = x.getComments();
+        int m = c.length;
+        if (!printComments) {
+        // If printComments is set, comments are already being written
         for (Comment aC : c) {
             printComment(aC);
         }
+        } else {
+            write("\n");
+        }
 	if (x.getModifiers() != null) {
 	    ImmutableArray<Modifier> mods = x.getModifiers();
 	    m += mods.size();
@@ -3160,7 +3069,8 @@ public class PrettyPrinter {
     }
 
     public void printComment(Comment x) throws java.io.IOException {
-	write("/*" + x.getText() + "*/");
+        writeIndentation(1, getTotalIndentation());
+        write(x.getText());
     }
 
     public void printParenthesizedExpression(ParenthesizedExpression x) 
diff --git a/key/key.core/src/de/uka/ilkd/key/logic/OpCollector.java b/key/key.core/src/de/uka/ilkd/key/logic/OpCollector.java
index 34642c0b9b..f4f18be866 100644
--- a/key/key.core/src/de/uka/ilkd/key/logic/OpCollector.java
+++ b/key/key.core/src/de/uka/ilkd/key/logic/OpCollector.java
@@ -13,7 +13,6 @@
 
 package de.uka.ilkd.key.logic;
 
-import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
@@ -25,7 +24,7 @@ import de.uka.ilkd.key.logic.op.Operator;
  */
 public class OpCollector extends DefaultVisitor {
     /** the found operators */
-    private HashSet<Operator> ops;
+    private Set<Operator> ops;
 
     /** creates the Op collector */
     public OpCollector() {
diff --git a/key/key.core/src/de/uka/ilkd/key/logic/SemisequentChangeInfo.java b/key/key.core/src/de/uka/ilkd/key/logic/SemisequentChangeInfo.java
index 9c4ae5aea1..aa8b339721 100644
--- a/key/key.core/src/de/uka/ilkd/key/logic/SemisequentChangeInfo.java
+++ b/key/key.core/src/de/uka/ilkd/key/logic/SemisequentChangeInfo.java
@@ -13,6 +13,10 @@
 
 package de.uka.ilkd.key.logic;
 
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+
 import org.key_project.util.collection.ImmutableList;
 import org.key_project.util.collection.ImmutableSLList;
 
@@ -155,7 +159,7 @@ public class SemisequentChangeInfo {
     /**
      * This method combines this change information from this info and its successor. 
      * ATTENTION: it takes over ownership over {@link succ} and does not release it. This means
-     * when invoking the method it must be snsured that succ is never used afterwards.
+     * when invoking the method it must be ensured that succ is never used afterwards.
      */
     public void combine(SemisequentChangeInfo succ) {
        final SemisequentChangeInfo predecessor = this;
@@ -182,13 +186,41 @@ public class SemisequentChangeInfo {
           }
        }
        
-       for (FormulaChangeInfo fci : succ.modified) {
-          if (predecessor.addedFormulas().contains(fci.getOriginalFormula())) {
-             predecessor.added = predecessor.added.removeAll(fci.getOriginalFormula());
-             predecessor.addedFormula(succ.lastFormulaIndex, fci.getNewFormula());
-          } else {
-             predecessor.modifiedFormula(succ.lastFormulaIndex, fci);
-          }
+        for (final FormulaChangeInfo fci : succ.modified) {
+            if (predecessor.addedFormulas()
+                    .contains(fci.getOriginalFormula())) {
+                predecessor.added = predecessor.added
+                        .removeAll(fci.getOriginalFormula());
+                predecessor.addedFormula(succ.lastFormulaIndex,
+                        fci.getNewFormula());
+            } else {
+                // In the presence of term labels, it has happened that there
+                // are two changes f<<label1>> ==> f<<label2>> and f<<label2>>
+                // ==> f<<label3>>, those have to be treated transitively since
+                // otherwise, eventually there will be a search for a formula
+                // which does not exist in the sequent.
+                final List<FormulaChangeInfo> transitivityCandidates = StreamSupport
+                        .stream(predecessor.modified.spliterator(), true)
+                        .filter(fci2 -> fci2.getNewFormula()
+                                .equals(fci.getOriginalFormula()))
+                        .collect(Collectors.toList());
+
+                assert transitivityCandidates
+                        .size() < 2 : "There are more than 1 'transitive'"
+                                + " modifications, check what happens here.";
+
+                if (!transitivityCandidates.isEmpty()) {
+                    predecessor.modifiedFormula(succ.lastFormulaIndex,
+                            new FormulaChangeInfo(
+                                    transitivityCandidates.get(0)
+                                            .getPositionOfModification(),
+                                    fci.getNewFormula()));
+                    predecessor.modified = predecessor.modified
+                            .removeAll(transitivityCandidates.get(0));
+                } else {
+                    predecessor.modifiedFormula(succ.lastFormulaIndex, fci);
+                }
+            }
        }
 
        for (SequentFormula sf : succ.added) {
diff --git a/key/key.core/src/de/uka/ilkd/key/logic/label/ParameterlessTermLabel.java b/key/key.core/src/de/uka/ilkd/key/logic/label/ParameterlessTermLabel.java
index fa2f0f5a16..e523affb20 100644
--- a/key/key.core/src/de/uka/ilkd/key/logic/label/ParameterlessTermLabel.java
+++ b/key/key.core/src/de/uka/ilkd/key/logic/label/ParameterlessTermLabel.java
@@ -117,6 +117,17 @@ public final class ParameterlessTermLabel implements TermLabel {
    public static final TermLabel LOOP_SCOPE_INDEX_LABEL =
            new ParameterlessTermLabel(LOOP_SCOPE_INDEX_LABEL_NAME);
 
+    /**
+     * Name of {@link #LOOP_INV_ANON_LABEL}.
+     */
+    public static final Name LOOP_INV_ANON_LABEL_NAME = new Name("loopInvAnon");
+
+    /**
+     * Label attached to loop scope index variables in {@link LoopScopeInvariantRule}.
+     */
+    public static final TermLabel LOOP_INV_ANON_LABEL =
+            new ParameterlessTermLabel(LOOP_INV_ANON_LABEL_NAME);
+
     /**
      * The unique name of this label.
      * This is the basename and does not include the parameters
diff --git a/key/key.core/src/de/uka/ilkd/key/macros/AbstractPropositionalExpansionMacro.java b/key/key.core/src/de/uka/ilkd/key/macros/AbstractPropositionalExpansionMacro.java
index 7cfc8ebea9..c75336f1cd 100644
--- a/key/key.core/src/de/uka/ilkd/key/macros/AbstractPropositionalExpansionMacro.java
+++ b/key/key.core/src/de/uka/ilkd/key/macros/AbstractPropositionalExpansionMacro.java
@@ -24,6 +24,7 @@ import de.uka.ilkd.key.proof.Goal;
 import de.uka.ilkd.key.proof.Proof;
 import de.uka.ilkd.key.rule.OneStepSimplifierRuleApp;
 import de.uka.ilkd.key.rule.RuleApp;
+import de.uka.ilkd.key.rule.RuleSet;
 import de.uka.ilkd.key.strategy.NumberRuleAppCost;
 import de.uka.ilkd.key.strategy.RuleAppCost;
 import de.uka.ilkd.key.strategy.RuleAppCostCollector;
@@ -35,7 +36,7 @@ import de.uka.ilkd.key.strategy.TopRuleAppCost;
  * rules.
  *
  * The names of the set of rules to be applied is defined by the abstract method
- * {@link #getAdmittedRuleNames()}.
+ * {@link #getAdmittedRuleNames(Proof)}.
  *
  * This is very helpful to perform many "andLeft", "impRight" or even "andRight"
  * steps at a time.
@@ -59,9 +60,13 @@ public abstract class AbstractPropositionalExpansionMacro extends StrategyProofM
     /**
      * Gets the set of admitted rule names.
      *
+     * @param proof
+     *            The {@link Proof} object, can be used for obtaining rules from
+     *            {@link RuleSet} names.
+     *
      * @return a constant non-<code>null</code> set
      */
-    protected abstract Set<String> getAdmittedRuleNames();
+    protected abstract Set<String> getAdmittedRuleNames(Proof proof);
     
     /**
      * Whether this macro includes One Step Simplification.
@@ -71,7 +76,7 @@ public abstract class AbstractPropositionalExpansionMacro extends StrategyProofM
     @Override
     protected Strategy createStrategy(Proof proof, PosInOccurrence posInOcc) {
         return new PropExpansionStrategy(proof.getActiveStrategy(),
-                                         getAdmittedRuleNames(), allowOSS());
+                                         getAdmittedRuleNames(proof), allowOSS());
     }
     
     /**
diff --git a/key/key.core/src/de/uka/ilkd/key/macros/FullPropositionalExpansionMacro.java b/key/key.core/src/de/uka/ilkd/key/macros/FullPropositionalExpansionMacro.java
index a367d6619e..092dd02cf2 100644
--- a/key/key.core/src/de/uka/ilkd/key/macros/FullPropositionalExpansionMacro.java
+++ b/key/key.core/src/de/uka/ilkd/key/macros/FullPropositionalExpansionMacro.java
@@ -15,6 +15,8 @@ package de.uka.ilkd.key.macros;
 
 import java.util.Set;
 
+import de.uka.ilkd.key.proof.Proof;
+
 /**
  * The macro FullPropositionalExpansionMacro apply rules to decompose
  * propositional toplevel formulas; it even splits the goal if necessary.
@@ -52,7 +54,7 @@ public class FullPropositionalExpansionMacro extends AbstractPropositionalExpans
     private static final Set<String> ADMITTED_RULES_SET = asSet(ADMITTED_RULES);
 
     @Override
-    protected Set<String> getAdmittedRuleNames() {
+    protected Set<String> getAdmittedRuleNames(Proof proof) {
         return ADMITTED_RULES_SET;
     }
 
diff --git a/key/key.core/src/de/uka/ilkd/key/macros/GeneralSimplificationMacro.java b/key/key.core/src/de/uka/ilkd/key/macros/GeneralSimplificationMacro.java
new file mode 100644
index 0000000000..1b2de1cbb6
--- /dev/null
+++ b/key/key.core/src/de/uka/ilkd/key/macros/GeneralSimplificationMacro.java
@@ -0,0 +1,125 @@
+package de.uka.ilkd.key.macros;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import org.key_project.util.collection.ImmutableList;
+import org.key_project.util.collection.ImmutableSLList;
+
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.rule.*;
+
+/**
+ * This macro applies only simplification rules. The idea is to use it instead
+ * of the {@link OneStepSimplifier}.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class GeneralSimplificationMacro extends
+        AbstractPropositionalExpansionMacro {
+
+    /**
+     * Name for this {@link ProofMacro}.
+     */
+    public static final String SIMPLIFICATION_ONLY =
+            "Simplification Only";
+
+    /**
+     * The sets of {@link Rule}s that should be activated by this
+     * {@link ProofMacro}.
+     */
+    private static final ImmutableList<String> RULE_SETS =
+            ImmutableSLList.<String> nil() //
+                    .append("concrete")
+                    .append("update_elim")
+                    .append("update_apply_on_update")
+                    .append("update_apply")
+                    .append("update_join")
+                    .append("elimQuantifier");
+
+    /**
+     * {@link Rule} sets that should explicitely be excluded.
+     */
+    private static final ImmutableList<String> EXCLUDED_RULE_SETS =
+            ImmutableSLList.<String> nil();
+
+    @Override
+    public String getName() {
+        return SIMPLIFICATION_ONLY;
+    }
+
+    @Override
+    public String getCategory() {
+        return "Simplification";
+    }
+
+    @Override
+    public String getScriptCommandName() {
+        return "simp";
+    }
+
+    @Override
+    public String getDescription() {
+        return "Applies only simplification rules";
+    }
+
+    @Override
+    protected Set<String> getAdmittedRuleNames(final Proof proof) {
+        assert !proof.openGoals().isEmpty();
+        final Set<String> result = new LinkedHashSet<>();
+
+        // collect apps present in all open goals
+        final Set<NoPosTacletApp> allApps =
+                proof.openGoals().head().ruleAppIndex()
+                        .tacletIndex().allNoPosTacletApps();
+
+        for (final Goal goal : proof.openGoals().tail()) {
+            allApps.retainAll(goal.ruleAppIndex()
+                    .tacletIndex()
+                    .allNoPosTacletApps());
+        }
+
+        for (final NoPosTacletApp app : allApps) {
+            final Taclet tac = app.taclet();
+            if (!(tac instanceof RewriteTaclet)
+                    || !tac.hasReplaceWith()
+                    || !tac.ifSequent().isEmpty()
+                    || tac.goalTemplates().size() != 1
+                    || !tac.goalTemplates().head().sequent().isEmpty()
+                    || !tac.varsNew().isEmpty()
+                    || !tac.varsNewDependingOn().isEmpty()
+                    || ((RewriteTaclet) tac)
+                            .getApplicationRestriction() != RewriteTaclet.NONE
+                    || !proof.getInitConfig().getJustifInfo()
+                            .getJustification(tac).isAxiomJustification()) {
+                continue;
+            }
+
+            boolean accept = false;
+            for (final String ruleSetName : RULE_SETS) {
+                for (RuleSet rs : app.taclet().getRuleSets()) {
+                    if (rs.name().toString().equals(ruleSetName)) {
+                        accept = true;
+                    } else if (EXCLUDED_RULE_SETS
+                            .contains(rs.name().toString())) {
+                        accept = false;
+                        break;
+                    }
+                }
+            }
+
+            if (accept) {
+                result.add(tac.name().toString());
+            }
+        }
+
+        return result;
+    }
+
+    @Override
+    protected boolean allowOSS() {
+        return false;
+    }
+
+}
diff --git a/key/key.core/src/de/uka/ilkd/key/macros/HeapSimplificationMacro.java b/key/key.core/src/de/uka/ilkd/key/macros/HeapSimplificationMacro.java
index bf14199685..445cfb8fb8 100644
--- a/key/key.core/src/de/uka/ilkd/key/macros/HeapSimplificationMacro.java
+++ b/key/key.core/src/de/uka/ilkd/key/macros/HeapSimplificationMacro.java
@@ -15,6 +15,8 @@ package de.uka.ilkd.key.macros;
 
 import java.util.Set;
 
+import de.uka.ilkd.key.proof.Proof;
+
 /**
  * This macro performs simplification of Heap and LocSet terms.
  * It applies simplification rules (including the "unoptimized" select rules),
@@ -202,7 +204,7 @@ public class HeapSimplificationMacro extends AbstractPropositionalExpansionMacro
 
 
     @Override
-    protected Set<String> getAdmittedRuleNames() {
+    protected Set<String> getAdmittedRuleNames(Proof proof) {
         return ADMITTED_RULES_SET;
     }
     
diff --git a/key/key.core/src/de/uka/ilkd/key/macros/IntegerSimplificationMacro.java b/key/key.core/src/de/uka/ilkd/key/macros/IntegerSimplificationMacro.java
index 7d71589ecf..9b755e0ee9 100644
--- a/key/key.core/src/de/uka/ilkd/key/macros/IntegerSimplificationMacro.java
+++ b/key/key.core/src/de/uka/ilkd/key/macros/IntegerSimplificationMacro.java
@@ -2,6 +2,8 @@ package de.uka.ilkd.key.macros;
 
 import java.util.Set;
 
+import de.uka.ilkd.key.proof.Proof;
+
 /**
  * This macro performs simplification of integers and terms with integers.
  * It applies only non-splitting simplification rules.
@@ -134,7 +136,7 @@ public class IntegerSimplificationMacro extends AbstractPropositionalExpansionMa
     });
 
     @Override
-    protected Set<String> getAdmittedRuleNames() {
+    protected Set<String> getAdmittedRuleNames(Proof proof) {
         return ADMITTED_RULES_SET;
     }
 
diff --git a/key/key.core/src/de/uka/ilkd/key/macros/PropositionalExpansionMacro.java b/key/key.core/src/de/uka/ilkd/key/macros/PropositionalExpansionMacro.java
index 9102dbbbfc..51cb219290 100644
--- a/key/key.core/src/de/uka/ilkd/key/macros/PropositionalExpansionMacro.java
+++ b/key/key.core/src/de/uka/ilkd/key/macros/PropositionalExpansionMacro.java
@@ -15,6 +15,8 @@ package de.uka.ilkd.key.macros;
 
 import java.util.Set;
 
+import de.uka.ilkd.key.proof.Proof;
+
 /**
  * The macro PropositionalExpansionMacro apply rules to decompose propositional
  * toplevel formulas; but does not split the goal.
@@ -49,7 +51,7 @@ public class PropositionalExpansionMacro extends AbstractPropositionalExpansionM
     private static final Set<String> ADMITTED_RULES_SET = asSet(ADMITTED_RULES);
 
     @Override
-    protected Set<String> getAdmittedRuleNames() {
+    protected Set<String> getAdmittedRuleNames(Proof proof) {
         return ADMITTED_RULES_SET;
     }
 
diff --git a/key/key.core/src/de/uka/ilkd/key/macros/PropositionalExpansionWithSimplificationMacro.java b/key/key.core/src/de/uka/ilkd/key/macros/PropositionalExpansionWithSimplificationMacro.java
index 1b8262677d..139f9f79ca 100644
--- a/key/key.core/src/de/uka/ilkd/key/macros/PropositionalExpansionWithSimplificationMacro.java
+++ b/key/key.core/src/de/uka/ilkd/key/macros/PropositionalExpansionWithSimplificationMacro.java
@@ -6,6 +6,8 @@ package de.uka.ilkd.key.macros;
 
 import java.util.Set;
 
+import de.uka.ilkd.key.proof.Proof;
+
 /**
  *
  * @author christoph
@@ -31,7 +33,7 @@ public class PropositionalExpansionWithSimplificationMacro extends AbstractPropo
     private static final Set<String> ADMITTED_RULES_SET = asSet(ADMITTED_RULES);
 
     @Override
-    protected Set<String> getAdmittedRuleNames() {
+    protected Set<String> getAdmittedRuleNames(Proof proof) {
         return ADMITTED_RULES_SET;
     }
 
diff --git a/key/key.core/src/de/uka/ilkd/key/macros/UpdateSimplificationMacro.java b/key/key.core/src/de/uka/ilkd/key/macros/UpdateSimplificationMacro.java
index 5f3bc8c8ce..b1bbf12628 100644
--- a/key/key.core/src/de/uka/ilkd/key/macros/UpdateSimplificationMacro.java
+++ b/key/key.core/src/de/uka/ilkd/key/macros/UpdateSimplificationMacro.java
@@ -4,6 +4,8 @@ import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
+import de.uka.ilkd.key.proof.Proof;
+
 /**
  * This macro applies only update simplification rules.
  * @author Richard Bubel
@@ -60,7 +62,7 @@ public class UpdateSimplificationMacro extends
 	}
 
 	@Override
-	protected Set<String> getAdmittedRuleNames() {
+    protected Set<String> getAdmittedRuleNames(Proof proof) {
 		return ADMITTED_RULE_NAMES_AS_SET;
 	}
 
diff --git a/key/key.core/src/de/uka/ilkd/key/proof/Node.java b/key/key.core/src/de/uka/ilkd/key/proof/Node.java
index f2446b0653..519ebb37a8 100644
--- a/key/key.core/src/de/uka/ilkd/key/proof/Node.java
+++ b/key/key.core/src/de/uka/ilkd/key/proof/Node.java
@@ -449,7 +449,17 @@ public class Node  {
             c += n.localIntroducedRules.size();
                       
             if (n.parent != null && n.parent.childrenCount() > 1) {
-               id.append(n.siblingNr);
+                // Appending the sibling number may fail if there's a rule app
+                // with a lot of siblings; say, a rule produces 10 siblings,
+                // then cannot be distinguished from two levels where we first
+                // visit the second and then the first sibling.
+                assert n.siblingNr < Character.MAX_RADIX :
+                    "Could fail in getting a unique taclet id "
+                  + "due to high sibling number " + n.siblingNr;
+
+                final String convertedSiblingNumber =
+                        Integer.toUnsignedString(n.siblingNr, Character.MAX_RADIX);
+                id.append(convertedSiblingNumber);
             }
             
             n = n.parent;
diff --git a/key/key.core/src/de/uka/ilkd/key/proof/Proof.java b/key/key.core/src/de/uka/ilkd/key/proof/Proof.java
index 2da28e56d9..ba945547df 100644
--- a/key/key.core/src/de/uka/ilkd/key/proof/Proof.java
+++ b/key/key.core/src/de/uka/ilkd/key/proof/Proof.java
@@ -778,6 +778,8 @@ public class Proof implements Named {
             return null;
         }
 
+        final String origBranchLabel = cuttingPoint.getNodeInfo().getBranchLabel();
+
         ProofPruner pruner = new ProofPruner();
         if (fireChanges) {
             fireProofIsBeingPruned(cuttingPoint);
@@ -787,6 +789,11 @@ public class Proof implements Named {
             fireProofGoalsChanged();
             fireProofPruned(cuttingPoint);
         }
+
+        // We have to reset the branch label, otherwise it will get lost when
+        // the NodeInfo is "refreshed" after pruning
+        cuttingPoint.getNodeInfo().setBranchLabel(origBranchLabel);
+
         return result;
     }
 
diff --git a/key/key.core/src/de/uka/ilkd/key/proof/init/AbstractOperationPO.java b/key/key.core/src/de/uka/ilkd/key/proof/init/AbstractOperationPO.java
index acf61e7e50..eb0af04019 100644
--- a/key/key.core/src/de/uka/ilkd/key/proof/init/AbstractOperationPO.java
+++ b/key/key.core/src/de/uka/ilkd/key/proof/init/AbstractOperationPO.java
@@ -95,6 +95,10 @@ import de.uka.ilkd.key.speclang.HeapContext;
  * @author Martin Hentschel
  */
 public abstract class AbstractOperationPO extends AbstractPO {
+    /**
+     * The name of the uninterpreted predicate for symbolic execution.
+     */
+    public static final String UNINTERPRETED_PREDICATE_NAME = "SETAccumulate";
    private static final String JAVA_LANG_THROWABLE = "java.lang.Throwable";
 
 /**
@@ -236,7 +240,8 @@ public abstract class AbstractOperationPO extends AbstractPO {
           // Add uninterpreted predicate
           if (isAddUninterpretedPredicate()) {
               postTerm = tb.and(postTerm,
-                      ensureUninterpretedPredicateExists(paramVars, formalParamVars, null, getUninterpretedPredicateName(), proofServices));
+                      ensureUninterpretedPredicateExists(paramVars, formalParamVars,
+                              resultVar, null, getUninterpretedPredicateName(), proofServices));
           }
 
           Term frameTerm = buildFrameClause(heaps, heapToBefore, selfVar, paramVars, proofServices);
@@ -391,8 +396,9 @@ public abstract class AbstractOperationPO extends AbstractPO {
          // Add uninterpreted predicate
          if (isAddUninterpretedPredicate()) {
             postTerm = tb.and(postTerm,
-                              ensureUninterpretedPredicateExists(paramVars, formalParamVars, exceptionVar,
-                                                          getUninterpretedPredicateName(), proofServices));
+                              ensureUninterpretedPredicateExists(paramVars,
+                              formalParamVars, resultVar, exceptionVar,
+                              getUninterpretedPredicateName(), proofServices));
          }
 
          Term frameTerm = buildFrameClause(modHeaps, heapToAtPre, selfVar, paramVars, proofServices);
@@ -693,19 +699,21 @@ public abstract class AbstractOperationPO extends AbstractPO {
     * @return The name of the uninterpreted predicate.
     */
    protected String getUninterpretedPredicateName() {
-      return "SETAccumulate";
+        return UNINTERPRETED_PREDICATE_NAME;
    }
 
    /**
     * Creates {@link #uninterpretedPredicate}.
     * @param paramVars The parameters {@link ProgramVariable}s.
     * @param formalParamVars The formal parameters {@link LocationVariable}s.
+    * @param resultVar The result variable.
     * @param exceptionVar The exception variable.
     * @param name The name of the uninterpreted predicate.
     * @return The created uninterpreted predicate.
     */
    protected Term ensureUninterpretedPredicateExists(ImmutableList<ProgramVariable> paramVars,
                                                      ImmutableList<LocationVariable> formalParamVars,
+                                                     ProgramVariable resultVar,
                                                      ProgramVariable exceptionVar,
                                                      String name,
                                                      Services services) {
@@ -713,36 +721,40 @@ public abstract class AbstractOperationPO extends AbstractPO {
       if (uninterpretedPredicate != null) {
          throw new IllegalStateException("The uninterpreted predicate is already available.");
       }
-      uninterpretedPredicate = createUninterpretedPredicate(formalParamVars, tb.var(exceptionVar), name, services);
+        uninterpretedPredicate = createUninterpretedPredicate(formalParamVars,
+              resultVar == null ? null : tb.var(resultVar), tb.var(exceptionVar), name, services);
       return uninterpretedPredicate;
    }
    
    /**
     * Creates a new uninterpreted predicate which is added to {@link #additionalUninterpretedPredicates}.
     * @param formalParamVars The formal parameters {@link LocationVariable}s.
+    * @param resultVar The result variable.
     * @param exceptionVar The exception variable.
     * @param name The name of the uninterpreted predicate.
     * @return The created uninterpreted predicate.
     */   
    protected Term newAdditionalUninterpretedPredicate(ImmutableList<LocationVariable> formalParamVars,
-                                                      Term exceptionVar,
+                                                      Term resultVar, Term exceptionVar,
                                                       String name,
                                                       Services services) {
-      Term up = createUninterpretedPredicate(formalParamVars, exceptionVar, name, services);
-      additionalUninterpretedPredicates.add(up);
-      return up;
+        Term up = createUninterpretedPredicate(formalParamVars,
+                resultVar, exceptionVar, name, services);
+        additionalUninterpretedPredicates.add(up);
+        return up;
    }
    
    /**
     * Creates a {@link Term} to use in the postcondition of the generated
     * {@link Sequent} which represents the uninterpreted predicate.
     * @param formalParamVars The formal parameters {@link LocationVariable}s.
+    * @param resultVar The result variable.
     * @param exceptionVar The exception variable.
     * @param name The name of the uninterpreted predicate.
     * @return The created uninterpreted predicate.
     */   
    protected Term createUninterpretedPredicate(ImmutableList<LocationVariable> formalParamVars,
-                                               Term exceptionVar,
+                                               Term resultVar, Term exceptionVar,
                                                String name,
                                                Services services) {
       // Create parameters for predicate SETAccumulate(HeapSort, MethodParameter1Sort, ... MethodParameterNSort)
@@ -750,6 +762,11 @@ public abstract class AbstractOperationPO extends AbstractPO {
       for (LocationVariable formalParam : formalParamVars) {
          arguments = arguments.prepend(tb.var(formalParam));
       }
+        if (resultVar != null) {
+            // There might not be a result variable, in the case of void methods
+            // Result variable (As third argument for the predicate)
+            arguments = arguments.prepend(resultVar);
+        }
       arguments = arguments.prepend(exceptionVar); // Exception variable (As second argument for the predicate)
       arguments = arguments.prepend(tb.getBaseHeap()); // Heap (As first argument for the predicate)
       // Create non-rigid predicate with signature: SETAccumulate(HeapSort, MethodParameter1Sort, ... MethodParameterNSort)
@@ -1081,19 +1098,24 @@ public abstract class AbstractOperationPO extends AbstractPO {
     * @param services The {@link Services} which provides the {@link Proof} and its {@link ProofOblInput}.
     * @param term The {@link Term} to modify.
     * @param variablesToProtect {@link LocationVariable}s to protect.
+    * @param resultVar The result variable.
     * @param exceptionVar The exception variable to protect.
     * @return The modified or original {@link Term}.
     */
    public static Term addAdditionalUninterpretedPredicateIfRequired(Services services, 
                                                                     Term term, 
-                                                                    ImmutableList<LocationVariable> variablesToProtect,
+                                                                    ImmutableList<LocationVariable>
+                                                                        variablesToProtect,
+                                                                    Term resultVar,
                                                                     Term exceptionVar) {
       ProofOblInput problem = services.getSpecificationRepository().getProofOblInput(services.getProof());
       if (problem instanceof AbstractOperationPO) {
          AbstractOperationPO operationPO = (AbstractOperationPO)problem;
-         if (operationPO.isAddUninterpretedPredicate()) {
-            Term up = operationPO.newAdditionalUninterpretedPredicate(variablesToProtect, exceptionVar, operationPO.getUninterpretedPredicateName(), services);
-            term = services.getTermBuilder().and(term, up);
+            if (operationPO.isAddUninterpretedPredicate()) {
+                Term up = operationPO.newAdditionalUninterpretedPredicate(variablesToProtect,
+                     resultVar, exceptionVar,
+                     operationPO.getUninterpretedPredicateName(), services);
+                term = services.getTermBuilder().and(term, up);
          }
       }
       return term;
diff --git a/key/key.core/src/de/uka/ilkd/key/proof/io/IntermediatePresentationProofFileParser.java b/key/key.core/src/de/uka/ilkd/key/proof/io/IntermediatePresentationProofFileParser.java
index aa66aa48fe..56e8112e55 100644
--- a/key/key.core/src/de/uka/ilkd/key/proof/io/IntermediatePresentationProofFileParser.java
+++ b/key/key.core/src/de/uka/ilkd/key/proof/io/IntermediatePresentationProofFileParser.java
@@ -499,8 +499,11 @@ public class IntermediatePresentationProofFileParser implements
         protected int currCorrespondingMergeNodeId = 0;
         protected int currMergeNodeId = 0;
         protected String currDistFormula = null;
-        protected Class<? extends AbstractPredicateAbstractionLattice> currPredAbstraLatticeType =
-                null;
+        /**
+         * The type of the lattice.
+         */
+        protected Class<? extends AbstractPredicateAbstractionLattice>
+                currPredAbstraLatticeType = null;
         protected String currAbstractionPredicates = null;
         public String currUserChoices = null;
 
diff --git a/key/key.core/src/de/uka/ilkd/key/proof/io/IntermediateProofReplayer.java b/key/key.core/src/de/uka/ilkd/key/proof/io/IntermediateProofReplayer.java
index 3a5ec4e5cd..d010d404d0 100644
--- a/key/key.core/src/de/uka/ilkd/key/proof/io/IntermediateProofReplayer.java
+++ b/key/key.core/src/de/uka/ilkd/key/proof/io/IntermediateProofReplayer.java
@@ -185,6 +185,13 @@ public class IntermediateProofReplayer {
                     assert currNodeInterm.getChildren()
                             .size() <= 1 : "Branch node should have exactly one child.";
                     if (currNodeInterm.getChildren().size() == 1) {
+                        final String branchTitle = ((BranchNodeIntermediate) currNodeInterm)
+                                .getBranchTitle();
+                        if (branchTitle != null && !branchTitle.isEmpty()
+                                && !branchTitle.equals(
+                                        OutputStreamProofSaver.DUMMY_ID_BRANCH_LABEL)) {
+                            currNode.getNodeInfo().setBranchLabel(branchTitle);
+                        }
                         queue.addFirst(new Pair<Node, NodeIntermediate>(
                                 currNode, currNodeInterm.getChildren().get(0)));
                     }
@@ -473,15 +480,16 @@ public class IntermediateProofReplayer {
         Services services = proof.getServices();
 
         if (currFormula != 0) { // otherwise we have no pos
-            try {
-                pos = PosInOccurrence.findInSequent(currGoal.sequent(),
-                        currFormula, currPosInTerm);
-                ourApp = ((NoPosTacletApp) ourApp).matchFind(pos, services);
-                ourApp = ourApp.setPosInOccurrence(pos, services);
-            } catch (Exception e) {
+            pos = PosInOccurrence.findInSequent(currGoal.sequent(),
+                    currFormula, currPosInTerm);
+            ourApp = ((NoPosTacletApp) ourApp).matchFind(pos, services);
+
+            if (ourApp == null) {
                 throw new TacletConstructionException(
                         "Wrong position information.");
             }
+
+            ourApp = ourApp.setPosInOccurrence(pos, services);
         }
 
         ourApp = constructInsts(ourApp, currGoal, currInterm.getInsts(),
diff --git a/key/key.core/src/de/uka/ilkd/key/proof/io/OutputStreamProofSaver.java b/key/key.core/src/de/uka/ilkd/key/proof/io/OutputStreamProofSaver.java
index cd2a3d6b98..22e38ad0a6 100644
--- a/key/key.core/src/de/uka/ilkd/key/proof/io/OutputStreamProofSaver.java
+++ b/key/key.core/src/de/uka/ilkd/key/proof/io/OutputStreamProofSaver.java
@@ -13,8 +13,6 @@
 
 package de.uka.ilkd.key.proof.io;
 
-import static de.uka.ilkd.key.proof.io.IProofFileParser.ProofElementID;
-
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintWriter;
@@ -53,6 +51,7 @@ import de.uka.ilkd.key.proof.Proof;
 import de.uka.ilkd.key.proof.init.IPersistablePO;
 import de.uka.ilkd.key.proof.init.Profile;
 import de.uka.ilkd.key.proof.init.ProofOblInput;
+import de.uka.ilkd.key.proof.io.IProofFileParser.ProofElementID;
 import de.uka.ilkd.key.proof.mgt.RuleJustification;
 import de.uka.ilkd.key.proof.mgt.RuleJustificationBySpec;
 import de.uka.ilkd.key.rule.IBuiltInRuleApp;
@@ -84,6 +83,10 @@ import de.uka.ilkd.key.util.MiscTools;
  */
 public class OutputStreamProofSaver {
 
+    /**
+     * TODO Comment.
+     */
+    static final String DUMMY_ID_BRANCH_LABEL = "dummy ID";
     protected final Proof proof;
     protected final String internalVersion;
 
@@ -548,7 +551,8 @@ public class OutputStreamProofSaver {
     public String node2Proof(Node node) {
         StringBuffer tree = new StringBuffer();
         String s =
-                "(branch \"dummy ID\"\n" + collectProof(node, "", tree) + ")\n";
+                "(branch \"" + DUMMY_ID_BRANCH_LABEL + "\"\n"
+                        + collectProof(node, "", tree) + ")\n";
         return s;
     }
 
diff --git a/key/key.core/src/de/uka/ilkd/key/rule/AbstractLoopInvariantRule.java b/key/key.core/src/de/uka/ilkd/key/rule/AbstractLoopInvariantRule.java
index 0f21b2d4b4..f9487536a3 100644
--- a/key/key.core/src/de/uka/ilkd/key/rule/AbstractLoopInvariantRule.java
+++ b/key/key.core/src/de/uka/ilkd/key/rule/AbstractLoopInvariantRule.java
@@ -25,20 +25,23 @@ import de.uka.ilkd.key.logic.TermServices;
 import de.uka.ilkd.key.logic.label.ParameterlessTermLabel;
 import de.uka.ilkd.key.logic.label.TermLabelState;
 import de.uka.ilkd.key.logic.op.Function;
+import de.uka.ilkd.key.logic.op.IProgramVariable;
 import de.uka.ilkd.key.logic.op.LocationVariable;
 import de.uka.ilkd.key.logic.op.Modality;
+import de.uka.ilkd.key.logic.op.ProgramMethod;
 import de.uka.ilkd.key.logic.op.ProgramVariable;
 import de.uka.ilkd.key.logic.op.Transformer;
 import de.uka.ilkd.key.logic.op.UpdateApplication;
 import de.uka.ilkd.key.logic.sort.Sort;
 import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.Node;
 import de.uka.ilkd.key.speclang.LoopSpecification;
 import de.uka.ilkd.key.util.MiscTools;
 import de.uka.ilkd.key.util.Pair;
 
 /**
  * An abstract super class for loop invariant rules. Extending rules should
- * usually call {@link #doPreparations(Goal, Services, RuleApp)} directly at the
+ * usually call {@link #doPreparationsAndSplit(Goal, Services, RuleApp)} directly at the
  * beginning of the {@link #apply(Goal, Services, RuleApp)} method.
  *
  * @see LoopScopeInvariantRule
@@ -79,9 +82,39 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
      *            the rule application to be executed
      * @return The {@link LoopInvariantInformation} object containing the data
      *         for the application of loop invariant rules.
-     * @throws RuleAbortException
+     * @throws RuleAbortException If the {@link LoopInvariantBuiltInRuleApp} does not contain a
+     *             {@link LoopSpecification}.
+     */
+    protected LoopInvariantInformation doPreparationsAndSplit(Goal goal, Services services,
+            RuleApp ruleApp) throws RuleAbortException {
+
+        LoopInvariantInformation inf = doPreparations(goal.node(), services, ruleApp);
+
+        // Prepare the new goals
+        ImmutableList<Goal> goals = goal.split(getNrOfGoals());
+
+        inf.goal = goal;
+        inf.goals = goals;
+
+        return inf;
+    }
+
+    /**
+     * Constructs the data needed for the currently implemented loop invariants.
+     *
+     * @param node
+     *            the {@link Node} on which to apply <tt>ruleApp</tt>
+     * @param services
+     *            the Services with the necessary information about the java
+     *            programs
+     * @param ruleApp
+     *            the rule application to be executed
+     * @return The {@link LoopInvariantInformation} object containing the data
+     *         for the application of loop invariant rules.
+     * @throws RuleAbortException If the {@link LoopInvariantBuiltInRuleApp} does not contain a
+     *             {@link LoopSpecification}.
      */
-    public LoopInvariantInformation doPreparations(Goal goal, Services services,
+    public LoopInvariantInformation doPreparations(Node node, Services services,
             RuleApp ruleApp) throws RuleAbortException {
         // Basic objects needed for rule application
         final TermBuilder tb = services.getTermBuilder();
@@ -96,9 +129,10 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
         final List<LocationVariable> heapContext = ((IBuiltInRuleApp) ruleApp)
                 .getHeapContext();
 
-        final Term invTerm = conjunctInv(services, inst, atPres, heapContext);
+        final Term invTerm = conjunctInv(services, heapContext, inst.inv,
+            inst.progPost.javaBlock());
         final Term invFreeTerm = conjunctFreeInv(services, inst, atPres,
-                heapContext);
+            heapContext);
 
         // Collect input and output local variables,
         // prepare reachableOut.
@@ -137,14 +171,13 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
         final Term[] uBeforeLoopDefAnonVariant = new Term[] { inst.u,
                 beforeLoopUpdate, additionalHeapTerms.anonUpdate,
                 variantUpdate };
-        final Term uAnonInv = tb.applySequential(uAnon,
-                tb.and(tb.and(invTerm, reachableOut), invFreeTerm));
+        final Term uAnonInv = tb.label(
+                tb.applySequential(uAnon,
+                        tb.and(tb.and(invTerm, reachableOut), invFreeTerm)),
+                ParameterlessTermLabel.LOOP_INV_ANON_LABEL);
 
-        // Prepare the new goals
-        ImmutableList<Goal> goals = goal.split(getNrOfGoals());
-
-        return new LoopInvariantInformation(goal, services, inst, loopRuleApp,
-                goals, termLabelState, invTerm, variantPO,
+        return new LoopInvariantInformation(null, services, inst, loopRuleApp,
+                null, termLabelState, invTerm, variantPO,
                 additionalHeapTerms.reachableState,
                 additionalHeapTerms.anonUpdate,
                 additionalHeapTerms.wellFormedAnon, uAnonInv,
@@ -206,7 +239,7 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
             final ImmutableSet<ProgramVariable> localOuts,
             final Map<LocationVariable, Map<Term, Term>> heapToBeforeLoop) {
         final TermBuilder tb = services.getTermBuilder();
-        final Namespace progVarNS = services.getNamespaces().programVariables();
+        final Namespace<IProgramVariable> progVarNS = services.getNamespaces().programVariables();
 
         Term beforeLoopUpdate = null;
         for (LocationVariable heap : heapContext) {
@@ -272,20 +305,24 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
      * 
      * @param services
      *            The {@link Services} object.
-     * @param inst
-     *            The {@link Instantiation} for this rule application.
      * @param atPres
      *            TODO
      * @param heapContext
      *            The heap formulas to create a conjunction of invariants for.
+     * @param loopSpec
+     *            TODO
+     * @param javaBlock
+     *            TODO
      * @return A conjunction of all invariant formulas for the
      *         {@link LocationVariable}s in heapContext.
      */
-    protected static Term conjunctInv(Services services, Instantiation inst,
-            final Map<LocationVariable, Term> atPres,
-            final List<LocationVariable> heapContext) {
-        return mapAndConjunct(services, (pv -> inst.inv.getInvariant(pv,
-                inst.selfTerm, atPres, services)), heapContext);
+    public static Term conjunctInv(Services services,
+            final List<LocationVariable> heapContext,
+            LoopSpecification loopSpec, JavaBlock javaBlock) {
+        return mapAndConjunct(services,
+            (pv -> loopSpec.getInvariant(pv, getSelfTerm(javaBlock, services),
+                loopSpec.getInternalAtPres(), services)),
+            heapContext);
     }
 
     /**
@@ -458,27 +495,19 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
         // active statement must be while loop
         final While loop = app.getLoopStatement();
 
-        // try to get invariant from JML specification
-        LoopSpecification spec = app.getSpec();
-        if (spec == null) { // may happen after reloading proof
-            throw new RuleAbortException(
-                    "No invariant found. Probably broken after proof reloading...");
-        }
-
         // collect self, execution context
         final MethodFrame innermostMethodFrame = JavaTools
                 .getInnermostMethodFrame(progPost.javaBlock(), services);
-        if (innermostMethodFrame != null) {
-            spec = spec.setTarget(innermostMethodFrame.getProgramMethod());
-        }
-
-        final Term selfTerm = innermostMethodFrame == null ? null
-                : MiscTools.getSelfTerm(innermostMethodFrame, services);
 
         final ExecutionContext innermostExecutionContext = //
                 innermostMethodFrame == null ? null
                         : (ExecutionContext) innermostMethodFrame
                                 .getExecutionContext();
+
+        final Term selfTerm = getSelfTerm(progPost.javaBlock(), services);
+
+        // try to get invariant from JML specification
+        LoopSpecification spec = getInvariant(app, progPost.javaBlock(), services);
         services.getSpecificationRepository().addLoopInvariant(spec);
 
         // cache and return result
@@ -491,6 +520,51 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
         return result;
     }
 
+    /**
+     * Returns the self {@link Term} for a {@link JavaBlock}.
+     *
+     * @param javaBlock
+     * @param services
+     * @return
+     */
+    private static Term getSelfTerm(JavaBlock javaBlock, Services services) {
+        final MethodFrame innermostMethodFrame = JavaTools
+                .getInnermostMethodFrame(javaBlock, services);
+
+        return innermostMethodFrame == null ? null
+                : MiscTools.getSelfTerm(
+                    JavaTools.getInnermostMethodFrame(javaBlock, services),
+                    services);
+    }
+
+    /**
+     * Retrieves the {@link LoopSpecification} from the app and sets the target
+     * to the current {@link ProgramMethod}.
+     *
+     * @param app
+     * @param innermostMethodFrame
+     * @return
+     * @throws RuleAbortException
+     */
+    private static LoopSpecification getInvariant(
+            final LoopInvariantBuiltInRuleApp app, final JavaBlock javaBlock,
+            Services services) throws RuleAbortException {
+        final MethodFrame innermostMethodFrame = JavaTools
+                .getInnermostMethodFrame(javaBlock, services);
+        LoopSpecification spec = app.getSpec();
+
+        if (spec == null) { // may happen after reloading proof
+            throw new RuleAbortException(
+                "No invariant found. Probably broken after proof reloading...");
+        }
+
+        if (innermostMethodFrame != null) {
+            spec = spec.setTarget(innermostMethodFrame.getProgramMethod());
+        }
+
+        return spec;
+    }
+
     /**
      * Computes the anonymizing update, the loop heap, the base heap, and the
      * anonymized heap.
@@ -644,7 +718,7 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
      * {@link While} loop the {@link LoopScopeInvariantRule} should be applied
      * to, the {@link LoopSpecification}, the the self {@link Term}.
      */
-    protected static final class Instantiation {
+    public static final class Instantiation {
         public final Term u;
         public final Term progPost;
         public final While loop;
@@ -693,9 +767,9 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
      * A container object containing the information required for the concrete
      * loop invariant rules to create the sequents for the new goals.
      */
-    protected static class LoopInvariantInformation {
+    public static class LoopInvariantInformation {
         /** The original goal. */
-        public final Goal goal;
+        public Goal goal;
 
         /** The {@link Services} object. */
         public final Services services;
@@ -716,7 +790,7 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
          * The goals created by the invariant rules application; those are
          * filled with content by the concrete loop invariant rules.
          */
-        public final ImmutableList<Goal> goals;
+        public ImmutableList<Goal> goals;
 
         /** The {@link TermLabelState}. */
         public final TermLabelState termLabelState;
@@ -804,7 +878,6 @@ public abstract class AbstractLoopInvariantRule implements BuiltInRule {
                 Term anonUpdate, Term wellFormedAnon, Term uAnonInv,
                 Term frameCondition, Term[] uBeforeLoopDefAnonVariant,
                 ImmutableList<AnonUpdateData> anonUpdateData) {
-            super();
             this.goal = goal;
             this.services = services;
             this.inst = inst;
diff --git a/key/key.core/src/de/uka/ilkd/key/rule/BlockContractRule.java b/key/key.core/src/de/uka/ilkd/key/rule/BlockContractRule.java
index 3a03a6673a..f1166ffab4 100644
--- a/key/key.core/src/de/uka/ilkd/key/rule/BlockContractRule.java
+++ b/key/key.core/src/de/uka/ilkd/key/rule/BlockContractRule.java
@@ -1179,7 +1179,11 @@ public class BlockContractRule implements BuiltInRule {
             StatementBlock finishedBlock = finishTransactionIfModalityIsTransactional(wrappedBlock);
             JavaBlock newJavaBlock = JavaBlock.createJavaBlock(finishedBlock);
             Term newPost = tb.and(postconditions);
-            newPost = AbstractOperationPO.addAdditionalUninterpretedPredicateIfRequired(services, newPost, ImmutableSLList.<LocationVariable>nil().prepend(terms.remembranceLocalVariables.keySet()), terms.exception);
+            newPost = AbstractOperationPO.addAdditionalUninterpretedPredicateIfRequired(
+                    services, newPost,
+                    ImmutableSLList.<LocationVariable>nil().prepend(
+                            terms.remembranceLocalVariables.keySet()),
+                    null, terms.exception);
             newPost = TermLabelManager.refactorTerm(termLabelState, services, null, newPost, rule, goal, BlockContractRule.NEW_POSTCONDITION_TERM_HINT, null);
             goal.changeFormula(new SequentFormula(
                   tb.applySequential(
diff --git a/key/key.core/src/de/uka/ilkd/key/rule/LoopScopeInvariantRule.java b/key/key.core/src/de/uka/ilkd/key/rule/LoopScopeInvariantRule.java
index 257430a0ba..0d508a6503 100644
--- a/key/key.core/src/de/uka/ilkd/key/rule/LoopScopeInvariantRule.java
+++ b/key/key.core/src/de/uka/ilkd/key/rule/LoopScopeInvariantRule.java
@@ -5,32 +5,27 @@ import java.util.Optional;
 
 import org.key_project.util.collection.ImmutableArray;
 import org.key_project.util.collection.ImmutableList;
+import org.key_project.util.collection.ImmutableSLList;
 
 import de.uka.ilkd.key.informationflow.proof.InfFlowCheckInfo;
-import de.uka.ilkd.key.java.KeYJavaASTFactory;
-import de.uka.ilkd.key.java.Label;
-import de.uka.ilkd.key.java.ProgramElement;
-import de.uka.ilkd.key.java.Services;
-import de.uka.ilkd.key.java.Statement;
-import de.uka.ilkd.key.java.StatementBlock;
+import de.uka.ilkd.key.java.*;
 import de.uka.ilkd.key.java.abstraction.KeYJavaType;
 import de.uka.ilkd.key.java.statement.LabeledStatement;
 import de.uka.ilkd.key.java.statement.LoopScopeBlock;
 import de.uka.ilkd.key.java.statement.While;
 import de.uka.ilkd.key.java.visitor.ProgramElementReplacer;
-import de.uka.ilkd.key.logic.JavaBlock;
-import de.uka.ilkd.key.logic.Name;
-import de.uka.ilkd.key.logic.PosInOccurrence;
-import de.uka.ilkd.key.logic.ProgramPrefix;
-import de.uka.ilkd.key.logic.SequentFormula;
-import de.uka.ilkd.key.logic.Term;
-import de.uka.ilkd.key.logic.TermBuilder;
+import de.uka.ilkd.key.logic.*;
 import de.uka.ilkd.key.logic.label.ParameterlessTermLabel;
 import de.uka.ilkd.key.logic.label.TermLabelManager;
 import de.uka.ilkd.key.logic.label.TermLabelState;
+import de.uka.ilkd.key.logic.op.LocationVariable;
 import de.uka.ilkd.key.logic.op.Modality;
 import de.uka.ilkd.key.logic.op.ProgramVariable;
 import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.init.AbstractOperationPO;
+import de.uka.ilkd.key.proof.init.ContractPO;
+import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
+import de.uka.ilkd.key.speclang.FunctionalOperationContract;
 import de.uka.ilkd.key.speclang.WellDefinednessCheck;
 import de.uka.ilkd.key.util.Pair;
 
@@ -75,28 +70,42 @@ import de.uka.ilkd.key.util.Pair;
  * @author Dominic Scheurer
  */
 public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
-    /**
-     * The number of goals generated by the {@link LoopScopeInvariantRule}.
-     */
-    private static final int NR_GOALS = 2;
 
     /**
      * The Singleton instance of {@link LoopScopeInvariantRule}.
      */
-    public static final LoopScopeInvariantRule INSTANCE = new LoopScopeInvariantRule();
+    public static final LoopScopeInvariantRule INSTANCE =
+            new LoopScopeInvariantRule();
 
     /**
      * The hint used to refactor the initial invariant.
      */
-    public static final String INITIAL_INVARIANT_ONLY_HINT = "onlyInitialInvariant";
+    public static final String INITIAL_INVARIANT_ONLY_HINT =
+            "onlyInitialInvariant";
 
     /**
      * The hint used to refactor the full invariant.
      */
     public static final String FULL_INVARIANT_TERM_HINT = "fullInvariant";
 
+    /**
+     * The hint used to refactor the full invariant.
+     */
+    public static final String ANON_INVARIANT_TERM_HINT = "anonInvariant";
+
+    /**
+     * The branch label for the initially valid branch.
+     */
+    public static final String INVARIANT_INITIALLY_VALID_BRANCH_LABEL =
+            "Invariant Initially Valid";
+
     private static final Name NAME = new Name("Loop (Scope) Invariant");
 
+    /**
+     * The number of goals generated by the {@link LoopScopeInvariantRule}.
+     */
+    private static final int NR_GOALS = 2;
+
     @Override
     public Name name() {
         return NAME;
@@ -127,9 +136,11 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
         final Modality modality = (Modality) progPost.op();
 
         return !InfFlowCheckInfo.isInfFlow(goal)
-                && !WellDefinednessCheck.isOn() // TODO: Remove when wd goal is integrated,
-                                                //  otherwise loop invariant rule would be unsound
-                                                //  w.r.t. well-definedness
+                && !WellDefinednessCheck.isOn() // TODO: Remove when wd goal is
+                                                // integrated,
+                                                // otherwise loop invariant rule
+                                                // would be unsound
+                                                // w.r.t. well-definedness
                 && !(modality == Modality.BOX_TRANSACTION
                         || modality == Modality.DIA_TRANSACTION);
     }
@@ -140,8 +151,9 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
         // Initial assertions
         assert ruleApp instanceof LoopInvariantBuiltInRuleApp;
 
-        LoopInvariantInformation loopInvInfo = doPreparations(goal, services,
-                ruleApp);
+        LoopInvariantInformation loopInvInfo =
+                doPreparationsAndSplit(goal, services,
+                        ruleApp);
 
         ImmutableList<Goal> goals = loopInvInfo.goals;
         Goal initiallyGoal = goals.tail().head();
@@ -204,7 +216,7 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
     private void constructInitiallyGoal(Services services, RuleApp ruleApp,
             final TermLabelState termLabelState, Goal initiallyGoal,
             final Instantiation inst, final Term invTerm, Term reachableState) {
-        initiallyGoal.setBranchLabel("Invariant Initially Valid");
+        initiallyGoal.setBranchLabel(INVARIANT_INITIALLY_VALID_BRANCH_LABEL);
         initiallyGoal
                 .changeFormula(
                         initFormula(termLabelState, inst, invTerm,
@@ -260,15 +272,21 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
             Term[] uBeforeLoopDefAnonVariant) {
         final While loop = inst.loop;
 
+        presrvAndUCGoal.setBranchLabel("Invariant Preserved and Used");
+
         final Term newFormula = formulaWithLoopScope(services, inst, anonUpdate,
                 loop, loopLabel, stmtToReplace, frameCondition, variantPO,
                 termLabelState, presrvAndUCGoal, uBeforeLoopDefAnonVariant,
                 invTerm);
 
-        presrvAndUCGoal.setBranchLabel("Invariant Preserved and Used");
-        presrvAndUCGoal.addFormula(new SequentFormula(uAnonInv), true, false);
+        final Term labeledUAnonInv = TermLabelManager.refactorTerm(
+                termLabelState, services, null, uAnonInv, this, presrvAndUCGoal,
+                ANON_INVARIANT_TERM_HINT, null);
+
         presrvAndUCGoal.addFormula(new SequentFormula(wellFormedAnon), true,
                 false);
+        presrvAndUCGoal.addFormula(new SequentFormula(labeledUAnonInv), true,
+                false);
         presrvAndUCGoal.changeFormula(new SequentFormula(newFormula),
                 ruleApp.posInOccurrence());
     }
@@ -329,10 +347,10 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
         } else {
             stmnt.add(loop.getBody());
         }
-        
+
         // If this assignment of "false" to the loop scope index is reached, we
         // are in the standard "preserved" case and have to show the invariant.
-        
+
         stmnt.add(KeYJavaASTFactory.assign(loopScopeIdxVar,
                 KeYJavaASTFactory.falseLiteral()));
 
@@ -358,7 +376,7 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
         // differs from Nathan Wasser's thesis and the paper on loop scope
         // invariants, where we instead use an artificial "continue" statement.
         // We wanted to get rid of this.
-        
+
         final StatementBlock newBlock = KeYJavaASTFactory
                 .block(KeYJavaASTFactory.declare(loopScopeIdxVar,
                         KeYJavaASTFactory.trueLiteral()), loopScope);
@@ -445,6 +463,11 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
         final Term progPost = splitUpdates(inst.progPost, services).second;
 
         Term fullInvariant = tb.and(invTerm, frameCondition, variantPO);
+
+        // Add uninterpreted SE predicate if required; this will, not as in the
+        // standard, also contain local out variables of the loop.
+        fullInvariant = addUninterpretedPredicateWithLocalOuts(services,
+                inst.inv.getLocalOuts(), fullInvariant);
         fullInvariant = TermLabelManager.refactorTerm(termLabelState, services,
                 null, fullInvariant, this, presrvAndUCGoal,
                 FULL_INVARIANT_TERM_HINT, null);
@@ -454,6 +477,8 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
         final JavaBlock origJavaBlock = progPost.javaBlock();
 
         final ProgramVariable loopScopeIdxVar = loopScopeIdxVar(services);
+        presrvAndUCGoal.getLocalNamespaces().programVariables()
+                .add(loopScopeIdxVar);
 
         final ProgramElement newProg = newProgram(services, loop, loopLabel,
                 stmtToReplace, origJavaBlock, loopScopeIdxVar);
@@ -476,6 +501,69 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
         return newFormula;
     }
 
+    /**
+     * Adds the "SETAccumulate(...)" uninterpreted predicate. The predicate will
+     * also contain the "localOuts", that is, the assignable fields / variables
+     * of the loop body. That way, a also the final values for these variables
+     * can in any case be analyzed, independently of whether they're used in the
+     * post condition / after the loop, or not.
+     * <p>
+     * NOTE: If the current {@link ContractPO} is not a
+     * {@link FunctionalOperationContractPO}, we will leave out the local outs.
+     *
+     * @param services
+     *            The {@link Services} object.
+     * @param localOuts
+     *            The location variables the loop body may write to.
+     * @param fullInvariant
+     *            The invariant {@link Term} to which to append the
+     *            SETAccumulate predicate.
+     * @return The fullInvariant term with an additional conjunct containing the
+     *         SETAccumulate predicate.
+     */
+    private Term addUninterpretedPredicateWithLocalOuts(Services services,
+            final ImmutableList<Term> localOuts,
+            Term fullInvariant) {
+        final TermBuilder tb = services.getTermBuilder();
+
+        // Protected variables: Heap and localOuts
+        ImmutableList<LocationVariable> variablesToProtect =
+                ImmutableSLList.<LocationVariable> nil();
+
+        for (final Term localOut : localOuts) {
+            variablesToProtect =
+                    variablesToProtect.append((LocationVariable) localOut.op());
+        }
+
+        // Result variable
+        final ContractPO contractPO = services.getSpecificationRepository()
+                .getContractPOForProof(services.getProof());
+
+        if (contractPO == null
+                || !(contractPO instanceof FunctionalOperationContractPO)) {
+            // Unexpected PO type, fallback to standard predicate.
+            return AbstractOperationPO.addUninterpretedPredicateIfRequired(
+                    services, fullInvariant);
+        }
+
+        final FunctionalOperationContract fContract = //
+                ((FunctionalOperationContractPO) contractPO).getContract();
+
+        final LocationVariable resultVar =
+                (LocationVariable) services.getNamespaces()
+                        .programVariables()
+                        .lookup(fContract.getResult().op().name());
+
+        // Exception variable
+        final Term exceptionVar = fContract.getExc();
+
+        return AbstractOperationPO
+                .addAdditionalUninterpretedPredicateIfRequired(services,
+                        fullInvariant, variablesToProtect,
+                        resultVar == null ? null : tb.var(resultVar),
+                        exceptionVar);
+    }
+
     /**
      * If the {@link While} loop has a loop label, returns this and the labeled
      * statement. Otherwise, returns an empty {@link Optional} and the given
@@ -492,16 +580,19 @@ public class LoopScopeInvariantRule extends AbstractLoopInvariantRule {
         Optional<Label> loopLabel = Optional.empty();
         Statement stmtToRepl = whileLoop;
 
-        ImmutableArray<ProgramPrefix> prefixElems = ((StatementBlock) TermBuilder
-                .goBelowUpdates(ruleApp.posInOccurrence().subTerm()).javaBlock()
-                .program()).getPrefixElements();
+        ImmutableArray<ProgramPrefix> prefixElems =
+                ((StatementBlock) TermBuilder
+                        .goBelowUpdates(ruleApp.posInOccurrence().subTerm())
+                        .javaBlock()
+                        .program()).getPrefixElements();
 
         if (prefixElems.size() > 0
                 && (prefixElems.last() instanceof LabeledStatement)
                 && ((LabeledStatement) prefixElems.last()).getBody()
                         .equals(whileLoop)) {
-            final LabeledStatement lastLabeledStmt = (LabeledStatement) prefixElems
-                    .last();
+            final LabeledStatement lastLabeledStmt =
+                    (LabeledStatement) prefixElems
+                            .last();
             loopLabel = Optional.of(lastLabeledStmt.getLabel());
             stmtToRepl = lastLabeledStmt.getBody();
         }
diff --git a/key/key.core/src/de/uka/ilkd/key/speclang/LoopSpecImpl.java b/key/key.core/src/de/uka/ilkd/key/speclang/LoopSpecImpl.java
index b77c7f1ed6..25d85746f5 100644
--- a/key/key.core/src/de/uka/ilkd/key/speclang/LoopSpecImpl.java
+++ b/key/key.core/src/de/uka/ilkd/key/speclang/LoopSpecImpl.java
@@ -178,6 +178,11 @@ public final class LoopSpecImpl implements LoopSpecification {
         return loop;
     }
 
+    @Override
+    public ImmutableList<Term> getLocalOuts() {
+        return localOuts;
+    }
+
     @Override    
     public Term getInvariant(LocationVariable heap,
                              Term selfTerm,
diff --git a/key/key.core/src/de/uka/ilkd/key/speclang/LoopSpecification.java b/key/key.core/src/de/uka/ilkd/key/speclang/LoopSpecification.java
index d23fc2a5e5..13ea881a23 100644
--- a/key/key.core/src/de/uka/ilkd/key/speclang/LoopSpecification.java
+++ b/key/key.core/src/de/uka/ilkd/key/speclang/LoopSpecification.java
@@ -197,4 +197,9 @@ public interface LoopSpecification extends SpecificationElement {
      */
     public OriginalVariables getOrigVars();
 
+    /**
+     * @return The variables that are modified in the loop and visible to the outside.
+     */
+    ImmutableList<Term> getLocalOuts();
+
 }
\ No newline at end of file
diff --git a/key/key.core/src/de/uka/ilkd/key/util/mergerule/MergeRuleUtils.java b/key/key.core/src/de/uka/ilkd/key/util/mergerule/MergeRuleUtils.java
index 3a7246a20f..6d4e56eee7 100644
--- a/key/key.core/src/de/uka/ilkd/key/util/mergerule/MergeRuleUtils.java
+++ b/key/key.core/src/de/uka/ilkd/key/util/mergerule/MergeRuleUtils.java
@@ -44,6 +44,7 @@ import de.uka.ilkd.key.logic.JavaBlock;
 import de.uka.ilkd.key.logic.Name;
 import de.uka.ilkd.key.logic.Namespace;
 import de.uka.ilkd.key.logic.NamespaceSet;
+import de.uka.ilkd.key.logic.OpCollector;
 import de.uka.ilkd.key.logic.PosInOccurrence;
 import de.uka.ilkd.key.logic.PosInTerm;
 import de.uka.ilkd.key.logic.ProgramElementName;
@@ -70,6 +71,7 @@ import de.uka.ilkd.key.parser.KeYLexerF;
 import de.uka.ilkd.key.parser.KeYParserF;
 import de.uka.ilkd.key.parser.ParserException;
 import de.uka.ilkd.key.parser.ParserMode;
+import de.uka.ilkd.key.pp.LogicPrinter;
 import de.uka.ilkd.key.proof.ApplyStrategy.ApplyStrategyInfo;
 import de.uka.ilkd.key.proof.Goal;
 import de.uka.ilkd.key.proof.Node;
@@ -202,6 +204,30 @@ public class MergeRuleUtils {
         }
     }
 
+    /**
+     * Translates a String into a formula or to null if not applicable.
+     *
+     * @param services
+     *            The services object.
+     * @param namespaces
+     *            The (usually local) {@link NamespaceSet} to use for parsing.
+     * @param toTranslate
+     *            The formula to be translated.
+     * @return The formula represented by the input or null if not applicable.
+     */
+    public static Term translateToFormula(final Services services,
+            NamespaceSet namespaces, final String toTranslate) {
+        try {
+            final KeYParserF parser = new KeYParserF(ParserMode.TERM,
+                    new KeYLexerF(new StringReader(toTranslate), ""), services,
+                    namespaces);
+            final Term result = parser.term();
+            return result.sort() == Sort.FORMULA ? result : null;
+        } catch (Throwable e) {
+            return null;
+        }
+    }
+
     /**
      * @param u
      *            The update (in normal form) to extract program locations from.
@@ -311,6 +337,13 @@ public class MergeRuleUtils {
 
         if (term.op() instanceof LocationVariable) {
             result.add((LocationVariable) term.op());
+        } else if (term.op() instanceof ElementaryUpdate) {
+            if (((ElementaryUpdate) term.op())
+                    .lhs() instanceof LocationVariable) {
+                result.add((LocationVariable) ((ElementaryUpdate) term.op())
+                        .lhs());
+            }
+            result.addAll(getLocationVariablesHashSet(term.sub(0), services));
         } else {
             if (!term.javaBlock().isEmpty()) {
                 result.addAll(getProgramLocationsHashSet(term, services));
@@ -1376,41 +1409,43 @@ public class MergeRuleUtils {
                 final Operator mergeStateOp = thisGoalSymbols.parallelStream()
                         .filter(s -> s.name().equals(partnerStateOp.name()))
                         .collect(Collectors.toList()).get(0);
-                
+
                 Operator newOp1;
                 Operator newOp2;
                 if (partnerStateOp instanceof Function) {
-                    newOp1 = ((Function) mergeStateOp)
-                            .rename(new Name(tb.newName(partnerStateOp.name().toString(),
+                    newOp1 = ((Function) mergeStateOp).rename(new Name(
+                            tb.newName(partnerStateOp.name().toString(),
                                     thisGoal.getLocalNamespaces())));
                     thisGoalNamespaces.functions().add((Function) newOp1);
                     thisGoalNamespaces.flushToParent();
 
-                    newOp2 = ((Function) partnerStateOp)
-                            .rename(new Name(tb.newName(partnerStateOp.name().toString(),
+                    newOp2 = ((Function) partnerStateOp).rename(new Name(
+                            tb.newName(partnerStateOp.name().toString(),
                                     thisGoal.getLocalNamespaces())));
                     thisGoalNamespaces.functions().add((Function) newOp2);
                     thisGoalNamespaces.flushToParent();
                 } else if (partnerStateOp instanceof LocationVariable) {
-                    newOp1 = ((LocationVariable) mergeStateOp)
-                            .rename(new Name(tb.newName(partnerStateOp.name().toString(),
+                    newOp1 = ((LocationVariable) mergeStateOp).rename(new Name(
+                            tb.newName(partnerStateOp.name().toString(),
                                     thisGoal.getLocalNamespaces())));
                     thisGoalNamespaces.programVariables()
                             .add((LocationVariable) newOp1);
                     thisGoalNamespaces.flushToParent();
 
                     newOp2 = ((LocationVariable) partnerStateOp)
-                            .rename(new Name(tb.newName(partnerStateOp.name().toString(),
-                                    thisGoal.getLocalNamespaces())));
+                            .rename(new Name(
+                                    tb.newName(partnerStateOp.name().toString(),
+                                            thisGoal.getLocalNamespaces())));
                     thisGoalNamespaces.programVariables()
                             .add((LocationVariable) newOp2);
                     thisGoalNamespaces.flushToParent();
                 } else {
                     throw new RuntimeException(
                             "MergeRule: Unexpected type of Operator involved in name clash: "
-                                    + partnerStateOp.getClass().getSimpleName());
+                                    + partnerStateOp.getClass()
+                                            .getSimpleName());
                 }
-                
+
                 mergeState = new SymbolicExecutionState(
                         OpReplacer.replace(mergeStateOp, newOp1,
                                 mergeState.getSymbolicState(), tb.tf()),
@@ -1807,6 +1842,23 @@ public class MergeRuleUtils {
         final Proof proof = proofResult.getProof();
         boolean result = proof.closed();
 
+        // XXX Remove -->
+        if (!result) {
+            for (Goal g : proof.openGoals()) {
+                Set<Operator> ops = new HashSet<>();
+                for (SequentFormula sf : g.node().sequent()) {
+                    OpCollector opColl = new OpCollector();
+                    sf.formula().execPostOrder(opColl);
+                    ops.addAll(opColl.ops());
+                }
+
+                System.out.println(
+                        LogicPrinter.quickPrintSequent(g.sequent(), services));
+                System.out.println();
+            }
+        }
+        // XXX <-- Remove
+
         return result;
 
     }
diff --git a/key/key.specstrength.test/.classpath b/key/key.specstrength.test/.classpath
new file mode 100644
index 0000000000..242bb81cda
--- /dev/null
+++ b/key/key.specstrength.test/.classpath
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="resources/testcase/analyzer/squareRootInt"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
+	<classpathentry kind="lib" path="/home/dscheurer/key-workspace/GIT_master/key/key/key.specstrength/lib/log4j-api-2.6.2.jar"/>
+	<classpathentry kind="lib" path="/home/dscheurer/key-workspace/GIT_master/key/key/key.specstrength/lib/log4j-core-2.6.2.jar"/>
+	<classpathentry kind="lib" path="lib/junit-4.12.jar"/>
+	<classpathentry kind="lib" path="lib/hamcrest-all-1.3.jar"/>
+	<classpathentry kind="src" path="/key.util"/>
+	<classpathentry kind="src" path="/key.specstrength"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/key.core"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/key/key.specstrength.test/.project b/key/key.specstrength.test/.project
new file mode 100644
index 0000000000..197a5611c2
--- /dev/null
+++ b/key/key.specstrength.test/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>key.specstrength.test</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/key/key.specstrength.test/.settings/org.eclipse.jdt.core.prefs b/key/key.specstrength.test/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000000..3a21537071
--- /dev/null
+++ b/key/key.specstrength.test/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/key/key.specstrength.test/build.xml b/key/key.specstrength.test/build.xml
new file mode 100644
index 0000000000..d8e90c3613
--- /dev/null
+++ b/key/key.specstrength.test/build.xml
@@ -0,0 +1,73 @@
+<?xml version="1.0"?>
+<project name="key.specstrength.test" default="runTests" basedir=".">
+	<property name="src.dir" value="${basedir}/src" />
+	<property name="build.dir" value="${basedir}/bin" />
+	<property name="dist.dir" value="${basedir}/../deployment/components" />
+	<property name="ext.dir" value="${basedir}/lib" />
+	<property name="specstrength.ext.dir" value="${basedir}/../key.specstrength/lib" />
+
+
+	<target name="test-deploy" depends="compile">
+		<junit printsummary="withOutAndErr" haltonfailure="no" fork="yes" forkMode="once" haltonerror="no" enableTestListenerEvents="false" showoutput="yes" dir="${basedir}">
+			<jvmarg value="-Xmx2048m" />
+			<jvmarg value="-XX:MaxPermSize=256m" />
+			<jvmarg value="-ea" />
+			<classpath>
+				<pathelement path="${basedir}/../key.core/bin" />
+				<pathelement path="${basedir}/../key.util/bin" />
+				<pathelement path="${basedir}/../key.core.symbolic_execution/bin" />
+				<pathelement path="${basedir}/../key.core/lib/recoderKey.jar" />
+				<pathelement location="${ext.dir}/junit-4.12.jar" />
+				<pathelement location="${ext.dir}/hamcrest-core-1.3.jar" />
+				<pathelement location="${specstrength.ext.dir}/log4j-api-2.6.2.jar" />
+				<pathelement location="${specstrength.ext.dir}/log4j-core-2.6.2.jar" />
+				<pathelement path="${basedir}/../key.specstrength/bin" />
+				<pathelement path="${build.dir}" />
+			</classpath>
+			<formatter type="xml" />
+			<test name="de.tud.cs.se.ds.specstr.suite.TestSpecStrength" todir="${test.reports}" />
+		</junit>
+		<fail message="Test failure detected, check test results." if="test.failedOrError" />
+	</target>
+
+
+	<target name="runTests" depends="compile">
+		<junit printsummary="withOutAndErr" haltonfailure="no" fork="yes" forkMode="once" haltonerror="no" enableTestListenerEvents="false" showoutput="yes" dir="${basedir}">
+			<jvmarg value="-Xmx2048m" />
+			<jvmarg value="-XX:MaxPermSize=256m" />
+			<jvmarg value="-ea" />
+			<classpath>
+				<pathelement path="${basedir}/../key.core/bin" />
+				<pathelement path="${basedir}/../key.util/bin" />
+				<pathelement path="${basedir}/../key.core.symbolic_execution/bin" />
+				<pathelement path="${basedir}/../key.core/lib/recoderKey.jar" />
+				<pathelement location="${ext.dir}/junit-4.12.jar" />
+				<pathelement location="${ext.dir}/hamcrest-core-1.3.jar" />
+				<pathelement location="${specstrength.ext.dir}/log4j-api-2.6.2.jar" />
+				<pathelement location="${specstrength.ext.dir}/log4j-core-2.6.2.jar" />
+				<pathelement path="${basedir}/../key.specstrength/bin" />
+				<pathelement path="${build.dir}" />
+			</classpath>
+			<formatter type="brief" usefile="false" />
+			<test name="de.tud.cs.se.ds.specstr.suite.TestSpecStrength" />
+		</junit>
+	</target>
+
+
+	<target name="compile" description="Compile all source files into the build directory.">
+		<mkdir dir="${build.dir}" />
+		<javac srcdir="${src.dir}" destdir="${build.dir}" sourcepath="${src.dir}" includeantruntime="false" source="1.8" target="1.8" deprecation="off" debug="on" depend="${build.depend}" optimize="off">
+			<classpath>
+				<pathelement path="${basedir}/../key.specstrength/bin" />
+				<pathelement location="${ext.dir}/junit-4.12.jar" />
+				<pathelement location="${ext.dir}/hamcrest-core-1.3.jar" />
+			</classpath>
+		</javac>
+	</target>
+
+	<target name="clean" description="Deletes all generated files and folders.">
+		<delete failonerror="false" includeemptydirs="true">
+			<fileset dir="${build.dir}" includes="**/*" />
+		</delete>
+	</target>
+</project>
diff --git a/key/key.specstrength.test/lib/hamcrest-all-1.3.jar b/key/key.specstrength.test/lib/hamcrest-all-1.3.jar
new file mode 100644
index 0000000000..6f62ba00c7
Binary files /dev/null and b/key/key.specstrength.test/lib/hamcrest-all-1.3.jar differ
diff --git a/key/key.specstrength.test/lib/junit-4.12.jar b/key/key.specstrength.test/lib/junit-4.12.jar
new file mode 100644
index 0000000000..3a7fc266c3
Binary files /dev/null and b/key/key.specstrength.test/lib/junit-4.12.jar differ
diff --git a/key/key.specstrength.test/resources/testcase/analyzer/add/Add.java b/key/key.specstrength.test/resources/testcase/analyzer/add/Add.java
new file mode 100644
index 0000000000..7408bc23da
--- /dev/null
+++ b/key/key.specstrength.test/resources/testcase/analyzer/add/Add.java
@@ -0,0 +1,99 @@
+public class Add {
+    
+   // 6 facts in total, uncovered Facts:
+   //
+   // Loop body fact, Path condition "y < 0 & !y = i_0"
+   // res = -1 + res_0
+   // Loop body fact, Path condition "y > -1 & y > i_0"
+   // res = 1 + res_0
+   /*@ normal_behaviour
+     @   ensures \result == x + y;
+     @*/
+   public /*@pure@*/ int addStrongest(int x, int y) {
+       int res = x;
+       
+       if(y < 0) {
+           //@ ghost int oldRes = res + 1;
+           /*@ loop_invariant y <= i && i <= 0 && res == x + i && res == oldRes - 1; 
+             @ assignable \nothing;
+             @ decreases i - y;
+             @*/
+           for(int i = 0; i > y; i--) {
+               //@ set oldRes = res;
+               res--;
+           }
+       } else {
+           //@ ghost int oldRes = res - 1;
+           /*@ loop_invariant 0 <= i && i <= y && res == x + i && res == oldRes + 1; 
+             @ assignable \nothing;
+             @ decreases y - i;
+             @*/
+           for(int i = 0; i < y; i++) {
+               //@ set oldRes = res;
+               res++;
+           }
+       }
+       
+       return res;
+   }
+     
+    // 6 facts in total, uncovered Facts:
+    //
+    // Loop body fact, Path condition "y < 0 & !y = i_0"
+    // res = -1 + res_0
+    // Loop body fact, Path condition "y > -1 & y > i_0"
+    // res = 1 + res_0
+    /*@ normal_behaviour
+      @   ensures \result == x + y;
+      @*/
+    public /*@pure@*/ int addStandard(int x, int y) {
+        int res = x;
+        
+        if(y < 0) {
+            /*@ loop_invariant y <= i && i <= 0 && res == x + i; 
+              @ assignable \nothing;
+              @ decreases i - y;
+              @*/
+            for(int i = 0; i > y; i--) {
+                res--;
+            }
+        } else {
+            /*@ loop_invariant 0 <= i && i <= y && res == x + i; 
+              @ assignable \nothing;
+              @ decreases y - i;
+              @*/
+            for(int i = 0; i < y; i++) {
+                res++;
+            }
+        }
+        
+        return res;
+    }
+    
+   /*@ normal_behaviour
+     @   ensures \result == x + y;
+     @*/
+   public /*@pure@*/ int addTrivialInvariants(int x, int y) {
+       int res = x;
+       
+       if(y < 0) {
+           /*@ loop_invariant true; 
+             @ assignable \nothing;
+             @ decreases i - y;
+             @*/
+           for(int i = 0; i > y; i--) {
+               res--;
+           }
+       } else {
+           /*@ loop_invariant true; 
+             @ assignable \nothing;
+             @ decreases y - i;
+             @*/
+           for(int i = 0; i < y; i++) {
+               res++;
+           }
+       }
+       
+       return res;
+   }
+}
diff --git a/key/key.specstrength.test/resources/testcase/analyzer/arrSum/ArrSum.java b/key/key.specstrength.test/resources/testcase/analyzer/arrSum/ArrSum.java
new file mode 100644
index 0000000000..8866de1804
--- /dev/null
+++ b/key/key.specstrength.test/resources/testcase/analyzer/arrSum/ArrSum.java
@@ -0,0 +1,35 @@
+public class ArrSum {
+  /*@ public normal_behavior
+    @ requires arr != null;
+    @ ensures (\forall int n; n >= 0 && n < arr.length;
+    @            \result[n] == (\sum int k; 0 <= k && k < n; arr[k]));
+    @*/
+  public static final int[] arrSumStd(int[] arr) {
+    int[] result = new int[arr.length];
+
+    /*@ loop_invariant
+      @      i >= 0 && i <= arr.length
+      @   && (\forall int n; n >= 0 && n < i;
+      @        result[n] == (\sum int k; 0 <= k && k < n; arr[k]));
+      @ decreases arr.length - i;
+      @ assignable result[*];
+      @*/
+    for (int i = 0; i < arr.length; i++) {
+      int res = 0;
+
+      /*@ loop_invariant
+        @      j >= 0 && j <= i
+        @   && res == (\sum int k; 0 <= k && k < j; arr[k]);
+        @ decreases i - j;
+        @ assignable res;
+        @*/
+      for (int j = 0; j < i; j++) {
+        res += arr[j];
+      }
+
+      result[i] = res;
+    }
+
+    return result;
+  }
+}
\ No newline at end of file
diff --git a/key/key.specstrength.test/resources/testcase/analyzer/findMethods/FindMethods.java b/key/key.specstrength.test/resources/testcase/analyzer/findMethods/FindMethods.java
new file mode 100644
index 0000000000..dc68c95dbc
--- /dev/null
+++ b/key/key.specstrength.test/resources/testcase/analyzer/findMethods/FindMethods.java
@@ -0,0 +1,306 @@
+public class FindMethods {
+    //@ ghost int f_iLastRun;
+    
+    // Everything covered
+    /*@ public normal_behavior
+      @ ensures
+      @      ((\exists int i; i >= 0 && i < arr.length; arr[i] == n) ==>
+      @          (arr[\result] == n && \result == f_iLastRun)
+      @      )
+      @   && ((\forall int i; i >= 0 && i < arr.length; arr[i] != n) ==> \result == -1)
+      @   ;
+      @ assignable f_iLastRun;
+      @*/
+    public int find_strongest_post(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+      
+        //@ set f_iLastRun = i - 1;
+
+        /*@ loop_invariant
+          @      i >= 0 && i <= arr.length
+          @   && i == f_iLastRun + 1
+          @   && (result != -1 || (\forall int k; k >= 0 && k < i; arr[k] != n))
+          @   && (result == -1 || arr[result] == n && result == i-1)
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable f_iLastRun;
+          @*/
+        while (result == -1 && i < arr.length) {
+            //@ set f_iLastRun = i;
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+
+    // One "abstractly covered" fact:
+    // Post condition fact: "result_1_0 = iLastRun_0"
+    /*@ public normal_behavior
+      @ ensures
+      @      ((\exists int i; i >= 0 && i < arr.length; arr[i] == n) ==> arr[\result] == n)
+      @   && ((\forall int i; i >= 0 && i < arr.length; arr[i] != n) ==> \result == -1)
+      @   ;
+      @*/
+    public static int find_strongest_inv(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+        
+        //@ ghost int iLastRun = i - 1;
+
+        /*@ loop_invariant
+          @      i >= 0 && i <= arr.length
+          @   && i == iLastRun + 1
+          @   && (result != -1 || (\forall int k; k >= 0 && k < i; arr[k] != n))
+          @   && (result == -1 || arr[result] == n && result == i-1)
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable \nothing;
+          @*/
+        while (result == -1 && i < arr.length) {
+            //@ set iLastRun = i;
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+  
+
+    // Missing facts:
+    //   2x loop body fact "i = 1 + i0", that is exact change of i.
+    // One fact "abstractly covered":
+    //   Post condition fact: "result = i_0 - 1"
+    /*@ public normal_behavior
+      @ ensures
+      @      ((\exists int i; i >= 0 && i < arr.length; arr[i] == n) ==> arr[\result] == n)
+      @   && ((\forall int i; i >= 0 && i < arr.length; arr[i] != n) ==> \result == -1)
+      @   ;
+      @*/
+    public static int find_stronger_post(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+
+        /*@ loop_invariant
+          @      i >= 0 && i <= arr.length
+          @   && (result != -1 || (\forall int k; k >= 0 && k < i; arr[k] != n))
+          @   && (result == -1 || arr[result] == n && result == i-1)
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable \nothing;
+          @*/
+        while (result == -1 && i < arr.length) {
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+  
+    // Two "abstractly covered" facts:
+    //   Post condition fact: "result = i_0 - 1"
+    //   Post condition fact: "result = -1"
+    // Two uncovered facts:
+    //   2x loop body fact "i = 1 + i0"
+    /*@ public normal_behavior
+      @ ensures \result == -1 || arr[\result] == n;
+      @*/
+    public static int find_stronger_inv_3(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+
+        /*@ loop_invariant
+          @      i >= 0 && i <= arr.length
+          @   && (result != -1 || (\forall int k; k >= 0 && k < i; arr[k] != n))
+          @   && (result == -1 || arr[result] == n && result == i-1)
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable \nothing;
+          @*/
+        while (result == -1 && i < arr.length) {
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+  
+    // Two "abstractly covered" facts:
+    //   Post condition fact: "result = result_1_0"
+    //   Post condition fact: "result = -1"
+    // Four uncovered facts:
+    //   2x loop body fact "i = 1 + i0"
+    //   Loop body fact: "result = -1"
+    //   Loop body fact: "result = i_0"
+    /*@ public normal_behavior
+      @ ensures \result == -1 || arr[\result] == n;
+      @*/
+    public static int find_stronger_inv_2(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+
+        /*@ loop_invariant
+          @      i >= 0 && i <= arr.length
+          @   && (result != -1 || (\forall int k; k >= 0 && k < i; arr[k] != n))
+          @   && (result == -1 || arr[result] == n)
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable \nothing;
+          @*/
+        while (result == -1 && i < arr.length) {
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+  
+    // This method is "stonger" than the above find_stronger_inv_2,
+    // but for the price of an open exception branch, since i is
+    // not restrained to the legal rance in arr.
+    // Four "abstractly covered" facts:
+    //   Post condition fact: "result = -1"
+    //   Post condition fact: "result = result_1_0"
+    //   Loop body fact "i = 1 + i0"
+    //     (from that, we can derive "i=0" together with one part of
+    //     the inv (result != -1) and result == i_0 from the path condition,
+    //     which can be used to make true the second part of the inv (\forall...))
+    //   Loop body fact: "result = i_0"
+    // Two uncovered facts:
+    //   Loop body fact "i = 1 + i0"
+    //   Loop body fact: "result = -1"
+    // Open exception: "arr_0 != null, but i Out of Bounds"
+    /*@ public normal_behavior
+      @ ensures \result == -1 || arr[\result] == n;
+      @*/
+    public static int find_stronger_inv_2a(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+
+        /*@ loop_invariant
+          @      (result != -1 || (\forall int k; k >= 0 && k < i; arr[k] != n))
+          @   && (result == -1 || arr[result] == n)
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable \nothing;
+          @*/
+        while (result == -1 && i < arr.length) {
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+  
+    // Two uncovered facts:
+    //   2x loop body fact "i = 1 + i0", that is exact change of i.
+    // Four "abstractly covered" facts:
+    //   Loop body fact: "result = -1"
+    //   Loop body fact: "result = i_0"
+    //   Post condition fact: "result = result_1_0"
+    //   Post condition fact: "result = -1"
+    // Open exception: "arr_0 != null, but i Out of Bounds"
+    /*@ public normal_behavior
+      @ ensures \result == -1 || arr[\result] == n;
+      @*/
+    public static int find_stronger_inv(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+
+        /*@ loop_invariant
+          @   (result == -1 || arr[result] == n)
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable \nothing;
+          @*/
+        while (result == -1 && i < arr.length) {
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+  
+    // One "abstractly covered" fact:
+    //   Post condition fact: "result = -1"
+    // Four uncovered facts:
+    //   2x loop body fact "i = 1 + i0", that is exact change of i.
+    //   Post condition fact "result = result_1_0"
+    //   Loop use case fact: "arr_0[result_1_0] = n"
+    // Open exception: "arr_0 != null, but i Out of Bounds"
+    /*@ public normal_behavior
+      @ ensures \result == -1 || arr[\result] == n;
+      @*/
+    public static int find_sensible_post(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+
+        /*@ loop_invariant
+          @      true
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable \nothing;
+          @*/
+        while (result == -1 && i < arr.length) {
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+  
+    // All available facts are uncovered:
+    //   2x loop body fact "i = 1 + i0", that is exact change of i.
+    //   Post condition fact: "result = -1"
+    //   Post condition fact: "result = result_1_0"
+    // Open exception: "arr_0 != null, but i Out of Bounds"
+    /*@ public normal_behavior
+      @ ensures true;
+      @*/
+    public static int find_weakest(int[] arr, int n) {
+        int i = 0;
+        int result = -1;
+
+        /*@ loop_invariant
+          @      true
+          @   ;
+          @ decreases arr.length - i;
+          @ assignable \nothing;
+          @*/
+        while (result == -1 && i < arr.length) {
+            if (arr[i] == n) {
+                result = i;
+            }
+
+            i++;
+        }
+
+        return result;
+    }
+
+}
diff --git a/key/key.specstrength.test/resources/testcase/analyzer/loopFree/SimpleMath.java b/key/key.specstrength.test/resources/testcase/analyzer/loopFree/SimpleMath.java
new file mode 100644
index 0000000000..ef3a10e749
--- /dev/null
+++ b/key/key.specstrength.test/resources/testcase/analyzer/loopFree/SimpleMath.java
@@ -0,0 +1,54 @@
+public class SimpleMath {
+    
+    /*@ public normal_behavior
+      @ ensures    (num < 0  ==> \result == -num) 
+      @         && (num >= 0 ==> \result == num);
+      @*/
+    public static int abs_strongest(int num) {
+        if (num < 0)
+            return num * -1;
+        else
+            return num;
+    }
+    
+    /*@ public normal_behavior
+      @ ensures (num >= 0 ==> \result == num);
+      @*/
+    public static int abs_stronger_3(int num) {
+        if (num < 0)
+            return num * -1;
+        else
+            return num;
+    }
+    
+    /*@ public normal_behavior
+      @ ensures (num < 0 ==> \result == -num);
+      @*/
+    public static int abs_stronger_2(int num) {
+        if (num < 0)
+            return num * -1;
+        else
+            return num;
+    }
+    
+    /*@ public normal_behavior
+      @ ensures \result >= 0;
+      @*/
+    public static int abs_stronger_1(int num) {
+        if (num < 0)
+            return num * -1;
+        else
+            return num;
+    }
+    
+    /*@ public normal_behavior
+      @ ensures true;
+      @*/
+    public static int abs(int num) {
+        if (num < 0)
+            return num * -1;
+        else
+            return num;
+    }
+    
+}
\ No newline at end of file
diff --git a/key/key.specstrength.test/resources/testcase/analyzer/reverse/Reverse.java b/key/key.specstrength.test/resources/testcase/analyzer/reverse/Reverse.java
new file mode 100644
index 0000000000..2e1559d894
--- /dev/null
+++ b/key/key.specstrength.test/resources/testcase/analyzer/reverse/Reverse.java
@@ -0,0 +1,37 @@
+public class Reverse {
+
+  /*@ public normal_behavior
+    @ ensures (\forall int i; i >= 0 && i < arr.length; \result[arr.length - i - 1] == arr[i]);
+    @*/
+  public static int[] reverse(int[] arr) {
+	  int[] result = new int[arr.length];
+
+	  int i = arr.length - 1;
+	  int k = 0;
+
+	  // if "k == arr.length - i - 1" is left out, then after some
+	  // frickling around with the proof tree, we get the proof
+	  // obligation "-1+i_2*-1+arr_0.length<=-1+k_0" which
+	  // is implied by this. However, we only get this proof obligation
+	  // if we interact with the proof, otherwise the antecedent formula
+	  // this originates from is simplified away, since it's essentially
+	  // false (without the additional knowledge).
+
+	  /*@ loop_invariant
+	    @ 	   i + 1 >= 0 && i < arr.length && k >= 0 && k <= arr.length
+	    @   && k == arr.length - i - 1
+	    @   && (\forall int j; j >= 0 && j < k; result[j] == arr[arr.length - j - 1])
+	    @   ;
+	    @   //true;
+	    @ decreases i + 1;
+	    @ assignable result[*];
+	    @*/
+	  while (i >= 0) {
+		  result[k] = arr[i];
+		  i--; k++;
+	  }
+
+	  return result;
+  }
+
+}
diff --git a/key/key.specstrength.test/resources/testcase/analyzer/squareRootInt/SquareRoot.java b/key/key.specstrength.test/resources/testcase/analyzer/squareRootInt/SquareRoot.java
new file mode 100644
index 0000000000..8a53e68935
--- /dev/null
+++ b/key/key.specstrength.test/resources/testcase/analyzer/squareRootInt/SquareRoot.java
@@ -0,0 +1,88 @@
+public class SquareRoot {
+    
+    /*@ public normal_behavior
+      @ requires n >= 0;
+      @ ensures    \result * \result <= n
+      @         && n < (\result + 1) * (\result + 1)
+      @         && \result >= 0
+      @         // && (\forall int x; x >= 0 && x * x <= n && n < (x+1)*(x+1); \result == x)
+      @   ;
+      @*/
+    public static int sqrt(int n) {
+        int r = n;
+        int y = r*r;
+        int z = -2*r + 1;
+        
+        //@ ghost int r0 = r + 1;
+        //@ ghost int y0 = y + 2*r0 - 1;
+        
+        /*@ loop_invariant
+          @   0 <= r            && 
+          @   r <= n            &&
+          @   y == r*r          &&
+          @   z == -2*r + 1     &&
+          @   (r+1) * (r+1) > n &&
+          @   r == r0 - 1       && // those two formulas are not necessary for proving the method,
+          @   y == 1 - 2*r0 + y0;  // but for achieving more strength.
+          @ decreases r;
+          @*/
+        while (y > n) {
+            //@ set y0 = y;
+            //@ set r0 = r;
+            r--;
+            
+            y += z;
+            z += 2;
+        }
+        
+        /* // Lemma needed for post cond:
+         * // Existence and uniqueness of Integer square root
+         *\forallintn;
+         *(n>=0
+         *->\existsintr;
+         *(r>=0
+         *&r*r<=n
+         *&n<(r+1)*(r+1)
+         *&!\existsinto;(!o=r&o>=0&o*o<=n&n<(o+1)*(o+1))))
+         */
+        // Still, manual interaction needed for using lemma sensibly.
+        
+        return r;
+    }
+    
+    /*@ requires n >= 0;
+      @ requires r*r <= n && n < (r+1)*(r+1);
+      @ ensures \result*\result <= n+1 && n+1 < (\result+1)*(\result+1);
+      @ ensures \result == r || \result == r+1;
+      @*/
+    public static int nextSqrt(final int n, final int r) {
+        final int p = (n+1) - r*r;
+        if (p > r+r) {
+            return r+1;
+        } else {
+            return r;
+        }
+    }
+    
+    /*@ requires n >= 0;
+      @ ensures    \result * \result <= n
+      @         && n < (\result + 1) * (\result + 1)
+      @   ;
+      @*/
+    public static int sqrtIt(int n) {
+        int sqrt = 0;
+        
+        /*@ loop_invariant
+          @      i >= 0 && i <= n
+          @   && sqrt * sqrt <= i
+          @   && i < (sqrt + 1) * (sqrt + 1);
+          @ decreases n - i;
+          @*/
+        for (int i = 0; i < n; i++) {
+            sqrt = nextSqrt(i, sqrt);
+        }
+        
+        return sqrt;
+    }
+    
+}
diff --git a/key/key.specstrength.test/resources/testcase/analyzer/sum/Sum.java b/key/key.specstrength.test/resources/testcase/analyzer/sum/Sum.java
new file mode 100644
index 0000000000..9ffc273020
--- /dev/null
+++ b/key/key.specstrength.test/resources/testcase/analyzer/sum/Sum.java
@@ -0,0 +1,38 @@
+public class Sum {
+
+  /*@ public normal_behavior
+    @ ensures
+    @   \result == (\sum int i; 0 <= i && i < arr.length; arr[i]);
+    @*/
+  public static int sum(int[] arr) {
+    int result = 0, i = 0;
+
+    // If the \sum expression is missing in the invariant,
+    // then the fact "result_1 = result_1_0 + arr[i_0]" is
+    // not covered.
+    // Question: Can we prove that the \sum, if it's there,
+    // implies this fact?
+
+    // If only the \sum expression is present, then there is
+    // one open branches (exception) with path conditions
+    // "i_0 < 0" the invariant does not talk about. Also,
+    // the use case cannot be proven, since i could be too big;
+    // in the proof, this is reflected in the fact that there is
+    // a precondition "i < arr.length" not covered by the invariant.
+
+    /*@ loop_invariant
+      @   i >= 0 && i <= arr.length && result == (\sum int k; 0 <= k && k < i; arr[k]);
+      @   //i >= 0 && i <= arr.length;
+      @   //result == (\sum int k; 0 <= k && k < i; arr[k]);
+      @ decreases arr.length - i;
+      @ assignable \nothing;
+      @*/
+    while (i < arr.length) {
+        result += arr[i];
+        i++;
+    }
+
+    return result;
+  }
+
+}
diff --git a/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/AbstractAnalyzerTest.java b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/AbstractAnalyzerTest.java
new file mode 100644
index 0000000000..eda5dcf88e
--- /dev/null
+++ b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/AbstractAnalyzerTest.java
@@ -0,0 +1,135 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.analyzer;
+
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.equalTo;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.PrintStream;
+import java.util.Optional;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.hamcrest.number.IsCloseTo;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.rules.ErrorCollector;
+import org.key_project.util.java.IOUtil;
+
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.AnalyzerResult;
+import de.tud.cs.se.ds.specstr.util.GeneralUtilities;
+import de.uka.ilkd.key.control.DefaultUserInterfaceControl;
+import de.uka.ilkd.key.control.KeYEnvironment;
+import de.uka.ilkd.key.proof.io.ProblemLoaderException;
+
+/**
+ * TODO
+ *
+ * @author Dominic Steinhoefel
+ */
+public abstract class AbstractAnalyzerTest {
+    private static final Logger logger = LogManager.getFormatterLogger();
+    private static final String FUNCTIONAL_TESTS_RELATIVE_DIR = "/resources/testcase/analyzer/";
+    private static final File TMP_DIR = new File(
+            System.getProperty("java.io.tmpdir") + "/analyzerTests/");
+    
+    // We assume that in each test case, only one Java file is under test, and
+    // therefore we have a stable environment
+    private KeYEnvironment<DefaultUserInterfaceControl> keyEnv = null;
+    
+    @Rule
+    public final ErrorCollector collector = new ErrorCollector();
+
+    public void assertEquals(int expected, int actual) {
+        collector.checkThat(actual, equalTo(expected));
+    }
+
+    public void assertEquals(String expected, String actual) {
+        collector.checkThat(actual, equalTo(expected));
+    }
+
+    public void assertEquals(double expected, double actual, double error) {
+        collector.checkThat(actual, new IsCloseTo(expected, error));
+    }
+
+    public void assertContains(String expected, String completeString) {
+        collector.checkThat(completeString, containsString(expected));
+    }
+
+    private String functionalTestsDir;
+
+    @Before
+    public void setUp() throws Exception {
+        final File projectRoot = IOUtil
+                .getProjectRoot(AbstractAnalyzerTest.class);
+        functionalTestsDir = projectRoot + FUNCTIONAL_TESTS_RELATIVE_DIR;
+
+        if (!TMP_DIR.exists()) {
+            if (!TMP_DIR.mkdirs()) {
+                GeneralUtilities.logErrorAndThrowRTE(logger,
+                        "Could not create temporary directory %s",
+                        TMP_DIR.getAbsolutePath());
+            }
+        }
+    }
+
+    /**
+     * TODO
+     * 
+     * @param relPathToJavaFile
+     * @param fullyQualifiedMethodDescriptor
+     * @return
+     * @throws ProblemLoaderException
+     */
+    protected AnalyzerResult analyzeMethod(String relPathToJavaFile,
+            String fullyQualifiedMethodDescriptor) {
+        final File outProofFile = new File(TMP_DIR,
+                fullyQualifiedMethodDescriptor + ".proof");
+        final File outResultsFile = new File(TMP_DIR,
+                fullyQualifiedMethodDescriptor + ".txt");
+
+        logger.info("Output file for proof: %s",
+                outProofFile.getAbsolutePath());
+        
+        final File file = new File(functionalTestsDir, relPathToJavaFile);
+
+        if (keyEnv == null) {
+            try {
+                keyEnv = new SymbExInterface(file).keyEnvironment();
+            }
+            catch (ProblemLoaderException e) {
+                logger.error("Problem: %s", e.getMessage());
+            }
+        }
+        
+        final Analyzer analyzer = new Analyzer(
+                file,
+                fullyQualifiedMethodDescriptor, Optional.of(outProofFile),
+                keyEnv);
+        final AnalyzerResult result = analyzer.analyze();
+
+        try {
+            Analyzer.printResults(result,
+                    new PrintStream(new FileOutputStream(outResultsFile)));
+        } catch (FileNotFoundException e) {
+            logger.error("Couldn't write results to file %s",
+                    outResultsFile.getAbsolutePath());
+        }
+
+        return result;
+    }
+}
diff --git a/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/AddTest.java b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/AddTest.java
new file mode 100644
index 0000000000..85d68bebec
--- /dev/null
+++ b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/AddTest.java
@@ -0,0 +1,54 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.analyzer;
+
+import org.junit.Test;
+
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.AnalyzerResult;
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.FactType;
+
+/**
+ * TODO
+ *
+ * @author Dominic Steinhoefel
+ */
+public class AddTest extends AbstractAnalyzerTest {
+    
+    @Test
+    public void testAdd() {
+        final AnalyzerResult result = analyzeMethod( //
+            "add/Add.java", //
+            "Add::addStandard(II)I");
+
+        assertEquals(2,
+            result.getUncoveredFactsOfType(FactType.LOOP_BODY_FACT).size());
+        assertEquals(2, result.numUncoveredFacts());
+        assertEquals(0, result.numAbstractlyCoveredFacts());
+        assertEquals(4, result.numCoveredFacts());
+        assertEquals(6, result.numFacts());
+    }
+    
+    @Test
+    public void testAddStrongest() {
+        final AnalyzerResult result = analyzeMethod( //
+            "add/Add.java", //
+            "Add::addStrongest(II)I");
+
+        assertEquals(0, result.numUncoveredFacts());
+        assertEquals(0, result.numAbstractlyCoveredFacts());
+        assertEquals(8, result.numCoveredFacts());
+        assertEquals(8, result.numFacts());
+    }
+
+}
diff --git a/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/ArrSumTest.java b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/ArrSumTest.java
new file mode 100644
index 0000000000..3d5a25338b
--- /dev/null
+++ b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/ArrSumTest.java
@@ -0,0 +1,58 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.analyzer;
+
+import org.junit.Test;
+
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.AnalyzerResult;
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.Fact;
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.FactType;
+
+/**
+ * A method that returns, for a given array, an array where at each position
+ * there is the sum up to that index in the input array.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class ArrSumTest extends AbstractAnalyzerTest {
+
+    @Test
+    public void testArrSumStd() {
+        final AnalyzerResult result = analyzeMethod( //
+            "arrSum/ArrSum.java", //
+            "ArrSum::arrSumStd([I)[I");
+
+        assertEquals(0d, result.coveredStrength(), 0.0d);
+        assertEquals(16.66, result.strength(), 0.01d);
+
+        assertEquals(4, result.numFacts());
+        assertEquals(2, result.numUncoveredFacts());
+        assertEquals(1, result.numAbstractlyCoveredFacts());
+        assertEquals(1, result.numCoveredFacts());
+
+        assertEquals(2,
+            result.getUncoveredFactsOfType(FactType.LOOP_BODY_FACT).size());
+        assertEquals(1,
+            result.getAbstractlyCoveredFactsOfType(FactType.POST_COND_FACT)
+                    .size());
+
+        final Fact absCoveredPostCondFact = result
+                .getAbstractlyCoveredFactsOfType(FactType.POST_COND_FACT)
+                .get(0);
+        assertContains("result = x_arr_2", absCoveredPostCondFact.getDescr());
+        assertEquals("arr_0.length <= i_0",
+            absCoveredPostCondFact.getPathCond());
+    }
+
+}
diff --git a/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/FindMethodsTest.java b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/FindMethodsTest.java
new file mode 100644
index 0000000000..f9bba4b3bb
--- /dev/null
+++ b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/FindMethodsTest.java
@@ -0,0 +1,344 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.analyzer;
+
+import static de.tud.cs.se.ds.specstr.analyzer.Analyzer.FactType.*;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.AnalyzerResult;
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.Fact;
+
+/**
+ * A test suite based on multiple specifications for a simple "find-in-array"
+ * method with one loop.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class FindMethodsTest extends AbstractAnalyzerTest {
+
+    @Test
+    public void testFindStrongestPost() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java",
+            "FindMethods::find_strongest_post([II)I");
+
+        assertEquals(100d, result.coveredStrength(), 0d);
+        assertEquals(100d, result.strength(), 0d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+        assertEquals(0, result.problematicExceptions().size());
+
+        assertEquals(0, result.numUncoveredFacts());
+        assertEquals(0, result.numAbstractlyCoveredFacts());
+    }
+
+    @Test
+    public void testFindStrongestInv() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java",
+            "FindMethods::find_strongest_inv([II)I");
+
+        assertEquals(87.5d, result.coveredStrength(), 0d);
+        assertEquals(93.75d, result.strength(), 0d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+        assertEquals(0, result.problematicExceptions().size());
+
+        assertEquals(0, result.numUncoveredFacts());
+        assertEquals(1, result.numAbstractlyCoveredFacts());
+
+        final List<Fact> abstrPostCondFacts = result
+                .getAbstractlyCoveredFactsOfType(POST_COND_FACT);
+
+        assertEquals("result = iLastRun_0",
+            abstrPostCondFacts.get(0).getDescr());
+        assertContains("!result_1_0 = -1",
+            abstrPostCondFacts.get(0).getPathCond());
+    }
+
+    @Test
+    public void testFindStrongerPost() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java",
+            "FindMethods::find_stronger_post([II)I");
+
+        assertEquals(50d, result.coveredStrength(), 0d);
+        assertEquals(58.33d, result.strength(), .01d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+        assertEquals(0, result.problematicExceptions().size());
+
+        final List<Fact> loopBodyFacts = result
+                .getUncoveredFactsOfType(LOOP_BODY_FACT);
+
+        assertEquals(2, loopBodyFacts.size());
+        assertEquals(0, result.getUncoveredFactsOfType(POST_COND_FACT).size());
+
+        assertEquals(2, result.numUncoveredFacts());
+
+        loopBodyFacts.forEach(f -> {
+            assertEquals("i = 1 + i_0", f.getDescr());
+        });
+
+        assertContains("& arr_0[i_0] = n", loopBodyFacts.get(0).getPathCond());
+        assertContains("& !arr_0[i_0] = n", loopBodyFacts.get(1).getPathCond());
+    }
+
+    @Test
+    public void testFindStrongerInv3() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java",
+            "FindMethods::find_stronger_inv_3([II)I");
+
+        assertEquals(33.33d, result.coveredStrength(), .01d);
+        assertEquals(50d, result.strength(), 0d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+        assertEquals(0, result.problematicExceptions().size());
+
+        final List<Fact> abstrLoopBodyFacts = result
+                .getAbstractlyCoveredFactsOfType(LOOP_BODY_FACT);
+        final List<Fact> abstrPostCondFacts = result
+                .getAbstractlyCoveredFactsOfType(POST_COND_FACT);
+        final List<Fact> uncPostCondFacts = result
+                .getUncoveredFactsOfType(POST_COND_FACT);
+        final List<Fact> uncLoopBodyFacts = result
+                .getUncoveredFactsOfType(LOOP_BODY_FACT);
+
+        assertEquals(0, abstrLoopBodyFacts.size());
+        assertEquals(2, abstrPostCondFacts.size());
+
+        assertEquals(0, uncPostCondFacts.size());
+        assertEquals(2, uncLoopBodyFacts.size());
+
+        assertEquals(2, result.numUncoveredFacts());
+        assertEquals(2, result.numAbstractlyCoveredFacts());
+
+        uncLoopBodyFacts.forEach(f -> {
+            assertEquals("i = 1 + i_0", f.getDescr());
+        });
+    }
+
+    @Test
+    public void testFindStrongerInv2() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java",
+            "FindMethods::find_stronger_inv_2([II)I");
+
+        assertEquals(0d, result.coveredStrength(), 0d);
+        assertEquals(16.66d, result.strength(), .01d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+        assertEquals(0, result.problematicExceptions().size());
+
+        final List<Fact> abstrLoopBodyFacts = result
+                .getAbstractlyCoveredFactsOfType(LOOP_BODY_FACT);
+        final List<Fact> abstrPostCondFacts = result
+                .getAbstractlyCoveredFactsOfType(POST_COND_FACT);
+        final List<Fact> uncPostCondFacts = result
+                .getUncoveredFactsOfType(POST_COND_FACT);
+        final List<Fact> uncLoopBodyFacts = result
+                .getUncoveredFactsOfType(LOOP_BODY_FACT);
+
+        assertEquals(0, abstrLoopBodyFacts.size());
+        assertEquals(2, abstrPostCondFacts.size());
+
+        assertEquals(0, uncPostCondFacts.size());
+        assertEquals(4, uncLoopBodyFacts.size());
+
+        assertEquals(4, result.numUncoveredFacts());
+        assertEquals(2, result.numAbstractlyCoveredFacts());
+    }
+
+    @Test
+    public void testFindStrongerInv2a() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java",
+            "FindMethods::find_stronger_inv_2a([II)I");
+
+        assertEquals(0d, result.coveredStrength(), 0d);
+        assertEquals(33.33d, result.strength(), .01d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+
+        assertEquals(1, result.problematicExceptions().size());
+        assertContains("arr_0 != null, but i Out of Bounds",
+            result.problematicExceptions().get(0).getExcLabel());
+        assertContains("arr_0.length > i_0 & i_0 < 0",
+            result.problematicExceptions().get(0).getPathCondition());
+
+        final List<Fact> abstrLoopBodyFacts = result
+                .getAbstractlyCoveredFactsOfType(LOOP_BODY_FACT);
+        final List<Fact> abstrPostCondFacts = result
+                .getAbstractlyCoveredFactsOfType(POST_COND_FACT);
+        final List<Fact> uncPostCondFacts = result
+                .getUncoveredFactsOfType(POST_COND_FACT);
+        final List<Fact> uncLoopBodyFacts = result
+                .getUncoveredFactsOfType(LOOP_BODY_FACT);
+
+        assertEquals(2, abstrLoopBodyFacts.size());
+        assertEquals(2, abstrPostCondFacts.size());
+
+        assertEquals(0, uncPostCondFacts.size());
+        assertEquals(2, uncLoopBodyFacts.size());
+
+        assertEquals(2, result.numUncoveredFacts());
+        assertEquals(4, result.numAbstractlyCoveredFacts());
+    }
+
+    @Test
+    public void testFindStrongerInv() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java",
+            "FindMethods::find_stronger_inv([II)I");
+
+        assertEquals(0d, result.coveredStrength(), 0d);
+        assertEquals(33.33d, result.strength(), .01d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+
+        assertEquals(1, result.problematicExceptions().size());
+        assertContains("arr_0 != null, but i Out of Bounds",
+            result.problematicExceptions().get(0).getExcLabel());
+        assertContains("arr_0.length > i_0 & i_0 < 0",
+            result.problematicExceptions().get(0).getPathCondition());
+
+        final List<Fact> abstrLoopBodyFacts = result
+                .getAbstractlyCoveredFactsOfType(LOOP_BODY_FACT);
+        final List<Fact> uncLoopBodyFacts = result
+                .getUncoveredFactsOfType(LOOP_BODY_FACT);
+        final List<Fact> abstrPostCondFacts = result
+                .getAbstractlyCoveredFactsOfType(POST_COND_FACT);
+        final List<Fact> uncPostCondFacts = result
+                .getUncoveredFactsOfType(POST_COND_FACT);
+
+        assertEquals(2, abstrLoopBodyFacts.size());
+        assertEquals(2, uncLoopBodyFacts.size());
+        assertEquals(2, abstrPostCondFacts.size());
+
+        assertEquals(0, uncPostCondFacts.size());
+
+        assertEquals(2, result.numUncoveredFacts());
+        assertEquals(4, result.numAbstractlyCoveredFacts());
+
+        uncLoopBodyFacts.forEach(f -> {
+            assertEquals("i = 1 + i_0", f.getDescr());
+        });
+    }
+
+    @Test
+    public void testFindSensiblePost() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java",
+            "FindMethods::find_sensible_post([II)I");
+
+        assertEquals(0d, result.coveredStrength(), 0d);
+        assertEquals(8.33d, result.strength(), .01d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+
+        assertEquals(1, result.problematicExceptions().size());
+        assertContains("arr_0 != null, but i Out of Bounds",
+            result.problematicExceptions().get(0).getExcLabel());
+        assertContains("arr_0.length > i_0 & i_0 < 0",
+            result.problematicExceptions().get(0).getPathCondition());
+
+        final List<Fact> abstrPostCondFacts = result
+                .getAbstractlyCoveredFactsOfType(POST_COND_FACT);
+        final List<Fact> uncLoopBodyFacts = result
+                .getUncoveredFactsOfType(LOOP_BODY_FACT);
+        final List<Fact> uncPostCondFacts = result
+                .getUncoveredFactsOfType(POST_COND_FACT);
+
+        assertEquals(1, abstrPostCondFacts.size());
+
+        assertEquals(1, uncPostCondFacts.size());
+        assertEquals(4, uncLoopBodyFacts.size());
+
+        assertEquals(5, result.numUncoveredFacts());
+        assertEquals(1, result.numAbstractlyCoveredFacts());
+
+        assertEquals("result = result_1_0", uncPostCondFacts.get(0).getDescr());
+
+        assertEquals("!result_1_0 = -1", uncPostCondFacts.get(0).getPathCond());
+
+        assertEquals("result = -1", abstrPostCondFacts.get(0).getDescr());
+        assertContains("result_1_0 = -1",
+            abstrPostCondFacts.get(0).getPathCond());
+
+        assertEquals("i = 1 + i_0", uncLoopBodyFacts.get(0).getDescr());
+        assertEquals("result_1 = i_0", uncLoopBodyFacts.get(1).getDescr());
+        assertEquals("i = 1 + i_0", uncLoopBodyFacts.get(2).getDescr());
+        assertEquals("result_1 = -1", uncLoopBodyFacts.get(3).getDescr());
+
+        assertContains("& arr_0[i_0] = n",
+            uncLoopBodyFacts.get(0).getPathCond());
+        assertContains("& arr_0[i_0] = n",
+            uncLoopBodyFacts.get(1).getPathCond());
+        assertContains("& !arr_0[i_0] = n",
+            uncLoopBodyFacts.get(2).getPathCond());
+        assertContains("& !arr_0[i_0] = n",
+            uncLoopBodyFacts.get(3).getPathCond());
+    }
+
+    @Test
+    public void testFindWeakest() {
+        final AnalyzerResult result = analyzeMethod(
+            "findMethods/FindMethods.java", "FindMethods::find_weakest([II)I");
+
+        assertEquals(0d, result.coveredStrength(), 0d);
+        assertEquals(0d, result.strength(), 0d);
+        
+        assertEquals(0, result.unclosedLoopInvPreservedGoals());
+
+        assertEquals(1, result.problematicExceptions().size());
+        assertContains("arr_0 != null, but i Out of Bounds",
+            result.problematicExceptions().get(0).getExcLabel());
+        assertContains("arr_0.length > i_0 & i_0 < 0",
+            result.problematicExceptions().get(0).getPathCondition());
+
+        final List<Fact> loopBodyFacts = result
+                .getUncoveredFactsOfType(LOOP_BODY_FACT);
+        final List<Fact> postCondFacts = result
+                .getUncoveredFactsOfType(POST_COND_FACT);
+
+        assertEquals(4, loopBodyFacts.size());
+        assertEquals(2, postCondFacts.size());
+
+        assertEquals(6, result.numUncoveredFacts());
+
+        assertEquals("result = -1", postCondFacts.get(0).getDescr());
+        assertEquals("result = result_1_0", postCondFacts.get(1).getDescr());
+        assertContains("result_1_0 = -1", postCondFacts.get(0).getPathCond());
+        assertContains("!result_1_0 = -1", postCondFacts.get(1).getPathCond());
+
+        assertContains("& arr_0[i_0] = n",
+                loopBodyFacts.get(0).getPathCond());
+        assertContains("& arr_0[i_0] = n",
+                loopBodyFacts.get(1).getPathCond());
+        assertContains("& !arr_0[i_0] = n",
+                loopBodyFacts.get(2).getPathCond());
+        assertContains("& !arr_0[i_0] = n",
+                loopBodyFacts.get(3).getPathCond());
+
+        assertContains("& arr_0[i_0] = n", loopBodyFacts.get(0).getPathCond());
+        assertContains("& arr_0[i_0] = n", loopBodyFacts.get(1).getPathCond());
+        assertContains("& !arr_0[i_0] = n", loopBodyFacts.get(2).getPathCond());
+        assertContains("& !arr_0[i_0] = n", loopBodyFacts.get(3).getPathCond());
+    }
+
+}
\ No newline at end of file
diff --git a/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/LoopFreeTest.java b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/LoopFreeTest.java
new file mode 100644
index 0000000000..5d9bf556f9
--- /dev/null
+++ b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/analyzer/LoopFreeTest.java
@@ -0,0 +1,82 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.analyzer;
+
+import static de.tud.cs.se.ds.specstr.analyzer.Analyzer.FactType.POST_COND_FACT;
+
+import org.junit.Test;
+
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.AnalyzerResult;
+
+/**
+ * TODO
+ *
+ * @author Dominic Steinhoefel
+ */
+public class LoopFreeTest extends AbstractAnalyzerTest {
+
+    @Test
+    public void testAbsWeakPost() {
+        final AnalyzerResult result = analyzeMethod( //
+                "loopFree/SimpleMath.java", //
+                "SimpleMath::abs(I)I");
+
+        assertEquals(2, result.getUncoveredFactsOfType(POST_COND_FACT).size());
+        assertEquals(2, result.numFacts());
+    }
+
+    @Test
+    public void testAbsStronger1() {
+        // Here, the post condition is "\result >= 0".
+        // This is a case where we could apply the generalization...
+        final AnalyzerResult result = analyzeMethod( //
+                "loopFree/SimpleMath.java", //
+                "SimpleMath::abs_stronger_1(I)I");
+
+        assertEquals(2, result.getAbstractlyCoveredFactsOfType(POST_COND_FACT).size());
+        assertEquals(2, result.numFacts());
+    }
+
+    @Test
+    public void testAbsStronger2() {
+        final AnalyzerResult result = analyzeMethod( //
+                "loopFree/SimpleMath.java", //
+                "SimpleMath::abs_stronger_2(I)I");
+
+        assertEquals(1, result.getCoveredFactsOfType(POST_COND_FACT).size());
+        assertEquals(1, result.getUncoveredFactsOfType(POST_COND_FACT).size());
+        assertEquals(2, result.numFacts());
+    }
+
+    @Test
+    public void testAbsStronger3() {
+        final AnalyzerResult result = analyzeMethod( //
+                "loopFree/SimpleMath.java", //
+                "SimpleMath::abs_stronger_3(I)I");
+
+        assertEquals(1, result.getCoveredFactsOfType(POST_COND_FACT).size());
+        assertEquals(1, result.getUncoveredFactsOfType(POST_COND_FACT).size());
+        assertEquals(2, result.numFacts());
+    }
+
+    @Test
+    public void testAbsStrongest() {
+        final AnalyzerResult result = analyzeMethod( //
+                "loopFree/SimpleMath.java", //
+                "SimpleMath::abs_strongest(I)I");
+
+        assertEquals(0, result.numUncoveredFacts());
+    }
+
+}
diff --git a/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/suite/TestSpecStrength.java b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/suite/TestSpecStrength.java
new file mode 100644
index 0000000000..866e1d4051
--- /dev/null
+++ b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/suite/TestSpecStrength.java
@@ -0,0 +1,37 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.suite;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+
+import de.tud.cs.se.ds.specstr.analyzer.FindMethodsTest;
+import de.tud.cs.se.ds.specstr.analyzer.LoopFreeTest;
+import de.tud.cs.se.ds.specstr.util.CNFConverterTest;
+
+@RunWith(Suite.class)
+@Suite.SuiteClasses({
+    FindMethodsTest.class,
+    LoopFreeTest.class,
+    CNFConverterTest.class,
+})
+
+/**
+ * TODO
+ *
+ * @author Dominic Steinhoefel
+ */
+public class TestSpecStrength {
+
+}
diff --git a/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/util/CNFConverterTest.java b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/util/CNFConverterTest.java
new file mode 100644
index 0000000000..0340ee07b5
--- /dev/null
+++ b/key/key.specstrength.test/src/de/tud/cs/se/ds/specstr/util/CNFConverterTest.java
@@ -0,0 +1,174 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.util;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import de.uka.ilkd.key.java.Services;
+import de.uka.ilkd.key.logic.Name;
+import de.uka.ilkd.key.logic.Term;
+import de.uka.ilkd.key.logic.TermBuilder;
+import de.uka.ilkd.key.logic.op.Function;
+import de.uka.ilkd.key.logic.op.LogicVariable;
+import de.uka.ilkd.key.logic.sort.Sort;
+import de.uka.ilkd.key.logic.sort.SortImpl;
+import de.uka.ilkd.key.proof.init.AbstractProfile;
+
+/**
+ * TODO
+ *
+ * @author Dominic Steinhoefel
+ */
+public class CNFConverterTest {
+    private CNFConverter conv;
+    private TermBuilder tb;
+    private Services services;
+
+    private final Sort s = new SortImpl(new Name("S"));
+
+    @Before
+    public void setUp() throws Exception {
+        services = new Services(AbstractProfile.getDefaultProfile());
+        tb = services.getTermBuilder();
+        conv = new CNFConverter(tb);
+    }
+
+    @Test
+    public void testCNFConversion() {
+        final Term p = predicate("p");
+        final Term q = predicate("q");
+        final LogicVariable x = qv("x");
+
+        // !(p ==> !q) || !(\forall x; p && !q)
+        final Term input = tb.or(tb.not(tb.imp(p, tb.not(q))),
+                tb.not(tb.all(x, tb.and(p, tb.not(q)))));
+
+        // (p || ((\exists x; !p) || (\exists x; q))) &&
+        // (q || ((\exists x; !p) || (\exists x; q)))
+        final Term expected = tb.and(
+                tb.or(p, tb.or(tb.ex(x, tb.not(p)), tb.ex(x, q))),
+                tb.or(q, tb.or(tb.ex(x, tb.not(p)), tb.ex(x, q))));
+
+        final Term result = conv.convertToCNF(input);
+
+        assertEquals(expected, result);
+    }
+
+    @Test
+    public void testBiimplicationElimination() {
+        final Term p = predicate("p");
+        final Term q = predicate("q");
+
+        // (p ==> q) && ((p <==> q) || p)
+        final Term input = tb.and(tb.imp(p, q), tb.or(tb.equals(p, q), p));
+
+        // (!p || q) && (((!p || q) && (!q || p)) || p)
+        final Term expected = tb.and( //
+                tb.or(tb.not(p), q), //
+                tb.or( //
+                        tb.and( //
+                                tb.or(tb.not(p), q), //
+                                tb.or(tb.not(q), p)), //
+                        p));
+
+        final Term result = conv.eliminateBiImplications(input);
+
+        assertEquals(expected, result);
+    }
+
+    @Test
+    public void testPushNegationInvards() {
+        final Term p = predicate("p");
+        final LogicVariable x = qv("x");
+        final LogicVariable y = qv("y");
+        final Term xT = tb.var(x);
+        final Term yT = tb.var(y);
+
+        // !(\forall x; (x != y && (!!p || (\exists y; x == y))))
+        final Term input = //
+                tb.not( //
+                        tb.all(x,
+                                tb.and( //
+                                        tb.not(tb.equals(xT, yT)), //
+                                        tb.or( //
+                                                tb.not(tb.not(p)),
+                                                tb.ex(y, tb.equals(xT, yT))))));
+
+        // (\exists x; (x == y || (p && (\forall y; x != y))))
+        final Term expected = //
+                tb.ex(x, tb.or( //
+                        tb.equals(xT, yT), //
+                        tb.and( //
+                                tb.not(p), //
+                                tb.all(y, tb.not( //
+                                        tb.equals(xT, yT))))));
+
+        final Term result = conv.pushNegationsInvards(input);
+
+        assertEquals(expected, result);
+    }
+
+    @Test
+    public void testSplitQuantifiers() {
+        final Term p = predicate("p");
+        final Term q = predicate("q");
+        final LogicVariable x = qv("x");
+
+        // (\forall x; (p && (\exists x; q || p)))
+        final Term input = //
+                tb.all(x, tb.and(p, tb.ex(x, tb.or(q, p))));
+
+        // (\forall x; p) && (\forall x; ((\exists x; q) || (\exists x; p)))
+        final Term expected = //
+                tb.and(tb.all(x, p),
+                        tb.all(x, tb.or(tb.ex(x, q), tb.ex(x, p))));
+
+        final Term result = conv.splitQuantifiers(input);
+
+        assertEquals(expected, result);
+    }
+
+    @Test
+    public void testApplyDistributivity() {
+        final Term a = predicate("a");
+        final Term b = predicate("b");
+        final Term c = predicate("c");
+        final Term d = predicate("d");
+
+        // (a && b) || (c && d)
+        final Term input = //
+                tb.or(tb.and(a, b), tb.and(c, d));
+
+        // (a || c) && (a || d) && (b || c) && (b || d)
+        final Term expected = //
+                tb.and( //
+                        tb.and(tb.or(a, c), tb.or(a, d)),
+                        tb.and(tb.or(b, c), tb.or(b, d)));
+
+        final Term result = conv.applyDistributivityLaws(input);
+
+        assertEquals(expected, result);
+    }
+
+    private LogicVariable qv(String name) {
+        return new LogicVariable(new Name(name), s);
+    }
+
+    private Term predicate(String name) {
+        return tb.func(new Function(new Name(name), Sort.FORMULA));
+    }
+}
diff --git a/key/key.specstrength.test/src/log4j2.properties b/key/key.specstrength.test/src/log4j2.properties
new file mode 100644
index 0000000000..4f9d284f01
--- /dev/null
+++ b/key/key.specstrength.test/src/log4j2.properties
@@ -0,0 +1,21 @@
+# Set root logger level to DEBUG and its only appender to A1.
+#log4j.rootLogger=DEBUG, A1
+
+# A1 is set to be a ConsoleAppender.
+#log4j.appender.A1=org.apache.log4j.ConsoleAppender
+
+# A1 uses PatternLayout.
+#log4j.appender.A1.layout=org.apache.log4j.PatternLayout
+#log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n
+
+name=PropertiesConfig
+property.filename = logs
+appenders = console
+appender.console.type = Console
+appender.console.name = STDOUT
+appender.console.layout.type = PatternLayout
+appender.console.layout.pattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %c{1} - %msg%n
+
+rootLogger.level = info
+rootLogger.appenderRefs = stdout
+rootLogger.appenderRef.stdout.ref = STDOUT
\ No newline at end of file
diff --git a/key/key.specstrength/.classpath b/key/key.specstrength/.classpath
new file mode 100644
index 0000000000..9307376271
--- /dev/null
+++ b/key/key.specstrength/.classpath
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="lib" path="lib/commons-cli-1.3.1.jar"/>
+	<classpathentry kind="lib" path="lib/log4j-api-2.6.2.jar"/>
+	<classpathentry kind="lib" path="lib/log4j-core-2.6.2.jar"/>
+	<classpathentry kind="lib" path="lib/JHighlighter.jar"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/key.core"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/key.util"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/key.core.symbolic_execution"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/jdk1.8.0_92"/>
+	<classpathentry kind="src" path="/key.ui"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/key/key.specstrength/.gitignore b/key/key.specstrength/.gitignore
new file mode 100644
index 0000000000..ae3c172604
--- /dev/null
+++ b/key/key.specstrength/.gitignore
@@ -0,0 +1 @@
+/bin/
diff --git a/key/key.specstrength/.project b/key/key.specstrength/.project
new file mode 100644
index 0000000000..686c475409
--- /dev/null
+++ b/key/key.specstrength/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>key.specstrength</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/key/key.specstrength/.settings/org.eclipse.jdt.core.prefs b/key/key.specstrength/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000000..3a21537071
--- /dev/null
+++ b/key/key.specstrength/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/key/key.specstrength/META-INF/MANIFEST.MF b/key/key.specstrength/META-INF/MANIFEST.MF
new file mode 100644
index 0000000000..002b7591c0
--- /dev/null
+++ b/key/key.specstrength/META-INF/MANIFEST.MF
@@ -0,0 +1,4 @@
+Manifest-Version: 1.0
+Permissions: all-permissions
+Class-Path: key.util.jar key.core.jar key.symbolic_execution.jar
+Codebase: formal.iti.kit.edu
diff --git a/key/key.specstrength/build.xml b/key/key.specstrength/build.xml
new file mode 100644
index 0000000000..0e538640b6
--- /dev/null
+++ b/key/key.specstrength/build.xml
@@ -0,0 +1,86 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<project basedir="." default="all" name="Specification Strength Estimation">
+	<property name="src.dir" value="${basedir}/src" />
+	<property name="build.dir" value="${basedir}/bin" />
+	<property name="ext.dir" value="${basedir}/lib" />
+	<property name="destfile" value="key.specstrength.jar" />
+	<property name="dist.dir"  value="${basedir}/../deployment" />
+	<property name="lib.dir" value="${basedir}/../key.core/lib"/>
+
+	<path id="classpath">
+		<fileset dir="${ext.dir}" includes="commons-cli-1.3.1.jar" />
+		<fileset dir="${ext.dir}" includes="log4j-api-2.6.2.jar" />
+		<fileset dir="${ext.dir}" includes="log4j-core-2.6.2.jar" />
+      <fileset dir="${ext.dir}" includes="JHighlighter.jar"/>
+		<pathelement path="${basedir}/../key.core/bin" />
+		<pathelement path="${basedir}/../key.util/bin" />
+		<pathelement path="${basedir}/../key.core.symbolic_execution/bin" />
+      <pathelement path="${basedir}/../key.ui/bin" />
+		<pathelement path="${lib.dir}/antlr.jar"/>
+		<pathelement path="${lib.dir}/recoderKey.jar"/>
+	</path>
+
+	<target name="clean" description="Deletes all generated files and folders.">
+		<delete failonerror="false" includeemptydirs="true">
+			<fileset dir="${build.dir}" includes="**/*" />
+		</delete>
+		<delete file="${destfile}" />
+	</target>
+
+	<target name="copy" description="Copy all resources into the binary directory.">
+		<copy todir="${build.dir}">
+			<fileset dir="${basedir}/resources/" />
+		</copy>
+		<copy todir="${build.dir}/META-INF">
+			<fileset dir="${basedir}/META-INF/" />
+		</copy>
+	</target>
+
+	<target name="compile" depends="copy">
+		<mkdir dir="${build.dir}" />
+		<javac
+			srcdir="${src.dir}"
+			destdir="${build.dir}"
+			includes="**/*.java"
+			classpathref="classpath"
+			includeantruntime="false"
+			deprecation="true"
+			debug="true"
+			debuglevel="lines,vars,source"
+			source="1.8" />
+	</target>
+
+	<target name="deploy" depends="compile" description="Create a JAR archive in the destination directory.">
+		<mkdir dir="${dist.dir}"/>
+		<mkdir dir="${dist.dir}/components"/>
+		<mkdir dir="${dist.dir}/libs"/>
+		<copy todir="${dist.dir}/libs">
+			<fileset file="${ext.dir}/commons-cli-1.3.1.jar"/>
+			<fileset file="${ext.dir}/log4j-api-2.6.2.jar"/>
+			<fileset file="${ext.dir}/log4j-core-2.6.2.jar"/>
+         <fileset file="${ext.dir}/JHighlighter.jar"/>
+		</copy>
+		<jar destfile="${dist.dir}/components/key.specstrength.jar" basedir="${build.dir}" manifest="${basedir}/META-INF/MANIFEST.MF" />
+	</target>
+
+	<target name="jar" depends="compile">
+		<jar destfile="${destfile}" basedir="${build.dir}" includes="**/*">
+			<zipgroupfileset dir="${ext.dir}" includes="*.jar" />
+			<!--<fileset dir="." includes="gpl.txt" />-->
+			<manifest>
+				<attribute name="Main-Class" value="de.tud.cs.se.ds.specstr.cli.Main" />
+			</manifest>
+		</jar>
+		<chmod file="${destfile}" perm="ugo+x" />
+	</target>
+
+	<target name="run" depends="jar">
+		<java jar="${destfile}" fork="true">
+			<classpath>
+				<pathelement location="${destfile}" />
+			</classpath>
+		</java>
+	</target>
+
+	<target name="all" depends="compile,jar" />
+</project>
\ No newline at end of file
diff --git a/key/key.specstrength/lib/JHighlighter.jar b/key/key.specstrength/lib/JHighlighter.jar
new file mode 100644
index 0000000000..5056fb0a6d
Binary files /dev/null and b/key/key.specstrength/lib/JHighlighter.jar differ
diff --git a/key/key.specstrength/lib/commons-cli-1.3.1.jar b/key/key.specstrength/lib/commons-cli-1.3.1.jar
new file mode 100644
index 0000000000..c3e7a1f47f
Binary files /dev/null and b/key/key.specstrength/lib/commons-cli-1.3.1.jar differ
diff --git a/key/key.specstrength/lib/log4j-api-2.6.2.jar b/key/key.specstrength/lib/log4j-api-2.6.2.jar
new file mode 100644
index 0000000000..a40cc563e9
Binary files /dev/null and b/key/key.specstrength/lib/log4j-api-2.6.2.jar differ
diff --git a/key/key.specstrength/lib/log4j-core-2.6.2.jar b/key/key.specstrength/lib/log4j-core-2.6.2.jar
new file mode 100644
index 0000000000..388918f6c7
Binary files /dev/null and b/key/key.specstrength/lib/log4j-core-2.6.2.jar differ
diff --git a/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/AnalyzerGUI.fxml b/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/AnalyzerGUI.fxml
new file mode 100644
index 0000000000..2518a65f90
--- /dev/null
+++ b/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/AnalyzerGUI.fxml
@@ -0,0 +1,113 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<?import javafx.geometry.Insets?>
+<?import javafx.scene.control.Button?>
+<?import javafx.scene.control.ComboBox?>
+<?import javafx.scene.control.Label?>
+<?import javafx.scene.control.SplitPane?>
+<?import javafx.scene.control.TextField?>
+<?import javafx.scene.layout.AnchorPane?>
+<?import javafx.scene.layout.BorderPane?>
+<?import javafx.scene.layout.FlowPane?>
+<?import javafx.scene.layout.VBox?>
+<?import javafx.scene.text.Font?>
+<?import javafx.scene.web.WebView?>
+
+<AnchorPane prefHeight="582.0" prefWidth="926.0" xmlns="http://javafx.com/javafx/8.0.92" xmlns:fx="http://javafx.com/fxml/1" fx:controller="de.tud.cs.se.ds.specstr.gui.AnalyzerGUIController">
+   <children>
+      <BorderPane AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
+         <center>
+            <SplitPane dividerPositions="0.3008658008658009" BorderPane.alignment="CENTER">
+               <items>
+                  <AnchorPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minHeight="0.0" minWidth="0.0" prefHeight="501.0" prefWidth="295.0">
+                     <children>
+                        <VBox prefHeight="220.0" prefWidth="274.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
+                           <children>
+                              <BorderPane prefWidth="200.0">
+                                 <center>
+                                    <TextField id="txtJavaFile" fx:id="txtJavaFile" editable="false" maxWidth="1.7976931348623157E308" BorderPane.alignment="CENTER" />
+                                 </center>
+                                 <top>
+                                    <Label text="Select Java File" BorderPane.alignment="TOP_LEFT">
+                                       <opaqueInsets>
+                                          <Insets />
+                                       </opaqueInsets>
+                                       <font>
+                                          <Font name="System Bold" size="14.0" />
+                                       </font>
+                                       <BorderPane.margin>
+                                          <Insets bottom="10.0" />
+                                       </BorderPane.margin>
+                                    </Label>
+                                 </top>
+                                 <VBox.margin>
+                                    <Insets bottom="20.0" />
+                                 </VBox.margin>
+                                 <bottom>
+                                    <FlowPane hgap="10.0" prefHeight="26.0" prefWrapLength="90" BorderPane.alignment="CENTER">
+                                       <BorderPane.margin>
+                                          <Insets top="10.0" />
+                                       </BorderPane.margin>
+                                       <children>
+                                          <Button id="btnFileChooser" fx:id="btnFileChooser" mnemonicParsing="false" onAction="#handleChooseFilePressed" text="Load" />
+                                          <Button fx:id="btnFileEdit" mnemonicParsing="false" onAction="#handleEditFilePressed" text="Edit" />
+                                          <Button fx:id="btnRecent" mnemonicParsing="false" onAction="#handleLoadRecentPressed" style="-fx-graphic: url('/de/tud/cs/se/ds/specstr/gui/refresh.png')">
+                                             <FlowPane.margin>
+                                                <Insets />
+                                             </FlowPane.margin>
+                                          </Button>
+                                       </children>
+                                    </FlowPane>
+                                 </bottom>
+                              </BorderPane>
+                              <BorderPane prefWidth="200.0">
+                                 <center>
+                                    <ComboBox fx:id="cmbMethodChooser" maxWidth="1.7976931348623157E308" onAction="#handleMethodSelected" BorderPane.alignment="CENTER" />
+                                 </center>
+                                 <top>
+                                    <Label text="Select Method" BorderPane.alignment="TOP_LEFT">
+                                       <opaqueInsets>
+                                          <Insets />
+                                       </opaqueInsets>
+                                       <font>
+                                          <Font name="System Bold" size="14.0" />
+                                       </font>
+                                       <BorderPane.margin>
+                                          <Insets bottom="10.0" />
+                                       </BorderPane.margin>
+                                    </Label>
+                                 </top>
+                                 <VBox.margin>
+                                    <Insets bottom="20.0" />
+                                 </VBox.margin>
+                                 <bottom>
+                                    <FlowPane hgap="10.0" prefWidth="239.0" BorderPane.alignment="CENTER">
+                                       <children>
+                                          <Button fx:id="btnStartAnalysis" mnemonicParsing="false" onAction="#handleAnalyzeButtonPressed" text="Analyze" />
+                                          <Button fx:id="btnOpenKeY" mnemonicParsing="false" onAction="#handleOpenKeYButtonPressed" text="Open KeY" />
+                                          <Button fx:id="btnReloadProof" mnemonicParsing="false" onAction="#handleReloadProofButtonPressed" style="-fx-graphic: url('/de/tud/cs/se/ds/specstr/gui/refresh.png')" />
+                                       </children>
+                                       <BorderPane.margin>
+                                          <Insets top="10.0" />
+                                       </BorderPane.margin>
+                                    </FlowPane>
+                                 </bottom>
+                              </BorderPane>
+                           </children>
+                        </VBox>
+                     </children>
+                     <padding>
+                        <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
+                     </padding>
+                  </AnchorPane>
+                  <AnchorPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minHeight="0.0" minWidth="0.0">
+                     <children>
+                        <WebView fx:id="wvInfo" prefHeight="-1.0" prefWidth="-1.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" BorderPane.alignment="CENTER" />
+                     </children>
+                  </AnchorPane>
+               </items>
+            </SplitPane>
+         </center>
+      </BorderPane>
+   </children>
+</AnchorPane>
diff --git a/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/refresh.png b/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/refresh.png
new file mode 100644
index 0000000000..e08c21d935
Binary files /dev/null and b/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/refresh.png differ
diff --git a/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/refresh.svg b/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/refresh.svg
new file mode 100644
index 0000000000..fb51a42b4b
--- /dev/null
+++ b/key/key.specstrength/resources/de/tud/cs/se/ds/specstr/gui/refresh.svg
@@ -0,0 +1,397 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://web.resource.org/cc/"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   inkscape:export-ydpi="90.000000"
+   inkscape:export-xdpi="90.000000"
+   inkscape:export-filename="c:\Tango\git\view-refresh.png"
+   width="48"
+   height="48"
+   id="svg11300"
+   sodipodi:version="0.32"
+   inkscape:version="0.45"
+   sodipodi:docbase="/home/dobey/Projects/gnome-icon-theme/scalable/actions"
+   sodipodi:docname="view-refresh.svg"
+   version="1.0"
+   inkscape:r_cx="true"
+   inkscape:r_cy="true"
+   inkscape:output_extension="org.inkscape.output.svg.inkscape">
+  <defs
+     id="defs3">
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient5335">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop5337" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0;"
+         offset="1"
+         id="stop5339" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient5313">
+      <stop
+         id="stop5315"
+         offset="0"
+         style="stop-color:#99b8df;stop-opacity:1" />
+      <stop
+         style="stop-color:#3969a8;stop-opacity:1;"
+         offset="0.23705086"
+         id="stop5333" />
+      <stop
+         style="stop-color:#4f7eba;stop-opacity:1;"
+         offset="0.54706067"
+         id="stop5317" />
+      <stop
+         id="stop5321"
+         offset="0.74557692"
+         style="stop-color:#96b6d7;stop-opacity:1" />
+      <stop
+         style="stop-color:#a0bddc;stop-opacity:1"
+         offset="0.87321436"
+         id="stop5331" />
+      <stop
+         id="stop5319"
+         offset="1"
+         style="stop-color:#729fcf;stop-opacity:1;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient8152">
+      <stop
+         style="stop-color:#3465a4;stop-opacity:1;"
+         offset="0"
+         id="stop8154" />
+      <stop
+         id="stop3174"
+         offset="0.5"
+         style="stop-color:#4f7eba;stop-opacity:1;" />
+      <stop
+         style="stop-color:#729fcf;stop-opacity:1;"
+         offset="1"
+         id="stop8156" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3207">
+      <stop
+         style="stop-color:#eeeeec;stop-opacity:0.47058824;"
+         offset="0"
+         id="stop3209" />
+      <stop
+         style="stop-color:#eeeeec;stop-opacity:0;"
+         offset="1"
+         id="stop3211" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient2847">
+      <stop
+         style="stop-color:#3465a4;stop-opacity:1;"
+         offset="0"
+         id="stop2849" />
+      <stop
+         style="stop-color:#3465a4;stop-opacity:0;"
+         offset="1"
+         id="stop2851" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2831">
+      <stop
+         style="stop-color:#3465a4;stop-opacity:1;"
+         offset="0"
+         id="stop2833" />
+      <stop
+         id="stop2855"
+         offset="0.33333334"
+         style="stop-color:#5b86be;stop-opacity:1;" />
+      <stop
+         style="stop-color:#83a8d8;stop-opacity:0;"
+         offset="1"
+         id="stop2835" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient8662">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop8664" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop8666" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2831"
+       id="linearGradient1486"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.0818662,0,0,1.1166851,-0.8207482,-1.8622434)"
+       x1="13.478554"
+       y1="10.612206"
+       x2="15.419417"
+       y2="19.115122" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2847"
+       id="linearGradient1488"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(-1.0818662,0,0,-1.1166851,50.09459,49.644854)"
+       x1="37.128052"
+       y1="29.729605"
+       x2="37.40255"
+       y2="26.800913" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient8662"
+       id="radialGradient1503"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1,0,0,0.536723,0,16.87306)"
+       cx="24.837126"
+       cy="36.421127"
+       fx="24.837126"
+       fy="36.421127"
+       r="15.644737" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient8152"
+       id="linearGradient8158"
+       x1="49.412277"
+       y1="37.904068"
+       x2="11.881318"
+       y2="19.776045"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2831"
+       id="linearGradient8170"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(-1.0818662,0,0,-1.1166851,48.639854,47.862243)"
+       x1="13.478554"
+       y1="10.612206"
+       x2="15.419417"
+       y2="19.115122" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2847"
+       id="linearGradient8172"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.0818662,0,0,1.1166851,-2.2754847,-3.644854)"
+       x1="37.128052"
+       y1="29.729605"
+       x2="37.40255"
+       y2="26.800913" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient8152"
+       id="linearGradient8174"
+       gradientUnits="userSpaceOnUse"
+       x1="49.412277"
+       y1="37.904068"
+       x2="11.881318"
+       y2="19.776045" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3207"
+       id="linearGradient8178"
+       gradientUnits="userSpaceOnUse"
+       x1="5.8925977"
+       y1="20.540676"
+       x2="45.198921"
+       y2="27.721035" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient5313"
+       id="linearGradient8180"
+       gradientUnits="userSpaceOnUse"
+       x1="61.572533"
+       y1="28.049652"
+       x2="10.969182"
+       y2="20.333939" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient5335"
+       id="linearGradient5341"
+       x1="8.6878577"
+       y1="25.265626"
+       x2="52.122673"
+       y2="25.265626"
+       gradientUnits="userSpaceOnUse" />
+  </defs>
+  <sodipodi:namedview
+     stroke="#3465a4"
+     fill="#729fcf"
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#e8e8e8"
+     borderopacity="0.86666667"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1"
+     inkscape:cx="48.628749"
+     inkscape:cy="21.704614"
+     inkscape:current-layer="layer1"
+     showgrid="true"
+     inkscape:grid-bbox="true"
+     inkscape:document-units="px"
+     inkscape:showpageshadow="false"
+     inkscape:window-width="892"
+     inkscape:window-height="938"
+     inkscape:window-x="374"
+     inkscape:window-y="37"
+     width="48px"
+     height="48px"
+     borderlayer="true" />
+  <metadata
+     id="metadata4">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:creator>
+          <cc:Agent>
+            <dc:title>Jakub Steiner</dc:title>
+          </cc:Agent>
+        </dc:creator>
+        <dc:source>http://jimmac.musichall.cz</dc:source>
+        <cc:license
+           rdf:resource="http://creativecommons.org/licenses/GPL/2.0/" />
+        <dc:title>View Refresh</dc:title>
+        <dc:subject>
+          <rdf:Bag>
+            <rdf:li>reload</rdf:li>
+            <rdf:li>refresh</rdf:li>
+            <rdf:li>view</rdf:li>
+          </rdf:Bag>
+        </dc:subject>
+        <dc:contributor>
+          <cc:Agent>
+            <dc:title>Ricardo 'Rick' Gonzlez</dc:title>
+          </cc:Agent>
+        </dc:contributor>
+      </cc:Work>
+      <cc:License
+         rdf:about="http://creativecommons.org/licenses/GPL/2.0/">
+        <cc:permits
+           rdf:resource="http://web.resource.org/cc/Reproduction" />
+        <cc:permits
+           rdf:resource="http://web.resource.org/cc/Distribution" />
+        <cc:requires
+           rdf:resource="http://web.resource.org/cc/Notice" />
+        <cc:permits
+           rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
+        <cc:requires
+           rdf:resource="http://web.resource.org/cc/ShareAlike" />
+        <cc:requires
+           rdf:resource="http://web.resource.org/cc/SourceCode" />
+      </cc:License>
+    </rdf:RDF>
+  </metadata>
+  <g
+     id="layer1"
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     inkscape:r_cx="true"
+     inkscape:r_cy="true">
+    <path
+       transform="matrix(-1.5146484,0,0,-0.7917058,60.923237,69.528413)"
+       d="M 40.481863 36.421127 A 15.644737 8.3968935 0 1 1  9.1923885,36.421127 A 15.644737 8.3968935 0 1 1  40.481863 36.421127 z"
+       sodipodi:ry="8.3968935"
+       sodipodi:rx="15.644737"
+       sodipodi:cy="36.421127"
+       sodipodi:cx="24.837126"
+       id="path8660"
+       style="opacity:0.36111109;color:#000000;fill:url(#radialGradient1503);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:10;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible"
+       sodipodi:type="arc"
+       inkscape:r_cx="true"
+       inkscape:r_cy="true" />
+    <path
+       style="color:#000000;fill:url(#linearGradient1486);fill-opacity:1;fill-rule:nonzero;stroke:url(#linearGradient1488);stroke-width:1.04300582000000008;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:block;overflow:visible;opacity:0.51807229"
+       d="M 20.478497,9.7711467 C 20.478497,9.7711467 12.632988,7.9438002 14.368023,21.024298 L 5.1028658,21.024298 C 5.1028658,21.024298 6.0085332,7.5377773 20.478497,9.7711467 z "
+       id="path2865"
+       inkscape:r_cx="true"
+       inkscape:r_cy="true"
+       sodipodi:nodetypes="cccc" />
+    <g
+       id="g1878"
+       transform="matrix(-0.6129282,-0.5154381,-0.5178496,0.610074,58.686164,13.911361)"
+       inkscape:r_cx="true"
+       inkscape:r_cy="true"
+       style="fill:url(#linearGradient8158);fill-opacity:1;stroke:#204a87;stroke-width:1.24932528;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1">
+      <path
+         sodipodi:nodetypes="ccccccc"
+         id="path1880"
+         d="M 45.862102,50.273522 C 62.924432,34.96305 47.150241,15.929711 22.760624,12.513943 L 22.113577,3.1522143 L 7.613534,20.510135 L 22.703188,33.23244 C 22.703188,33.23244 22.454828,23.347105 22.454828,23.347105 C 41.289895,24.339584 54.775794,35.675041 45.862102,50.273522 z "
+         style="opacity:1;color:#000000;fill:url(#linearGradient8180);fill-opacity:1;fill-rule:nonzero;stroke:#204a87;stroke-width:1.24977946000000006;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:block;overflow:visible"
+         inkscape:r_cx="true"
+         inkscape:r_cy="true" />
+    </g>
+    <g
+       style="fill:none;fill-opacity:1;stroke:url(#linearGradient5341);stroke-width:1.24928653000000001;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;opacity:0.54819277"
+       inkscape:r_cy="true"
+       inkscape:r_cx="true"
+       transform="matrix(-0.612811,-0.5154406,-0.5177506,0.6100769,58.675633,13.911365)"
+       id="g3185">
+      <path
+         sodipodi:type="inkscape:offset"
+         inkscape:radius="-1.197237"
+         inkscape:original="M 22.125 3.15625 L 7.625 20.5 L 22.71875 33.21875 C 22.718749 33.21875 22.46875 23.34375 22.46875 23.34375 C 41.298509 24.342727 54.468144 35.661007 45.5625 50.25 C 62.614067 34.952315 46.852277 15.923275 22.46875 12.5 L 22.125 3.15625 z "
+         style="opacity:1;color:#000000;fill:none;fill-opacity:1;fill-rule:nonzero;stroke:url(#linearGradient5341);stroke-width:1.24928653000000001;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:block;overflow:visible"
+         id="path3189"
+         d="M 21.0625,6.3125 L 9.3125,20.34375 L 21.46875,30.59375 C 21.39688,27.754893 21.28125,23.375 21.28125,23.375 C 21.27502,23.044409 21.405774,22.725958 21.642519,22.495132 C 21.879264,22.264306 22.200923,22.141654 22.53125,22.15625 C 32.170255,22.667629 40.441027,25.773015 45.28125,30.875 C 48.676469,34.453835 50.102049,39.131532 49.125,44.21875 C 50.368339,42.205641 51.107893,40.194594 51.375,38.21875 C 51.870422,34.55401 50.856988,30.946652 48.5625,27.59375 C 43.973525,20.887947 34.236978,15.361613 22.3125,13.6875 C 21.732114,13.606381 21.295727,13.117098 21.28125,12.53125 L 21.0625,6.3125 z "
+         transform="translate(1.0080026e-6,8.5223784e-7)" />
+    </g>
+    <g
+       id="g2424"
+       transform="matrix(0.190868,0.16126,0.16126,-0.190868,-0.719083,15.30613)"
+       inkscape:r_cx="true"
+       inkscape:r_cy="true"
+       style="opacity:0.5;fill:none;fill-opacity:1;stroke:#ffffff;stroke-opacity:1" />
+    <path
+       sodipodi:nodetypes="cccc"
+       inkscape:r_cy="true"
+       inkscape:r_cx="true"
+       id="path8160"
+       d="M 27.340608,36.228853 C 27.340608,36.228853 35.186117,38.0562 33.451082,24.975702 L 42.71624,24.975702 C 42.71624,24.975702 41.810572,38.462223 27.340608,36.228853 z "
+       style="color:#000000;fill:url(#linearGradient8170);fill-opacity:1;fill-rule:nonzero;stroke:url(#linearGradient8172);stroke-width:1.04300582000000008;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:block;overflow:visible;opacity:0.51807229" />
+    <g
+       style="fill:url(#linearGradient8174);fill-opacity:1;stroke:#204a87;stroke-width:1.24932528;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       inkscape:r_cy="true"
+       inkscape:r_cx="true"
+       transform="matrix(0.6101332,0.5154999,0.5154881,-0.6101471,-10.618024,32.088556)"
+       id="g8162">
+      <path
+         inkscape:r_cy="true"
+         inkscape:r_cx="true"
+         style="opacity:1;color:#000000;fill:url(#linearGradient8180);fill-opacity:1;fill-rule:nonzero;stroke:#204a87;stroke-width:1.25256376;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:block;overflow:visible;enable-background:accumulate"
+         d="M 45.862102,50.273522 C 62.924432,34.96305 47.150241,15.929711 22.760624,12.513943 L 22.113577,3.1522141 L 7.6135337,20.510135 L 22.703188,33.23244 C 22.703188,33.23244 22.454828,23.347105 22.454828,23.347105 C 41.289895,24.339584 54.775794,35.675041 45.862102,50.273522 z "
+         id="path8164"
+         sodipodi:nodetypes="ccccccc" />
+    </g>
+    <g
+       id="g8166"
+       transform="matrix(0.6128107,0.5154406,0.5177504,-0.6100769,-10.856505,32.088635)"
+       inkscape:r_cx="true"
+       inkscape:r_cy="true"
+       style="fill:none;fill-opacity:1;stroke:#204a87;stroke-width:1.24928653;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1">
+      <path
+         transform="matrix(0.9972307,-2.4605589e-3,-2.4605593e-3,0.9980642,0.2457029,0.2077351)"
+         d="M 21.0625,6.3125 L 9.3125,20.34375 L 21.46875,30.59375 C 21.39688,27.754893 21.28125,23.375 21.28125,23.375 C 21.27502,23.044409 21.405774,22.725958 21.642519,22.495132 C 21.879264,22.264306 22.200923,22.141654 22.53125,22.15625 C 32.170255,22.667629 40.441027,25.773015 45.28125,30.875 C 48.676469,34.453835 50.102049,39.131532 49.125,44.21875 C 50.368339,42.205641 51.107893,40.194594 51.375,38.21875 C 51.870422,34.55401 50.856988,30.946652 48.5625,27.59375 C 43.973525,20.887947 34.236978,15.361613 22.3125,13.6875 C 21.732114,13.606381 21.295727,13.117098 21.28125,12.53125 L 21.0625,6.3125 z "
+         id="path8168"
+         style="opacity:1;color:#000000;fill:none;fill-opacity:1;fill-rule:nonzero;stroke:url(#linearGradient8178);stroke-width:1.24973191;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:0.70588235;visibility:visible;display:block;overflow:visible"
+         inkscape:original="M 22.125 3.15625 L 7.625 20.5 L 22.71875 33.21875 C 22.718749 33.21875 22.46875 23.34375 22.46875 23.34375 C 41.298509 24.342727 54.468144 35.661007 45.5625 50.25 C 62.614067 34.952315 46.852277 15.923275 22.46875 12.5 L 22.125 3.15625 z "
+         inkscape:radius="-1.197237"
+         sodipodi:type="inkscape:offset" />
+    </g>
+  </g>
+</svg>
diff --git a/key/key.specstrength/resources/log4j2.properties b/key/key.specstrength/resources/log4j2.properties
new file mode 100644
index 0000000000..4f9d284f01
--- /dev/null
+++ b/key/key.specstrength/resources/log4j2.properties
@@ -0,0 +1,21 @@
+# Set root logger level to DEBUG and its only appender to A1.
+#log4j.rootLogger=DEBUG, A1
+
+# A1 is set to be a ConsoleAppender.
+#log4j.appender.A1=org.apache.log4j.ConsoleAppender
+
+# A1 uses PatternLayout.
+#log4j.appender.A1.layout=org.apache.log4j.PatternLayout
+#log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n
+
+name=PropertiesConfig
+property.filename = logs
+appenders = console
+appender.console.type = Console
+appender.console.name = STDOUT
+appender.console.layout.type = PatternLayout
+appender.console.layout.pattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %c{1} - %msg%n
+
+rootLogger.level = info
+rootLogger.appenderRefs = stdout
+rootLogger.appenderRef.stdout.ref = STDOUT
\ No newline at end of file
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/Analyzer.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/Analyzer.java
new file mode 100644
index 0000000000..10bbade353
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/Analyzer.java
@@ -0,0 +1,1690 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.analyzer;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.key_project.util.collection.ImmutableArray;
+import org.key_project.util.collection.ImmutableList;
+
+import de.tud.cs.se.ds.specstr.profile.StrengthAnalysisSEProfile;
+import de.tud.cs.se.ds.specstr.rule.AbstractAnalysisRule;
+import de.tud.cs.se.ds.specstr.rule.AnalyzeInvImpliesLoopEffectsRule;
+import de.tud.cs.se.ds.specstr.rule.AnalyzePostCondImpliesMethodEffectsRule;
+import de.tud.cs.se.ds.specstr.rule.FactAnalysisRule;
+import de.tud.cs.se.ds.specstr.util.GeneralUtilities;
+import de.tud.cs.se.ds.specstr.util.JavaTypeInterface;
+import de.uka.ilkd.key.control.DefaultUserInterfaceControl;
+import de.uka.ilkd.key.control.KeYEnvironment;
+import de.uka.ilkd.key.java.Services;
+import de.uka.ilkd.key.java.abstraction.KeYJavaType;
+import de.uka.ilkd.key.java.declaration.ClassDeclaration;
+import de.uka.ilkd.key.logic.PosInOccurrence;
+import de.uka.ilkd.key.logic.PosInTerm;
+import de.uka.ilkd.key.logic.SequentFormula;
+import de.uka.ilkd.key.logic.Term;
+import de.uka.ilkd.key.logic.op.LocationVariable;
+import de.uka.ilkd.key.logic.op.ProgramMethod;
+import de.uka.ilkd.key.logic.op.UpdateApplication;
+import de.uka.ilkd.key.macros.TryCloseMacro;
+import de.uka.ilkd.key.pp.LogicPrinter;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.Node;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.proof.ProofVisitor;
+import de.uka.ilkd.key.proof.init.ProofInputException;
+import de.uka.ilkd.key.proof.io.ProblemLoaderException;
+import de.uka.ilkd.key.rule.LoopInvariantBuiltInRuleApp;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
+import de.uka.ilkd.key.rule.Rule;
+import de.uka.ilkd.key.rule.RuleApp;
+import de.uka.ilkd.key.symbolic_execution.util.SymbolicExecutionUtil;
+
+/**
+ * Loads the supplied method and performs the strength analysis. Access
+ * {@link #analyze()} for starting the analysis. The returned
+ * {@link AnalyzerResult} can be printed out using
+ * {@link #printResults(AnalyzerResult, PrintStream)}.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class Analyzer {
+    /**
+     * The {@link Logger} for this class.
+     */
+    private static final Logger LOGGER = LogManager.getFormatterLogger();
+
+    /**
+     * The {@link File} including the method to analyze.
+     */
+    private File file;
+
+    /**
+     * The class name for the method to parse.
+     */
+    private String className;
+
+    /**
+     * The method name for the method to parse.
+     */
+    private String methodName;
+
+    /**
+     * The type descriptor for the method to parse.
+     */
+    private String methodTypeStr;
+
+    /**
+     * The {@link SymbExInterface} used in the background.
+     */
+    private SymbExInterface seIf;
+
+    /**
+     * The {@link Optional} {@link File} to save the output in.
+     */
+    private Optional<File> outProofFile;
+
+    /**
+     * An {@link Optional} {@link AnalyzerResult} with the result of the most
+     * resent {@link Analyzer} run; only is non-empty after {@link #analyze()} /
+     * {@link #analyze(Optional)} has been called.
+     */
+    private Optional<AnalyzerResult> analyzerResult = Optional.empty();
+
+    /**
+     * An {@link Optional} with a {@link Proof} of the most resent
+     * {@link Analyzer} run; only is non-empty after {@link #analyze()} /
+     * {@link #analyze(Optional)} has been called.
+     */
+    private Optional<Proof> analyzerProofResult = Optional.empty();
+
+    /**
+     * Constructor.
+     *
+     * @param file
+     *            The file containing the method.
+     * @param method
+     *            The method identifier; should respect the format<br>
+     *            <br>
+     *
+     *            <code>&lt;fully qualified type name&gt;::&lt;method
+     *            name&gt;(&lt;arg decl&gt;)&lt;return type decl&gt;</code>,<br>
+     *            <br>
+     *
+     *            where where <code>&lt;arg decl&gt;</code> is according to the
+     *            field descriptors in the JVM specification, for instance
+     *            <code>[ILjava.lang.Object;D</code> for an integer array, an
+     *            Object and a double (not that we would support
+     *            doubles...).<br>
+     *            <code>&lt;return type decl&gt;</code> is constructed
+     *            similarly, only for a single type.
+     * @param outProofFile
+     *            An {@link Optional} {@link File} for writing the analyzer
+     *            results to, when running the {@link Analyzer} from the command
+     *            line and not programmatically.
+     * @throws RuntimeException
+     *             If the method could not be loaded.
+     */
+    public Analyzer(File file, String method, Optional<File> outProofFile) {
+        this(file, method, outProofFile, null);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param file
+     *            The file containing the method.
+     * @param method
+     *            The method identifier; should respect the format<br>
+     *            <br>
+     *
+     *            <code>&lt;fully qualified type name&gt;::&lt;method
+     *            name&gt;(&lt;arg decl&gt;)&lt;return type decl&gt;</code>,<br>
+     *            <br>
+     *
+     *            where where <code>&lt;arg decl&gt;</code> is according to the
+     *            field descriptors in the JVM specification, for instance
+     *            <code>[ILjava.lang.Object;D</code> for an integer array, an
+     *            Object and a double (not that we would support
+     *            doubles...).<br>
+     *            <code>&lt;return type decl&gt;</code> is constructed
+     *            similarly, only for a single type.
+     * @param outProofFile
+     *            An {@link Optional} {@link File} for writing the analyzer
+     *            results to, when running the {@link Analyzer} from the command
+     *            line and not programmatically.
+     * @param env
+     *            The {@link KeYEnvironment} for the problem to analyse (based
+     *            on the {@link StrengthAnalysisSEProfile}).
+     * @throws RuntimeException
+     *             If the method could not be loaded.
+     */
+    public Analyzer(File file, String method, Optional<File> outProofFile,
+            KeYEnvironment<DefaultUserInterfaceControl> env) {
+        this.file = file;
+        if (!parseMethodString(method)) {
+            final String errorMsg = GeneralUtilities
+                    .format("Error in parsing method descriptor %s", method);
+            LOGGER.error(errorMsg);
+            throw new RuntimeException(errorMsg);
+        }
+
+        try {
+            if (env == null) {
+                this.seIf = new SymbExInterface(file);
+            }
+            else {
+                this.seIf = new SymbExInterface(file, env);
+            }
+        }
+        catch (ProblemLoaderException e) {
+            GeneralUtilities.logErrorAndThrowRTE(LOGGER,
+                    "ProblemLoaderException occurred while loading file %s\nMessage:\n%s",
+                    file.getName(), e.getMessage());
+        }
+        this.outProofFile = outProofFile;
+    }
+
+    /**
+     * An {@link Optional} {@link AnalyzerResult} with the result of the most
+     * resent {@link Analyzer} run; only is non-empty after {@link #analyze()} /
+     * {@link #analyze(Optional)} has been called.
+     *
+     * @return The most recent {@link AnalyzerResult} or an empty
+     *         {@link Optional}.
+     */
+    public Optional<AnalyzerResult> result() {
+        return analyzerResult;
+    }
+
+    /**
+     * An {@link Optional} with a {@link Proof} of the most resent
+     * {@link Analyzer} run; only is non-empty after {@link #analyze()} /
+     * {@link #analyze(Optional)} has been called.
+     *
+     * @return The most recent {@link Proof} or an empty {@link Optional}.
+     */
+    public Optional<Proof> proof() {
+        return analyzerProofResult;
+    }
+
+    /**
+     * Performs the actual analysis, and sets the internal
+     * {@link AnalyzerResult}, which is also returned to the result. This result
+     * can afterward be obtained by calling {@link #result()}.
+     *
+     * @return An {@link AnalyzerResult} object.
+     * @throws RuntimeException
+     *             If the results file could not be saved due to an
+     *             {@link IOException}.
+     */
+    public AnalyzerResult analyze() {
+        return analyze(Optional.empty());
+    }
+
+    /**
+     * Performs the actual analysis, and sets the internal
+     * {@link AnalyzerResult}, which is also returned to the result. This result
+     * can afterward be obtained by calling {@link #result()}.
+     *
+     * @return An {@link AnalyzerResult} object.
+     * @throws RuntimeException
+     *             If the results file could not be saved due to an
+     *             {@link IOException}.
+     */
+    public AnalyzerResult analyze(File proofFile) {
+        assert proofFile != null;
+        try {
+            seIf = new SymbExInterface(file, KeYEnvironment.load(proofFile));
+            return analyze(Optional.of(seIf.keyEnvironment().getLoadedProof()));
+        }
+        catch (ProblemLoaderException e) {
+            GeneralUtilities.logErrorAndThrowRTE(LOGGER,
+                    "%s while loading proof file %s:\n%s",
+                    e.getClass().getSimpleName(), proofFile.getName(),
+                    e.getMessage());
+        }
+
+        return analyze(Optional.empty());
+    }
+
+    /**
+     * Performs the actual analysis, and sets the internal
+     * {@link AnalyzerResult}, which is also returned to the result. This result
+     * can afterward be obtained by calling {@link #result()}.
+     *
+     * @param existingProof
+     *            An existing {@link Optional} {@link Proof} object to
+     *            re-analyze, in particular after interaction.
+     * @return An {@link AnalyzerResult} object.
+     * @throws RuntimeException
+     *             If the results file could not be saved due to an
+     *             {@link IOException}.
+     */
+    public AnalyzerResult analyze(Optional<Proof> existingProof) {
+        LOGGER.info("Analyzing Java file %s", file);
+
+        final ProgramMethod method = findMethod();
+
+        LOGGER.info("Analyzing method %s::%s%s", className, methodName,
+                methodTypeStr);
+
+        // TODO: Finishing SE with the macro has the side effect that some goals
+        // that would be trivially closable, like exception branches, are closed
+        // late since the macro is focusing on SE.
+
+        LOGGER.trace("Building proof tree");
+        // Finish symbolic execution
+        seIf.finishSEForMethod(method);
+        final Proof proof = existingProof.orElse(seIf.proof());
+
+        FactExtractionResult fer;
+        if (existingProof.isPresent()) {
+            LOGGER.trace("Collecting facts");
+            fer = extractFactsFromProofTree(proof);
+        }
+        else {
+            LOGGER.trace("Applying analysis rules and collecting facts");
+            fer = applyAnalysisRules(proof);
+        }
+
+        final List<Fact> facts = fer.getFacts();
+        final int unclosedLoopInvPreservedGoals =
+                fer.getUnclosedLoopInvPreservedGoals();
+        final int unclosedPostCondSatisfiedGoals =
+                fer.getUnclosedPostCondSatisfiedGoals();
+
+        LOGGER.info("Collected %s facts", facts.size());
+
+        LOGGER.info("Proving facts, this may take some time...");
+
+        List<Fact> coveredFacts = new ArrayList<>();
+        List<Fact> abstractlyCoveredFacts = new ArrayList<>();
+        List<Fact> unCoveredFacts = new ArrayList<>();
+
+        analyzeFacts(facts, coveredFacts, abstractlyCoveredFacts,
+                unCoveredFacts);
+
+        LOGGER.trace("Done proving facts.");
+
+        LOGGER.trace("Checking exception branches.");
+
+        final List<ExceptionResult> problematicExceptions = //
+                checkExceptionBranches(proof);
+
+        // TODO also check if loop invariants are initially valid.
+
+        LOGGER.trace("Done checking exception branches.");
+
+        if (outProofFile.isPresent()) {
+            try {
+                LOGGER.info("Writing proof to file %s", outProofFile.get());
+                proof.saveToFile(outProofFile.get());
+            }
+            catch (IOException e) {
+                LOGGER.error("Problem writing proof to file %s, message:\n%s",
+                        outProofFile.get(), e.getMessage());
+            }
+        }
+
+        LOGGER.trace("Finished analysis of Java file %s", file);
+
+        final AnalyzerResult result = new AnalyzerResult(coveredFacts,
+                abstractlyCoveredFacts,
+                unCoveredFacts, problematicExceptions,
+                unclosedLoopInvPreservedGoals, unclosedPostCondSatisfiedGoals);
+
+        this.analyzerResult = Optional.of(result);
+        this.analyzerProofResult = Optional.of(proof);
+
+        return result;
+    }
+
+    /**
+     * Extracts facts from a {@link Proof} tree after exhaustive symbolic
+     * execution.
+     *
+     * @param proof
+     *            The {@link Proof} tree to extract facts from.
+     * @return A {@link FactExtractionResult}.
+     */
+    private FactExtractionResult extractFactsFromProofTree(Proof proof) {
+        final RuleProofVisitor analysisRuleVisitor =
+                new RuleProofVisitor(AbstractAnalysisRule.class);
+        proof.breadthFirstSearch(proof.root(), analysisRuleVisitor);
+
+        final List<Fact> facts = new ArrayList<>();
+        int unclosedLoopInvPreservedGoals = 0;
+        int unclosedPostCondSatisfiedGoals = 0;
+
+        for (final Node analysisRuleNode : analysisRuleVisitor.result()) {
+            final String readablePathCond =
+                    extractReadablePathCondition(
+                            analysisRuleNode.parent());
+
+            final Rule analysisRule =
+                    analysisRuleNode.getAppliedRuleApp().rule();
+
+            assert analysisRule instanceof AbstractAnalysisRule;
+
+            final FactType factType;
+            if (analysisRule instanceof AnalyzeInvImpliesLoopEffectsRule) {
+                factType = FactType.LOOP_BODY_FACT;
+            }
+            else if (analysisRule instanceof AnalyzePostCondImpliesMethodEffectsRule) {
+                factType = FactType.POST_COND_FACT;
+            }
+            else {
+                factType = null;
+                GeneralUtilities.logErrorAndThrowRTE(LOGGER,
+                        "Unknown %s: %s",
+                        AbstractAnalysisRule.class.getName(),
+                        analysisRule.getClass().getName());
+            }
+
+            final Iterable<Node> factNodes = GeneralUtilities
+                    .toStream((() -> analysisRuleNode.childrenIterator()))
+                    .collect(Collectors.toList());
+
+            for (final Node factNode : factNodes) {
+                final String branchLabel =
+                        factNode.getNodeInfo().getBranchLabel();
+
+                if (factNode.getAppliedRuleApp() == null
+                        || !factNode.getAppliedRuleApp().rule()
+                                .equals(FactAnalysisRule.INSTANCE)) {
+                    // This is a "post condition satisfied" / "loop invariant
+                    // preserved" node and no FactAnalysisRule node -- has to be
+                    // treated specially.
+
+                    seIf.applyMacro(new TryCloseMacro(10000), factNode);
+
+                    if (!factNode.isClosed()) {
+                        if (branchLabel.equals(
+                                AbstractAnalysisRule.INVARIANT_PRESERVED_BRANCH_LABEL)) {
+                            unclosedLoopInvPreservedGoals++;
+                        }
+                        else if (branchLabel.equals(
+                                AbstractAnalysisRule.POSTCONDITION_SATISFIED_BRANCH_LABEL)) {
+                            unclosedPostCondSatisfiedGoals++;
+                        }
+                        else {
+                            GeneralUtilities.logErrorAndThrowRTE(LOGGER,
+                                    "Unknown / unexpected branch label \"%s\" where %s or %s was expected.",
+                                    branchLabel,
+                                    AbstractAnalysisRule.INVARIANT_PRESERVED_BRANCH_LABEL,
+                                    AbstractAnalysisRule.POSTCONDITION_SATISFIED_BRANCH_LABEL);
+                        }
+                    }
+
+                    continue;
+                }
+
+                final String factTitle = branchLabel.split("\"")[1];
+
+                final Iterable<Node> factAnalysisCaseNodes =
+                        GeneralUtilities
+                                .toStream((() -> factNode
+                                        .childrenIterator()))
+                                .collect(Collectors.toList());
+
+                if (factType != FactType.POST_COND_FACT &&
+                        factCanBeDiscarded(factAnalysisCaseNodes)) {
+                    // Discard the fact -- too easy ;)
+                    continue;
+                }
+
+                facts.add(new Fact(factTitle,
+                        readablePathCond, factType,
+                        FactAnalysisRule
+                                .getFactCoveredNode(factAnalysisCaseNodes),
+                        FactAnalysisRule
+                                .getFactAbstractlyCoveredNode(
+                                        factAnalysisCaseNodes),
+                        FactAnalysisRule
+                                .getFactAbstractlyCoveredVerifNode(
+                                        factAnalysisCaseNodes)));
+            }
+        }
+
+        return new FactExtractionResult(facts, unclosedLoopInvPreservedGoals,
+                unclosedPostCondSatisfiedGoals);
+    }
+
+    /**
+     * Applies analysis rules and extracts facts from a {@link Proof} tree after
+     * exhaustive symbolic execution.
+     *
+     * @param proof
+     *            The {@link Proof} tree to extract facts from.
+     * @return A {@link FactExtractionResult}.
+     */
+    private FactExtractionResult applyAnalysisRules(Proof proof) {
+        final List<Node> postConditionNodes = new ArrayList<>();
+        final List<Fact> facts = new ArrayList<>();
+
+        int unclosedLoopInvPreservedGoals = 0;
+        int unclosedPostCondGoals = 0;
+
+        if (proofHasLoopInvApp(proof)) {
+            // Post condition facts. Those have to be extracted *before* the use
+            // case facts, since the goals might change that are analyzed for
+            // the use case
+            unclosedPostCondGoals = extractPostCondFacts(proof, facts);
+
+            // Find "preserves" and "use case" branches
+            final List<Node> preservedNodes = new ArrayList<>();
+
+            extractPreservedAndUseCaseNodes(proof, preservedNodes,
+                    postConditionNodes);
+
+            // Loop facts
+            unclosedLoopInvPreservedGoals = //
+                    extractLoopBodyFactsAndShowValidity(//
+                            proof, preservedNodes, facts);
+        }
+        else {
+            // Post condition facts
+            extractPostCondFacts(proof, facts);
+        }
+
+        return new FactExtractionResult(facts, unclosedLoopInvPreservedGoals,
+                unclosedPostCondGoals);
+    }
+
+    /**
+     * Analyzes the {@link List} facts of extracted {@link Fact}s by trying to
+     * close the related {@link Goal}s.
+     *
+     * @param facts
+     *            The {@link List} of {@link Fact}s to analyze.
+     * @param coveredFacts
+     *            The {@link List} into which the covered {@link Fact}s should
+     *            be written.
+     * @param abstractlyCoveredFacts
+     *            The {@link List} into which the abstractly covered
+     *            {@link Fact}s should be written.
+     * @param unCoveredFacts
+     *            The {@link List} into which the uncovered {@link Fact}s should
+     *            be written.
+     */
+    private void analyzeFacts(final List<Fact> facts, List<Fact> coveredFacts,
+            List<Fact> abstractlyCoveredFacts, List<Fact> unCoveredFacts) {
+        for (Fact fact : facts) {
+            LOGGER.trace("Proving fact %s", fact.descr);
+
+            final Node factNode = fact.factCoveredNode;
+            seIf.applyMacro(new TryCloseMacro(10000), factNode);
+
+            if (factNode.isClosed()) {
+                LOGGER.trace("Fact covered");
+                coveredFacts.add(fact);
+                fact.setCovered(true);
+            }
+            else {
+                final Node abstractlyCoveredNode =
+                        fact.factAbstractlyCoveredNode;
+                final Node abstractlyCoveredTestNode =
+                        fact.factAbstractlyCoveredTestNode;
+
+                boolean abstractlyCovered = false;
+                if (abstractlyCoveredNode != null) {
+                    seIf.applyMacro(new TryCloseMacro(10000),
+                            abstractlyCoveredNode);
+                    seIf.applyMacro(new TryCloseMacro(10000),
+                            abstractlyCoveredTestNode);
+                    abstractlyCovered = abstractlyCoveredNode.isClosed()
+                            && !abstractlyCoveredTestNode.isClosed();
+                }
+
+                if (abstractlyCovered) {
+                    LOGGER.trace("Fact abstractly covered");
+                    abstractlyCoveredFacts.add(fact);
+                    fact.setAbstractlyCovered(true);
+                }
+                else {
+                    LOGGER.trace("Fact uncovered");
+                    unCoveredFacts.add(fact);
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks whether the given {@link Proof} has a
+     * {@link LoopInvariantBuiltInRuleApp} application.
+     *
+     * @param proof
+     *            The {@link Proof} to check.
+     * @return true iff the {@link Proof} has a
+     *         {@link LoopInvariantBuiltInRuleApp}.
+     */
+    private boolean proofHasLoopInvApp(final Proof proof) {
+        final RuleAppVisitor ruleAppVisitor = new RuleAppVisitor(
+                LoopInvariantBuiltInRuleApp.class);
+        proof.breadthFirstSearch(proof.root(), ruleAppVisitor);
+
+        return ruleAppVisitor.success();
+    }
+
+    /**
+     * Tries to close exception branches, and returns {@link ExceptionResult}s
+     * for those for which it was not possible.
+     *
+     * @param proof
+     *            The {@link Proof} object to find the exception branches in.
+     * @return A {@link List} of {@link ExceptionResult}s for exception branches
+     *         that could not be closed.
+     */
+    private List<ExceptionResult> checkExceptionBranches(final Proof proof) {
+        final List<ExceptionResult> unclosedExceptions = new ArrayList<>();
+
+        // TODO That's a hackish way of filtering exception branches; can we do
+        // this more systematically? In any case, the list is incomplete.
+        final String[] exceptionBranchLabels = new String[] { //
+                "Null Reference", //
+                "Index Out of Bounds", //
+        };
+
+        final List<Node> exceptionNodes = GeneralUtilities
+                .toStream(proof.openGoals()).map(g -> g.node())
+                .filter(n -> n.getNodeInfo().getBranchLabel() != null
+                        && Arrays.stream(exceptionBranchLabels).anyMatch(
+                                s -> n.getNodeInfo().getBranchLabel()
+                                        .contains(s)))
+                .collect(Collectors.toList());
+
+        for (final Node excNode : exceptionNodes) {
+            LOGGER.trace("Checking exception node \"%s\"",
+                    excNode.getNodeInfo().getBranchLabel());
+            seIf.applyMacro(new TryCloseMacro(), excNode);
+            if (!excNode.isClosed()) {
+                unclosedExceptions.add(
+                        new ExceptionResult(
+                                excNode.getNodeInfo().getBranchLabel(),
+                                extractReadablePathCondition(excNode)));
+            }
+        }
+
+        return unclosedExceptions;
+    }
+
+    /**
+     * Extracts post condition {@link Fact}s, that is equations about the final
+     * state after the method execution (or the use case in the presence of a
+     * loop).
+     *
+     * @param proof
+     *            The {@link Proof} object.
+     * @param facts
+     *            A {@link List} of {@link Fact}s; the method will write
+     *            {@link Fact}s into this list.
+     * @return The number of unclosed "post condition satisfied" goals.
+     */
+    private int extractPostCondFacts(Proof proof, List<Fact> facts) {
+        int numPostCondGoalsNotClosed = 0;
+
+        for (Goal g : proof.openGoals()) {
+            final Node postCondNode = g.node();
+            final Optional<PosInOccurrence> maybePio = //
+                    getPioOfFormulaWhichHadSELabel(postCondNode);
+
+            if (!maybePio.isPresent()) {
+                continue;
+            }
+
+            if (!AnalyzePostCondImpliesMethodEffectsRule.INSTANCE.isApplicable(//
+                    g, maybePio.get())) {
+                continue;
+            }
+
+            final Iterable<Node> analysisNodes = //
+                    GeneralUtilities
+                            .toStream(g.apply(
+                                    AnalyzePostCondImpliesMethodEffectsRule.INSTANCE
+                                            .createApp(maybePio.get(),
+                                                    proof.getServices())))
+                            .map(goal -> goal.node())
+                            .collect(Collectors.toList());
+
+            for (Node analysisNode : analysisNodes) {
+                if (!analysisNode.getNodeInfo().getBranchLabel().equals(
+                        AbstractAnalysisRule.POSTCONDITION_SATISFIED_BRANCH_LABEL)) {
+
+                    final String readablePathCond =
+                            extractReadablePathCondition(
+                                    analysisNode.parent());
+                    final String branchLabel = analysisNode.getNodeInfo()
+                            .getBranchLabel();
+
+                    final Iterable<Node> factAnalysisNodes = //
+                            GeneralUtilities
+                                    .toStream(proof.getGoal(analysisNode)
+                                            .apply(FactAnalysisRule.INSTANCE
+                                                    .createApp(null,
+                                                            proof.getServices())))
+                                    .map(_g -> _g.node())
+                                    .collect(Collectors.toList());
+
+                    facts.add(new Fact(branchLabel.split("\"")[1],
+                            readablePathCond, FactType.POST_COND_FACT,
+                            FactAnalysisRule
+                                    .getFactCoveredNode(factAnalysisNodes),
+                            FactAnalysisRule.getFactAbstractlyCoveredNode(
+                                    factAnalysisNodes),
+                            FactAnalysisRule.getFactAbstractlyCoveredVerifNode(
+                                    factAnalysisNodes)));
+                }
+                else {
+                    // That's a post condition branch -- try to close it
+                    seIf.applyMacro(new TryCloseMacro(10000),
+                            analysisNode);
+                    if (!analysisNode.isClosed()) {
+                        numPostCondGoalsNotClosed++;
+                    }
+                }
+            }
+        }
+
+        if (numPostCondGoalsNotClosed > 0) {
+            LOGGER.warn(
+                    "Specification (method precondition / loop invariant) could "
+                            + "be too weak, or post condition / program wrong: "
+                            + "%s open preserves goals",
+                    numPostCondGoalsNotClosed);
+        }
+
+        return numPostCondGoalsNotClosed;
+    }
+
+    /**
+     * Extracts loop body {@link Fact}s, that is equations about the final state
+     * after execution of a loop body.
+     *
+     * @param proof
+     *            The {@link Proof} object.
+     * @param preservedNodes
+     *            The {@link Node}s containing the "preserved" nodes after the
+     *            application of the {@link LoopScopeInvariantRule}.
+     * @param facts
+     *            A {@link List} of {@link Fact}s; the method will write
+     *            {@link Fact}s into this list.
+     * @return The number of loop invariant goals that are not preserved.
+     */
+    private int extractLoopBodyFactsAndShowValidity(final Proof proof,
+            final List<Node> preservedNodes, final List<Fact> facts) {
+        final Services services = proof.getServices();
+
+        int invariantGoalsNotPreserved = 0;
+
+        for (Node preservedNode : preservedNodes) {
+            final Optional<PosInOccurrence> proofOblPio =
+                    getPioOfFormulaWhichHadSELabel(
+                            preservedNode);
+
+            assert proofOblPio
+                    .isPresent() : "There should be a formula with SE label";
+
+            final RuleApp app = AnalyzeInvImpliesLoopEffectsRule.INSTANCE
+                    .createApp(proofOblPio.get(), services)
+                    .forceInstantiate(proof.getGoal(preservedNode));
+
+            final ImmutableList<Goal> analysisNodesImmList = proof
+                    .getSubtreeGoals(preservedNode).head().apply(app);
+
+            final List<Node> analysisNodes = GeneralUtilities
+                    .toStream(analysisNodesImmList).map(goal -> goal.node())
+                    .filter(n -> !n.getNodeInfo().getBranchLabel().equals(
+                            AbstractAnalysisRule.INVARIANT_PRESERVED_BRANCH_LABEL))
+                    .collect(Collectors.toList());
+
+            for (Node analysisNode : analysisNodes) {
+                final String branchLabel = analysisNode.getNodeInfo()
+                        .getBranchLabel();
+                final String readablePathCondition =
+                        extractReadablePathCondition(
+                                analysisNode.parent());
+
+                final Iterable<Node> factAnalysisNodes = //
+                        GeneralUtilities.toStream(proof.getGoal(analysisNode)
+                                .apply(FactAnalysisRule.INSTANCE.createApp(null,
+                                        proof.getServices())))
+                                .map(g -> g.node())
+                                .collect(Collectors.toList());
+
+                if (factCanBeDiscarded(factAnalysisNodes)) {
+                    // Discard the fact -- too easy ;)
+                    continue;
+                }
+
+                facts.add(new Fact(branchLabel.split("\"")[1],
+                        readablePathCondition, FactType.LOOP_BODY_FACT,
+                        FactAnalysisRule.getFactCoveredNode(factAnalysisNodes),
+                        FactAnalysisRule
+                                .getFactAbstractlyCoveredNode(
+                                        factAnalysisNodes),
+                        FactAnalysisRule
+                                .getFactAbstractlyCoveredVerifNode(
+                                        factAnalysisNodes)));
+            }
+
+            final Optional<Node> maybeActualPreservedNode = GeneralUtilities
+                    .toStream(analysisNodesImmList).map(goal -> goal.node())
+                    .filter(n -> n.getNodeInfo().getBranchLabel() != null
+                            && n.getNodeInfo().getBranchLabel().equals(
+                                    AbstractAnalysisRule.INVARIANT_PRESERVED_BRANCH_LABEL))
+                    .findAny();
+            assert maybeActualPreservedNode.isPresent();
+
+            final Node actualPreservedNode = maybeActualPreservedNode.get();
+            seIf.applyMacro(new TryCloseMacro(10000), actualPreservedNode);
+            if (!actualPreservedNode.isClosed()) {
+                invariantGoalsNotPreserved++;
+            }
+        }
+
+        if (invariantGoalsNotPreserved > 0) {
+            LOGGER.warn(
+                    "Loop invariant could be invalid: %s open preserves goals",
+                    invariantGoalsNotPreserved);
+        }
+
+        return invariantGoalsNotPreserved;
+    }
+
+    /**
+     * Checks for a list of {@link Node}s of a {@link Fact} whether the fact can
+     * be discarded, which is the case if the loop invariant is not needed for
+     * showing it.
+     *
+     * @param analysisNodes
+     *            The collection of {@link Node}s for the {@link Fact} to check.
+     * @return true iff the fact can be shown without the loop invariant.
+     */
+    private boolean factCanBeDiscarded(Iterable<Node> analysisNodes) {
+        // Discard the fact if it can be proven without the
+        // specification
+        final Node coveredByTrueNode = FactAnalysisRule
+                .getCoveredByTrueNode(analysisNodes);
+        seIf.applyMacro(new TryCloseMacro(1000), coveredByTrueNode);
+
+        return coveredByTrueNode.isClosed();
+    }
+
+    /**
+     * Creates a "readable" path condition for the given {@link Node}. If the
+     * path condition could not be computed by the
+     * {@link SymbolicExecutionUtil}, a trivial path condition prefixed with
+     * "ERROR-PC" is returned.
+     *
+     * @param analysisNode
+     *            The {@link Node} to compute a path condition for.
+     * @return The path condition for the {@link Node}.
+     */
+    private static String extractReadablePathCondition(Node analysisNode) {
+        boolean problem = false;
+        Term pathCondTerm = analysisNode.proof().getServices()
+                .getTermBuilder().tt();
+
+        try {
+            pathCondTerm = SymbolicExecutionUtil
+                    .computePathCondition(analysisNode, true, true, false);
+        }
+        catch (ProofInputException e) {
+            problem = true;
+        }
+
+        return (problem ? "ERROR-PC " : "") + GeneralUtilities
+                .cleanWhitespace(LogicPrinter.quickPrintTerm(pathCondTerm,
+                        analysisNode.proof().getServices()));
+    }
+
+    /**
+     * Extracts {@link Proof} {@link Node}s that are representing preserved and
+     * use case parts after a {@link LoopScopeInvariantRule} application. Writes
+     * the result in the given {@link List}s for preserved and post condition
+     * {@link Node}s.
+     *
+     * @param proof
+     *            The {@link Proof} to extract the nodes from.
+     * @param preservedNodes
+     *            The {@link List} into which to store the preserved nodes.
+     * @param postconditionNodes
+     *            The {@link List} into which to store the use case / post
+     *            condition nodes.
+     */
+    private void extractPreservedAndUseCaseNodes(final Proof proof,
+            final List<Node> preservedNodes,
+            final List<Node> postconditionNodes) {
+        final Services services = proof.getServices();
+
+        for (Goal g : proof.openGoals()) {
+            if (g.node().parent().getAppliedRuleApp()
+                    .rule() == AnalyzePostCondImpliesMethodEffectsRule.INSTANCE
+                    && g != proof.getSubtreeGoals(g.node().parent()).head()) {
+                // We ignore the goals for the strength analysis of post
+                // conditions; only the first one after such a rule app will be
+                // considered.
+                continue;
+            }
+
+            final List<LocationVariable> loopScopeIndices = SymbExInterface
+                    .findLoopScopeIndeces(g.node());
+
+            if (loopScopeIndices.isEmpty()) {
+                continue;
+            }
+
+            final boolean isFalseLsiPresent = loopScopeIndices.stream()
+                    .anyMatch(lsi -> {
+                        Optional<Term> maybeRHS = GeneralUtilities
+                                .toStream(g.node().sequent().succedent())
+                                .map(sf -> sf.formula())
+                                .filter(
+                                        f -> f.op() instanceof UpdateApplication)
+                                .map(f -> {
+                                    ImmutableArray<Term> values =
+                                            SymbolicExecutionUtil
+                                                    .extractValueFromUpdate(
+                                                            f.sub(0),
+                                                            lsi);
+
+                                    return values == null || values.size() != 1
+                                            ? (Term) null
+                                            : (Term) values.get(0);
+                                }).filter(t -> t != null).findAny();
+
+                        return maybeRHS.orElse(services.getTermBuilder().TRUE())
+                                .equals(services.getTermBuilder().FALSE());
+                    });
+
+            if (!isFalseLsiPresent) {
+                postconditionNodes.add(g.node());
+            }
+            else {
+                preservedNodes.add(g.node());
+            }
+        }
+    }
+
+    /**
+     * Returns the {@link PosInOccurrence} of the {@link SequentFormula} in the
+     * given node which had the SE term label before (or still has it). Returns
+     * an empty {@link Optional} is it could not be found.
+     *
+     * @param node
+     *            The node to retrieve the {@link PosInOccurrence} from.
+     * @return The {@link PosInOccurrence} of the {@link SequentFormula} in the
+     *         given node which has / had the SE term label.
+     */
+    private Optional<PosInOccurrence> getPioOfFormulaWhichHadSELabel(
+            Node node) {
+        Node currNode = node;
+        int pos = -1;
+
+        while (!currNode.root() && pos == -1) {
+            int i = 0;
+            for (SequentFormula sf : currNode.sequent().succedent()) {
+                if (SymbolicExecutionUtil
+                        .hasSymbolicExecutionLabel(sf.formula())) {
+                    pos = i;
+                    break;
+                }
+
+                i++;
+            }
+
+            currNode = currNode.parent();
+        }
+
+        if (pos == -1) {
+            return Optional.empty();
+        }
+
+        final ImmutableList<SequentFormula> succList = node.sequent()
+                .succedent().asList();
+        final SequentFormula updPostCondSeqFor = succList.take(pos).head();
+        final PosInOccurrence proofOblPio = new PosInOccurrence(
+                updPostCondSeqFor, PosInTerm.getTopLevel(), false);
+
+        return Optional.of(proofOblPio);
+    }
+
+    /**
+     * @return The {@link ProgramMethod} designated by the information provided
+     *         to the constructor.
+     */
+    private ProgramMethod findMethod() {
+        final List<KeYJavaType> declaredTypes = seIf.getDeclaredTypes();
+
+        assert declaredTypes
+                .size() > 0 : "Unexpectedly, no type is declared in the supplied Java file.";
+
+        final List<ClassDeclaration> matchingClassDecls = declaredTypes.stream()
+                .filter(t -> t.getJavaType().getFullName().equals(className))
+                .filter(t -> t.getJavaType() instanceof ClassDeclaration)
+                .map(t -> (ClassDeclaration) t.getJavaType())
+                .collect(Collectors.toList());
+
+        if (matchingClassDecls.isEmpty()) {
+            final String errorMsg = GeneralUtilities.format(
+                    "Could not find type %s in class %s", className,
+                    file.getName());
+            LOGGER.error(errorMsg);
+            throw new RuntimeException(errorMsg);
+        }
+
+        assert matchingClassDecls
+                .size() == 1 : "There should be only one type of a given name";
+
+        final List<ProgramMethod> matchingMethods = GeneralUtilities
+                .toStream(matchingClassDecls.get(0).getMembers())
+                .filter(m -> m instanceof ProgramMethod)
+                .map(m -> (ProgramMethod) m)
+                .filter(m -> m.getName().equals(methodName))
+                .filter(m -> JavaTypeInterface.getMethodTypeDescriptor(m)
+                        .equals(methodTypeStr))
+                .collect(Collectors.toList());
+
+        if (matchingMethods.isEmpty()) {
+            final String errorMsg = GeneralUtilities.format(
+                    "Could not find method %s%s in class %s", methodName,
+                    methodTypeStr, className);
+            LOGGER.error(errorMsg);
+            throw new RuntimeException(errorMsg);
+        }
+
+        assert matchingMethods
+                .size() == 1 : "There should be only one method of a given signature";
+
+        final ProgramMethod method = matchingMethods.get(0);
+        return method;
+    }
+
+    /**
+     * Parses a method identifier string; see
+     * {@link #Analyzer(File, String, Optional)} for comments on the format.
+     *
+     * @param methodStr
+     *            The string to parse.
+     * @return true iff the parsing succeeded, false otherwise.
+     */
+    private boolean parseMethodString(String methodStr) {
+        // @ formatter:off
+        // Expected format:
+        //
+        // <fully qualified type name>::<method name>(<arg decl>)<return type
+        // decl>
+        //
+        // where <arg decl> is according to the field descriptors
+        // in the JVM specification, for instance
+        //
+        // [ILjava.lang.Object;D
+        //
+        // for an integer array, an Object and a double (not that
+        // we would support doubles...). <return type decl> is
+        // constructed similarly, only for a single type.
+        // @ formatter:on
+
+        final Pattern p = Pattern
+                .compile("^([^:]*)::([^\\(]*)(\\([^\\)]*\\).*)$");
+        final Matcher m = p.matcher(methodStr);
+
+        if (!m.matches() || m.groupCount() != 3) {
+            return false;
+        }
+
+        className = m.group(1);
+        methodName = m.group(2);
+        methodTypeStr = m.group(3);
+
+        return true;
+    }
+
+    /**
+     * Pretty prints an {@link AnalyzerResult} to the given {@link PrintStream},
+     * e.g. System.out.
+     *
+     * @param result
+     *            The {@link AnalyzerResult} to print.
+     * @param ps
+     *            The {@link PrintStream} used as an output.
+     */
+    public static void printResults(AnalyzerResult result, PrintStream ps) {
+        if (result.unclosedLoopInvPreservedGoals() > 0) {
+            // @formatter:off
+            ps.println(String.format(
+                    "============================================\n"
+                  + "Open \"invariant preserved\" branches: **%s**:\n"
+                  + "============================================\n",
+                    result.unclosedLoopInvPreservedGoals()));
+            // @formatter:on
+        }
+
+        if (result.unclosedPostCondSatisfiedGoals() > 0) {
+            // @formatter:off
+            ps.println(String.format(
+                    "===================================================\n"
+                  + "Open \"post condition satisfied\" branches: **%s**:\n"
+                  + "===================================================\n",
+                    result.unclosedPostCondSatisfiedGoals()));
+            // @formatter:on
+        }
+
+        if (result.problematicExceptions().size() > 0) {
+            // @formatter:off
+            ps.println("=====================\n"
+                    + "Unhandled Exceptions:\n"
+                    + "=====================\n");
+            // @formatter:on
+
+            final PrintStream fPs = ps;
+            result.problematicExceptions().forEach(e -> {
+                fPs.println(e);
+                fPs.println();
+            });
+        }
+
+        if (result.numUncoveredFacts() > 0) {
+            // @formatter:off
+            ps.println("================\n"
+                     + "Uncovered Facts:\n"
+                     + "================\n");
+            // @formatter:on
+
+            final PrintStream fPs = ps;
+            result.getUncoveredFacts().forEach(f -> {
+                fPs.println(f);
+                fPs.println();
+            });
+        }
+
+        if (result.numAbstractlyCoveredFacts() > 0) {
+            // @formatter:off
+            ps.println("=========================\n"
+                     + "Abstractly Covered Facts:\n"
+                     + "=========================\n");
+            // @formatter:on
+
+            final PrintStream fPs = ps;
+            result.getAbstractlyCoveredFacts().forEach(f -> {
+                fPs.println(f);
+                fPs.println();
+            });
+        }
+
+        // @formatter:off
+        ps.println("========\n"
+                 + "Summary:\n"
+                 + "========\n");
+        // @formatter:on
+
+        ps.printf(
+                "Covered %s (%s concretely, %s abstractly) out of %s facts\n"
+                        + "Strength:          %.2f%%\n"
+                        + "Concrete Strength: %.2f%%\n",
+                result.numCoveredFacts() + result.numAbstractlyCoveredFacts(),
+                result.numCoveredFacts(), result.numAbstractlyCoveredFacts(),
+                result.numFacts(), result.strength(),
+                result.coveredStrength());
+    }
+
+    /**
+     * Result of extracting {@link Fact}s from a {@link Proof} tree.
+     *
+     * @author Dominic Steinhoefel
+     */
+    private static class FactExtractionResult {
+        /**
+         * @see #getFacts()
+         */
+        private final List<Fact> facts;
+
+        /**
+         * @see #getUnclosedLoopInvPreservedGoals()
+         */
+        private final int unclosedLoopInvPreservedGoals;
+
+        /**
+         * @see #getUnclosedPostCondSatisfiedGoals()
+         */
+        private final int unclosedPostCondSatisfiedGoals;
+
+        /**
+         * Constructor.
+         *
+         * @param facts
+         * @param unclosedExceptionGoals
+         */
+        public FactExtractionResult(List<Fact> facts,
+                int unclosedExceptionGoals,
+                int unclosedPostCondSatisfiedGoals) {
+            this.facts = facts;
+            this.unclosedLoopInvPreservedGoals = unclosedExceptionGoals;
+            this.unclosedPostCondSatisfiedGoals =
+                    unclosedPostCondSatisfiedGoals;
+        }
+
+        /**
+         * @return the facts
+         */
+        public List<Fact> getFacts() {
+            return facts;
+        }
+
+        /**
+         * @return the number of unclosed "loop inv preserved" goals
+         */
+        public int getUnclosedLoopInvPreservedGoals() {
+            return unclosedLoopInvPreservedGoals;
+        }
+
+        /**
+         * @return the number of unclosed "post condition satisfied" goals
+         */
+        public int getUnclosedPostCondSatisfiedGoals() {
+            return unclosedPostCondSatisfiedGoals;
+        }
+
+    }
+
+    /**
+     * A visitor for checking whether a given {@link RuleApp} type is present in
+     * a {@link Proof} tree.
+     *
+     * @author Dominic Steinhoefel
+     */
+    private static class RuleAppVisitor implements ProofVisitor {
+        /**
+         * See {@link #success()}.
+         */
+        private boolean success = false;
+
+        /**
+         * The {@link RuleApp} {@link Class} type to search for.
+         */
+        private Class<? extends RuleApp> toSearch;
+
+        /**
+         * @param toSearch
+         *            The {@link RuleApp} {@link Class} type to search for.
+         */
+        public RuleAppVisitor(Class<? extends RuleApp> toSearch) {
+            this.toSearch = toSearch;
+        }
+
+        @Override
+        public void visit(Proof proof, Node visitedNode) {
+            if (visitedNode.getAppliedRuleApp() != null
+                    && toSearch.isInstance(visitedNode.getAppliedRuleApp())) {
+                success = true;
+            }
+        }
+
+        /**
+         * @return true iff the {@link RuleApp} type was found.
+         */
+        public boolean success() {
+            return success;
+        }
+    }
+
+    /**
+     * Types of extracted {@link Fact}s.
+     *
+     * @author Dominic Steinhoefel
+     */
+    public static enum FactType {
+        /** Loop body fact, i.e. an equation of the preserved part. */
+        LOOP_BODY_FACT,
+
+        /**
+         * Post condition fact, i.e. a part of the final state after method
+         * execution that should be shown using the post condition.
+         */
+        POST_COND_FACT
+    }
+
+    /**
+     * A fact is a piece of knowledge about a final state or a specification
+     * element which should be shown. A fact can be "covered" or "abstractly
+     * covered"; for each of those cases, it contains a {@link Node} that should
+     * be used for checking which is the case.
+     *
+     * @author Dominic Steinhoefel
+     */
+    public static class Fact {
+        /**
+         * Concise description of the fact, e.g. a (better short) formula.
+         */
+        private final String descr;
+
+        /**
+         * A {@link String} describing the path condition for this fact.
+         */
+        private final String pathCond;
+
+        /**
+         * The {@link FactType} of this {@link Fact}.
+         */
+        private final FactType factType;
+
+        /**
+         * The {@link Node} that indicates the {@link Fact} is covered if it can
+         * be closed.
+         */
+        private final Node factCoveredNode;
+
+        /**
+         * The {@link Node} that indicates the {@link Fact} is abstractly
+         * covered if it can be closed.
+         */
+        private final Node factAbstractlyCoveredNode;
+
+        /**
+         * The {@link Node} that indicates the {@link Fact} is indeed abstractly
+         * covered, i.e. that the factAbstractlyCoveredNode cannot only be
+         * closed because of the path condition implying the spec (this node has
+         * to remain open).
+         */
+        private final Node factAbstractlyCoveredTestNode;
+
+        /**
+         * True iff the fact is covered.
+         */
+        private boolean covered = false;
+
+        /**
+         * True iff the fact is not covered, but abstractly covered.
+         */
+        private boolean abstractlyCovered = false;
+
+        /**
+         * Constructor. Sets all the final fields, i.e. all but covered and
+         * abstractlyCovered.
+         *
+         * @param descr
+         *            Concise description of the fact, e.g. a (better short)
+         *            formula.
+         * @param pathCond
+         *            A {@link String} describing the path condition for this
+         *            fact.
+         * @param factType
+         *            The {@link FactType} of this {@link Fact}.
+         * @param factCoveredNode
+         *            The {@link Node} that indicates the {@link Fact} is
+         *            covered if it can be closed.
+         * @param factAbstractlyCoveredNode
+         *            The {@link Node} that indicates the {@link Fact} is
+         *            abstractly covered if it can be closed.
+         * @param factAbstractlyCoveredTestNode
+         *            The {@link Node} that indicates the {@link Fact} is indeed
+         *            abstractly covered, i.e. that the
+         *            factAbstractlyCoveredNode cannot only be closed because of
+         *            the path condition implying the spec (this node has to
+         *            remain open).
+         */
+        public Fact(String descr, String pathCond, FactType factType,
+                Node factCoveredNode, Node factAbstractlyCoveredNode,
+                Node factAbstractlyCoveredTestNode) {
+            this.descr = descr.trim();
+            this.pathCond = pathCond.trim().replaceAll("<<[^>]*?>>", "");
+            this.factType = factType;
+            this.factCoveredNode = factCoveredNode;
+            this.factAbstractlyCoveredNode = factAbstractlyCoveredNode;
+            this.factAbstractlyCoveredTestNode = factAbstractlyCoveredTestNode;
+        }
+
+        /**
+         * @return true iff the fact has been set to "covered".
+         */
+        public boolean isCovered() {
+            return covered;
+        }
+
+        /**
+         * Sets the "covered" flag of this {@link Fact}.
+         *
+         * @param covered
+         *            true iff the {@link Fact} should be marked as "covered".
+         */
+        public void setCovered(boolean covered) {
+            assert !abstractlyCovered || !covered;
+
+            this.covered = covered;
+        }
+
+        /**
+         * @return @return true iff the fact has been set to "abstractly
+         *         covered".
+         */
+        public boolean isAbstractlyCovered() {
+            return abstractlyCovered;
+        }
+
+        /**
+         * Sets the "abstractly covered" flag of this {@link Fact}.
+         *
+         * @param abstractlyCovered
+         *            true iff the {@link Fact} should be marked as "abstractly
+         *            covered".
+         */
+        public void setAbstractlyCovered(boolean abstractlyCovered) {
+            assert !abstractlyCovered || !covered;
+
+            this.abstractlyCovered = abstractlyCovered;
+        }
+
+        public String getDescr() {
+            return descr;
+        }
+
+        public String getPathCond() {
+            return pathCond;
+        }
+
+        public FactType getFactType() {
+            return factType;
+        }
+
+        public Node getFactCoveredNode() {
+            return factCoveredNode;
+        }
+
+        public Node getFactAbstractlyCoveredNode() {
+            return factAbstractlyCoveredNode;
+        }
+
+        public Node getFactAbstractlyCoveredTestNode() {
+            return factAbstractlyCoveredTestNode;
+        }
+
+        @Override
+        public String toString() {
+            return String.format("%s, Path condition \"%s\"\n%s",
+                    factTypeToString(factType), pathCond, descr);
+        }
+
+        private static String factTypeToString(FactType ft) {
+            switch (ft) {
+            case LOOP_BODY_FACT:
+                return "Loop body fact";
+            case POST_COND_FACT:
+                return "Post condition implies final state fact";
+            default:
+                GeneralUtilities.logErrorAndThrowRTE(//
+                        LOGGER, "Unknown fact type: %s", ft);
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Represents an exception branch that could not be closed.
+     *
+     * @author Dominic Steinhoefel
+     */
+    public static class ExceptionResult {
+        /**
+         * A description of the exception, e.g. "Array Index out ouf Bounds".
+         */
+        private final String excLabel;
+
+        /**
+         * The path condition of the exception branch.
+         */
+        private final String pathCondition;
+
+        /**
+         * Constructor.
+         *
+         * @param excLabel
+         *            A description of the exception, e.g. "Array Index out ouf
+         *            Bounds".
+         * @param pathCondition
+         *            The path condition of the exception branch.
+         */
+        public ExceptionResult(String excLabel, String pathCondition) {
+            this.excLabel = excLabel;
+            this.pathCondition = pathCondition;
+        }
+
+        public String getExcLabel() {
+            return excLabel;
+        }
+
+        public String getPathCondition() {
+            return pathCondition;
+        }
+
+        @Override
+        public String toString() {
+            return String.format(
+                    "Unclosed exception node \"%s\"\nPath condition: \"%s\"",
+                    excLabel, pathCondition);
+        }
+    }
+
+    /**
+     * Result of a strength analysis as returned by {@link Analyzer#analyze()}.
+     *
+     * @author Dominic Steinhoefel
+     */
+    public static class AnalyzerResult {
+        /**
+         * A weight for "abstractly covered" facts.
+         */
+        private static final double ABSTRACTLY_COVERED_WEIGHT = 0.5d;
+
+        /**
+         * {@link List} of covered {@link Fact}s.
+         */
+        private final List<Fact> coveredFacts;
+
+        /**
+         * {@link List} of abstractly covered {@link Fact}s.
+         */
+        private final List<Fact> abstractlyCoveredFacts;
+
+        /**
+         * {@link List} of uncovered {@link Fact}s.
+         */
+        private final List<Fact> uncoveredFacts;
+
+        /**
+         * The number of loop invariant "preserved" goals that couldn't be
+         * closed.
+         */
+        private final int unclosedLoopInvPreservedGoals;
+
+        /**
+         * The number of "post condition satisfied" goals that couldn't be
+         * closed.
+         */
+        private final int unclosedPostCondSatisfiedGoals;
+
+        /**
+         * A {@link List} of {@link ExceptionResult}s for exception branches
+         * that couldn't be closed.
+         */
+        private final List<ExceptionResult> problematicExceptions;
+
+        /**
+         * Constructor.
+         *
+         * @param coveredFacts
+         *            See {@link #coveredFacts}
+         * @param abstractlyCoveredFacts
+         *            See {@link #abstractlyCoveredFacts}
+         * @param unCoveredFacts
+         *            See {@link #unCoveredFacts}
+         * @param problematicExceptions
+         *            See {@link #problematicExceptions}
+         * @param unclosedLoopInvPreservedGoals
+         *            See {@link #unclosedLoopInvPreservedGoals}
+         * @param unclosedPostCondSatisfiedGoals
+         *            See {@link #unclosedPostCondSatisfiedGoals}
+         */
+        public AnalyzerResult(List<Fact> coveredFacts,
+                List<Fact> abstractlyCoveredFacts, List<Fact> unCoveredFacts,
+                List<ExceptionResult> problematicExceptions,
+                int unclosedLoopInvPreservedGoals,
+                int unclosedPostCondSatisfiedGoals) {
+            this.coveredFacts = coveredFacts;
+            this.abstractlyCoveredFacts = abstractlyCoveredFacts;
+            this.uncoveredFacts = unCoveredFacts;
+            this.unclosedLoopInvPreservedGoals = unclosedLoopInvPreservedGoals;
+            this.problematicExceptions = problematicExceptions;
+            this.unclosedPostCondSatisfiedGoals =
+                    unclosedPostCondSatisfiedGoals;
+        }
+
+        public List<Fact> getCoveredFacts() {
+            return coveredFacts;
+        }
+
+        public List<Fact> getAbstractlyCoveredFacts() {
+            return abstractlyCoveredFacts;
+        }
+
+        public List<Fact> getUncoveredFacts() {
+            return uncoveredFacts;
+        }
+
+        /**
+         * Returns the covered {@link Fact}s of {@link FactType} type.
+         *
+         * @param type
+         *            The type of {@link Fact}s to retrieve.
+         * @return The covered {@link Fact}s of {@link FactType} type.
+         */
+        public List<Fact> getCoveredFactsOfType(FactType type) {
+            return coveredFacts.stream().filter(f -> f.factType == type)
+                    .collect(Collectors.toList());
+        }
+
+        /**
+         * Returns the abstractly covered {@link Fact}s of {@link FactType}
+         * type.
+         *
+         * @param type
+         *            The type of {@link Fact}s to retrieve.
+         * @return The abstractly covered {@link Fact}s of {@link FactType}
+         *         type.
+         */
+        public List<Fact> getAbstractlyCoveredFactsOfType(FactType type) {
+            return abstractlyCoveredFacts.stream()
+                    .filter(f -> f.factType == type)
+                    .collect(Collectors.toList());
+        }
+
+        /**
+         * Returns the uncovered {@link Fact}s of {@link FactType} type.
+         *
+         * @param type
+         *            The type of {@link Fact}s to retrieve.
+         * @return The uncovered {@link Fact}s of {@link FactType} type.
+         */
+        public List<Fact> getUncoveredFactsOfType(FactType type) {
+            return uncoveredFacts.stream().filter(f -> f.factType == type)
+                    .collect(Collectors.toList());
+        }
+
+        /**
+         * @return The number of covered {@link Fact}s.
+         */
+        public int numCoveredFacts() {
+            return coveredFacts.size();
+        }
+
+        /**
+         * @return The number of abstractly covered {@link Fact}s.
+         */
+        public int numAbstractlyCoveredFacts() {
+            return abstractlyCoveredFacts.size();
+        }
+
+        /**
+         * @return The number of uncovered {@link Fact}s.
+         */
+        public int numUncoveredFacts() {
+            return uncoveredFacts.size();
+        }
+
+        /**
+         * @return The total number of {@link Fact}s.
+         */
+        public int numFacts() {
+            return numCoveredFacts() + numAbstractlyCoveredFacts()
+                    + numUncoveredFacts();
+        }
+
+        /**
+         * @return A {@link List} of {@link ExceptionResult}s for exception
+         *         branches that couldn't be closed.
+         */
+        public List<ExceptionResult> problematicExceptions() {
+            return problematicExceptions;
+        }
+
+        /**
+         * @return The number of loop invariant "preserved" goals that couldn't
+         *         be closed.
+         */
+        public int unclosedLoopInvPreservedGoals() {
+            return unclosedLoopInvPreservedGoals;
+        }
+
+        /**
+         * @return The number of "post condition satisfied" goals that couldn't
+         *         be closed.
+         */
+        public int unclosedPostCondSatisfiedGoals() {
+            return unclosedPostCondSatisfiedGoals;
+        }
+
+        /**
+         * @return The strength of this {@link AnalyzerResult} as a percentage
+         *         value. Includes abstractly covered facts that are weighted by
+         *         {@link #ABSTRACTLY_COVERED_WEIGHT}.
+         */
+        public double strength() {
+            return 100d
+                    * (((double) numCoveredFacts())
+                            + ((double) numAbstractlyCoveredFacts())
+                                    * ABSTRACTLY_COVERED_WEIGHT)
+                    / ((double) numFacts());
+        }
+
+        /**
+         * @return A strength value <b>without</b> the "abstractly covered"
+         *         facts.
+         */
+        public double coveredStrength() {
+            return 100d * ((double) numCoveredFacts()) / ((double) numFacts());
+        }
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/RuleProofVisitor.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/RuleProofVisitor.java
new file mode 100644
index 0000000000..405fa60453
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/RuleProofVisitor.java
@@ -0,0 +1,61 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.analyzer;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import de.uka.ilkd.key.proof.Node;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.proof.ProofVisitor;
+import de.uka.ilkd.key.rule.Rule;
+
+/**
+ * Finds {@link Node}s with application of a given {@link Rule} {@link Class}
+ * (or subclasses of it) in the {@link Proof} tree.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class RuleProofVisitor implements ProofVisitor {
+    private Set<Node> result = new LinkedHashSet<>();
+    private final Class<? extends Rule> searched;
+
+    /**
+     * Constructor.
+     * 
+     * @param searched
+     *            The {@link Rule} {@link Class} that the {@link Proof} tree is
+     *            searched for.
+     */
+    public RuleProofVisitor(Class<? extends Rule> searched) {
+        this.searched = searched;
+    }
+
+    @Override
+    public void visit(Proof proof, Node visitedNode) {
+        if (visitedNode.getAppliedRuleApp() != null && searched
+                .isInstance(visitedNode.getAppliedRuleApp().rule())) {
+            result.add(visitedNode);
+        }
+    }
+
+    /**
+     * @return The found {@link Set} of {@link Node}s on which a {@link Rule} of
+     *         the given type has been applied
+     */
+    public Set<Node> result() {
+        return result;
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/SymbExInterface.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/SymbExInterface.java
new file mode 100644
index 0000000000..564e32a815
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/analyzer/SymbExInterface.java
@@ -0,0 +1,370 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.analyzer;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.key_project.util.collection.ImmutableSet;
+
+import de.tud.cs.se.ds.specstr.profile.StrengthAnalysisSEProfile;
+import de.tud.cs.se.ds.specstr.strategy.StrengthAnalysisStrategy;
+import de.tud.cs.se.ds.specstr.util.GeneralUtilities;
+import de.tud.cs.se.ds.specstr.util.JavaTypeInterface;
+import de.tud.cs.se.ds.specstr.util.LogicUtilities;
+import de.uka.ilkd.key.control.DefaultUserInterfaceControl;
+import de.uka.ilkd.key.control.KeYEnvironment;
+import de.uka.ilkd.key.java.abstraction.KeYJavaType;
+import de.uka.ilkd.key.logic.PosInOccurrence;
+import de.uka.ilkd.key.logic.PosInTerm;
+import de.uka.ilkd.key.logic.SequentFormula;
+import de.uka.ilkd.key.logic.op.IProgramMethod;
+import de.uka.ilkd.key.logic.op.LocationVariable;
+import de.uka.ilkd.key.logic.op.ProgramMethod;
+import de.uka.ilkd.key.macros.FinishSymbolicExecutionMacro;
+import de.uka.ilkd.key.macros.ProofMacro;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.Node;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
+import de.uka.ilkd.key.proof.init.ProofInputException;
+import de.uka.ilkd.key.proof.io.ProblemLoaderException;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
+import de.uka.ilkd.key.settings.ProofSettings;
+import de.uka.ilkd.key.speclang.Contract;
+import de.uka.ilkd.key.speclang.FunctionalOperationContract;
+import de.uka.ilkd.key.strategy.StrategyProperties;
+
+/**
+ * Bridge to KeY's symbolic execution engine.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class SymbExInterface {
+    /**
+     * The {@link Logger} for this class.
+     */
+    private static final Logger LOGGER = LogManager.getFormatterLogger();
+
+    /**
+     * The {@link KeYEnvironment} for the method to analyze.
+     */
+    private KeYEnvironment<DefaultUserInterfaceControl> env;
+
+    /**
+     * The {@link File} containing the method to analyze.
+     */
+    private File file;
+
+    /**
+     * The constructed {@link Proof} object.
+     */
+    private Proof proof;
+
+    /**
+     * Constructor.
+     *
+     * @param file
+     *            The {@link File} containing the method to analyze.
+     * @throws ProblemLoaderException
+     *             If the {@link File} could not be loaded, e.g. due to syntax
+     *             errors.
+     */
+    public SymbExInterface(File file) throws ProblemLoaderException {
+        this.file = file;
+        initializeKeYEnv();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param file
+     *            The {@link File} containing the method to analyze.
+     * @param env
+     *            The {@link KeYEnvironment} for the problem to analyse (based
+     *            on the {@link StrengthAnalysisSEProfile}).
+     * @throws ProblemLoaderException
+     *             If the {@link File} could not be loaded, e.g. due to syntax
+     *             errors.
+     */
+    public SymbExInterface(File file,
+            KeYEnvironment<DefaultUserInterfaceControl> env)
+            throws ProblemLoaderException {
+        this.file = file;
+        this.env = env;
+    }
+
+    /**
+     * Builds the {@link KeYEnvironment} for the problem to analyse (based on
+     * the {@link StrengthAnalysisSEProfile}).
+     *
+     * @throws ProblemLoaderException
+     *             If the {@link File} could not be loaded, e.g. due to syntax
+     *             errors.
+     */
+    private void initializeKeYEnv() throws ProblemLoaderException {
+        LOGGER.trace("Building KeY environment for file %s", file);
+        // @formatter:off
+        env = KeYEnvironment.load(
+                StrengthAnalysisSEProfile.INSTANCE,
+                file, // location
+                null, // class path
+                null, // boot class path
+                null, // includes
+                true); // forceNewProfileOfNewProofs
+        // @formatter:on
+        LOGGER.trace("Built up environment.");
+    }
+
+    /**
+     * @see JavaTypeInterface#getDeclaredTypes(KeYEnvironment)
+     * @return The {@link KeYJavaType}s declared in the {@link KeYEnvironment}.
+     */
+    public List<KeYJavaType> getDeclaredTypes() {
+        return JavaTypeInterface.getDeclaredTypes(env);
+    }
+
+    /**
+     * @return The {@link KeYEnvironment} object.
+     */
+    public KeYEnvironment<DefaultUserInterfaceControl> keyEnvironment() {
+        return env;
+    }
+
+    /**
+     * @return The {@link Proof} object if already initialized; make sure to
+     *         call {@link #finishSEForMethod(ProgramMethod)} before calling
+     *         this method.
+     */
+    public Proof proof() {
+        return proof;
+    }
+
+    /**
+     * Initializes the {@link Proof} for the given {@link IProgramMethod}.
+     *
+     * @param pm
+     *            The {@link IProgramMethod} to analyze.
+     * @see #setupStrategy(Proof)
+     */
+    private void initProof(ProgramMethod pm) {
+        if (proof != null) {
+            return;
+        }
+
+        final ImmutableSet<Contract> contracts = env
+                .getSpecificationRepository()
+                .getContracts(pm.getContainerType(), pm);
+
+        if (contracts == null || contracts.size() != 1) {
+            final String msg = GeneralUtilities.format(
+                    "Expected 1 contract for method %s, found %s",
+                    pm.getFullName(),
+                    contracts == null ? 0 : contracts.size());
+
+            LOGGER.error(msg);
+            throw new RuntimeException(msg);
+        }
+
+        final Contract contract = contracts.iterator().next();
+        assert contract instanceof FunctionalOperationContract;
+
+        try {
+            final FunctionalOperationContractPO po = //
+                    new FunctionalOperationContractPO(//
+                            env.getInitConfig(), //
+                            (FunctionalOperationContract) contract, //
+                            true, // add uninterpreted predicate
+                            true); // add symbolic execution label
+
+            proof = env.createProof(po);
+            setupStrategy(proof);
+        }
+        catch (ProofInputException e) {
+            GeneralUtilities.logErrorAndThrowRTE(LOGGER,
+                    "Exception at '%s' of %s:\n%s", contract.getDisplayName(),
+                    contract.getTarget(), e.getMessage());
+        }
+    }
+
+    /**
+     * Initializes the {@link Proof} for pm and finishes symbolic execution.
+     *
+     * @param pm
+     *            The {@link ProgramMethod} to analyze.
+     */
+    public void finishSEForMethod(ProgramMethod pm) {
+        initProof(pm);
+
+        // Start auto mode
+        finishSEForNode(proof.root());
+    }
+
+    /**
+     * Finishes symbolic execution starting at the given {@link Node}.
+     *
+     * @param node
+     *            The {@link Node} to start symbolic execution at.
+     */
+    private void finishSEForNode(Node node) {
+        List<Node> openNodesWithModality = LogicUtilities
+                .extractOpenNodesWithModality(node);
+        List<Node> lastNodesWithModality = new ArrayList<>();
+
+        while (!openNodesWithModality.isEmpty()
+                && !openNodesWithModality.equals(lastNodesWithModality)) {
+
+            openNodesWithModality.forEach(n -> {
+                applyMacro(new FinishSymbolicExecutionMacro(), n);
+            });
+
+            lastNodesWithModality = new ArrayList<>(openNodesWithModality);
+
+            openNodesWithModality = LogicUtilities
+                    .extractOpenNodesWithModality(node);
+        }
+    }
+
+    /**
+     * Applies the given {@link ProofMacro} exhaustively, i.e. until it does not
+     * change anything anymore.
+     *
+     * @param macro
+     *            The {@link ProofMacro} to apply.
+     * @param node
+     *            The root of the subtree to apply the {@link ProofMacro} to.
+     */
+    public void applyMacroExhaustively(ProofMacro macro, Node node) {
+        List<Node> openNodes = GeneralUtilities
+                .toStream(node.proof().getSubtreeGoals(node)).map(g -> g.node())
+                .collect(Collectors.toList());
+        List<Node> lastNodes = new ArrayList<>();
+
+        while (!openNodes.equals(lastNodes)) {
+            openNodes.forEach(n -> applyMacro(macro, n));
+            lastNodes = new ArrayList<>(openNodes);
+
+            openNodes = GeneralUtilities
+                    .toStream(node.proof().getSubtreeGoals(node))
+                    .map(g -> g.node()).collect(Collectors.toList());
+        }
+    }
+
+    /**
+     * Applies a {@link ProofMacro} on a given {@link Node}.
+     *
+     * @param macro
+     *            The {@link ProofMacro} to apply.
+     * @param node
+     *            The {@link Node} to apply the macro on.
+     */
+    public void applyMacro(ProofMacro macro, Node node) {
+        try {
+            macro.applyTo(env.getUi(), node, null, env.getUi());
+        }
+        catch (Exception e) {
+            GeneralUtilities.logErrorAndThrowRTE(LOGGER,
+                    "Problem in applying macro, message: %s", e.getMessage());
+        }
+    }
+
+    /**
+     * Finds all loop scope index variables in the {@link Proof} subtree
+     * starting at the given {@link Node}.
+     *
+     * @param node
+     *            To root of the subtree to search.
+     * @return All loop scope index variables in the {@link Proof} subtree
+     *         starting at the given {@link Node}.
+     * @see LoopScopeInvariantRule
+     */
+    public static List<LocationVariable> findLoopScopeIndeces(final Node node) {
+        final Proof proof = node.proof();
+        List<LocationVariable> result = new ArrayList<>();
+
+        for (Goal g : proof.getSubtreeGoals(node)) {
+            for (SequentFormula sf : g.node().sequent().succedent()) {
+                result.addAll(LogicUtilities.retrieveLoopScopeIndices(
+                        new PosInOccurrence(sf, PosInTerm.getTopLevel(), false),
+                        proof.getServices()));
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Sets up the default strategy settings for strength analysis in the given
+     * {@link Proof}.
+     *
+     * @param proof
+     *            The {@link Proof} to set up.
+     */
+    private static void setupStrategy(Proof proof) {
+        // Set proof strategy options
+        final StrategyProperties sp = strategyProperties(proof);
+
+        // Make sure that the new options are used
+        int maxSteps = 10000;
+        ProofSettings.DEFAULT_SETTINGS.getStrategySettings()
+                .setMaxSteps(maxSteps);
+        ProofSettings.DEFAULT_SETTINGS.getStrategySettings()
+                .setActiveStrategyProperties(sp);
+        proof.getSettings().getStrategySettings().setMaxSteps(maxSteps);
+        proof.setActiveStrategy(
+                new StrengthAnalysisStrategy.Factory().create(proof, sp));
+    }
+
+    /**
+     * Sets and returns the {@link StrategyProperties} for strength analysis.
+     *
+     * @param proof
+     *            The {@link Proof} the strategy of which to set.
+     * @return The {@link StrategyProperties} for strength analysis.
+     */
+    private static StrategyProperties strategyProperties(Proof proof) {
+        final StrategyProperties sp;
+        sp = proof.getSettings().getStrategySettings()
+                .getActiveStrategyProperties();
+
+        // @formatter:off
+        sp.setProperty(StrategyProperties.METHOD_OPTIONS_KEY,
+                StrategyProperties.METHOD_CONTRACT);
+        sp.setProperty(StrategyProperties.DEP_OPTIONS_KEY,
+                StrategyProperties.DEP_ON);
+        sp.setProperty(StrategyProperties.QUERY_OPTIONS_KEY,
+                StrategyProperties.QUERY_ON);
+        sp.setProperty(
+                StrategyProperties.NON_LIN_ARITH_OPTIONS_KEY,
+                StrategyProperties.NON_LIN_ARITH_DEF_OPS);
+        sp.setProperty(
+                StrategyProperties.STOPMODE_OPTIONS_KEY,
+                StrategyProperties.STOPMODE_NONCLOSE);
+        sp.setProperty(
+                StrategyProperties.LOOP_OPTIONS_KEY,
+                StrategyProperties.LOOP_SCOPE_INVARIANT);
+        sp.setProperty(StrategyProperties.OSS_OPTIONS_KEY,
+                StrategyProperties.OSS_OFF);
+        // @formatter:on
+
+        proof.getSettings().getStrategySettings()
+                .setActiveStrategyProperties(sp);
+
+        return sp;
+    }
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/cli/Main.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/cli/Main.java
new file mode 100644
index 0000000000..700589da09
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/cli/Main.java
@@ -0,0 +1,187 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.cli;
+
+import java.io.*;
+import java.util.Optional;
+
+import org.apache.commons.cli.CommandLine;
+import org.apache.commons.cli.CommandLineParser;
+import org.apache.commons.cli.DefaultParser;
+import org.apache.commons.cli.HelpFormatter;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.cli.ParseException;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer;
+import de.tud.cs.se.ds.specstr.gui.AnalyzerGUIDialog;
+import javafx.application.Application;
+
+/**
+ * Main class for CLI access.
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class Main {
+
+    /**
+     * The {@link Logger} for this class.
+     */
+    private static final Logger LOGGER = LogManager.getFormatterLogger();
+
+    /**
+     * The information {@link String} for the help output to the command line.
+     */
+    private static final String INFO_STRING =
+    // @formatter:off
+              "===========================================\n"
+            + "            This is  SpecStr v0.1          \n"
+            + "a tool for assessing the strength of formal\n"
+            + "  specifications using symbolic execution  \n"
+            + "===========================================\n\n";
+            // @formatter:on
+
+    /**
+     * This is a utility class, the constructor is hidden.
+     */
+    private Main() {
+        // Hidden constructor -- utility class
+    }
+
+    /**
+     * The main method for running Alfred from command line.
+     *
+     * @param args
+     *            Command line options; run with -h flag for obtaining
+     *            information about available options.
+     */
+    public static void main(String[] args) {
+        Options options = new Options();
+
+        Option guiOpt = Option.builder("g").longOpt("gui")
+                .desc("Open the Graphical User Interface").required(false)
+                .build();
+
+        Option outFileOpt = Option.builder("o").longOpt("out-file")
+                .desc("Save output to this file").hasArg().required(false)
+                .build();
+
+        Option outFileProofOpt = Option.builder("p").longOpt("proof-out-file")
+                .desc("Save proof to this file").hasArg().required(false)
+                .build();
+
+        Option helpOpt = Option.builder("h").longOpt("help")
+                .desc("Display help (this text) and terminate").required(false)
+                .build();
+
+        options.addOption(guiOpt);
+        options.addOption(outFileOpt);
+        options.addOption(outFileProofOpt);
+        options.addOption(helpOpt);
+
+        CommandLineParser parser = new DefaultParser();
+        try {
+            // parse the command line arguments
+            CommandLine line = parser.parse(options, args);
+
+            if ((line.getArgList().size() < 2 && !line.hasOption("g"))
+                    || line.hasOption("h")) {
+                printHelp(options);
+                System.exit(0);
+            }
+
+            if (line.hasOption("g")) {
+                Application.launch(AnalyzerGUIDialog.class, args);
+                return;
+            }
+
+            String inputFileName = line.getArgList().get(0);
+            File inputFile = new File(inputFileName);
+            String theMethod = line.getArgList().get(1);
+
+            if (!inputFileName.endsWith(".java") || !inputFile.exists()
+                    || !inputFile.isFile()) {
+                System.out.println(
+                        "Invalid file name or not existing file: "
+                                + inputFileName);
+                System.out.println("Please supply an existing Java file.\n");
+                printHelp(options);
+            }
+
+            Optional<File> outProof = line.hasOption(outFileProofOpt.getOpt())
+                    ? Optional.of(
+                            new File(line
+                                    .getOptionValue(outFileProofOpt.getOpt())))
+                    : Optional.empty();
+
+            Analyzer analyzer = new Analyzer(inputFile, theMethod, outProof);
+            Analyzer.AnalyzerResult result = analyzer.analyze();
+
+            PrintStream ps = null;
+            if (line.hasOption(outFileOpt.getOpt())) {
+                File file = new File(line.getOptionValue(outFileOpt.getOpt()));
+                try {
+                    ps = new PrintStream(new FileOutputStream(file));
+                }
+                catch (FileNotFoundException e) {
+                    LOGGER.error("Could not open file %s", file.getName());
+                }
+            }
+
+            if (ps == null) {
+                ps = System.out;
+            }
+
+            Analyzer.printResults(result, ps);
+
+            System.exit(0);
+        }
+        catch (ParseException exp) {
+            printHelp(options);
+            System.exit(0);
+        }
+        catch (RuntimeException e) {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            e.printStackTrace(new PrintStream(baos));
+            LOGGER.error(
+                    "Problem occurred during the analysis:\n%s\n\nStack Trace:\n%s",
+                    e.getMessage(), baos.toString());
+        }
+
+        System.exit(1);
+    }
+
+    /**
+     * Prints a standard help line.
+     *
+     * @param options
+     *            Command line options supplied.
+     */
+    private static void printHelp(Options options) {
+         System.out.println(INFO_STRING);
+        HelpFormatter helpFormatter = new HelpFormatter();
+
+        helpFormatter.printHelp(String.format(
+                "java -cp KeY.jar de.tud.cs.se.ds.specstr.cli.Main\t%s\t%s",
+                "[input Java file]", "[fully qualified method name]"),
+                "", options, "\nFully qualified method names:\n\t"
+                        + "<fully qualified type name>::<method name>(<arg decl>)<return type decl>"
+                        + "\n\t<arg decl> is according to the field descriptors "
+                        + "in the JVM specification, for instance \"[ILjava.lang.Object;B\" "
+                        + "for an integer array, an Object and a boolean");
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/gui/AnalyzerGUIController.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/gui/AnalyzerGUIController.java
new file mode 100644
index 0000000000..0866e646f3
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/gui/AnalyzerGUIController.java
@@ -0,0 +1,612 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2015 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.gui;
+
+import java.awt.Desktop;
+import java.io.*;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+
+import javax.swing.SwingUtilities;
+
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.core.Appender;
+import org.apache.logging.log4j.core.Filter;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.appender.OutputStreamAppender;
+import org.apache.logging.log4j.core.config.Configuration;
+import org.apache.logging.log4j.core.config.LoggerConfig;
+import org.apache.logging.log4j.core.layout.PatternLayout;
+
+import com.uwyn.jhighlight.renderer.XhtmlRendererFactory;
+
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer;
+import de.tud.cs.se.ds.specstr.analyzer.Analyzer.AnalyzerResult;
+import de.tud.cs.se.ds.specstr.analyzer.SymbExInterface;
+import de.tud.cs.se.ds.specstr.util.JavaTypeInterface;
+import de.uka.ilkd.key.gui.MainWindow;
+import de.uka.ilkd.key.java.PrettyPrinter;
+import de.uka.ilkd.key.java.abstraction.KeYJavaType;
+import de.uka.ilkd.key.java.declaration.TypeDeclaration;
+import de.uka.ilkd.key.logic.op.IObserverFunction;
+import de.uka.ilkd.key.logic.op.IProgramMethod;
+import de.uka.ilkd.key.logic.op.ProgramMethod;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.proof.io.ProblemLoaderException;
+import javafx.application.Platform;
+import javafx.beans.binding.Bindings;
+import javafx.beans.property.BooleanProperty;
+import javafx.beans.property.ObjectProperty;
+import javafx.beans.property.SimpleBooleanProperty;
+import javafx.beans.property.SimpleObjectProperty;
+import javafx.collections.FXCollections;
+import javafx.concurrent.Task;
+import javafx.event.ActionEvent;
+import javafx.fxml.FXML;
+import javafx.scene.Cursor;
+import javafx.scene.Node;
+import javafx.scene.Parent;
+import javafx.scene.Scene;
+import javafx.scene.control.*;
+import javafx.scene.control.Alert.AlertType;
+import javafx.scene.layout.GridPane;
+import javafx.scene.layout.Priority;
+import javafx.scene.web.WebView;
+import javafx.stage.FileChooser;
+import javafx.stage.FileChooser.ExtensionFilter;
+import javafx.stage.Window;
+
+/**
+ * TODO: Document.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class AnalyzerGUIController {
+
+    ////// FXML fields
+
+    @FXML
+    private TextField txtJavaFile;
+
+    @FXML
+    private Button btnFileChooser;
+
+    @FXML
+    private Button btnFileEdit;
+
+    @FXML
+    private Button btnRecent;
+
+    @FXML
+    private Button btnOpenKeY;
+
+    @FXML
+    private ComboBox<IObserverFunction> cmbMethodChooser;
+
+    @FXML
+    private Button btnStartAnalysis;
+
+    @FXML
+    private Button btnReloadProof;
+
+    @FXML
+    private WebView wvInfo;
+
+    ////// Private constants
+
+    private final File TMP_DIR;
+
+    ////// Private properties
+
+    private ObjectProperty<Window> mainWindowProperty =
+            new SimpleObjectProperty<>();
+
+    private ObjectProperty<File> javaFileProperty =
+            new SimpleObjectProperty<>();
+
+    private BooleanProperty interfaceDisabledProperty =
+            new SimpleBooleanProperty(false);
+
+    private ObjectProperty<File> proofFileProperty =
+            new SimpleObjectProperty<>();
+
+    private ObjectProperty<Analyzer> analyzerProperty =
+            new SimpleObjectProperty<>();
+
+    private ObjectProperty<Proof> proofProperty =
+            new SimpleObjectProperty<>();
+
+    ////// Private fields
+
+    private SymbExInterface seIf;
+
+    ////// Initializer and public interface
+
+    public AnalyzerGUIController() {
+        File tmpDir;
+        try {
+            tmpDir = Files.createTempDirectory("analyzerOutput").toFile();
+        }
+        catch (IOException e) {
+            tmpDir = null;
+            handleException(e);
+        }
+
+        TMP_DIR = tmpDir;
+    }
+
+    public void initialize() {
+        if (!TMP_DIR.exists()) {
+            if (!TMP_DIR.mkdirs()) {
+                handleException(new RuntimeException(String.format(
+                        "Could not create temporary directory %s",
+                        TMP_DIR.getAbsolutePath())));
+            }
+        }
+
+        txtJavaFile.textProperty().bind(Bindings.when(javaFileProperty.isNull())
+                .then("")
+                .otherwise(javaFileProperty.asString()));
+
+        txtJavaFile.textProperty().addListener((obs, oldV, newV) -> {
+            txtJavaFile.selectPositionCaret(newV.length() - 1);
+        });
+    }
+
+    public void setMainWindow(Window mainWindow) {
+        mainWindowProperty.set(mainWindow);
+
+        recursivelyDoForChildren(mainWindow.sceneProperty().get().getRoot(),
+                n -> {
+                    if (n instanceof Control
+                            && !(n instanceof ScrollBar)
+                            && !(n instanceof SplitPane)) {
+                        final Control ctrl = (Control) n;
+                        ctrl.disableProperty()
+                                .bind(interfaceDisabledProperty);
+                    }
+                });
+
+        btnFileEdit.disableProperty()
+                .bind(javaFileProperty.isNull().or(interfaceDisabledProperty));
+
+        btnRecent.disableProperty().bind(
+                javaFileProperty.isNull().or(interfaceDisabledProperty));
+
+        cmbMethodChooser.disableProperty()
+                .bind(javaFileProperty.isNull().or(interfaceDisabledProperty));
+
+        btnStartAnalysis.disableProperty()
+                .bind(cmbMethodChooser.selectionModelProperty().getValue()
+                        .selectedItemProperty().isNull()
+                        .or(interfaceDisabledProperty));
+
+        btnOpenKeY.disableProperty()
+                .bind(proofProperty.isNull()
+                        .or(btnStartAnalysis.disabledProperty())
+                        .or(interfaceDisabledProperty));
+
+        btnReloadProof.disableProperty()
+                .bind(proofFileProperty.isNull()
+                        .or(btnOpenKeY.disableProperty())
+                        .or(interfaceDisabledProperty));
+    }
+
+    ////// FXML event handlers
+
+    @FXML
+    public void handleMethodSelected(ActionEvent e) {
+        IObserverFunction selected =
+                cmbMethodChooser.getSelectionModel().getSelectedItem();
+
+        if (selected == null) {
+            return;
+        }
+
+        StringWriter sw = new StringWriter();
+        PrettyPrinter pw = new PrettyPrinter(sw, false, true);
+        try {
+            ((ProgramMethod) selected).prettyPrint(pw);
+            loadTextToWebView(sw.getBuffer().toString(), true);
+        }
+        catch (IOException ex) {
+            handleException(ex);
+        }
+
+        proofFileProperty.set(null);
+    }
+
+    @FXML
+    public void handleAnalyzeButtonPressed() {
+        final String methodDescriptor = JavaTypeInterface.getMethodDescriptor(
+                (IProgramMethod) cmbMethodChooser.getSelectionModel()
+                        .getSelectedItem());
+        final File outProofFile = new File(TMP_DIR,
+                methodDescriptor + ".proof");
+
+        proofFileProperty.set(outProofFile);
+
+        Task<Analyzer> task = new Task<Analyzer>() {
+            @Override
+            protected Analyzer call() throws Exception {
+                return doWithDisabledWindow(() -> {
+                    final Analyzer analyzer =
+                            new Analyzer(javaFileProperty.get(),
+                                    methodDescriptor,
+                                    Optional.of(outProofFile),
+                                    seIf.keyEnvironment());
+                    Logger logger =
+                            LogManager.getLogger(AnalyzerGUIController.class);
+                    try (WebViewOutputStream webViewOutputStream =
+                            new WebViewOutputStream()) {
+                        appendWebViewLogger(webViewOutputStream);
+                        analyzer.analyze();
+                    }
+
+                    // Funny hack for "null-terminating" the log stream --
+                    // without that, somehow the log buffer is not reset.
+                    logger.info("\0");
+
+                    return analyzer;
+                });
+            }
+        };
+
+        Thread th = new Thread(task);
+        th.setDaemon(true);
+        th.start();
+
+        task.setOnSucceeded(ev -> {
+            AnalyzerResult result;
+            try {
+                final Analyzer analyzer = task.get();
+                analyzerProperty.set(analyzer);
+                proofProperty.set(analyzer.proof().orElse(null));
+                result = analyzer.result().get();
+
+                ByteArrayOutputStream os = new ByteArrayOutputStream();
+                Analyzer.printResults(result, new PrintStream(os));
+                String resultStr = new String(os.toByteArray(), "UTF-8");
+
+                loadTextToWebView(resultStr, false);
+            }
+            catch (InterruptedException | ExecutionException
+                    | IOException ex) {
+                handleException(ex);
+            }
+        });
+    }
+
+    @FXML
+    public void handleReloadProofButtonPressed() {
+        Task<Void> task = new Task<Void>() {
+            @Override
+            protected Void call() throws Exception {
+                return doWithDisabledWindow(() -> {
+                    Logger logger =
+                            LogManager.getLogger(AnalyzerGUIController.class);
+                    try (WebViewOutputStream webViewOutputStream =
+                            new WebViewOutputStream()) {
+                        appendWebViewLogger(webViewOutputStream);
+                        analyzerProperty.get()
+                                .analyze(proofFileProperty.get());
+                    }
+
+                    // Funny hack for "null-terminating" the log stream --
+                    // without that, somehow the log buffer is not reset.
+                    logger.info("\0");
+                    return null;
+                });
+            }
+        };
+
+        Thread th = new Thread(task);
+        th.setDaemon(true);
+        th.start();
+
+        task.setOnSucceeded(ev -> {
+            try {
+                task.get();
+
+                ByteArrayOutputStream os = new ByteArrayOutputStream();
+                Analyzer.printResults(analyzerProperty.get().result().get(),
+                        new PrintStream(os));
+                String resultStr = new String(os.toByteArray(), "UTF-8");
+
+                loadTextToWebView(resultStr, false);
+            }
+            catch (InterruptedException | ExecutionException
+                    | IOException ex) {
+                handleException(ex);
+            }
+        });
+    }
+
+    @FXML
+    public void handleOpenKeYButtonPressed() {
+        SwingUtilities.invokeLater(() -> {
+            MainWindow keyWin = MainWindow.getInstance(true);
+            keyWin.loadProblem(proofFileProperty.get());
+        });
+    }
+
+    @FXML
+    public void handleChooseFilePressed() {
+        final FileChooser fileChooser = new FileChooser();
+        fileChooser.setTitle("Open Resource File");
+        fileChooser.getExtensionFilters().addAll(
+                new ExtensionFilter("Java Files", "*.java"));
+
+        final File selectedFile =
+                fileChooser.showOpenDialog(mainWindowProperty.get());
+        if (selectedFile != null) {
+            javaFileProperty.set(selectedFile);
+            loadFile();
+        }
+
+        proofFileProperty.set(null);
+    }
+
+    @FXML
+    public void handleEditFilePressed() {
+        if (Desktop.isDesktopSupported()) {
+            new Thread(() -> {
+                try {
+                    Desktop.getDesktop().open(javaFileProperty.get());
+                }
+                catch (IOException e) {
+                    handleException(e);
+                }
+            }).start();
+        }
+    }
+
+    @FXML
+    public void handleLoadRecentPressed() {
+        loadFile();
+    }
+
+    /////// Private helpers
+
+    private void loadFile() {
+        Task<Void> task = new Task<Void>() {
+            @Override
+            protected Void call() throws Exception {
+                return doWithDisabledWindow(() -> {
+                    Platform.runLater(() -> {
+                        try {
+                            String file = new String(Files.readAllBytes(
+                                    javaFileProperty.get().toPath()));
+                            loadTextToWebView(file, true);
+                        }
+                        catch (IOException e) {
+                            handleException(e);
+                        }
+                    });
+                    
+                    loadContractTargets(javaFileProperty.get());
+                    
+                    return null;
+                });
+            }
+        };
+
+        Thread th = new Thread(task);
+        th.setDaemon(true);
+        th.start();
+    }
+
+    private void recursivelyDoForChildren(Parent node, Consumer<Node> job) {
+        for (final Node child : node
+                .getChildrenUnmodifiable()) {
+            job.accept(child);
+            if (child instanceof Parent
+                    && !((Parent) child).getChildrenUnmodifiable().isEmpty()) {
+                recursivelyDoForChildren((Parent) child, job);
+            }
+        }
+    }
+
+    private void loadContractTargets(final File selectedFile) {
+        try {
+            seIf = new SymbExInterface(selectedFile);
+            final List<KeYJavaType> types = seIf.getDeclaredTypes();
+            final List<IObserverFunction> contractTargets = types
+                    .stream()
+                    .filter(t -> t
+                            .getJavaType() instanceof TypeDeclaration
+                            && !((TypeDeclaration) t.getJavaType())
+                                    .isLibraryClass())
+                    .map(t -> seIf.keyEnvironment()
+                            .getSpecificationRepository()
+                            .getContractTargets(t).stream()
+                            .collect(Collectors.toList()))
+                    .flatMap(List::stream)
+                    .collect(Collectors.toList());
+
+            // We reverse the list because in the default ImmutableSet
+            // implementation, new elements are added by prepend() and
+            // therefore, the methods occur in the reverse order than
+            // implemented in the class.
+            Collections.reverse(contractTargets);
+
+            Platform.runLater(() -> {
+                cmbMethodChooser.setItems(FXCollections
+                        .observableArrayList(contractTargets));
+            });
+        }
+        catch (ProblemLoaderException e) {
+            handleException(e);
+        }
+    }
+
+    private <A> A doWithDisabledWindow(Callable<A> lambda) {
+        final Scene scene = mainWindowProperty.get().getScene();
+
+        interfaceDisabledProperty.set(true);
+        scene.setCursor(Cursor.WAIT);
+
+        A result = null;
+        try {
+            result = lambda.call();
+        }
+        catch (Exception e) {
+            handleException(e);
+        }
+
+        interfaceDisabledProperty.set(false);
+        scene.setCursor(Cursor.DEFAULT);
+
+        return result;
+    }
+
+    private void appendWebViewLogger(
+            final WebViewOutputStream webViewOutputStream) {
+        final Configuration config =
+                LoggerContext.getContext(false).getConfiguration();
+        final PatternLayout layout =
+                PatternLayout.createDefaultLayout(config);
+        final Appender appender =
+                OutputStreamAppender.createAppender(layout, null,
+                        webViewOutputStream, "WebViewAppender",
+                        false, true);
+        appender.start();
+        config.addAppender(appender);
+
+        final Level level = null;
+        final Filter filter = null;
+        for (final LoggerConfig loggerConfig : config.getLoggers()
+                .values()) {
+            loggerConfig.addAppender(appender, level, filter);
+        }
+        config.getRootLogger().addAppender(appender, level, filter);
+    }
+
+    private void loadTextToWebView(String text, boolean javaHighlight) {
+        wvInfo.getEngine()
+                .loadContent(new StringBuilder().append("<html>")
+                        .append("<head>")
+                        .append("<style type=\"text/css\">")
+                        .append(XhtmlRendererFactory.getRenderer("java")
+                                .getCssClassDefinitions())
+                        .append("</style>")
+                        .append("</head>")
+                        .append("<body>")
+                        .append(text2HTML(text, javaHighlight))
+                        .append("</body>")
+                        .append("</html>").toString());
+    }
+
+    private String text2HTML(String text, boolean javaHighlight) {
+        if (javaHighlight) {
+            text = text.trim();
+            InputStream in = new ByteArrayInputStream(
+                    text.getBytes(StandardCharsets.UTF_8));
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+            try {
+                XhtmlRendererFactory.getRenderer("java") //
+                        .highlight("", //
+                                in, //
+                                out, //
+                                "utf-8", //
+                                true);
+                text = out.toString("utf-8");
+                in.close();
+                out.close();
+            }
+            catch (IOException e) {
+                handleException(e);
+            }
+        }
+        else {
+            text = text.replaceAll("\n", "<br/>")
+                    .replaceAll(" ", "&nbsp;").replaceAll(
+                            "=+<br/>([^=]*?):<br/>=+",
+                            "<strong>$1</strong>")
+                    .replaceAll("\\*\\*([^\\*]+?)\\*\\*", "<em>$1</em>");
+        }
+
+        return text;
+    }
+
+    private void handleException(Exception e) {
+        Platform.runLater(() -> {
+            Alert alert = new Alert(AlertType.ERROR);
+            alert.setTitle("Exception Dialog");
+            alert.setHeaderText("Sorry, an exception occurred.");
+            alert.setContentText(e.getMessage());
+
+            // Create expandable Exception.
+            StringWriter sw = new StringWriter();
+            PrintWriter pw = new PrintWriter(sw);
+            e.printStackTrace(pw);
+            String exceptionText = sw.toString();
+
+            Label label = new Label("The exception stacktrace was:");
+
+            TextArea textArea = new TextArea(exceptionText);
+            textArea.setEditable(false);
+            textArea.setWrapText(true);
+
+            textArea.setMaxWidth(Double.MAX_VALUE);
+            textArea.setMaxHeight(Double.MAX_VALUE);
+            GridPane.setVgrow(textArea, Priority.ALWAYS);
+            GridPane.setHgrow(textArea, Priority.ALWAYS);
+
+            GridPane expContent = new GridPane();
+            expContent.setMaxWidth(Double.MAX_VALUE);
+            expContent.add(label, 0, 0);
+            expContent.add(textArea, 0, 1);
+
+            // Set expandable Exception into the dialog pane.
+            alert.getDialogPane().setExpandableContent(expContent);
+
+            alert.showAndWait();
+        });
+    }
+
+    ////// Inner classes
+
+    private class WebViewOutputStream extends OutputStream {
+        private String str = "";
+
+        @Override
+        public void write(int b) throws IOException {
+            if (b == 0) {
+                str = "";
+                return;
+            }
+
+            str += (char) b;
+            Platform.runLater(() -> {
+                loadTextToWebView(str.trim(), false);
+            });
+        }
+
+        @Override
+        public void close() throws IOException {
+            str = "";
+        }
+
+    }
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/gui/AnalyzerGUIDialog.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/gui/AnalyzerGUIDialog.java
new file mode 100644
index 0000000000..a439e14034
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/gui/AnalyzerGUIDialog.java
@@ -0,0 +1,55 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2015 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.gui;
+
+import java.net.URL;
+
+import javafx.application.Application;
+import javafx.fxml.FXMLLoader;
+import javafx.scene.Scene;
+import javafx.scene.layout.AnchorPane;
+import javafx.stage.Stage;
+
+/**
+ * The standalone GUI {@link Application} for strength analysis.
+ *
+ * @author Dominic Scheurer
+ */
+public class AnalyzerGUIDialog extends Application {
+
+    @Override
+    public void start(Stage stage) throws Exception {
+        final FXMLLoader loader = new FXMLLoader();
+        final URL resource = AnalyzerGUIDialog.class
+                .getResource("AnalyzerGUI.fxml");
+
+        assert resource != null : "Could not find FXML file for abstraction predicates choice dialog";
+
+        loader.setLocation(resource);
+        
+        final AnchorPane root = (AnchorPane) loader.load();
+        final AnalyzerGUIController controller =
+                (AnalyzerGUIController) loader.getController();
+
+        stage.setTitle("Coverage of Specifications Analysis");
+        stage.setScene(new Scene(root, 900, 500));
+        stage.show();
+
+        controller.setMainWindow(stage);
+    }
+
+    public static void main(String[] args) {
+        Application.launch(AnalyzerGUIDialog.class, args);
+    }
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/logic/label/StrengthAnalysisParameterlessTL.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/logic/label/StrengthAnalysisParameterlessTL.java
new file mode 100644
index 0000000000..b107515512
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/logic/label/StrengthAnalysisParameterlessTL.java
@@ -0,0 +1,88 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.logic.label;
+
+import de.uka.ilkd.key.logic.Name;
+import de.uka.ilkd.key.logic.label.ParameterlessTermLabel;
+import de.uka.ilkd.key.logic.label.TermLabel;
+
+/**
+ * Static {@link TermLabel}s for strength analysis.
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class StrengthAnalysisParameterlessTL implements TermLabel {
+
+    /**
+     * {@link Name} for {@link #FACT_LABEL}.
+     */
+    public static final Name FACT_LABEL_NAME = new Name("fact");
+
+    /**
+     * Label attached to the formula representing a fact to prove.
+     */
+    public static final TermLabel FACT_LABEL = //
+            new StrengthAnalysisParameterlessTL(FACT_LABEL_NAME);
+
+    ///////////////////
+
+    /**
+     * {@link Name} for {@link #FACT_PREMISE_LABEL}.
+     */
+    public static final Name FACT_PREMISE_LABEL_NAME = new Name("factPremise");
+
+    /**
+     * Label attached to the formula representing the premise for a fact, e.g. a
+     * loop invariant or a post condition.
+     */
+    public static final TermLabel FACT_PREMISE_LABEL = //
+            new StrengthAnalysisParameterlessTL(FACT_PREMISE_LABEL_NAME);
+
+    ///////////////////
+
+    /**
+     * Delegate {@link ParameterlessTermLabel} object.
+     */
+    private ParameterlessTermLabel delegate;
+
+    /**
+     * Constructor.
+     *
+     * @param name {@link Name} for the new {@link StrengthAnalysisParameterlessTL}.
+     */
+    private StrengthAnalysisParameterlessTL(Name name) {
+        this.delegate = new ParameterlessTermLabel(name);
+    }
+
+    @Override
+    public Name name() {
+        return delegate.name();
+    }
+
+    @Override
+    public Object getChild(int i) {
+        return delegate.getChild(i);
+    }
+
+    @Override
+    public int getChildCount() {
+        return delegate.getChildCount();
+    }
+
+    @Override
+    public String toString() {
+        return delegate.toString();
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/profile/StrengthAnalysisSEProfile.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/profile/StrengthAnalysisSEProfile.java
new file mode 100644
index 0000000000..01cd01c659
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/profile/StrengthAnalysisSEProfile.java
@@ -0,0 +1,71 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.profile;
+
+import org.key_project.util.collection.ImmutableList;
+import org.key_project.util.collection.ImmutableSet;
+
+import de.tud.cs.se.ds.specstr.rule.AnalyzeInvImpliesLoopEffectsRule;
+import de.tud.cs.se.ds.specstr.rule.AnalyzePostCondImpliesMethodEffectsRule;
+import de.tud.cs.se.ds.specstr.rule.FactAnalysisRule;
+import de.tud.cs.se.ds.specstr.strategy.StrengthAnalysisStrategy;
+import de.uka.ilkd.key.proof.init.Profile;
+import de.uka.ilkd.key.rule.BuiltInRule;
+import de.uka.ilkd.key.strategy.StrategyFactory;
+import de.uka.ilkd.key.symbolic_execution.profile.SymbolicExecutionJavaProfile;
+
+/**
+ * The {@link Profile} for strength analysis.
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class StrengthAnalysisSEProfile extends SymbolicExecutionJavaProfile {
+    /**
+     * Profile name.
+     */
+    public static final String NAME = "Java Profile for Strength Analysis";
+
+    /**
+     * Singleton instance.
+     */
+    public static final StrengthAnalysisSEProfile INSTANCE = new StrengthAnalysisSEProfile();
+
+    /**
+     * Singleton constructor.
+     */
+    private StrengthAnalysisSEProfile() {
+        super(true);
+    }
+
+    @Override
+    protected ImmutableList<BuiltInRule> initBuiltInRules() {
+        return super.initBuiltInRules()
+                .append(AnalyzeInvImpliesLoopEffectsRule.INSTANCE)
+                .append(AnalyzePostCondImpliesMethodEffectsRule.INSTANCE)
+                .append(FactAnalysisRule.INSTANCE);
+    }
+
+    @Override
+    protected ImmutableSet<StrategyFactory> getStrategyFactories() {
+        ImmutableSet<StrategyFactory> set = super.getStrategyFactories();
+        set = set.add(new StrengthAnalysisStrategy.Factory());
+        return set;
+    }
+
+    @Override
+    public String name() {
+        return NAME;
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/profile/StrengthAnalysisSEProfileDefaultProfileResolver.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/profile/StrengthAnalysisSEProfileDefaultProfileResolver.java
new file mode 100644
index 0000000000..547659fc83
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/profile/StrengthAnalysisSEProfileDefaultProfileResolver.java
@@ -0,0 +1,37 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.profile;
+
+import de.uka.ilkd.key.proof.init.DefaultProfileResolver;
+import de.uka.ilkd.key.proof.init.Profile;
+
+/**
+ * The {@link DefaultProfileResolver} for the {@link StrengthAnalysisSEProfile}.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class StrengthAnalysisSEProfileDefaultProfileResolver
+        implements DefaultProfileResolver {
+
+    @Override
+    public String getProfileName() {
+        return StrengthAnalysisSEProfile.NAME;
+    }
+
+    @Override
+    public Profile getDefaultProfile() {
+        return StrengthAnalysisSEProfile.INSTANCE;
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AbstractAnalysisRule.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AbstractAnalysisRule.java
new file mode 100644
index 0000000000..2afaf57416
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AbstractAnalysisRule.java
@@ -0,0 +1,114 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.rule;
+
+import java.util.Optional;
+
+import de.uka.ilkd.key.proof.Node;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.rule.BuiltInRule;
+import de.uka.ilkd.key.rule.RuleApp;
+
+/**
+ * An abstract {@link BuiltInRule} for strength analysis.
+ *
+ * @author Dominic Steinhoefel
+ */
+public abstract class AbstractAnalysisRule implements BuiltInRule {
+
+    /**
+     * The {@link Proof} branch label for a strength analysis case showing that
+     * a loop invariant is preserved.
+     */
+    public static final String INVARIANT_PRESERVED_BRANCH_LABEL = "Invariant preserved";
+
+    /**
+     * The {@link Proof} branch label for a strength analysis case showing that
+     * a post condition is satisfied.
+     */
+    public static final String POSTCONDITION_SATISFIED_BRANCH_LABEL = "Postcondition satisfied";
+
+    /**
+     * The {@link Proof} branch label prefix for fact coverage branches.
+     */
+    public static final String COVERS_FACT_BRANCH_LABEL_PREFIX = "Covers fact";
+
+    /**
+     * A hint for term label refactoring; indicates that a term is a fact of an
+     * analysis.
+     */
+    public static final String FACT_HINT = "factToAnalyze";
+
+    /**
+     * A hint for term label refactoring; indicates that a term is the premise
+     * used to show coverage of a fact.
+     */
+    public static final Object FACT_PREMISE_HINT = "factPremiseHint";
+
+    /**
+     * @return true iff the {@link FactAnalysisRule} should add a goal where all
+     *         loop invariant facts are removed.
+     */
+    public abstract boolean addCoveredWithoutLoopInvGoal();
+
+    /**
+     * @return true iff the {@link FactAnalysisRule} should add a goal where the
+     *         fact and the premise are swapped, i.e., the fact is "abstractly
+     *         covered" by the specification.
+     */
+    public abstract boolean addAbstractlyCoveredGoal();
+
+    /**
+     * Checks whether the given {@link Node} is already a child of an analysis
+     * case. In the worst case, this method iterates all the way to the root of
+     * a {@link Proof}.
+     *
+     * @param n
+     *            The {@link Node} to check.
+     * @return true iff the given {@link Node} is the child of an analysis case.
+     */
+    public static boolean alreadyAnalysisGoal(Node n) {
+        if (n.getAppliedRuleApp().rule() instanceof AbstractAnalysisRule) {
+            return true;
+        }
+
+        if (n.root()) {
+            return false;
+        }
+
+        return alreadyAnalysisGoal(n.parent());
+    }
+
+    /**
+     * If the given {@link Node} is in the subtree of an analysis case, the rule
+     * for that case is returned; otherwise an empty {@link Optional}.
+     *
+     * @param n
+     *            The {@link Node} to check.
+     * @return Either the {@link AbstractAnalysisRule} in the scope of which the
+     *         given {@link Node} resides, or an empty {@link Optional}.
+     */
+    public static Optional<RuleApp> analysisRuleAppOfThisScope(Node n) {
+        if (n.getAppliedRuleApp().rule() instanceof AbstractAnalysisRule) {
+            return Optional.of(n.getAppliedRuleApp());
+        }
+
+        if (n.root()) {
+            return Optional.empty();
+        }
+
+        return analysisRuleAppOfThisScope(n.parent());
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AbstractEffectsAnalysisRule.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AbstractEffectsAnalysisRule.java
new file mode 100644
index 0000000000..4c9d8322ef
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AbstractEffectsAnalysisRule.java
@@ -0,0 +1,215 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.rule;
+
+import static de.tud.cs.se.ds.specstr.util.LogicUtilities.addFactPreconditions;
+import static de.tud.cs.se.ds.specstr.util.LogicUtilities.addSETPredicateToAntec;
+import static de.tud.cs.se.ds.specstr.util.LogicUtilities.extractStoreEqsAndInnerHeapTerm;
+import static de.tud.cs.se.ds.specstr.util.LogicUtilities.prepareGoal;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import org.key_project.util.collection.ImmutableList;
+import org.key_project.util.collection.ImmutableSLList;
+
+import de.tud.cs.se.ds.specstr.util.GeneralUtilities;
+import de.tud.cs.se.ds.specstr.util.LogicUtilities;
+import de.uka.ilkd.key.java.Services;
+import de.uka.ilkd.key.logic.PosInOccurrence;
+import de.uka.ilkd.key.logic.Term;
+import de.uka.ilkd.key.logic.TermBuilder;
+import de.uka.ilkd.key.logic.label.TermLabelState;
+import de.uka.ilkd.key.logic.op.LocationVariable;
+import de.uka.ilkd.key.logic.op.UpdateJunctor;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.rule.BuiltInRule;
+import de.uka.ilkd.key.rule.RuleAbortException;
+import de.uka.ilkd.key.rule.RuleApp;
+import de.uka.ilkd.key.util.Pair;
+import de.uka.ilkd.key.util.mergerule.MergeRuleUtils;
+
+/**
+ * An {@link AbstractAnalysisRule} for the analysis of the coverage of
+ * specification elements (e.g., loop invariants or method post conditions)
+ * w.r.t. concrete code effects (update contents).
+ *
+ * @author Dominic Steinhoefel
+ */
+public abstract class AbstractEffectsAnalysisRule extends AbstractAnalysisRule {
+
+    @Override
+    public ImmutableList<Goal> apply(Goal goal, Services services,
+            RuleApp ruleApp) throws RuleAbortException {
+        final TermBuilder tb = services.getTermBuilder();
+
+        final PosInOccurrence pio = ruleApp.posInOccurrence();
+        final Term updateTerm = pio.subTerm().sub(0);
+
+        assert updateTerm.op() instanceof UpdateJunctor;
+
+        final LinkedHashMap<LocationVariable, Term> updateContent =
+                LogicUtilities
+                        .updateToMap(updateTerm);
+
+        final LinkedHashMap<LocationVariable, Term> updVarOfInterestMap =
+                updateContent
+                        .keySet().stream()
+                        .filter(lhs -> varsOfInterest(goal, services, ruleApp)
+                                .contains(lhs))
+                        .collect(GeneralUtilities.toLinkedHashMap(x -> x,
+                                x -> updateContent.get(x)));
+
+        final LocationVariable heapVar = services.getTypeConverter()
+                .getHeapLDT().getHeap();
+
+        // Retrieve store equalities
+        final Term origHeapTerm = MergeRuleUtils
+                .getUpdateRightSideFor(updateTerm, heapVar);
+
+        final Optional<Pair<Term, List<Term>>> storeEqsAndInnerHeapTerm = //
+                extractStoreEqsAndInnerHeapTerm(services, origHeapTerm);
+
+        final List<Term> storeEqualities = storeEqsAndInnerHeapTerm.isPresent()
+                ? storeEqsAndInnerHeapTerm.get().second
+                : new ArrayList<>();
+
+        final ImmutableList<Goal> goals = goal
+                .split(updVarOfInterestMap.size() + storeEqualities.size() + 1);
+        final Goal[] goalArray = goals.toArray(Goal.class);
+        final TermLabelState termLabelState = new TermLabelState();
+
+        // Mapping from an equation "x = t" to an update which equals the
+        // original update, but without the heap and without any elementary
+        // update which has the LHS of the equation as update LHS.
+        // The equation may be null, then it's ignored.
+        final Function<Term, Term> updWithoutHeapAndCurrLocal =
+                eq -> updateContent.keySet()
+                        .stream()
+                        .filter(lv -> !removeHeapVarInAnalysisOfLocVarEffects()
+                                || !lv.equals(heapVar))
+                        .filter(lv -> eq == null || !lv.equals(eq.sub(0).op()))
+                        .map(lv -> tb.elementary(lv, updateContent.get(lv)))
+                        .reduce(tb.skip(),
+                                (acc, elem) -> tb.parallel(acc, elem));
+
+        final List<Term> locVarAnalysisTerms =
+                updVarOfInterestMap.keySet().stream()
+                        .map(lv -> tb.equals(tb.var(lv),
+                                updVarOfInterestMap.get(lv)))
+                        .collect(Collectors.toList());
+        
+        final List<Term> analysisTerms = new ArrayList<>();
+        analysisTerms.addAll(locVarAnalysisTerms);
+        analysisTerms.addAll(storeEqualities);
+
+        int i = 0;
+        for (Term currAnalysisTerm : analysisTerms) {
+            final Goal analysisGoal = goalArray[i++];
+
+            prepareGoal(pio, analysisGoal,
+                    currAnalysisTerm, termLabelState,
+                    this);
+
+            performAdditionalAnalysisGoalOps(analysisGoal, goal, services,
+                    ruleApp);
+
+            {
+                final Term specNewState = tb.apply(
+                        updWithoutHeapAndCurrLocal.apply(currAnalysisTerm),
+                        specTerm(goal, services, ruleApp));
+
+                final ImmutableList<Term> preconds =
+                        ImmutableSLList.<Term> nil()
+                                .prepend(storeEqualities.stream()
+                                        .filter(eq -> !eq
+                                                .equals(currAnalysisTerm))
+                                        .collect(Collectors.toList()))
+                                .prepend(specNewState);
+
+                addFactPreconditions(analysisGoal, preconds, 1, termLabelState,
+                        this);
+            }
+        }
+
+        addSETPredicateToAntec(goalArray[goalArray.length - 1]);
+        goalArray[goalArray.length - 1].setBranchLabel(
+                specSatisfiedBranchLabel());
+
+        return goals;
+    }
+
+    /**
+     * The location variables the effects to which should be checked; could be
+     * the result variable for a post condition strength analysis, or the "local
+     * outs" for a loop body strength analysis.
+     * 
+     * @param goal
+     * @param services
+     * @param ruleApp
+     *
+     * @return The {@link LocationVariable}s that are of interest for this rule.
+     * 
+     * @see BuiltInRule#apply(Goal, Services, RuleApp) For parameter
+     *      explanations
+     */
+    protected abstract List<LocationVariable> varsOfInterest(Goal goal,
+            Services services, RuleApp ruleApp);
+
+    /**
+     * @param goal
+     * @param services
+     * @param ruleApp
+     * @return The specification {@link Term}, such as the loop invariant or
+     *         method post condition, or (in the future maybe) block contract
+     *         post condition.
+     * 
+     * @see BuiltInRule#apply(Goal, Services, RuleApp) For parameter
+     *      explanations
+     */
+    protected abstract Term specTerm(Goal goal, Services services,
+            RuleApp ruleApp);
+
+    /**
+     * Perform additional operations on an analysis {@link Goal}, like removing
+     * remaining loop invariant formulas that could distract the analysis.
+     *
+     * @param analysisGoal
+     *            The newly created effect analysis {@link Goal}.
+     * @param origGoal
+     *            The original {@link Goal} passed to this rule.
+     * @param services
+     * @param ruleApp
+     * 
+     * @see BuiltInRule#apply(Goal, Services, RuleApp) For parameter
+     *      explanations
+     */
+    protected abstract void performAdditionalAnalysisGoalOps(Goal analysisGoal,
+            Goal origGoal, Services services, RuleApp ruleApp);
+
+    /**
+     * @return true iff in the update generated for the preconditions in the
+     *         analysis of the effects on local variables, the "heap" variable
+     *         should be removed.
+     */
+    protected abstract boolean removeHeapVarInAnalysisOfLocVarEffects();
+
+    /**
+     * @return The branch label for the branch checking whether the
+     *         specification is satisfied.
+     */
+    protected abstract String specSatisfiedBranchLabel();
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzeInvImpliesLoopEffectsRule.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzeInvImpliesLoopEffectsRule.java
new file mode 100644
index 0000000000..b3782975d5
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzeInvImpliesLoopEffectsRule.java
@@ -0,0 +1,167 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.rule;
+
+import static de.tud.cs.se.ds.specstr.util.LogicUtilities.removeLoopInvFormulasFromAntec;
+import static de.tud.cs.se.ds.specstr.util.LogicUtilities.retrieveLoopScopeIndices;
+
+import java.util.List;
+
+import de.uka.ilkd.key.java.Services;
+import de.uka.ilkd.key.logic.Name;
+import de.uka.ilkd.key.logic.PosInOccurrence;
+import de.uka.ilkd.key.logic.Term;
+import de.uka.ilkd.key.logic.TermServices;
+import de.uka.ilkd.key.logic.op.LocationVariable;
+import de.uka.ilkd.key.logic.op.Modality;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.Node;
+import de.uka.ilkd.key.rule.IBuiltInRuleApp;
+import de.uka.ilkd.key.rule.RuleApp;
+import de.uka.ilkd.key.util.mergerule.MergeRuleUtils;
+
+/**
+ * Strength analysis rule for assessing the strength of a loop invariant with
+ * respect to the actual effects of a loop body.
+ * 
+ * TODO: A use case for an inner loop will be a preserves case for an outer
+ * loop. We have to make sure that we use AnalyzeInvImplies... here and not
+ * AnalyzeUseCase.
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class AnalyzeInvImpliesLoopEffectsRule
+        extends AbstractEffectsAnalysisRule {
+
+    /**
+     * The {@link Name} of this {@link AbstractAnalysisRule}.
+     */
+    public static final Name NAME = new Name("AnalyzeInvImpliesLoopEffects");
+
+    /**
+     * Singleton instance of the {@link AnalyzeInvImpliesLoopEffectsRule}.
+     */
+    public static final AnalyzeInvImpliesLoopEffectsRule INSTANCE = //
+            new AnalyzeInvImpliesLoopEffectsRule();
+
+    /**
+     * Singleton constructor.
+     */
+    private AnalyzeInvImpliesLoopEffectsRule() {
+        // Singleton Constructor
+    }
+
+    @Override
+    public Name name() {
+        return NAME;
+    }
+
+    @Override
+    public String displayName() {
+        return NAME.toString();
+    }
+
+    @Override
+    public String toString() {
+        return displayName();
+    }
+
+    @Override
+    public boolean isApplicable(Goal goal, PosInOccurrence pio) {
+        // Rule is applicable if the goal corresponds to one case of the
+        // "preserved" part of a loop (scope) invariant rule application; the
+        // pio must refer to a formula with a leading update where the loop
+        // scope index of the loop is set to FALSE. The formula must have an
+        // empty Java block.
+
+        final Services services = goal.proof().getServices();
+
+        return pio != null && inAnyPreservedCase(pio, services)
+                && !(pio.subTerm().sub(1).op() instanceof Modality)
+                && !alreadyAnalysisGoal(goal.node().parent());
+    }
+
+    private boolean inAnyPreservedCase(PosInOccurrence pio, Services services) {
+        final List<LocationVariable> indices = //
+                retrieveLoopScopeIndices(pio, services);
+
+        if (indices.isEmpty()) {
+            return false;
+        }
+
+        return indices.parallelStream().map(lsi -> MergeRuleUtils
+                .getUpdateRightSideFor(pio.subTerm().sub(0), lsi))
+                .map(rhs -> rhs != null
+                        && rhs.equals(services.getTermBuilder().FALSE()))
+                .reduce(false, (acc, elem) -> acc || elem);
+    }
+
+    @Override
+    public boolean isApplicableOnSubTerms() {
+        return false;
+    }
+
+    @Override
+    public IBuiltInRuleApp createApp(PosInOccurrence pos,
+            TermServices services) {
+        return new AnalyzeInvImpliesLoopEffectsRuleApp(this, pos, null, null,
+                null);
+    }
+
+    @Override
+    public boolean addCoveredWithoutLoopInvGoal() {
+        return true;
+    }
+
+    @Override
+    public boolean addAbstractlyCoveredGoal() {
+        return true;
+    }
+
+    @Override
+    protected List<LocationVariable> varsOfInterest(Goal goal,
+            Services services, RuleApp ruleApp) {
+        final AnalyzeInvImpliesLoopEffectsRuleApp aiileApp = //
+                (AnalyzeInvImpliesLoopEffectsRuleApp) ruleApp;
+
+        return aiileApp.getLocalOuts();
+    }
+
+    @Override
+    protected Term specTerm(Goal goal, Services services, RuleApp ruleApp) {
+        final AnalyzeInvImpliesLoopEffectsRuleApp aiileApp = //
+                (AnalyzeInvImpliesLoopEffectsRuleApp) ruleApp;
+        return aiileApp.getInvTerm();
+    }
+
+    @Override
+    protected void performAdditionalAnalysisGoalOps(Goal analysisGoal,
+            Goal origGoal, Services services, RuleApp ruleApp) {
+        final AnalyzeInvImpliesLoopEffectsRuleApp aiileApp = //
+                (AnalyzeInvImpliesLoopEffectsRuleApp) ruleApp;
+        final Node loopInvNode = aiileApp.getLoopInvNode();
+        removeLoopInvFormulasFromAntec(analysisGoal, loopInvNode);
+    }
+
+    @Override
+    protected boolean removeHeapVarInAnalysisOfLocVarEffects() {
+        return true;
+    }
+
+    @Override
+    protected String specSatisfiedBranchLabel() {
+        return AbstractAnalysisRule.INVARIANT_PRESERVED_BRANCH_LABEL;
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzeInvImpliesLoopEffectsRuleApp.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzeInvImpliesLoopEffectsRuleApp.java
new file mode 100644
index 0000000000..0bf517e6bf
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzeInvImpliesLoopEffectsRuleApp.java
@@ -0,0 +1,161 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.rule;
+
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+
+import org.key_project.util.collection.ImmutableList;
+
+import de.tud.cs.se.ds.specstr.util.LogicUtilities;
+import de.uka.ilkd.key.java.Services;
+import de.uka.ilkd.key.logic.JavaBlock;
+import de.uka.ilkd.key.logic.PosInOccurrence;
+import de.uka.ilkd.key.logic.Term;
+import de.uka.ilkd.key.logic.TermBuilder;
+import de.uka.ilkd.key.logic.op.LocationVariable;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.Node;
+import de.uka.ilkd.key.rule.AbstractBuiltInRuleApp;
+import de.uka.ilkd.key.rule.AbstractLoopInvariantRule;
+import de.uka.ilkd.key.rule.BuiltInRule;
+import de.uka.ilkd.key.rule.IBuiltInRuleApp;
+import de.uka.ilkd.key.rule.LoopInvariantBuiltInRuleApp;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
+import de.uka.ilkd.key.rule.RuleApp;
+import de.uka.ilkd.key.speclang.LoopSpecification;
+
+/**
+ * The {@link RuleApp} for the {@link AnalyzeInvImpliesLoopEffectsRule}.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class AnalyzeInvImpliesLoopEffectsRuleApp
+        extends AbstractBuiltInRuleApp {
+
+    /**
+     * The invariant {@link Term} (without updates).
+     */
+    private final Term invTerm;
+
+    /**
+     * The local out {@link LocationVariable}s of the loop, that is those that
+     * are accessible from the outside.
+     */
+    private final List<LocationVariable> localOuts;
+
+    /**
+     * The {@link Node} with the {@link LoopScopeInvariantRule} application for
+     * the loop the effects of are to be studied here.
+     */
+    private final Node loopInvNode;
+
+    /**
+     * Constructor.
+     *
+     * @param rule
+     *            The {@link BuiltInRule} for this app (an
+     *            {@link AnalyzeInvImpliesLoopEffectsRule}).
+     * @param pio
+     *            The {@link PosInOccurrence} of the rule application.
+     * @param invTerm
+     *            The invariant {@link Term} (without updates).
+     * @param localOuts
+     *            The local out {@link LocationVariable}s of the loop, that is
+     *            those that are accessible from the outside.
+     * @param loopInvNode
+     *            The {@link Node} with the {@link LoopScopeInvariantRule}
+     *            application for the loop the effects of are to be studied
+     *            here.
+     */
+    protected AnalyzeInvImpliesLoopEffectsRuleApp(BuiltInRule rule,
+            PosInOccurrence pio, Term invTerm, List<LocationVariable> localOuts,
+            Node loopInvNode) {
+        super(rule, pio);
+        this.invTerm = invTerm;
+        this.localOuts = localOuts;
+        this.loopInvNode = loopInvNode;
+    }
+
+    @Override
+    public AbstractBuiltInRuleApp replacePos(PosInOccurrence newPos) {
+        return null;
+    }
+
+    @Override
+    public IBuiltInRuleApp setIfInsts(ImmutableList<PosInOccurrence> ifInsts) {
+        setMutable(ifInsts);
+        return this;
+    }
+
+    @Override
+    public boolean complete() {
+        return super.complete() && invTerm != null && localOuts != null;
+    }
+
+    @Override
+    public AbstractBuiltInRuleApp tryToInstantiate(Goal goal) {
+        final Services services = goal.proof().getServices();
+
+        final LocationVariable loopScopeIdxVar = //
+                LogicUtilities.findLoopScopeIndexVar(goal.node());
+
+        if (loopScopeIdxVar == null) {
+            return null;
+        }
+
+        // Find loop where the loop scope index was introduced
+        final Node loopInvNode = LogicUtilities
+                .findCorrespondingLoopInvNode(goal.node(), loopScopeIdxVar);
+
+        if (loopInvNode == null) {
+            return null;
+        }
+
+        final LoopInvariantBuiltInRuleApp loopInvApp = //
+                (LoopInvariantBuiltInRuleApp) loopInvNode.getAppliedRuleApp();
+
+        final LoopSpecification loopSpec = loopInvApp
+                .retrieveLoopInvariantFromSpecification(services);
+
+        final JavaBlock javaBlock = TermBuilder
+                .goBelowUpdates(
+                    loopInvApp.posInOccurrence().sequentFormula().formula())
+                .javaBlock();
+        Term lLoopInvTerm = AbstractLoopInvariantRule.conjunctInv(services,
+            loopInvApp.getHeapContext(), loopSpec, javaBlock);
+
+        List<LocationVariable> lLocalOuts = StreamSupport
+                .stream(loopSpec.getLocalOuts().spliterator(), true)
+                .map(t -> (LocationVariable) t.op())
+                .collect(Collectors.toList());
+
+        return new AnalyzeInvImpliesLoopEffectsRuleApp(this.builtInRule,
+            this.pio, lLoopInvTerm, lLocalOuts, loopInvNode);
+    }
+
+    public Term getInvTerm() {
+        return invTerm;
+    }
+
+    public List<LocationVariable> getLocalOuts() {
+        return localOuts;
+    }
+
+    public Node getLoopInvNode() {
+        return loopInvNode;
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzePostCondImpliesMethodEffectsRule.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzePostCondImpliesMethodEffectsRule.java
new file mode 100644
index 0000000000..128deac85d
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzePostCondImpliesMethodEffectsRule.java
@@ -0,0 +1,161 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.rule;
+
+import static de.tud.cs.se.ds.specstr.util.LogicUtilities.getFOContract;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.uka.ilkd.key.java.Services;
+import de.uka.ilkd.key.logic.*;
+import de.uka.ilkd.key.logic.op.Junctor;
+import de.uka.ilkd.key.logic.op.LocationVariable;
+import de.uka.ilkd.key.logic.op.Modality;
+import de.uka.ilkd.key.logic.op.UpdateApplication;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.rule.IBuiltInRuleApp;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
+import de.uka.ilkd.key.rule.RuleApp;
+import de.uka.ilkd.key.speclang.FunctionalOperationContract;
+
+/**
+ * Strength analysis rule for assessing the strength of a post condition with
+ * respect to the actual effects of the method (modulo abstractions by loop
+ * invariants or method calls by contract).
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class AnalyzePostCondImpliesMethodEffectsRule
+        extends AbstractEffectsAnalysisRule {
+
+    /**
+     * The {@link Name} of this {@link AbstractAnalysisRule}.
+     */
+    public static final Name NAME = new Name(
+            "AnalyzePostCondImpliesMethodEffects");
+
+    /**
+     * Singleton instance of the
+     * {@link AnalyzePostCondImpliesMethodEffectsRule}.
+     */
+    public static final AnalyzePostCondImpliesMethodEffectsRule INSTANCE = //
+            new AnalyzePostCondImpliesMethodEffectsRule();
+
+    private AnalyzePostCondImpliesMethodEffectsRule() {
+        // Singleton Constructor
+    }
+
+    @Override
+    public Name name() {
+        return NAME;
+    }
+
+    @Override
+    public String displayName() {
+        return NAME.toString();
+    }
+
+    @Override
+    public String toString() {
+        return displayName();
+    }
+
+    @Override
+    public boolean isApplicable(Goal goal, PosInOccurrence pio) {
+        Term f = null;
+
+        // We exclude facts for sequents of type "\Gamma ==> \Delta, {U}false",
+        // those are irrelevant for us.
+
+        return pio != null && pio.isTopLevel() && !pio.isInAntec()
+                && !(f = pio.subTerm()).containsJavaBlockRecursive()
+                && f.op() instanceof UpdateApplication
+                && !(f.sub(1).op() instanceof Modality)
+                && !TermBuilder.goBelowUpdates(f).op().equals(Junctor.FALSE)
+                && !AnalyzeInvImpliesLoopEffectsRule.INSTANCE.isApplicable(goal,
+                        pio)
+                && (goal.node().getNodeInfo().getBranchLabel() == null
+                        || !goal.node().getNodeInfo().getBranchLabel()
+                                .equals(LoopScopeInvariantRule. //
+                                        INVARIANT_INITIALLY_VALID_BRANCH_LABEL))
+                && !AbstractAnalysisRule
+                        .alreadyAnalysisGoal(goal.node().parent());
+    }
+
+    @Override
+    public boolean isApplicableOnSubTerms() {
+        return false;
+    }
+
+    @Override
+    public IBuiltInRuleApp createApp(PosInOccurrence pos,
+            TermServices services) {
+        return new AnalyzePostCondImpliesMethodEffectsRuleApp(this, pos);
+    }
+
+    @Override
+    public boolean addCoveredWithoutLoopInvGoal() {
+        return false;
+    }
+
+    @Override
+    public boolean addAbstractlyCoveredGoal() {
+        return true;
+    }
+
+    @Override
+    protected List<LocationVariable> varsOfInterest(Goal goal,
+            Services services, RuleApp ruleApp) {
+        final List<LocationVariable> result = new ArrayList<>();
+
+        final FunctionalOperationContract fContract = //
+                getFOContract(services);
+
+        if (!fContract.getTarget().isVoid()) {
+            // We have to look the variable up from the current namespaces,
+            // since otherwise we will obtain a different object...
+            result.add((LocationVariable) goal.getLocalNamespaces()
+                    .programVariables()
+                    .lookup(fContract.getResult().op().name()));
+        }
+
+        return result;
+    }
+
+    @Override
+    protected Term specTerm(Goal goal, Services services, RuleApp ruleApp) {
+        // Note: That's a very hackish way of retrieving the post condition, but
+        // I did not find a clean one to get it with the correct variable
+        // instantiations
+        return TermBuilder.goBelowUpdates(goal.proof().root()
+                .sequent().succedent().getFirst().formula().sub(1)).sub(0);
+    }
+
+    @Override
+    protected void performAdditionalAnalysisGoalOps(Goal analysisGoal,
+            Goal origGoal, Services services, RuleApp ruleApp) {
+        // We don't do anything
+    }
+
+    @Override
+    protected boolean removeHeapVarInAnalysisOfLocVarEffects() {
+        return false;
+    }
+
+    @Override
+    protected String specSatisfiedBranchLabel() {
+        return AbstractAnalysisRule.POSTCONDITION_SATISFIED_BRANCH_LABEL;
+    }
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzePostCondImpliesMethodEffectsRuleApp.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzePostCondImpliesMethodEffectsRuleApp.java
new file mode 100644
index 0000000000..768bcda4c9
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/AnalyzePostCondImpliesMethodEffectsRuleApp.java
@@ -0,0 +1,68 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.rule;
+
+import org.key_project.util.collection.ImmutableList;
+
+import de.uka.ilkd.key.logic.PosInOccurrence;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.rule.AbstractBuiltInRuleApp;
+import de.uka.ilkd.key.rule.BuiltInRule;
+import de.uka.ilkd.key.rule.IBuiltInRuleApp;
+import de.uka.ilkd.key.rule.RuleApp;
+
+/**
+ * The {@link RuleApp} for the {@link AnalyzePostCondImpliesMethodEffectsRule}.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class AnalyzePostCondImpliesMethodEffectsRuleApp
+        extends AbstractBuiltInRuleApp {
+
+    /**
+     * Constructor.
+     *
+     * @param rule
+     *            The {@link BuiltInRule} for this app (an
+     *            {@link AnalyzePostCondImpliesMethodEffectsRule}).
+     * @param pio
+     *            The {@link PosInOccurrence} of the rule application.
+     */
+    protected AnalyzePostCondImpliesMethodEffectsRuleApp(BuiltInRule rule,
+            PosInOccurrence pio) {
+        super(rule, pio);
+    }
+
+    @Override
+    public AbstractBuiltInRuleApp replacePos(PosInOccurrence newPos) {
+        return null;
+    }
+
+    @Override
+    public IBuiltInRuleApp setIfInsts(ImmutableList<PosInOccurrence> ifInsts) {
+        setMutable(ifInsts);
+        return this;
+    }
+
+    @Override
+    public boolean complete() {
+        return super.complete();
+    }
+
+    @Override
+    public AbstractBuiltInRuleApp tryToInstantiate(Goal goal) {
+        return this;
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/FactAnalysisRule.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/FactAnalysisRule.java
new file mode 100644
index 0000000000..4bee5c1ca7
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/FactAnalysisRule.java
@@ -0,0 +1,317 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.rule;
+
+import static de.tud.cs.se.ds.specstr.util.GeneralUtilities.toStream;
+import static de.tud.cs.se.ds.specstr.util.LogicUtilities.removeLoopInvFormulasFromAntec;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import org.key_project.util.collection.ImmutableList;
+
+import de.tud.cs.se.ds.specstr.logic.label.StrengthAnalysisParameterlessTL;
+import de.tud.cs.se.ds.specstr.util.CNFConverter;
+import de.tud.cs.se.ds.specstr.util.GeneralUtilities;
+import de.tud.cs.se.ds.specstr.util.LogicUtilities;
+import de.uka.ilkd.key.java.Services;
+import de.uka.ilkd.key.logic.Name;
+import de.uka.ilkd.key.logic.PosInOccurrence;
+import de.uka.ilkd.key.logic.PosInTerm;
+import de.uka.ilkd.key.logic.SequentFormula;
+import de.uka.ilkd.key.logic.Term;
+import de.uka.ilkd.key.logic.TermBuilder;
+import de.uka.ilkd.key.logic.TermServices;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.Node;
+import de.uka.ilkd.key.rule.BuiltInRule;
+import de.uka.ilkd.key.rule.IBuiltInRuleApp;
+import de.uka.ilkd.key.rule.RuleAbortException;
+import de.uka.ilkd.key.rule.RuleApp;
+import de.uka.ilkd.key.util.mergerule.MergeRuleUtils;
+
+/**
+ * Performs a "sub analysis" of one of the other analysis rules; that is,
+ * whether a fact is covered, abstractly covered or trivially covered. Not all
+ * of these cases apply to all rules, which is why we do a case distinction.
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class FactAnalysisRule implements BuiltInRule {
+
+    /**
+     * The singleton instance of the {@link FactAnalysisRule}.
+     */
+    public static final FactAnalysisRule INSTANCE = new FactAnalysisRule();
+
+    /**
+     * The branch label for the "abstractly covered" case.
+     */
+    public static final String FACT_ABSTRACTLY_COVERED_BRANCH_LABEL =
+            "Fact abstractly covered (main)";
+
+    /**
+     * The branch label for the "abstractly covered check" case.
+     */
+    public static final String FACT_ABSTRACTLY_COVERED_VERIF_BRANCH_LABEL =
+            "Fact abstractly covered (check)";
+
+    /**
+     * The branch label for the "trivially covered" case.
+     */
+    public static final String FACT_COVERED_WITHOUT_SPECIFICATION_BRANCH_LABEL = //
+            "Fact covered without specification";
+
+    /**
+     * The branch label for the "covered" case.
+     */
+    public static final String FACT_COVERED_BRANCH_LABEL = "Fact covered";
+
+    /**
+     * The {@link Name} of this {@link BuiltInRule}.
+     */
+    private static final Name NAME = new Name("FactAnalysis");
+
+    private FactAnalysisRule() {
+        // Singleton constructor
+    }
+
+    @Override
+    public ImmutableList<Goal> apply(Goal goal, Services services,
+            RuleApp ruleApp) throws RuleAbortException {
+        final TermBuilder tb = services.getTermBuilder();
+        final Node node = goal.node();
+
+        final RuleApp analysisRuleApp = AbstractAnalysisRule
+                .analysisRuleAppOfThisScope(node).get();
+        final AbstractAnalysisRule abstractAnalysisRule = //
+                (AbstractAnalysisRule) analysisRuleApp.rule();
+        final boolean addCoveredWithoutLoopInvGoal = abstractAnalysisRule
+                .addCoveredWithoutLoopInvGoal();
+        final boolean addAbstractlyCoveredGoal = abstractAnalysisRule
+                .addAbstractlyCoveredGoal();
+
+        final Optional<SequentFormula> maybeFactSF = toStream(
+                node.sequent().succedent())
+                        .filter(sf -> sf.formula().containsLabel(
+                                StrengthAnalysisParameterlessTL.FACT_LABEL))
+                        .findAny();
+
+        assert maybeFactSF.isPresent();
+
+        final SequentFormula factSF = maybeFactSF.get();
+
+        final List<SequentFormula> premiseSFs = toStream(
+                node.sequent().antecedent())
+                        .filter(sf -> sf.formula().containsLabel(
+                                StrengthAnalysisParameterlessTL.FACT_PREMISE_LABEL))
+                        .collect(Collectors.toList());
+
+        final Term allPremiseSFs = tb.and(premiseSFs.stream()
+                .map(sf -> sf.formula()).collect(Collectors.toList()));
+        final CNFConverter cnfC = new CNFConverter(tb);
+        final List<Term> premiseConjElems = MergeRuleUtils
+                .getConjunctiveElementsFor(cnfC.convertToCNF(allPremiseSFs));
+
+        final ImmutableList<Goal> goals = goal
+                .split(1 + (addAbstractlyCoveredGoal ? 2 : 0)
+                        + (addCoveredWithoutLoopInvGoal ? 1 : 0));
+        final Goal[] goalArray = goals.toArray(new Goal[] {});
+
+        final Goal coveredGoal = goalArray[goalArray.length - 1];
+        final Goal coveredByTrueGoal = addCoveredWithoutLoopInvGoal
+                ? (addAbstractlyCoveredGoal ? goalArray[2] : goalArray[0])
+                : null;
+        final Goal abstractlyCoveredGoal = //
+                addAbstractlyCoveredGoal ? goalArray[1] : null;
+        final Goal abstractlyCoveredVerifGoal = //
+                addAbstractlyCoveredGoal ? goalArray[0] : null;
+
+        // The "fully covered" goal
+
+        coveredGoal.setBranchLabel(FACT_COVERED_BRANCH_LABEL);
+
+        // Get the loop invariant node for the following two cases -- needed for
+        // the removal of loop invariant formulas
+        Node loopInvNode = null;
+        if (analysisRuleApp instanceof AnalyzeInvImpliesLoopEffectsRuleApp) {
+            loopInvNode =
+                    ((AnalyzeInvImpliesLoopEffectsRuleApp) analysisRuleApp)
+                            .getLoopInvNode();
+        }
+
+        // Fact already covered without specification -- "covered by true"
+
+        if (addCoveredWithoutLoopInvGoal) {
+            coveredByTrueGoal.setBranchLabel(
+                    FACT_COVERED_WITHOUT_SPECIFICATION_BRANCH_LABEL);
+
+            premiseSFs.forEach(sf -> coveredByTrueGoal.removeFormula(
+                    new PosInOccurrence(sf, PosInTerm.getTopLevel(), true)));
+
+            removeLoopInvFormulasFromAntec(coveredByTrueGoal, loopInvNode);
+        }
+
+        // Facts that are "abstractly covered", that is, the fact with the
+        // remaining preconditions implies one of the specification elements, as
+        // in "result > 0" is implied by "result = 3"
+
+        if (addAbstractlyCoveredGoal) {
+            abstractlyCoveredGoal
+                    .setBranchLabel(FACT_ABSTRACTLY_COVERED_BRANCH_LABEL);
+            abstractlyCoveredVerifGoal
+                    .setBranchLabel(FACT_ABSTRACTLY_COVERED_VERIF_BRANCH_LABEL);
+
+            for (final Goal abstrGoal : new Goal[] { abstractlyCoveredGoal,
+                    abstractlyCoveredVerifGoal }) {
+                if (addCoveredWithoutLoopInvGoal) {
+                    // For these rules, we also have to remove the loop
+                    // invariant formulas here
+                    removeLoopInvFormulasFromAntec(abstrGoal, loopInvNode);
+                }
+
+                LogicUtilities.addSETPredicateToAntec(abstrGoal);
+
+                premiseSFs.forEach(sf -> abstrGoal.removeFormula(
+                        new PosInOccurrence(sf, PosInTerm.getTopLevel(),
+                                true)));
+                abstrGoal.removeFormula(
+                        new PosInOccurrence(factSF, PosInTerm.getTopLevel(),
+                                false));
+
+                // Add disjunction of premise formula parts to succedent
+                abstrGoal.addFormula(
+                        new SequentFormula(tb.or(premiseConjElems)), false,
+                        true);
+            }
+
+            // Add fact to antecedent, not for test goal
+            abstractlyCoveredGoal.addFormula(factSF, true, false);
+        }
+
+        return goals;
+    }
+
+    @Override
+    public Name name() {
+        return NAME;
+    }
+
+    @Override
+    public String displayName() {
+        return NAME.toString();
+    }
+
+    @Override
+    public String toString() {
+        return displayName();
+    }
+
+    @Override
+    public boolean isApplicable(Goal goal, PosInOccurrence pio) {
+        final Node node = goal.node();
+        return pio == null && !node.root() && //
+                (node.parent().getAppliedRuleApp()
+                        .rule() instanceof AbstractAnalysisRule)
+                && !node.getNodeInfo().getBranchLabel().equals(
+                        AbstractAnalysisRule.INVARIANT_PRESERVED_BRANCH_LABEL)
+                && !node.getNodeInfo().getBranchLabel().equals(
+                        AbstractAnalysisRule.POSTCONDITION_SATISFIED_BRANCH_LABEL);
+    }
+
+    @Override
+    public boolean isApplicableOnSubTerms() {
+        return false;
+    }
+
+    @Override
+    public IBuiltInRuleApp createApp(PosInOccurrence pos,
+            TermServices services) {
+        return new FactAnalysisRuleApp(this, pos);
+    }
+
+    /**
+     * @param analysisNodes
+     *            The {@link Node}s after an application of
+     *            {@link FactAnalysisRule}.
+     * @return The "abstactly covered" case {@link Node} of the nodes after a
+     *         {@link FactAnalysisRule} application.
+     */
+    public static Node getFactAbstractlyCoveredNode(
+            Iterable<Node> analysisNodes) {
+        return getCaseNode(
+                FactAnalysisRule.FACT_ABSTRACTLY_COVERED_BRANCH_LABEL,
+                analysisNodes);
+    }
+
+    /**
+     * @param analysisNodes
+     *            The {@link Node}s after an application of
+     *            {@link FactAnalysisRule}.
+     * @return The "abstactly covered test" case {@link Node} of the nodes after
+     *         a {@link FactAnalysisRule} application.
+     */
+    public static Node getFactAbstractlyCoveredVerifNode(
+            Iterable<Node> analysisNodes) {
+        return getCaseNode(
+                FactAnalysisRule.FACT_ABSTRACTLY_COVERED_VERIF_BRANCH_LABEL,
+                analysisNodes);
+    }
+
+    /**
+     * @param analysisNodes
+     *            The {@link Node}s after an application of
+     *            {@link FactAnalysisRule}.
+     * @return The "covered" case {@link Node} of the nodes after a
+     *         {@link FactAnalysisRule} application.
+     */
+    public static Node getFactCoveredNode(Iterable<Node> analysisNodes) {
+        return getCaseNode(
+                FactAnalysisRule.FACT_COVERED_BRANCH_LABEL,
+                analysisNodes);
+    }
+
+    /**
+     * @param analysisNodes
+     *            The {@link Node}s after an application of
+     *            {@link FactAnalysisRule}.
+     * @return The "trivially covered" case {@link Node} of the nodes after a
+     *         {@link FactAnalysisRule} application.
+     */
+    public static Node getCoveredByTrueNode(Iterable<Node> analysisNodes) {
+        return getCaseNode(
+                FactAnalysisRule.FACT_COVERED_WITHOUT_SPECIFICATION_BRANCH_LABEL,
+                analysisNodes);
+    }
+
+    /**
+     * @param analysisNodes
+     *            The {@link Node}s after an application of
+     *            {@link FactAnalysisRule}.
+     * @return The case {@link Node} (with the given label) of the nodes after a
+     *         {@link FactAnalysisRule} application.
+     */
+    private static Node getCaseNode(String label,
+            Iterable<Node> analysisNodes) {
+        assert GeneralUtilities.toStream(analysisNodes).findAny().get().parent()
+                .getAppliedRuleApp().rule() == INSTANCE;
+
+        return GeneralUtilities.toStream(analysisNodes)
+                .filter(node -> node.getNodeInfo().getBranchLabel().equals(
+                        label))
+                .findAny().get();
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/FactAnalysisRuleApp.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/FactAnalysisRuleApp.java
new file mode 100644
index 0000000000..1fdcd8bfd1
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/rule/FactAnalysisRuleApp.java
@@ -0,0 +1,61 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.rule;
+
+import org.key_project.util.collection.ImmutableList;
+
+import de.uka.ilkd.key.logic.PosInOccurrence;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.rule.AbstractBuiltInRuleApp;
+import de.uka.ilkd.key.rule.BuiltInRule;
+import de.uka.ilkd.key.rule.IBuiltInRuleApp;
+import de.uka.ilkd.key.rule.RuleApp;
+
+/**
+ * The {@link RuleApp} for the {@link FactAnalysisRule}.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class FactAnalysisRuleApp extends AbstractBuiltInRuleApp {
+
+    /**
+     * Constructor.
+     *
+     * @param rule
+     *            The {@link BuiltInRule} for this app (an
+     *            {@link FactAnalysisRule}).
+     * @param pio
+     *            The {@link PosInOccurrence} of the rule application.
+     */
+    protected FactAnalysisRuleApp(BuiltInRule rule, PosInOccurrence pio) {
+        super(rule, pio);
+    }
+
+    @Override
+    public AbstractBuiltInRuleApp replacePos(PosInOccurrence newPos) {
+        return null;
+    }
+
+    @Override
+    public IBuiltInRuleApp setIfInsts(ImmutableList<PosInOccurrence> ifInsts) {
+        setMutable(ifInsts);
+        return this;
+    }
+
+    @Override
+    public AbstractBuiltInRuleApp tryToInstantiate(Goal goal) {
+        return this;
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/strategy/StrengthAnalysisStrategy.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/strategy/StrengthAnalysisStrategy.java
new file mode 100644
index 0000000000..4f110d4a30
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/strategy/StrengthAnalysisStrategy.java
@@ -0,0 +1,97 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.strategy;
+
+import de.tud.cs.se.ds.specstr.rule.AbstractAnalysisRule;
+import de.tud.cs.se.ds.specstr.rule.AnalyzeInvImpliesLoopEffectsRule;
+import de.tud.cs.se.ds.specstr.rule.AnalyzePostCondImpliesMethodEffectsRule;
+import de.tud.cs.se.ds.specstr.rule.FactAnalysisRule;
+import de.uka.ilkd.key.logic.Name;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.proof.rulefilter.SetRuleFilter;
+import de.uka.ilkd.key.strategy.Strategy;
+import de.uka.ilkd.key.strategy.StrategyFactory;
+import de.uka.ilkd.key.strategy.StrategyProperties;
+import de.uka.ilkd.key.strategy.feature.ConditionalFeature;
+import de.uka.ilkd.key.strategy.feature.Feature;
+import de.uka.ilkd.key.symbolic_execution.strategy.SymbolicExecutionStrategy;
+
+/**
+ * A {@link SymbolicExecutionStrategy} with the {@link AbstractAnalysisRule}s.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class StrengthAnalysisStrategy extends SymbolicExecutionStrategy {
+    /**
+     * The {@link Name} of this strategy; will be saved in proo file headers.
+     */
+    public static final Name NAME = new Name("Strength Analysis Strategy");
+
+    /**
+     * Constructor.
+     *
+     * @param proof
+     *            The {@link Proof} this {@link Strategy} should be used for.
+     * @param sp
+     *            The {@link StrategyProperties} settings.
+     */
+    protected StrengthAnalysisStrategy(Proof proof, StrategyProperties sp) {
+        super(proof, sp);
+    }
+
+    /**
+     * The {@link StrategyFactory} to create strategies of type
+     * {@link StrengthAnalysisStrategy}.
+     *
+     * @author Dominic Steinhoefel
+     */
+    public static class Factory extends SymbolicExecutionStrategy.Factory {
+        @Override
+        public Strategy create(Proof proof, StrategyProperties sp) {
+            return new StrengthAnalysisStrategy(proof, sp);
+        }
+
+        @Override
+        public Name name() {
+            return NAME;
+        }
+    }
+
+    @Override
+    protected Feature setupGlobalF(Feature dispatcher) {
+        Feature globalF = super.setupGlobalF(dispatcher);
+
+        globalF = add(globalF, strengthAnalysisFeature(inftyConst()));
+
+        return globalF;
+    }
+
+    private static Feature strengthAnalysisFeature(Feature cost) {
+        SetRuleFilter filter = new SetRuleFilter();
+        filter.addRuleToSet(AnalyzeInvImpliesLoopEffectsRule.INSTANCE);
+        filter.addRuleToSet(AnalyzePostCondImpliesMethodEffectsRule.INSTANCE);
+        filter.addRuleToSet(FactAnalysisRule.INSTANCE);
+        return ConditionalFeature.createConditional(filter, cost);
+    }
+
+    @Override
+    public Name name() {
+        return NAME;
+    }
+
+    @Override
+    public String toString() {
+        return NAME.toString();
+    }
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/CNFConverter.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/CNFConverter.java
new file mode 100644
index 0000000000..58ccc73d0c
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/CNFConverter.java
@@ -0,0 +1,228 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.util;
+
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.key_project.util.collection.ImmutableArray;
+
+import de.uka.ilkd.key.logic.Term;
+import de.uka.ilkd.key.logic.TermBuilder;
+import de.uka.ilkd.key.logic.TermFactory;
+import de.uka.ilkd.key.logic.op.Equality;
+import de.uka.ilkd.key.logic.op.Junctor;
+import de.uka.ilkd.key.logic.op.QuantifiableVariable;
+import de.uka.ilkd.key.logic.op.Quantifier;
+import de.uka.ilkd.key.logic.op.UpdateApplication;
+
+/**
+ * Converter from formulas into conjunctive normal form, main method
+ * {@link #convertToCNF(Term)}. The returned formulas are logically equivalent,
+ * so no Skolemization takes place! Quantifiers will still be included.
+ *
+ * @author Dominic Steinhoefel
+ */
+public class CNFConverter {
+    /**
+     * The {@link Logger} for this class.
+     */
+    private static final Logger LOGGER = LogManager.getFormatterLogger();
+
+    /**
+     * The {@link TermBuilder} object.
+     */
+    private TermBuilder tb;
+
+    /**
+     * The {@link TermFactory} of {@link #tb}.
+     */
+    private TermFactory tf;
+
+    /**
+     * Constructor.
+     *
+     * @param tb
+     *            The {@link TermBuilder} to use for constructing CNF formulas.
+     */
+    public CNFConverter(TermBuilder tb) {
+        this.tb = tb;
+        this.tf = tb.tf();
+    }
+
+    /**
+     * Converts the {@link Term} t into CNF.
+     *
+     * @param t
+     *            {@link Term} to convert.
+     * @return A logically equivalent CNF of t.
+     */
+    public Term convertToCNF(Term t) {
+        List<Term> updates = null;
+
+        if (t.op() instanceof UpdateApplication) {
+            updates = LogicUtilities.getUpdates(t);
+        }
+
+        final Term cnfMatrix = applyDistributivityLaws(
+            splitQuantifiers(pushNegationsInvards(
+                eliminateBiImplications(TermBuilder.goBelowUpdates(t)))));
+
+        if (updates != null) {
+            Term result = cnfMatrix;
+            for (int i = updates.size() - 1; i >= 0; i--) {
+                result = tb.apply(updates.get(i), result);
+            }
+            return result;
+        } else {
+            return cnfMatrix;
+        }
+    }
+
+    /**
+     * Replaces (bi)implications by the corresponding formulas with negations,
+     * disjunctions and conjunctions only.
+     *
+     * @param t
+     *            The {@link Term} of which to remove (bi)implications.
+     * @return A logically equivalent {@link Term} without (bi)implications.
+     */
+    protected Term eliminateBiImplications(Term t) {
+        if (t.op() == Junctor.IMP) {
+            return tb.or(tb.not(eliminateBiImplications(t.sub(0))),
+                eliminateBiImplications(t.sub(1)));
+        } else if (t.op() == Equality.EQV) {
+            return tb.and(
+                tb.or(//
+                    tb.not(eliminateBiImplications(t.sub(0))),
+                    eliminateBiImplications(t.sub(1))),
+                tb.or(//
+                    tb.not(eliminateBiImplications(t.sub(1))),
+                    eliminateBiImplications(t.sub(0))));
+        } else {
+            return recurse(t, t1 -> eliminateBiImplications(t1));
+        }
+    }
+
+    /**
+     * Converts a formula without (bi)implications into NNF by pushing negations
+     * to the level of atoms.
+     *
+     * @param t
+     *            {@link Term} to convert into NNF; must not include
+     *            (bi)implications.
+     * @return A logically equivalent {@link Term} in NNF.
+     */
+    protected Term pushNegationsInvards(Term t) {
+        if (t.op() == Junctor.NOT) {
+            final Term sub = t.sub(0);
+
+            if (sub.op() == Quantifier.ALL) {
+                final QuantifiableVariable qv = sub.boundVars().get(0);
+                return tb.ex((QuantifiableVariable) qv,
+                    pushNegationsInvards(tb.not(sub.sub(0))));
+            } else if (sub.op() == Quantifier.EX) {
+                final QuantifiableVariable qv = sub.boundVars().get(0);
+                return tb.all(qv, pushNegationsInvards(tb.not(sub.sub(0))));
+            } else if (sub.op() == Junctor.OR) {
+                return tb.and(pushNegationsInvards(tb.not(sub.sub(0))),
+                    pushNegationsInvards(tb.not(sub.sub(1))));
+            } else if (sub.op() == Junctor.AND) {
+                return tb.or(pushNegationsInvards(tb.not(sub.sub(0))),
+                    pushNegationsInvards(tb.not(sub.sub(1))));
+            } else if (sub.op() == Junctor.NOT) {
+                return pushNegationsInvards(sub.sub(0));
+            } else if (sub.op() == Junctor.IMP || sub.op() == Equality.EQV) {
+                GeneralUtilities
+                        .logErrorAndThrowRTE(LOGGER,
+                            "Operator %s not supported by pushNegationInvards, "
+                                    + "call eliminateBiImplications before",
+                            sub.op());
+            }
+        }
+
+        return recurse(t, t1 -> pushNegationsInvards(t1));
+    }
+
+    /**
+     * Splits quantifiers if applicable, that is disjunctions in existentially
+     * and conjunctions in universally quantified formulas into two quantified
+     * subformulas connected by dis/conjunctions.
+     *
+     * @param t
+     *            The {@link Term} in which to split quantifiers.
+     * @return A logically equivalent formula with quantifiers split if
+     *         applicable.
+     */
+    protected Term splitQuantifiers(Term t) {
+        // (\exists x; q || p), (\forall x; q && p) to
+        // (\exists x; q) || (\exists x; p), (\forall x; q) && (\forall x; p)
+
+        if (t.op() instanceof Quantifier) {
+            final QuantifiableVariable qv = t.boundVars().get(0);
+            final Term sub = t.sub(0);
+
+            if (t.op() == Quantifier.ALL && sub.op() == Junctor.AND) {
+                return tb.and(splitQuantifiers(tb.all(qv, sub.sub(0))),
+                    splitQuantifiers(tb.all(qv, sub.sub(1))));
+            } else if (t.op() == Quantifier.EX && sub.op() == Junctor.OR) {
+                return tb.or(splitQuantifiers(tb.ex(qv, sub.sub(0))),
+                    splitQuantifiers(tb.ex(qv, sub.sub(1))));
+            }
+        }
+
+        return recurse(t, t1 -> splitQuantifiers(t1));
+    }
+
+    /**
+     * Converts a formula in NNF into CNF (with quantifiers.
+     *
+     * @param t
+     *            The {@link Term} to convert into CNF.
+     * @return A logically equivalent {@link Term} to t in CNF (with
+     *         quantifiers).
+     */
+    protected Term applyDistributivityLaws(Term t) {
+        // (p && q) || r <==> (p || r) && (q || r)
+        // r || (p && q) r <==> (r || p) && (r || q)
+
+        if (t.op() == Junctor.OR) {
+            final Term sub1 = t.sub(0);
+            final Term sub2 = t.sub(1);
+
+            if (sub1.op() == Junctor.AND) {
+                return tb.and(//
+                    applyDistributivityLaws(tb.or(sub1.sub(0), sub2)),
+                    applyDistributivityLaws(tb.or(sub1.sub(1), sub2)));
+            } else if (sub2.op() == Junctor.AND) {
+                return tb.and(//
+                    applyDistributivityLaws(tb.or(sub1, sub2.sub(0))),
+                    applyDistributivityLaws(tb.or(sub1, sub2.sub(1))));
+            }
+        }
+
+        return recurse(t, t1 -> applyDistributivityLaws(t1));
+    }
+
+    private Term recurse(Term t, Function<Term, Term> f) {
+        return tf.createTerm(//
+            t.op(), //
+            new ImmutableArray<Term>(GeneralUtilities.toStream(t.subs())
+                    .map(sub -> f.apply(sub)).collect(Collectors.toList())),
+            t.boundVars(), t.javaBlock());
+    }
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/GeneralUtilities.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/GeneralUtilities.java
new file mode 100644
index 0000000000..71a8ed8a5e
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/GeneralUtilities.java
@@ -0,0 +1,173 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.util;
+
+import java.util.*;
+import java.util.function.BiFunction;
+import java.util.function.BinaryOperator;
+import java.util.function.Function;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+
+import org.apache.logging.log4j.Logger;
+
+/**
+ * Miscellaneous utilities container class.
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class GeneralUtilities {
+
+    private GeneralUtilities() {
+        // Hidden constructor -- it's a utility class.
+    }
+
+    /**
+     * printf-style formats the given {@link String} with the given parameter
+     * {@link Object}s. The syntax of {@link Formatter} applies.
+     *
+     * @param s
+     *            The format {@link String}.
+     * @param args
+     *            The argument {@link Object}s to insert into the format
+     *            {@link String}.
+     * @return The formatted {@link String}.
+     * @see Formatter
+     */
+    public static String format(String s, Object... args) {
+        StringBuilder sb = new StringBuilder();
+
+        Formatter formatter = new Formatter(sb, Locale.US);
+        formatter.format(s, args);
+        formatter.close();
+
+        return sb.toString();
+    }
+
+    /**
+     * Trims s and replaces all consequitive whitespace characters inside by
+     * only one space.
+     *
+     * @param s
+     *            The {@link String} to clean.
+     * @return A cleaned-up representation of s, no whitespace at beginning and
+     *         end, and at most one whitespace (a space) inside.
+     */
+    public static String cleanWhitespace(String s) {
+        return s.trim().replaceAll("(\\s)+", " ");
+    }
+
+    /**
+     * Tries to parse a {@link String} to an {@link Integer}; returns an
+     * {@link Optional} containing the {@link Integer} in case of success or an
+     * empty {@link Optional} otherwise.
+     *
+     * @param s
+     *            The {@link String} to parse.
+     * @return An {@link Optional} containing the {@link Integer} in case of
+     *         success or an empty {@link Optional} otherwise.
+     */
+    public static Optional<Integer> tryParseInt(String s) {
+        try {
+            int result = Integer.parseInt(s);
+            return Optional.of(result);
+        }
+        catch (NumberFormatException e) {
+            return Optional.empty();
+        }
+    }
+
+    /**
+     * Logs an error messages and throws a {@link RuntimeException}; the message
+     * for the logging and the exception is configured in printf-style.
+     *
+     * @see #format(String, Object...)
+     * @param logger
+     *            The {@link Logger} to which to send the message.
+     * @param s
+     *            The format {@link String}.
+     * @param args
+     *            The argument {@link Object}s to insert into the format
+     *            {@link String}.
+     * @throws RuntimeException
+     *             Always throws a {@link RuntimeException}.
+     */
+    public static void logErrorAndThrowRTE(Logger logger, String s,
+            Object... args) throws RuntimeException {
+        final String msg = format(s, args);
+        logger.error(msg);
+        throw new RuntimeException(msg);
+    }
+
+    /**
+     * Converts the given {@link Iterable} to a {@link Stream}.
+     *
+     * @param it
+     *            The {@link Iterable} to convert to a {@link Stream}.
+     * @return The {@link Stream} for the given {@link Iterable}.
+     * @param <T>
+     *            The type of {@link Iterable}.
+     */
+    public static <T> Stream<T> toStream(Iterable<T> it) {
+        return StreamSupport.stream(it.spliterator(), false);
+    }
+
+    /**
+     * Returns a merge function, suitable for use in
+     * {@link Map#merge(Object, Object, BiFunction) Map.merge()} or
+     * {@link #toMap(Function, Function, BinaryOperator) toMap()}, which always
+     * throws {@code IllegalStateException}. This can be used to enforce the
+     * assumption that the elements being collected are distinct.
+     *
+     * @param <T>
+     *            the type of input arguments to the merge function
+     * @return a merge function which always throw {@code IllegalStateException}
+     * @see Collectors
+     */
+    private static <T> BinaryOperator<T> throwingMerger() {
+        return (u, v) -> {
+            throw new IllegalStateException(
+                    String.format("Duplicate key %s", u));
+        };
+    }
+
+    /**
+     * Returns a {@link LinkedHashMap} as opposed to
+     * {@link Collectors#toMap(Function, Function)} which will return a
+     * {@link HashMap} with unpredictable iteration order.
+     *
+     * @param <T>
+     *            the type of the input elements
+     * @param <K>
+     *            the output type of the key mapping function
+     * @param <U>
+     *            the output type of the value mapping function
+     * @param keyMapper
+     *            a mapping function to produce keys
+     * @param valueMapper
+     *            a mapping function to produce values
+     * @return a {@code Collector} which collects elements into a
+     *         {@code LinkedHashMap} whose keys and values are the result of
+     *         applying mapping functions to the input elements
+     */
+    public static <T, K, U> Collector<T, ?, LinkedHashMap<K, U>> toLinkedHashMap(
+            Function<? super T, ? extends K> keyMapper,
+            Function<? super T, ? extends U> valueMapper) {
+        return Collectors.toMap(keyMapper, valueMapper, throwingMerger(),
+                LinkedHashMap::new);
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/JavaTypeInterface.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/JavaTypeInterface.java
new file mode 100644
index 0000000000..f5569f59bf
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/JavaTypeInterface.java
@@ -0,0 +1,180 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.util;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+import de.uka.ilkd.key.control.DefaultUserInterfaceControl;
+import de.uka.ilkd.key.control.KeYEnvironment;
+import de.uka.ilkd.key.java.abstraction.KeYJavaType;
+import de.uka.ilkd.key.java.abstraction.Type;
+import de.uka.ilkd.key.java.declaration.ClassDeclaration;
+import de.uka.ilkd.key.java.declaration.InterfaceDeclaration;
+import de.uka.ilkd.key.java.declaration.TypeDeclaration;
+import de.uka.ilkd.key.logic.op.IProgramMethod;
+import de.uka.ilkd.key.logic.op.ProgramMethod;
+
+/**
+ * An interface to the String designators for Java types.
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class JavaTypeInterface {
+
+    private JavaTypeInterface() {
+        // Hidden utility class constructor
+    }
+
+    /**
+     * Retrieves all {@link KeYJavaType}s declared in the given
+     * {@link KeYEnvironment}.
+     *
+     * @param environment
+     *            The {@link KeYEnvironment} to retrieve all declared
+     *            {@link KeYJavaType}s from.
+     * @return A {@link List} of all declared {@link KeYJavaType}s in the given
+     *         {@link KeYEnvironment}.
+     */
+    public static List<KeYJavaType> getDeclaredTypes(
+            KeYEnvironment<DefaultUserInterfaceControl> environment) {
+        // @formatter:off
+        return environment.getJavaInfo().getAllKeYJavaTypes().parallelStream()
+                .filter(t -> t.getJavaType() instanceof InterfaceDeclaration
+                          || t.getJavaType() instanceof ClassDeclaration)
+                .filter(t -> !((TypeDeclaration) t.getJavaType()).isLibraryClass())
+                .collect(Collectors.toList());
+        // @formatter:on
+    }
+
+    /**
+     * Internally (in bytecode), fully qualified class names are spelled out
+     * with slashes instead of dots as separators. This method converts normal
+     * class names to these internal representations.
+     *
+     * @param javaClassName
+     *            The class name to convert.
+     * @return An internal representation of the class name.
+     */
+    public static String toInternalName(String javaClassName) {
+        return javaClassName.replaceAll("\\.", "/");
+    }
+
+    /**
+     * Internally (in bytecode), fully qualified class names are spelled out
+     * with slashes instead of dots as separators. This method returns an
+     * internal representation for the name of the supplied {@link KeYJavaType}.
+     *
+     * @param javaType
+     *            The type to return an internal name for.
+     * @return An internal representation of the class name of the given
+     *         {@link KeYJavaType}.
+     */
+    public static String toInternalName(KeYJavaType javaType) {
+        return toInternalName(javaType.getFullName());
+    }
+
+    /**
+     * Returns a bytecode type descriptor for a given {@link KeYJavaType}.
+     * <p>
+     * For instance, a descriptor for <code>de.tud.Test</code> would be
+     * <code>Lde/tud/Test;</code>. For an int, it would be <code>I</code>.
+     *
+     * @param type
+     *            The {@link KeYJavaType} to return a bytecode type descriptor
+     *            for.
+     * @return A bytecode type descriptor for the given {@link KeYJavaType}.
+     * @see Type#getDescriptor(Class)
+     */
+    public static String typeToTypeDescriptor(KeYJavaType type) {
+        if (type.equals(KeYJavaType.VOID_TYPE)) {
+            return "V";
+        }
+
+        // 'V' - void
+        // 'Z' - boolean
+        // 'C' - char
+        // 'B' - byte
+        // 'S' - short
+        // 'I' - int
+        // 'F' - float (unsupported)
+        // 'J' - long
+        // 'D' - double (unsupported)
+
+        final String fullName = type.getFullName();
+
+        if (fullName.startsWith("[")) {
+            // Array type name -- already correct
+            // XXX I know this for primitives, what about object types?
+            return fullName;
+        }
+
+        switch (fullName) {
+        case "int":
+            return "I";
+        case "boolean":
+            return "Z";
+        case "char":
+            return "C";
+        case "long":
+            return "LB";
+        case "short":
+            return "S";
+        case "byte":
+            return "B";
+        default:
+            return "L" + toInternalName(fullName) + ";";
+        }
+    }
+
+    /**
+     * Computes a bytecode method type descriptor for the given
+     * {@link ProgramMethod}. An example is <code>(ILjava/lang/Object;)Z</code>
+     * for a method taking an int and an Object, and returning a boolean.
+     *
+     * @param m
+     *            The {@link ProgramMethod} for the signature of which a method
+     *            type descriptor should be created.
+     * @return A method type descriptor describing the signature of the given
+     *         {@link ProgramMethod}.
+     */
+    public static String getMethodTypeDescriptor(IProgramMethod m) {
+        StringBuilder sb = new StringBuilder();
+
+        sb.append("(");
+        // TODO varargs parameters
+        m.getParameters().forEach(s -> sb.append(
+                typeToTypeDescriptor(s.getTypeReference().getKeYJavaType())));
+        sb.append(")");
+        sb.append(typeToTypeDescriptor(m.getReturnType()));
+
+        return sb.toString();
+    }
+
+    /**
+     * Returns a {@link String} describing the given {@link IProgramMethod}, of
+     * the form:
+     * <code>&lt;type&gt;#&lt;methodName&gt;&lt;methodTypeDescriptor&gt;</code>.
+     *
+     * @param m
+     *            The {@link IProgramMethod} for which a descriptor should be
+     *            generated.
+     * @return A {@link String} describing the given {@link IProgramMethod}.
+     */
+    public static String getMethodDescriptor(IProgramMethod m) {
+        return m.getContainerType().getFullName() + "::" + m.getName()
+                + getMethodTypeDescriptor(m);
+    }
+
+}
diff --git a/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/LogicUtilities.java b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/LogicUtilities.java
new file mode 100644
index 0000000000..82b4ad79a9
--- /dev/null
+++ b/key/key.specstrength/src/de/tud/cs/se/ds/specstr/util/LogicUtilities.java
@@ -0,0 +1,894 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package de.tud.cs.se.ds.specstr.util;
+
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+
+import de.tud.cs.se.ds.specstr.logic.label.StrengthAnalysisParameterlessTL;
+import de.tud.cs.se.ds.specstr.rule.AbstractAnalysisRule;
+import de.uka.ilkd.key.java.JavaInfo;
+import de.uka.ilkd.key.java.Services;
+import de.uka.ilkd.key.java.declaration.ArrayDeclaration;
+import de.uka.ilkd.key.java.visitor.Visitor;
+import de.uka.ilkd.key.ldt.HeapLDT;
+import de.uka.ilkd.key.logic.*;
+import de.uka.ilkd.key.logic.label.*;
+import de.uka.ilkd.key.logic.op.LocationVariable;
+import de.uka.ilkd.key.logic.op.ProgramVariable;
+import de.uka.ilkd.key.logic.op.UpdateApplication;
+import de.uka.ilkd.key.logic.sort.NullSort;
+import de.uka.ilkd.key.logic.sort.Sort;
+import de.uka.ilkd.key.pp.LogicPrinter;
+import de.uka.ilkd.key.proof.Goal;
+import de.uka.ilkd.key.proof.Node;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.proof.init.AbstractOperationPO;
+import de.uka.ilkd.key.proof.init.ContractPO;
+import de.uka.ilkd.key.proof.init.FunctionalOperationContractPO;
+import de.uka.ilkd.key.rule.LoopInvariantBuiltInRuleApp;
+import de.uka.ilkd.key.rule.LoopScopeInvariantRule;
+import de.uka.ilkd.key.rule.Rule;
+import de.uka.ilkd.key.speclang.FunctionalOperationContract;
+import de.uka.ilkd.key.util.LinkedHashMap;
+import de.uka.ilkd.key.util.Pair;
+import de.uka.ilkd.key.util.mergerule.MergeRuleUtils;
+
+/**
+ * TODO
+ *
+ * @author Dominic Steinhoefel
+ */
+public final class LogicUtilities {
+
+    /**
+     * A cache for formulas that are known to originate from a loop invariant.
+     */
+    private static final Map<Node, Set<Term>> LOOP_INV_FORMULAS_CACHE =
+            new LinkedHashMap<>();
+
+    private LogicUtilities() {
+        // Hidden constructor -- it's a utility class.
+    }
+
+    /**
+     * Extracts the store terms of the heap {@link Term} origHeapTerm and
+     * returns them along with the inner heap {@link Term}, which is a constant
+     * or a heap with a top level anon operation.
+     *
+     * @param services
+     *            The {@link Services} object.
+     * @param origHeapTerm
+     *            The heap {@link Term} to analyze.
+     * @return A pair of the inner heap in origHeapTerm and the stores around
+     *         the inner heap.
+     */
+    public static Optional<Pair<Term, List<Term>>> extractStoreEqsAndInnerHeapTerm(
+            Services services, final Term origHeapTerm) {
+        if (origHeapTerm == null) {
+            return Optional.empty();
+        }
+
+        final HeapLDT heapLDT = services.getTypeConverter().getHeapLDT();
+        final TermBuilder tb = services.getTermBuilder();
+
+        final List<Term> storeEqualities = new ArrayList<>();
+        Term innerHeapTerm = origHeapTerm;
+
+        // TODO: Is it justified to assume that a heap is of the form
+        // store(store(...(anon/heap...))), i.e. if there is a store,
+        // then we have a store sequence at the beginning?
+        Term currHeapTerm = innerHeapTerm;
+        while (currHeapTerm.op() == heapLDT.getStore()) {
+            final Term targetObj = currHeapTerm.sub(1);
+            final Term field = currHeapTerm.sub(2);
+            final Term value = currHeapTerm.sub(3);
+
+            // Note: value could contain method-local variables, in which
+            // case the fact is likely to be uncovered by the post
+            // condition. Still, we don't remove it, since then indeed, this
+            // reflects behavior that is not shown to the outside, and thus
+            // indicates that we're not using the strongest possible post
+            // condition.
+
+            final Sort sort = getHeapStoreTargetSort(services, currHeapTerm);
+
+            storeEqualities.add(tb.equals(
+                    tb.select(sort, tb.getBaseHeap(), targetObj, field),
+                    value));
+
+            currHeapTerm = currHeapTerm.sub(0);
+        }
+
+        // Here, currHeapTerm should be the "core" without any stores.
+        innerHeapTerm = currHeapTerm;
+
+        return Optional
+                .of(new Pair<Term, List<Term>>(innerHeapTerm, storeEqualities));
+    }
+
+    /**
+     * Gets the sort of a "store" expression, that is the sort of the stored
+     * value. Also works for null-assignments and Array types.
+     *
+     * @param services
+     *            The {@link Services} object for {@link NamespaceSet}s and
+     *            {@link JavaInfo}.
+     * @param currHeapTerm
+     *            The heap store {@link Term}.
+     * @return The sort of the store expression.
+     */
+    private static Sort getHeapStoreTargetSort(final Services services,
+            final Term currHeapTerm) {
+        final Term targetObj = currHeapTerm.sub(1);
+        final Term field = currHeapTerm.sub(2);
+        final Term value = currHeapTerm.sub(3);
+
+        Sort sort = null;
+        if (!(value.sort() instanceof NullSort)) {
+            sort = value.sort();
+        }
+        else if (((ProgramVariable) targetObj.op()).getKeYJavaType()
+                .getJavaType() instanceof ArrayDeclaration) {
+            sort = services.getNamespaces().sorts().lookup(
+                    ((ArrayDeclaration) ((ProgramVariable) targetObj.op())
+                            .getKeYJavaType().getJavaType()).getBaseType()
+                                    .getName());
+        }
+        else {
+            sort = services.getJavaInfo().getAttribute(
+                    // Format is "path.to.type::$field"; we have to remove the
+                    // "$"
+                    // to find the field in the JavaInfo.
+                    field.toString().replaceAll("\\$", ""),
+                    services.getJavaInfo()
+                            .getTypeByClassName(
+                                    field.toString().split("::")[0]))
+                    .sort();
+        }
+        return sort;
+    }
+
+    /**
+     * Returns the {@link FunctionalOperationContract} underlying the current
+     * {@link Proof}.
+     *
+     * @param services
+     *            The {@link Services} object of the {@link Proof}.
+     * @return The {@link FunctionalOperationContract} underlying the current
+     *         {@link Proof}.
+     */
+    public static FunctionalOperationContract getFOContract(Services services) {
+        final ContractPO contractPO = services.getSpecificationRepository()
+                .getContractPOForProof(services.getProof());
+        assert contractPO != null
+                && contractPO instanceof FunctionalOperationContractPO;
+        final FunctionalOperationContract fContract = //
+                ((FunctionalOperationContractPO) contractPO).getContract();
+        return fContract;
+    }
+
+    /**
+     * Extracts all loop scope indices from the given {@link PosInOccurrence},
+     * if possible; otherwise, returns an empty {@link Set}.
+     *
+     * @param pio
+     *            The {@link PosInOccurrence} that maybe contains one or more
+     *            loop scope indices
+     * @param services
+     *            The {@link Services} object.
+     * @return The {@link Set} of all loop scope indices.
+     * @see LoopScopeInvariantRule
+     * @see ParameterlessTermLabel#LOOP_SCOPE_INDEX_LABEL
+     */
+    public static List<LocationVariable> retrieveLoopScopeIndices(
+            PosInOccurrence pio, Services services) {
+        final LoopScopeIndexVisitor visitor = new LoopScopeIndexVisitor();
+        // Preorder walking makes sure that the "outer" loop scope index is
+        // visited first.
+        final Term formula = TermBuilder.goBelowUpdates(pio.subTerm());
+        formula.execPreOrder(visitor);
+        return visitor.getLoopScopeIndeces();
+    }
+
+    /**
+     * @see #prepareGoal(PosInOccurrence, Goal, Term, String, TermLabelState,
+     *      Rule)
+     *
+     * @param pio
+     *            The {@link PosInOccurrence} to remove.
+     * @param analysisGoal
+     *            The analysis {@link Goal} with which to work.
+     * @param fact
+     *            The fact {@link Term} to add.
+     * @param termLabelState
+     *            The {@link TermLabelState} for the ongoing rule application.
+     * @param rule
+     *            The {@link Rule} of the current rule application; needed for
+     *            the {@link TermLabel} stuff.
+     */
+    public static void prepareGoal(final PosInOccurrence pio,
+            final Goal analysisGoal, final Term fact,
+            TermLabelState termLabelState, Rule rule) {
+        prepareGoal(pio, analysisGoal, fact,
+                AbstractAnalysisRule.COVERS_FACT_BRANCH_LABEL_PREFIX,
+                termLabelState, rule);
+    }
+
+    /**
+     * Prepares a {@link Goal} for strength analysis:
+     * <ul>
+     * <li>Sets the branch label of the {@link Goal} according to the given fact
+     * {@link Term}</li>
+     * <li>Removes the given {@link PosInOccurrence} from the
+     * {@link Sequent}</li>
+     * <li>Adds the fact {@link Term} to the succedent</li>
+     * <li>Adds a {@link StrengthAnalysisParameterlessTL#FACT_LABEL}
+     * {@link TermLabel} to the fact {@link Term}</li>
+     * </ul>
+     *
+     * @param pio
+     *            The {@link PosInOccurrence} to remove.
+     * @param analysisGoal
+     *            The analysis {@link Goal} with which to work.
+     * @param fact
+     *            The fact {@link Term} to add.
+     * @param descr
+     *            The prefix description for the branch label, e.g. "Covers
+     *            fact" or whatever.
+     * @param termLabelState
+     *            The {@link TermLabelState} for the ongoing rule application.
+     * @param rule
+     *            The {@link Rule} of the current rule application; needed for
+     *            the {@link TermLabel} stuff.
+     */
+    public static void prepareGoal(final PosInOccurrence pio,
+            final Goal analysisGoal, final Term fact, final String descr,
+            TermLabelState termLabelState, Rule rule) {
+        final Services services = analysisGoal.proof().getServices();
+
+        analysisGoal.setBranchLabel(String.format("%s \"%s\"", descr,
+                LogicPrinter
+                        .quickPrintTerm(TermBuilder.goBelowUpdates(fact),
+                                services)
+                        .replaceAll("(\\r|\\n|\\r\\n)+", "")
+                        .replaceAll("<<[^>]+>>", "").trim()));
+
+        analysisGoal.removeFormula(pio);
+
+        Term newFormula = services.getTermBuilder().label(fact,
+                StrengthAnalysisParameterlessTL.FACT_LABEL);
+        newFormula = TermLabelManager.refactorTerm(termLabelState, services,
+                null, newFormula, rule, analysisGoal,
+                AbstractAnalysisRule.FACT_HINT, null);
+
+        analysisGoal.addFormula(new SequentFormula(newFormula), false, true);
+    }
+
+    /**
+     * Adds a precondition for a fact to the given {@link Goal}.
+     *
+     * @param analysisGoal
+     *            The {@link Goal} to work with.
+     * @param t
+     *            The fact {@link Term} to add.
+     * @param addFactPremiseLabel
+     *            Signals whether the
+     *            {@link StrengthAnalysisParameterlessTL#FACT_PREMISE_LABEL}
+     *            should be added to t.
+     * @param termLabelState
+     *            The {@link TermLabelState} for the ongoing rule application.
+     * @param rule
+     *            The {@link Rule} of the current rule application; needed for
+     *            the {@link TermLabel} stuff.
+     */
+    public static void addFactPrecondition(Goal analysisGoal, Term t,
+            boolean addFactPremiseLabel, TermLabelState termLabelState,
+            Rule rule) {
+        Term newFormula = addFactPremiseLabel
+                ? analysisGoal.proof().getServices().getTermBuilder().label(t,
+                        StrengthAnalysisParameterlessTL.FACT_PREMISE_LABEL)
+                : t;
+        newFormula = TermLabelManager.refactorTerm(termLabelState,
+                analysisGoal.proof().getServices(), null, newFormula, rule,
+                analysisGoal, AbstractAnalysisRule.FACT_PREMISE_HINT, null);
+
+        analysisGoal.addFormula(new SequentFormula(newFormula), true, false);
+    }
+
+    /**
+     * Adds the given {@link Iterable} of premise {@link Term}s to the succedent
+     * of the given {@link Goal}; labels those from index <code>0</code> to
+     * <code>numFactsWithPremiseLabels - 1</code> with
+     * {@link StrengthAnalysisParameterlessTL#FACT_PREMISE_LABEL}.
+     *
+     * @param analysisGoal
+     *            The {@link Goal} to work with.
+     * @param terms
+     *            The premises to add.
+     * @param numFactsWithPremiseLabels
+     *            All facts from index <code>0</code> to
+     *            <code>numFactsWithPremiseLabels - 1</code> will be labeled
+     *            with
+     *            {@link StrengthAnalysisParameterlessTL#FACT_PREMISE_LABEL}
+     * @param termLabelState
+     *            The {@link TermLabelState} for the ongoing rule application.
+     * @param rule
+     *            The {@link Rule} of the current rule application; needed for
+     *            the {@link TermLabel} stuff.
+     */
+    public static void addFactPreconditions(//
+            Goal analysisGoal, Iterable<Term> terms,
+            int numFactsWithPremiseLabels, TermLabelState termLabelState,
+            Rule rule) {
+
+        int i = 0;
+        for (Term term : terms) {
+            addFactPrecondition(analysisGoal, term,
+                    i < numFactsWithPremiseLabels, termLabelState, rule);
+            i++;
+        }
+    }
+
+    /**
+     * Recursively tries to find the origin of the given formula {@link Term} by
+     * getting the oldest {@link FormulaTermLabel} and finding the origin of
+     * that.
+     *
+     * @param analysisGoal
+     *            The {@link Goal} to start with.
+     * @param formula
+     *            The formula {@link Term} the origin of which is being looked
+     *            for.
+     * @return The {@link OriginOfFormula} for the given formula {@link Term}.
+     */
+    public static OriginOfFormula findOriginOfFormula(final Goal analysisGoal,
+            final Term formula) {
+        // First, retrieve all FormulaTermLabels
+        final List<FormulaTermLabel> formulaTermLabels = //
+                termLabelsOfType(formula, FormulaTermLabel.class);
+
+        assert formulaTermLabels.size() > 0 : //
+        "There should be <<F>> term labels in the invariant term";
+
+        // Get the smallest term label, this should identify the origin
+        Collections.sort(formulaTermLabels, (l1, l2) -> {
+            if (l1.equals(l2)) {
+                return 0;
+            }
+
+            final List<String> idsInFirst = getIDsOfFormulaTermLabel(l1);
+            final List<String> idsInSecond = getIDsOfFormulaTermLabel(l2);
+            final List<String> both = new ArrayList<>(idsInFirst);
+            both.addAll(idsInSecond);
+            Collections.sort(both);
+
+            final String smallest = both.get(0);
+            final int posResult = Integer.parseInt(smallest.split("\\.")[0]);
+            if (idsInFirst.contains(smallest)) {
+                return -posResult;
+            }
+            else {
+                return posResult;
+            }
+        });
+        final FormulaTermLabel smallest = formulaTermLabels.get(0);
+
+        return findOriginOfTermLabel(analysisGoal, smallest);
+    }
+
+    /**
+     * Extracts the open {@link Node}s that have a modality in the succedent
+     * from the subtree of the given {@link Node}.
+     *
+     * @param node
+     *            The root of the subtree to search.
+     * @return The open {@link Node}s in the subtree of node that have a
+     *         modality in the succedent.
+     */
+    public static List<Node> extractOpenNodesWithModality(Node node) {
+        return GeneralUtilities.toStream(node.proof().getSubtreeGoals(node))
+                .map(g -> g.node())
+                .filter(n -> GeneralUtilities.toStream(n.sequent().succedent())
+                        .anyMatch(
+                                f -> f.formula().containsJavaBlockRecursive()))
+                .collect(Collectors.toList());
+    }
+
+    /**
+     * Removes the formulas from the antecedent of the given {@link Goal} which
+     * are there because of the loop invariant.
+     *
+     * @param analysisGoal
+     *            The {@link Goal} to remove loop invariant formulas form.
+     * @param loopInvNode
+     *            The loop invariant {@link Node} designating the invariant
+     *            formulas to remove. May be null; in this case, all loop
+     *            invariant formulas will be removed.
+     */
+    public static void removeLoopInvFormulasFromAntec(final Goal analysisGoal,
+            Node loopInvNode) {
+        assert loopInvNode == null || loopInvNode
+                .getAppliedRuleApp() instanceof LoopInvariantBuiltInRuleApp : //
+        "You should pass a node with a loop invariant application.";
+
+        // We remove all partially instantiated no pos taclets, such as
+        // replaceKnownAuxiliaryConstant, since otherwise, there could be
+        // invariant formulas contained.
+
+        // TODO: This could be refined, such as inserting all things that
+        // taclets can insert and using the remaining procedure below to get rid
+        // of invariant formulas.
+
+        // XXX: Something goes wrong here. During the analysis, there are
+        // obviously replaceKnownSelect taclets left that are applied; when
+        // reloading with KeY, those taclets are however removed correctly. What
+        // goes wrong here?
+        analysisGoal.indexOfTaclets().removeTaclets(
+                analysisGoal.indexOfTaclets().getPartialInstantiatedApps());
+
+        for (SequentFormula sf : analysisGoal.sequent().antecedent()) {
+            boolean remove = loopInvNode == null
+                    ? LOOP_INV_FORMULAS_CACHE.values().stream()
+                            .anyMatch(set -> set.contains(sf.formula()))
+                    : LOOP_INV_FORMULAS_CACHE.containsKey(loopInvNode)
+                            && LOOP_INV_FORMULAS_CACHE.get(loopInvNode)
+                                    .contains(sf.formula());
+
+            if (!remove && sf.formula().hasLabels()) {
+                final LinkedHashSet<Term> sePreds = findSETPreds(sf.formula());
+                if (!sePreds.isEmpty() && !sePreds.stream()
+                        .noneMatch(pred -> sf.formula().equals(pred))) {
+                    // We don't remove the SE predicate formula
+                    continue;
+                }
+                
+                if (termLabelsOfType(sf.formula(), FormulaTermLabel.class)
+                        .isEmpty()) {
+                    // This is probably a formula which only has been added
+                    // during the application of the analysis goal, we
+                    // definitely
+                    // cannot trace it back. Ignore.
+                    continue;
+                }
+
+                // Find origin of this label
+                final OriginOfFormula origin = //
+                        findOriginOfFormula(analysisGoal, sf.formula());
+
+                final Node node = origin.getNode().parent();
+                if ((loopInvNode == null
+                        && node.getAppliedRuleApp() instanceof LoopInvariantBuiltInRuleApp)
+                        || node.equals(loopInvNode)) {
+                    remove = true;
+
+                    // Add value to the cache
+                    updateCache(sf.formula(), loopInvNode,
+                            analysisGoal.proof().root());
+                }
+            }
+
+            if (remove) {
+                analysisGoal.removeFormula(
+                        new PosInOccurrence(sf, PosInTerm.getTopLevel(), true));
+            }
+        }
+    }
+
+    /**
+     * Updates the {@link #LOOP_INV_FORMULAS_CACHE} s.th. the {@link Term}
+     * invFormula is listed as a loop invariant part of the given {@link Node}.
+     * Either loopInvNode of fallbackNode must be non-null.
+     *
+     * @param invFormula
+     *            The invariant formula to cache.
+     * @param loopInvNode
+     *            The loop invariant {@link Node}; may be null, in this case,
+     *            the fallbackNode must be non-null.
+     * @param fallbackNode
+     *            The fallback {@link Node} to use as a key for the cache if
+     *            loopInvNode is null.
+     */
+    private static void updateCache(final Term invFormula,
+            final Node loopInvNode, final Node fallbackNode) {
+        assert loopInvNode != null || fallbackNode != null;
+
+        final Node insertNode = loopInvNode == null ? fallbackNode
+                : loopInvNode;
+        Set<Term> cacheSet = LOOP_INV_FORMULAS_CACHE.get(insertNode);
+        if (cacheSet == null) {
+            cacheSet = new LinkedHashSet<>();
+            LOOP_INV_FORMULAS_CACHE.put(insertNode, cacheSet);
+        }
+        cacheSet.add(invFormula);
+    }
+
+    /**
+     * Adds the SE predicate to the antecedent of the given {@link Goal} such
+     * that it can be closed even with the SE predicate present in the
+     * succedent.
+     *
+     * @param goal
+     *            The {@link Goal} to add the SE predicate to.
+     */
+    public static void addSETPredicateToAntec(final Goal goal) {        
+        final Optional<Pair<SequentFormula, LinkedHashSet<Term>>> maybeSETPredicates = //
+                Stream.concat(
+                        GeneralUtilities.toStream(goal.sequent().succedent()),
+                        GeneralUtilities.toStream(goal.sequent().antecedent()))
+                        .map(sf -> {
+                            return new Pair<SequentFormula, LinkedHashSet<Term>>(sf,
+                                    findSETPreds(sf.formula()));
+                        }).filter(p -> !p.second.isEmpty()).findAny();
+
+        if (!maybeSETPredicates.isPresent()) {
+            // There are easy goals where the post condition is just "false", so
+            // that should be OK
+            return;
+        }
+
+        final Term seqFor = maybeSETPredicates.get().first.formula();
+        final List<Term> updates = getUpdates(seqFor);
+        
+        final TermBuilder tb = goal.proof().getServices().getTermBuilder();
+
+        Term newFormula = maybeSETPredicates.get().second.stream()
+                .reduce(tb.tt(), (acc, elem) -> tb.and(acc, elem));
+        
+        for (int i = updates.size() - 1; i >= 0; i--) {
+            newFormula = goal.proof().getServices().getTermBuilder()
+                    .apply(updates.get(i), newFormula);
+        }
+
+        goal.addFormula(new SequentFormula(newFormula), true, false);
+    }
+
+    /**
+     * Returns the list of updates in the {@link Term} t. t has to be an udpate
+     * application.
+     *
+     * @param t
+     *            The {@link UpdateApplication} {@link Term} to return the list
+     *            of update terms for.
+     * @return The list of updates in the {@link Term} t.
+     */
+    public static List<Term> getUpdates(Term t) {
+        assert t.op() instanceof UpdateApplication : //
+        "Can only extract updates from update apps, got: " + t.op();
+
+        final List<Term> result = new ArrayList<>();
+        while (t.op() instanceof UpdateApplication) {
+            result.add(t.sub(0));
+            t = t.sub(1);
+        }
+
+        return result;
+    }
+
+    /**
+     * Transforms an update to a {@link Map} from left-hand-sides to
+     * right-hand-sides.
+     *
+     * @param updateTerm
+     *            The {@link Term} to transform.
+     * @return A {@link Map} from update left-hand-sides to right-hand-sides.
+     */
+    public static LinkedHashMap<LocationVariable, Term> updateToMap(
+            final Term updateTerm) {
+        final LinkedHashMap<LocationVariable, Term> updateContent =
+                StreamSupport.stream(//
+                        MergeRuleUtils.getUpdateLeftSideLocations(updateTerm)
+                                .spliterator(),
+                        true).collect(
+                                Collectors.toMap(lhs -> lhs,
+                                        lhs -> MergeRuleUtils
+                                                .getUpdateRightSideFor(
+                                                        updateTerm, lhs),
+                                        (u, v) -> {
+                                            throw new IllegalStateException(
+                                                    String.format(
+                                                            "Duplicate key %s",
+                                                            u));
+                                        }, LinkedHashMap::new));
+        return updateContent;
+    }
+
+    private static <L extends TermLabel> List<L> termLabelsOfType(
+            final Term formula, Class<L> wanted) {
+        final List<L> labels = new ArrayList<L>();
+
+        formula.execPreOrder(new DefaultVisitor() {
+            @Override
+            public void visit(Term visited) {
+                if (visited.hasLabels()) {
+                    labels.addAll(GeneralUtilities.toStream(visited.getLabels())
+                            .filter(l -> wanted.isInstance(l))
+                            .map(l -> wanted.cast(l))
+                            .collect(Collectors.toList()));
+                }
+            }
+        });
+
+        return labels;
+    }
+
+    private static Set<String> formulaTermLabelIDsDeep(Term t) {
+        final Set<String> termLabelIDsInSeqFor = new LinkedHashSet<String>();
+
+        t.execPreOrder(new DefaultVisitor() {
+            @Override
+            public void visit(Term visited) {
+                if (visited.hasLabels()) {
+                    termLabelIDsInSeqFor.addAll(formulaTermLabelIDs(visited));
+                }
+            }
+        });
+
+        return termLabelIDsInSeqFor;
+    }
+
+    /**
+     * Recursively tries to find the origin of the given
+     * {@link FormulaTermLabel}.
+     *
+     * @param analysisGoal
+     *            The {@link Goal} to start with.
+     * @param label
+     *            The {@link FormulaTermLabel} the origin of which is being
+     *            looked for.
+     * @return An {@link OriginOfFormula} for the given
+     *         {@link FormulaTermLabel}; elements of this object might be null
+     *         if the origin is not found, which however should not happen if
+     *         the given {@link Goal} is a sensible choice (i.e., the origin is
+     *         in the tree above the {@link Goal}).
+     */
+    private static OriginOfFormula findOriginOfTermLabel(
+            final Goal analysisGoal, final FormulaTermLabel label) {
+        Node currNode = analysisGoal.node();
+        SequentFormula originForm = null;
+
+        while (!currNode.root()) {
+            List<String> allLabelsInNode = new ArrayList<>();
+            final Node parent = currNode.parent();
+            for (SequentFormula oSf : parent.sequent()) {
+                final Set<String> labelsInSeqFor = //
+                        formulaTermLabelIDsDeep(oSf.formula());
+
+                allLabelsInNode.addAll(labelsInSeqFor);
+                if (labelsInSeqFor.contains(label.toString())) {
+                    originForm = oSf;
+                    break;
+                }
+            }
+
+            final List<String> termLabelMajorIDsOfLabel = //
+                    getIDsOfFormulaTermLabel(label).stream()
+                            .map(s -> s.split("\\.")[0])
+                            .collect(Collectors.toList());
+            final List<String> termLabelMajorIDsInNode = //
+                    allLabelsInNode.stream().map(s -> s.split("\\.")[0])
+                            .collect(Collectors.toList());
+
+            final long numMatches = termLabelMajorIDsOfLabel.stream()
+                    .filter(s -> termLabelMajorIDsInNode.contains(s)).count();
+
+            if (numMatches == 0) {
+                break;
+            }
+            else {
+                currNode = parent;
+            }
+        }
+
+        return new OriginOfFormula(currNode, originForm);
+    }
+
+    private static List<String> formulaTermLabelIDs(Term t) {
+        final List<String> result = new ArrayList<>();
+
+        if (t.hasLabels()) {
+            StreamSupport.stream(t.getLabels().spliterator(), true)
+                    .filter(label -> (label instanceof FormulaTermLabel))
+                    .map(label -> (FormulaTermLabel) label).forEach(label -> {
+                        result.addAll(getIDsOfFormulaTermLabel(label));
+                    });
+        }
+
+        return result;
+    }
+
+    private static List<String> getIDsOfFormulaTermLabel(FormulaTermLabel l) {
+        final List<String> result = new ArrayList<>();
+
+        result.add(l.getId());
+        result.addAll(
+                Arrays.stream(l.getBeforeIds()).collect(Collectors.toList()));
+
+        return result;
+    }
+
+    /**
+     * @param formula
+     *            The formula to obtain the symbolic execution predicate from.
+     * @return The set of SE predicate {@link Term}s.
+     */
+    private static LinkedHashSet<Term> findSETPreds(Term formula) {
+        SETPredVisitor v = new SETPredVisitor();
+        formula.execPostOrder(v);
+        return v.getSetPredTerms();
+    }
+
+    /**
+     * Determines the origin of a {@link SequentFormula} in terms of a
+     * {@link Node} and the original {@link SequentFormula}.
+     *
+     * @author Dominic Steinhoefel
+     */
+    public static class OriginOfFormula {
+        /**
+         * The origin {@link Node}.
+         */
+        private final Node node;
+
+        /**
+         * The original {@link SequentFormula}.
+         */
+        private final SequentFormula seqFor;
+
+        /**
+         * Constructor.
+         *
+         * @param node
+         *            See {@link #node}.
+         * @param seqFor
+         *            See {@link #seqFor}.
+         */
+        public OriginOfFormula(Node node, SequentFormula seqFor) {
+            this.node = node;
+            this.seqFor = seqFor;
+        }
+
+        public Node getNode() {
+            return node;
+        }
+
+        public SequentFormula getSeqFor() {
+            return seqFor;
+        }
+    }
+
+    private static class SETPredVisitor extends DefaultVisitor {
+        /**
+         * The result of the {@link Visitor} execution.
+         */
+        private LinkedHashSet<Term> setPredTerms = new LinkedHashSet<>();
+
+        @Override
+        public void visit(Term visited) {
+            if (visited.op().name().toString()
+                    .startsWith(AbstractOperationPO.UNINTERPRETED_PREDICATE_NAME)) {
+                setPredTerms.add(visited);
+            }
+        }
+
+        public LinkedHashSet<Term> getSetPredTerms() {
+            return setPredTerms;
+        }
+    }
+
+    private static class LoopScopeIndexVisitor extends DefaultVisitor {
+        /**
+         * The result of the {@link Visitor} execution.
+         */
+        private List<LocationVariable> indices = new ArrayList<>();
+
+        @Override
+        public void visit(Term visited) {
+            if (visited.op() instanceof LocationVariable && visited.hasLabels()
+                    && visited.containsLabel(
+                            ParameterlessTermLabel.LOOP_SCOPE_INDEX_LABEL)) {
+                final LocationVariable lsi = (LocationVariable) visited.op();
+                if (!indices.contains(lsi)) {
+                    indices.add(lsi);
+                }
+            }
+        }
+
+        public List<LocationVariable> getLoopScopeIndeces() {
+            return indices;
+        }
+    }
+
+    /**
+     * Finds the loop scope index {@link LocationVariable} in the given
+     * {@link Node} that is assigned FALSE; determines the loop the preserved
+     * part of which is being analyzed.
+     * 
+     * @param node
+     *            The {@link Node} to find the loop scope index
+     *            {@link LocationVariable} which is set to false.
+     *
+     * @return The loop scope index {@link LocationVariable} in the given
+     *         {@link Node} that is assigned FALSE.
+     */
+    public static LocationVariable findLoopScopeIndexVar(Node node) {
+        final Services services = node.proof().getServices();
+
+        LocationVariable loopScopeIdxVar = null;
+
+        for (SequentFormula sf : node.sequent().succedent()) {
+            List<LocationVariable> maybeIdxVar = retrieveLoopScopeIndices(
+                    new PosInOccurrence(sf, PosInTerm.getTopLevel(), false),
+                    services);
+
+            if (!maybeIdxVar.isEmpty()) {
+                final List<LocationVariable> falseLSI = maybeIdxVar.stream()
+                        .filter(lsi -> MergeRuleUtils
+                                .getUpdateRightSideFor(sf.formula().sub(0), lsi)
+                                .equals(services.getTermBuilder().FALSE()))
+                        .collect(Collectors.toList());
+                assert falseLSI
+                        .size() == 1 : "There has to be exaclty one loop scope index that's set to false.";
+                loopScopeIdxVar = falseLSI.get(0);
+                break;
+            }
+        }
+
+        return loopScopeIdxVar;
+    }
+
+    /**
+     * Finds the {@link Node} where the given loop scope index has been
+     * introduced. The returned node, if non-null (so it has been found, which
+     * means that the inputs to the method make sense) has guaranteed a
+     * {@link LoopInvariantBuiltInRuleApp} application.
+     *
+     * @param node
+     *            The {@link Node} to start with; will search upwards in the
+     *            {@link Proof} tree from there.
+     * @param loopScopeIdxVar
+     *            The loop scope index {@link LocationVariable} to find the
+     *            introducing {@link Node} for.
+     * @return The {@link Node} where the given loop scope index has been
+     *         introduced, or null, if the inputs do not make sense (i.e., in
+     *         the tree above node there is not the
+     *         {@link LoopScopeInvariantRule} application that is being looked
+     *         for).
+     */
+    public static Node findCorrespondingLoopInvNode(Node node,
+            LocationVariable loopScopeIdxVar) {
+        Node currNode = node.parent();
+        boolean found = false;
+        while (!currNode.root()) {
+            if (currNode.getAppliedRuleApp()
+                    .rule() == LoopScopeInvariantRule.INSTANCE
+                    && !currNode.getLocalProgVars().contains(loopScopeIdxVar)) {
+
+                found = true;
+                break;
+
+            }
+
+            currNode = currNode.parent();
+        }
+
+        if (!found) {
+            currNode = null;
+        }
+        return currNode;
+    }
+
+}
diff --git a/key/key.specstrength/src/log4j2.properties b/key/key.specstrength/src/log4j2.properties
new file mode 100644
index 0000000000..4f9d284f01
--- /dev/null
+++ b/key/key.specstrength/src/log4j2.properties
@@ -0,0 +1,21 @@
+# Set root logger level to DEBUG and its only appender to A1.
+#log4j.rootLogger=DEBUG, A1
+
+# A1 is set to be a ConsoleAppender.
+#log4j.appender.A1=org.apache.log4j.ConsoleAppender
+
+# A1 uses PatternLayout.
+#log4j.appender.A1.layout=org.apache.log4j.PatternLayout
+#log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n
+
+name=PropertiesConfig
+property.filename = logs
+appenders = console
+appender.console.type = Console
+appender.console.name = STDOUT
+appender.console.layout.type = PatternLayout
+appender.console.layout.pattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %c{1} - %msg%n
+
+rootLogger.level = info
+rootLogger.appenderRefs = stdout
+rootLogger.appenderRef.stdout.ref = STDOUT
\ No newline at end of file
diff --git a/key/key.util/src/org/key_project/util/reflection/ReflectionUtil.java b/key/key.util/src/org/key_project/util/reflection/ReflectionUtil.java
new file mode 100644
index 0000000000..96e812a8ea
--- /dev/null
+++ b/key/key.util/src/org/key_project/util/reflection/ReflectionUtil.java
@@ -0,0 +1,78 @@
+// This file is part of KeY - Integrated Deductive Software Design
+//
+// Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+// Copyright (C) 2011-2017 Karlsruhe Institute of Technology, Germany
+//                         Technical University Darmstadt, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General
+// Public License. See LICENSE.TXT for details.
+//
+
+package org.key_project.util.reflection;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+/**
+ * TODO
+ *
+ * @author Dominic Steinhoefel
+ */
+public class ReflectionUtil {
+
+    /**
+     * TODO
+     * 
+     * @param resultClass
+     * @param className
+     * @param fieldName
+     * @return
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> Optional<T> getField(Class<T> resultClass,
+            String className, String fieldName) {
+        try {
+            final Class<?> c = Class.forName(className);
+            return Optional.of((T) c.getField(fieldName).get(null));
+        } catch (ClassNotFoundException | IllegalArgumentException
+                | IllegalAccessException | NoSuchFieldException
+                | SecurityException e) {
+            return Optional.empty();
+        }
+    }
+
+    /**
+     * TODO
+     * 
+     * @param resultClass
+     * @param obj
+     * @param methodName
+     * @param args
+     * @return
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> Optional<T> callMethodOnObj(Class<T> resultClass,
+            Object obj, String methodName, Object... args) {
+        final Class<?> cls = obj.getClass();
+
+        try {
+            final Method m = cls.getMethod(methodName,
+                    Arrays.stream(args).map(o -> o.getClass())
+                            .collect(Collectors.toList())
+                            .toArray(new Class[] {}));
+
+            return Optional.of((T) m.invoke(obj, args));
+        } catch (NoSuchMethodException | SecurityException
+                | IllegalAccessException | IllegalArgumentException
+                | InvocationTargetException e) {
+            return Optional.empty();
+        }
+    }
+
+}
diff --git a/key/scripts/KeY.jar/META-INF/MANIFEST.MF b/key/scripts/KeY.jar/META-INF/MANIFEST.MF
index 46de5f6dbf..7c5405a523 100644
--- a/key/scripts/KeY.jar/META-INF/MANIFEST.MF
+++ b/key/scripts/KeY.jar/META-INF/MANIFEST.MF
@@ -2,6 +2,6 @@ Manifest-Version: 1.0
 Permissions: all-permissions
 Codebase: formal.iti.kit.edu
 Application-Name: KeY
-Class-Path: ./components/key.util.jar ./libs/antlr.jar ./libs/recoderKey.jar ./components/key.core.jar ./components/key.core.testgen.jar ./components/key.core.symbolic_execution.jar ./components/key.ui.jar
+Class-Path: ./components/key.util.jar ./libs/antlr.jar ./libs/recoderKey.jar ./libs/commons-cli-1.3.1.jar ./libs/log4j-api-2.6.2.jar ./libs/log4j-core-2.6.2.jar ./libs/JHighlighter.jar ./components/key.core.jar ./components/key.core.testgen.jar ./components/key.core.symbolic_execution.jar ./components/key.specstrength.jar ./components/key.ui.jar
 Main-Class: de.uka.ilkd.key.core.Main
 SplashScreen-Image: key-color.gif
diff --git a/key/scripts/build.xml b/key/scripts/build.xml
index 787b5fbe44..b5ed0934e9 100644
--- a/key/scripts/build.xml
+++ b/key/scripts/build.xml
@@ -32,6 +32,7 @@
 		<ant antfile="${key.dir}/key.core.example/build.xml" target="compile" dir="${key.dir}/key.core.example" inheritall="false"/>
 		<ant antfile="${key.dir}/key.removegenerics/build.xml" target="compile" dir="${key.dir}/key.removegenerics" inheritall="false"/>
 		<ant antfile="${key.dir}/key.core.symbolic_execution.example/build.xml" target="compile" dir="${key.dir}/key.core.symbolic_execution.example" inheritall="false"/>
+		<ant antfile="${key.dir}/key.specstrength/build.xml" target="compile" dir="${key.dir}/key.specstrength" inheritall="false"/>
 	</target>
 
 	<target name="deployAll" description="Prepare KeY for shipping. Find results in directory 'deployment'. (Calls 'ant deploy' on production subprojects.)">
@@ -55,6 +56,7 @@
 		<ant antfile="${key.dir}/key.core.example/build.xml" target="deploy" dir="${key.dir}/key.core.example" inheritall="false"/>
 		<ant antfile="${key.dir}/key.removegenerics/build.xml" target="deploy" dir="${key.dir}/key.removegenerics" inheritall="false"/>
 		<ant antfile="${key.dir}/key.core.symbolic_execution.example/build.xml" target="deploy" dir="${key.dir}/key.core.symbolic_execution.example" inheritall="false"/>
+		<ant antfile="${key.dir}/key.specstrength/build.xml" target="deploy" dir="${key.dir}/key.specstrength" inheritall="false"/>
 		<!-- Deploy license -->
 		<copy todir="${key.dir}/deployment">
 			<fileset file="${key.dir}/LICENSE.TXT"/>
@@ -81,6 +83,7 @@
 		<ant antfile="${key.dir}/key.core.example/build.xml" target="clean" dir="${key.dir}/key.core.example" inheritall="false"/>
 		<ant antfile="${key.dir}/key.removegenerics/build.xml" target="clean" dir="${key.dir}/key.removegenerics" inheritall="false"/>
 		<ant antfile="${key.dir}/key.core.symbolic_execution.example/build.xml" target="clean" dir="${key.dir}/key.core.symbolic_execution.example" inheritall="false"/>
+		<ant antfile="${key.dir}/key.specstrength/build.xml" target="clean" dir="${key.dir}/key.specstrength" inheritall="false"/>
 		<!-- Delete deployed files -->
 		<delete file="${key.dir}/deployment/LICENSE.TXT" failonerror="false" />
 		<delete file="${key.dir}/deployment/KeY.jar" failonerror="false" />
diff --git a/key/scripts/runTests b/key/scripts/runTests
index 11173f3f88..a775aed4f0 100755
--- a/key/scripts/runTests
+++ b/key/scripts/runTests
@@ -90,9 +90,10 @@ key.core.proof_references.test
 key.removegenerics
 key.removegenerics.test
 key.core.proof_references
-key.core.proof_references.test       
+key.core.proof_references.test
 key.core.symbolic_execution
-key.core.symbolic_execution.test"
+key.core.symbolic_execution.test
+key.specstrength.test"
 
 for i in $included_projects ; do
     current_project="$KEY_HOME/$i"
