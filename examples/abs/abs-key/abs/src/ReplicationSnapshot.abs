module ReplicationSystem.Server.ReplicationSnapshot;

export *;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Interfaces;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;

import SearchDirectoryItem from ReplicationSystem.Server.ReplicationItem;

//For testing
import * from ReplicationSystem.Server.BaseReplicationItem;

def Bool hasElement<A>(List<A> ls, A a) =
	case ls {
		Nil => False;
		Cons(a,_) => True;
		Cons(x,xs) => hasElement(xs,a);
	};

class ReplicationSnapshotImpl(
	[Final] ServerDataBase db, 
	[Final] Schedules schedules) implements ReplicationSnapshot {

	//the transaction id after refreshing snapshot;
	TransactionId tid = -1;
	
	// if snapshot is cleaned
	Bool clean = True;
	
	Map<String,Set<ServerReplicationItem>> repItems = EmptyMap;
	
	//@ represents index <- tid;
	//@ represents data \such_that
	//@		tids < 0 ==> data == Nil &&
	//@		tids => 0 ==> length(data) ==  tids + 1 &&
	//@ 	\forall Int i; 0 <= i && i < tids ==> nth(data, tids) == Nothing &&
	//@ 	nth(data, tids) != Nothing && fromJust(nth(data, tids)) == repItems;
	
	Set<ServerReplicationItem> getItems(String name) {
		return lookupDefault(repItems,name,EmptySet);
	}
	
	/*
	 * Updating replication snapshot
	 */
	//@ ensures clean ==> 
	//		tid == \old(tid) && clean == \old(clean) && repItems == \old(repItems);
	[Atomic] 
	Unit refreshSnapshot() {
		if (clean) {
			tid = db.refresh();
			this.createReplicationItems();
				
			Set<String> names = keys(repItems);
			while (hasNext(names)) {
				Pair<Set<String>,String> nn = next(names);
				Set<ServerReplicationItem> titems = lookupUnsafe(repItems,snd(nn));
				while (hasNext(titems)) {
					Pair<Set<ServerReplicationItem>,ServerReplicationItem> ni = next(titems);
					ServerReplicationItem item = snd(ni);
					item.refresh();
					titems = fst(ni);
				}
				names = fst(nn);
			}
			clean = False;
		}
		
	}
	
	//@ ensures \forall Schedule s; contains(schedules, s) ==> 
	//@				lookup(repItems, schedname(s)) != Nothing
	[Atomic] 
	Unit createReplicationItems() {
		Schedules tsc = schedules;
		while (hasNext(tsc)) {
			Pair<Schedules,Schedule> ns = next(tsc);
			this.replicationItems(snd(ns));
			tsc = fst(ns);
		}
	}
	
	//@ ensures lookup(repItems, schedname(schedule)) != Nothing;
	//@ ensures \forall Item i; hasElement(items(schedule), i) ==>
	//@				contains(lookupUnsafe(repItems, schedname(schedule)),
	//@						 this.replicationItem(i));	
    [Atomic] 
	Unit replicationItems(Schedule schedule) {
		List<Item> is = items(schedule);
		Set<ServerReplicationItem> sitems = EmptySet;
		while (is != Nil) {
			ServerReplicationItem r = this.replicationItem(head(is));
			sitems = Insert(r,sitems);
			is = tail(is); 
		}
		repItems = InsertAssoc(Pair(schedname(schedule),sitems),repItems);
	}
	
	//@ assignable \nothing;
	//@ ensures \result != null;
    //@ ensures isSearchItem(i) ==> \result.getType() == SearchReplicationDirectory && 
    //@ 		isFileItem(i) ==> \result.getType() == ReplicationFilePattern && 
    //@ 		isLogItem(i) ==> \result.getType() == LogReplicationItem;
	[Atomic] 
	ServerReplicationItem replicationItem(Item i) {
		ServerReplicationItem item = null;
		if (isSearchItem(i)) {
			item = new SearchDirectoryItem(left(item(i)),this.db);
		}
		
		//for testing
		if (item == null && isFileItem(i)) {
			Pair<FileId,String> it = right(item(i));
			item = new ReplicationFilePattern(fst(it),snd(it),this.db);				
		}
		
		//for testing
		if (item == null && isLogItem(i)) { 
			item = new ReplicationLogItem(left(item(i)),this.db);
		}
		
		return item; 
	}
	
	//Clear snapshot
	[Atomic]
	Unit clearSnapshot() {
		repItems = EmptyMap;
		clean = True;
	}
	
	//@ assignable \nothing;
	Int getIndexingId() {
		return tid;
	}

}