module ReplicationSystem.Environment.DataTypes;
export *;

import * from ABS.DC;

def List<A> concatenates<A>(List<List<A>> lists) =
	case lists {
		Nil => Nil;
		Cons(x,xs) => concatenate(x,concatenates(xs));
	};
	
def Map<A,B> join<A,B>(Map<A,B> f, Map<A,B> g) =
	case g {
		EmptyMap => f;
		InsertAssoc(x,xs) => 
			case contains(keys(f),fst(x)) {
				True => join(f,xs);
				False => InsertAssoc(x,join(f,xs));
			};
	};
	
data Command =
	StartSnapShot | EndSnapShot | ListSchedule | 
	SearchSchedule(String ssname) | EndSearchFile | AppendSearchFile |
	ReceivePatternFile | 
	SkipFile | ContinueFile | OverwriteFile |
	EmptyCommand;
	
def String commandToString(Command c) =
	case c {
		StartSnapShot => "StartSnapShot";
		EndSnapShot => "EndSnapShot";
		ListSchedule => "ListSchedule";
		SearchSchedule(ss) => "Schedule for " + ss;
		EndSearchFile => "EndSearchFile";
		AppendSearchFile => "AppendSearchFile";
		ReceivePatternFile => "ReceivePatternFile";
		SkipFile => "SkipFile";
		ContinueFile => "ContinueFile";
		OverwriteFile => "OverwriteFile";
		EmptyCommand => "EmptyCommand";
	};
	
data JobType = Replication | Boot;

data ReplicationItemType =
	SearchReplicationDirectory | LogReplicationItem | ReplicationFilePattern;

type ClientId = Int;
	
// CSP set CheckPoint
// Java class com.fredhopper.search.fred.Checkpoint
// For Java method com.fredhopper.replication.server.item.SearchReplicationDirectory.isValid(String, long)
// type CheckPoint = Int;

type TransactionId = Int;

// Function on Maybe
def A fromJustDefault<A>(Maybe<A> m, A a) =
	case m { Just(j) => j; Nothing => a; };

// Functions on set of pairs
def Set<A> fsts<A, B>(Set<Pair<A, B>> ps) =
  case ps {
  	EmptySet => EmptySet;
  	Insert(x,xs) => Insert(fst(x),fsts(xs));
  };
  
def Set<B> snds<A, B>(Set<Pair<A, B>> ps) =
  case ps {
  	EmptySet => EmptySet;
  	Insert(x,xs) => Insert(snd(x),snds(xs));
  };
  
def Bool range(List<Int> vals, Int limit, Bool strict) =
	case vals {
		Nil => ~strict;
		_ => let (Int r) = maximum(vals) - minimum(vals) in
			 case strict {
			 	True => r == limit;
			 	False => r <= limit;
			 };
	};

def Int maximum(List<Int> l) = 
	case l {
		Cons(x,xs) => maximum0(xs,x);
	};
	
def Int maximum0(List<Int> l, Int i) =
	case l {
		Nil => i;
		Cons(x,xs) => maximum0(xs,max(x,i));
	};

//def Int min(Int a, Int b) = 
//    case a < b { True => a; False => b; };
	
def Int minimum(List<Int> l) = 
	case l {
		Cons(x,xs) => minimum0(xs,x);
	};
	
def Int minimum0(List<Int> l, Int i) =
	case l {
		Nil => i;
		Cons(x,xs) => minimum0(xs,min(x,i));
	};
  
// Functions on set
def Set<A> listToSet<A>(List<A> a) = 
	case a {
		Nil => EmptySet;
		Cons(x,xs) => Insert(x,listToSet(xs));
	};
	
def Map<A,B> setToMap<A,B>(Set<A> a, B b) = 
	case a {
		EmptySet => EmptyMap;
		Insert(x,xs) => InsertAssoc(Pair(x,b),setToMap(xs,b));
	};

// Take first i elements from list ss	
def List<A> take<A>(List<A> ss,Int i) =
	case i {
		0 => Nil;
		_ => case ss {
				Nil => Nil;
				Cons(x,xs) => Cons(x,take(xs,i-1));
			}; 
	};

// Choose i elements from set ss
def Set<A> choose<A>(Set<A> ss,Int i) =
	case i {
		0 => EmptySet;
		_ => case ss {
				EmptySet => EmptySet;
				Insert(x,xs) => Insert(x,choose(xs,i-1));
			}; 
	};
	
// Choose i elements from map mp 
def Map<A,B> takeMap<A,B>(Map<A,B> mp,Int i) =
	case i {
		0 => EmptyMap;
		_ => case mp {
				EmptyMap => EmptyMap;
				InsertAssoc(x,xs) => InsertAssoc(x,takeMap(xs,i-1));
			}; 
	};
  
// Functions on data Command
def Bool isAppendCommand(Command c) = 
	case c {
		SkipFile => True;
		ContinueFile => True;
		OverwriteFile => True;
		_ => False;
	};

// Insert 'a' at position i of list. 
def List<A> setAt<A>(List<A> list, A a, Int i) =
	case list {
		Nil => Nil;
		Cons(p,l) => 
			case i {
				0 => Cons(a,l);
				_ => Cons(p,setAt(l,a,i-1));
			 };
	};
	
def Bool setEquals<A>(Set<A> s, Set<A> t) = size(s) == size(t) && subset(s,t);

// t is a subset of s
def Bool subset<A>(Set<A> s, Set<A> t) = 
	case t {
		EmptySet => True;
		Insert(x,xs) => 
			case contains(s,x) {
				True => subset(s,xs);
				False => False; 
			};  
	};

// 	
def Int pow(Int b, Int e) =
	case e {
		0 => 1;
		_ => b * pow(b,e-1); 
	};


// String operations
// c must have length 1 currently
// COSTABS ANNOTATION 
// Here termsize(Cons(a,b)) = 1 + termsize(a) + termsize(b); 
//      termsize(Nil) = 1;
[text >= 1][result() >= 1][result() <= 2*text]
def List<String> split(String text, String c) = 
	case strlen(text) == 0 {
		True => Nil;
		False => split2(tailStr(text),c,Cons(headStr(text),Nil)); 
	};
	
def List<String> split2(String text, String c, List<String> result) =
	case result {
		Cons(h,t) =>
			case strlen(text) == 0 {
				True => reverse(result);
				False => 
					let (String hd) = headStr(text) in
					case hd == c {
						True => split2(tailStr(text),c,Cons("",result));
						False => split2(tailStr(text),c,Cons(h + hd,t));
					};
			}; 
	};
	
	
def String headStr(String text) = substr(text,0,1);
def String tailStr(String text) = substr(text,1,strlen(text)-1);

// if list2 is a prefix of list1 
def Bool isPrefix<A>(List<A> list1, List<A> list2) =
	case list2 {
		Nil => True;
		Cons(l,ll) => 
			case list1 {
				Nil => False;
				Cons(m,mm) => (l == m) && isPrefix(mm,ll);
			};
	};
	
// COSTABS ANNOTATION
[s >= 0][result() <= 2*s+1]
def List<String> stringToChar(String s) =
	let (Int l) = strlen(s) in
	case l == 0 {
		True => Nil;
		False => Cons(headStr(s),stringToChar(tailStr(s)));
	};
	
def Bool isPrefixText(String s1, String s2) = isPrefix(stringToChar(s2),stringToChar(s1));

def Bool filter(String pattern, String text) = isPrefixText(pattern,text);

// filters a set of strings against some pattern
def Set<String> filters(String pattern, Set<String> ts) =
	case ts {
		EmptySet => EmptySet;
		Insert(l,ls) => 
			case filter(pattern,l) {
				True => Insert(l,filters(pattern,ls));
				False => filters(pattern,ls);
			};
	};

//DeploymentComponent
def Set<DCData> modifyCPU(Set<DCData> ds, Int cpu) =
	case ds {
		EmptySet => Insert(CPU(cpu),EmptySet);
		Insert(x,xs) => 
			case x {
				CPU(_) => Insert(CPU(cpu),xs);
				_ => Insert(x,modifyCPU(xs,cpu));
			};
	};
