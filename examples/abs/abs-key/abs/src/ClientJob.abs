module ReplicationSystem.Client.ClientJob;

export ClientJobImpl;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.StateMachine;
import * from ReplicationSystem.Schedulers; 

import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Environment.Interfaces;

// CSP model ClientReplicationJob(n)
// Java class com.fredhopper.replication.client.ClientReplicationJob
class ClientJobImpl(
	[Final] Int maxJobs, //default maximum number of client jobs allowed per client
	[Far] [Final] InternalClient client, 
	[Final] JobType job, 
	[Final] Schedule schedule,
	[Final] Int id) implements ClientJob {
	
	Command start = EmptyCommand;
	Command command = EmptyCommand;
	Schedules schedules = EmptySet;
	ClientId clientId = -1;
	TransactionId transactionId = -1; //debugging
	
	ConnectionThread thread = null;
	[Far] ClientDataBase db;
	
	ConnectionThread getConnectionThread() {
		Fut<SyncServerAcceptor> fs = client!getAcceptor();
		SyncServerAcceptor acceptor = fs.get;
	
		// Acquire a connection
		Fut<ConnectionThread> ft = acceptor!getConnection(this); 
		await ft?;
	
		ConnectionThread t = ft.get;
		return t;
	}
	
	Unit clientDB() {
		Fut<ClientDataBase> fd = client!getClientDataBase();
		this.db = fd.get;
	}
	
	// starts the next set of replication jobs
	Unit establishSchedule() {
		Fut<Int> jcf = client!jobCount();
		Int stats = jcf.get; 
		if (maxJobs > 0 && stats >= maxJobs) {
			this.shutDownClient();
		} else {
			Schedules ss = schedules;
			while (hasNext(ss)) {
				Pair<Schedules,Schedule> nt = next(ss);
				ss = fst(nt); Schedule s = snd(nt);
				client!scheduleJob(Replication,s);
			}
		}
	}
	
	Unit executeJob() {
		Fut<ClientId> fut = client!getId();
		clientId = fut.get;
	
		// set data base
		this.clientDB();
			
		// Acquire a connection
		thread = this.getConnectionThread();
		
		if (thread != null) {
			// Connection successful!
			
			if (job == Boot) {
				this.becomeState(Booting);
				
				thread!command(ListSchedule);
				await schedules != EmptySet;
				
				//establish the next schedule triggers!
				this.establishSchedule();
			} else {
				this.becomeState(WorkOnReplicate);
				
				thread!command(SearchSchedule(schedname(schedule)));
				await schedules != EmptySet;
				
				//establish the next schedule triggers!
				this.establishSchedule();
				
				// wait for current job to start then end
				await start == StartSnapShot;
				await command == EndSnapShot;				
			}
			
			//Switch to the proper state after finishing.
			//From all states we can go to the end state to shutdown.
			Fut<Bool> sd = client!isShutdownRequested(); Bool shutDown = sd.get;
			if (~shutDown) {
				this.becomeState(WaitToReplicate);
			}
			
		} else {
			this.becomeState(End);
		}
	
		Fut<Unit> fj = client!finishJob(this); fj.get;

		//allow next job to proceed
		client!nextJob();		
	}
	
	Unit becomeState(State state) {
		if (state == WaitToBoot) {
			Fut<Unit> unit = client!waitToBoot(); unit.get;
		} else if (state == Booting) { 
			Fut<Unit> unit = client!boot(); unit.get;
		} else if (state == WorkOnReplicate) { 
			Fut<Unit> unit = client!replicate(); unit.get;
		} else if (state == WaitToReplicate) { 
			Fut<Unit> unit = client!waitToReplicate(); unit.get;
		} else if (state == End) { 
			Fut<Unit> unit = client!end(); unit.get;
		}
	}
	
	ClientId forClient() {
		return clientId;
	}
	
	Unit shutDownClient() {
		Fut<Bool> bf = client!isShutdownRequested(); await bf?; 
		Bool bool = bf.get;
		if (~bool) {
			Fut<Unit> unit = client!requestShutDown(); await unit?; unit.get;
			this.becomeState(End);
		}
	}
	
	Bool registerReplicationItems(TransactionId id) {
		Fut<Bool> reg = db!prepareReplicationItem(id,schedule);
		Bool rg = reg.get;
		if (rg) {
			transactionId = id; 
		}
		return rg;
	}
	
	Bool hasFile(List<String> id) {
		Fut<Bool> he = db!hasFile(id); await he?;
		return he.get;
	}
	
	/*
	 * CSP model Register
	 * com.fredhopper.replication.client.ClientReplicationJob.receiveItemFragment(DataInputStream, int, ClientReplicationItem)
	 */
	Maybe<FileSize> processFile(List<String> id) {
		Maybe<FileSize> result = Nothing;
		Bool hasfile = this.hasFile(id);
		if (hasfile) {
			Fut<FileContent> contentf = db!getContent(id); await contentf?;
			FileContent content = contentf.get; 
			if (isFile(content)) {
				FileSize size = content(content);
				result = Just(size);				
			}
		}
		return result;
	}  
	
	Unit overwrite(File file) {
		FileId id = fst(file);
		FileSize size = fileContent(file);
		Fut<Unit> u = db!updateFile(id,size); await u?;
	}
	
	Unit continue(File file) {
		FileId id = fst(file);
		FileSize size = fileContent(file);
		
		Bool he = this.hasFile(split(id,fileSep()));
		FileSize fsize = 0;
		if (he) {
			Fut<FileContent> s = db!getContent(nameToPath(fst(file))); await s?;
			FileContent c = s.get;
			fsize = content(c);		
		}
		
		size = size + fsize;
		Fut<Unit> u = db!updateFile(id,size); await u?;
	}
	
	Unit processContent(File file) {
		await isAppendCommand(command);
		if (command == SkipFile) {
			skip;
		} else if (command == OverwriteFile) {
			this.overwrite(file);
		} else if (command == ContinueFile) {
 			this.continue(file);
		}
	}  
	
	Unit command(Command c) {
		if (c == StartSnapShot) {
			start = c;
		} else {
			command = c;
		} 
	}
	
	[Atomic]  
	Unit receiveSchedule(Schedules schedules) {
		String sn = "";
		Schedules ss = schedules;
		while (hasNext(ss)) {
			Pair<Schedules,Schedule> nt = next(ss); ss = fst(nt);
			sn = sn + schedname(snd(nt)) + ", ";
		}
		this.schedules = schedules;
	}
		
}