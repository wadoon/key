module ReplicationSystem.Environment.Files;
export *;

import * from ABS.Scheduler;
import * from ReplicationSystem.Environment.DataTypes;

// transaction histories
type TransactionHistories = List<Transaction>;
type Transaction = Pair<TransactionId,Map<FileId,FileContent>>;

data JobData = 
	JobData(
			String jschedname, //schedule name
			Int waitperiod, //waiting period  
			Int jdeadline, //deadline
			Int jcost, //cost
			Int beforetime, //remaining time before execution
			Int deadlineafter, //deadline after execution
			Int totaltime, //total time spent
			Int jobid //id
	);

def Maybe<JobData> updateJobData(Maybe<JobData> jd, Int cost, Int currentDeadline, Time current) =
	case jd {
		Just(JobData(a,b,c,d,e,f,g,h)) => 
			Just(JobData(a,b,c,cost,e,currentDeadline,abs(timeValue(current)-g),h));
	};

// test data 
type TestData = Map<TransactionId,Map<FileId,FileContent>>;

// CSP set FileId 
// Used for identifying the file to be replicated
type FileId = String;

// CSP set FileSize
// Java method java.io.File.length()
// Used for identifying the state of the client-side file 
type FileSize = Int;

// CSP name type File
type File = Pair<FileId,FileContent>;
type Directory = Pair<FileId,FileContent>;

// CSP name type Item
// Java class com.fredhopper.replication.server.item.ServerReplicationItem
type ReplicationItem = Pair<TransactionId,Set<File>>;

// A File system structure
// internally file entry is organised hierarchically
// e.g. file 123 is organised 1/2/123 where 1 and 2 are directories
// default root directory id is 0 
// This will be extended once we allowed file ids as strings like "12/34/56".
type FileEntry = Map<FileId,FileContent>;

// Get a set of entries from this map
def Set<Pair<A,B>> entrySet<A,B>(Map<A,B> m) =
	case m {
		EmptyMap => EmptySet;
		InsertAssoc(x,xs) => Insert(x,entrySet(xs));
	};
	
// qualify an entry with the specified path.
def Pair<FileId,FileContent> qualifyEntry(Pair<FileId,FileContent> e, FileId path) =
	case isDirectory(snd(e)) {
		True => right(fromJust(qualify(Just(Right(e)),path)));
		False => left(fromJust(qualify(Just(Left(e)),path)));
	};
	
def Map<FileId,FileContent> qualifyFileEntry(Map<FileId,FileContent> m, FileId path) =
	case m {
		EmptyMap => EmptyMap;
		InsertAssoc(x,xs) => InsertAssoc(qualifyEntry(x,path),qualifyFileEntry(xs,path));
	};

def Map<String,Schedule> schedulemap(Schedules ss) =
	case ss {
		EmptySet => EmptyMap;
		Insert(x,xs) =>
			case x {
				NoSchedule => schedulemap(xs);
				_ => InsertAssoc(Pair(schedname(x),x),schedulemap(xs)); 
			}; 
	};
	
def String businesses() = "Business rules";
def String datas() = "Data";
def String search() = "Search";		 
			 
// Java com.fredhopper.replication.server.SyncServerSchedule
data Schedule = Schedule(
		String schedname, 
		List<Item> items, 
		Int sched, 
		Deadline dline) | NoSchedule;

data Item = 
	  SearchItem(FileId) | //top level directory
	  FileItem(FileId, String) | //top level directory, pattern, checkpoint
	  LogItem(FileId); //for now log item is the same as search item

def Bool isSearchItem(Item s) = case s { SearchItem(_) => True; _ => False; };
def Bool isFileItem(Item s) = case s { FileItem(_,_) => True; _ => False; };
def Bool isLogItem(Item s) = case s { LogItem(_) => True; _ => False; };

def Pair<Set<Schedule>, Schedule> getScheduleSet(Set<Schedule> ss, String n) = getSSet(ss, ss, n);
def Pair<Set<Schedule>, Schedule> getSSet(Set<Schedule> re, Set<Schedule> ss, String n) =
	case ss {
		EmptySet => Pair(re, NoSchedule);
		Insert(x,xs) => 
			case schedname(x) == n {
				True => Pair(remove(re, x), x);
				False => getSSet(re, xs, n); 
			};
	};

def Maybe<Schedule> getSchedule(List<Schedule> ss, String n) =
	case ss {
		Nil => Nothing;
		Cons(x,xs) => 
			case schedname(x) == n {
				True => Just(x);
				False => getSchedule(xs,n); 
			};
	};

/*
  @param ss a list of existing schedules, 
  @param ts a map of schedule name to scheduling and deadlines
  @param im a list of schedule name to replication items
  @return a list of schedules ss' with replication items described in im added

  @ensures (\forall Pair<String,List<Item>> i; contains(listToSet(im),i) ==> 
  				\exists Schedule s; contains(listToSet(\result),s) && schedname(s) == fst(i));
*/					       
def List<Schedule> itemMapToSchedule(
		List<Schedule> ss,
		Map<String,Pair<Int,Deadline>> ts,
		List<Pair<String,List<Item>>> im) =
	case im {
		Nil => ss;
		Cons(Pair(x,y),xs) => 
			let (Maybe<Schedule> s) = getSchedule(ss,x) in
			case s {
				Just(k) => 
					itemMapToSchedule(
						Cons(Schedule(schedname(k),concatenate(y,items(k)),sched(k),dline(k)), 
							 without(ss,k)),removeKey(ts,x),xs);
				Nothing => 
					let (Pair<Int,Deadline> p) = lookupUnsafe(ts,x) in
					itemMapToSchedule(
						Cons(Schedule(x,y,fst(p),snd(p)),ss),
							 removeKey(ts,x),xs);
			}; 
	};

def Schedules insertReplicationItemsTo(Schedules ss, String name, List<Item> items) =
	case ss {
		EmptySet => EmptySet;
		Insert(x,xs) => 
			case schedname(x) == name {
				True => Insert(insertReplicationItems(x,items),xs);
				False => Insert(x,insertReplicationItemsTo(xs,name,items));
			};
	};

def Schedule insertReplicationItems(Schedule s, List<Item> items) =
	case s {
		Schedule(n,ll,d,e) => Schedule(n,concatenate(ll,items),d,e);
	}; 

def Set<Item> scheduleItems(Schedules ss) =
	case ss {
		EmptySet => EmptySet;
		Insert(x,xs) => union(listToSet(items(x)),scheduleItems(xs));
	};

def Either<FileId,Pair<FileId,String>> item(Item s) = 
	case s { 
		SearchItem(i) => Left(i); 
		FileItem(i,r) => Right(Pair(i,r));
		LogItem(i) => Left(i); 
	};
	
// a set of schedules
type Schedules = Set<Schedule>;

// seems cannot use type synonym Either
data FileContent = Content(FileSize content) | Entries(FileEntry entries) | NoContent; 

// if id1 is an ancester of id2
def Bool isAncester(FileId id1, FileId id2) = 
	isPrefix(deroot(split(id2,fileSep())),deroot(split(id1,fileSep()))); 
	 
def List<String> deroot(List<String> path) =
	let (FileId r) = rootId() in case path { Cons(r,ps) => ps; _ => path; };

def File file(FileId i, FileSize s) = Pair(i,Content(s));
def Directory rootDir() = emptyDir(rootId());
def Directory emptyDir(FileId i) = Pair(i,Entries(EmptyMap));
def Directory dir(FileId i, FileEntry e) = Pair(i,Entries(e));

def String fileSep() = "/";
def FileId rootId() = "root";
def Bool isFile(FileContent c) = case c { Content(_) => True; _ => False; };
def Bool isDirectory(FileContent c) = ~isFile(c);

def List<String> nameToPath(String name) = split(name,fileSep());

// partial
def FileSize fileContent(File f) = content(snd(f));

// partial
def FileEntry dirContent(Directory f) = entries(snd(f));
	
def FileId getFileId(Either<File,Directory> f) =
	case f {
		Left(Pair(id,_)) => id;
		Right(Pair(id,_)) => id;
	};

def FileContent getFileContent(Either<File,Directory> f) =
	case f {
		Left(Pair(_,s)) => s;
		Right(Pair(_,fs)) => fs;
	};
	
def Either<File,Directory> makeContent(Pair<FileId,FileContent> content) =
	case isFile(snd(content)) {
		True => Left(content);
		False => Right(content);
	};

// given a/b and c returns a/b/c
def FileId makePath(FileId dir, FileId f) = dir + fileSep() + f;
def FileId makePaths(List<String> fs) = 
	case fs {
		Nil => "";
		Cons(f,Nil) => f;
		Cons(f,gs) => f + fileSep() + makePaths(gs);
	};

// given a/b/c returns (a/b,c)
def Pair<FileId,FileId> splitFileId(FileId f) = Pair(dirName(f),fileName(f));

// given a/b/c returns c
def FileId fileName(FileId f) = head(reverse(split(f,fileSep())));

// given a/b/c returns a/b
def FileId dirName(FileId f) = makePaths(reverse(tail(reverse(split(f,fileSep())))));	

// get fully qualified file ids from the suppied directory recursively
def Set<FileId> getFileIdFromDir(Directory d) = 
	case snd(d) { 
		Entries(e) => 
			case fst(d) == rootId() {
				True => getFileIdFromEntries1(e);
				False => getFileIdFromEntries(fst(d),e);
			};
	};
	
def Set<FileId> getFileIdFromEntries1(FileEntry fe) =
	case fe {
		EmptyMap => EmptySet;
		InsertAssoc(Pair(i,c),fs) => 
			case isFile(c) {
				True => Insert(i,getFileIdFromEntries1(fs));
				False => union(getFileIdFromEntries(i,entries(c)),getFileIdFromEntries1(fs));
			};
	};
	
def Set<FileId> getFileIdFromEntries(FileId id, FileEntry fe) =
	case fe {
		EmptyMap => EmptySet;
		InsertAssoc(Pair(i,c),fs) => 
			case isFile(c) {
				True => Insert(makePath(id,i),getFileIdFromEntries(id,fs));
				False => union(getFileIdFromEntries(makePath(id,i),entries(c)),getFileIdFromEntries(id,fs));
			};
	};

// find a file given the file name	
def Bool hasEntriesIn(Directory d, FileId id) = case snd(d) { Entries(e) => hasEntry(e,id); };
def Bool hasEntry(FileEntry f, FileId id) = isJust(findFromEntry(f,id));

// find either a file or a directory (if it exists) given
// the file name
def Maybe<Either<File,Directory>> findFromEntryIn(Directory d, FileId id) = 
	case snd(d) { Entries(e) => findFromEntry(e,id); };

// find either a file or a directory (if it exists) given
// the file name
def Maybe<Either<File,Directory>> findFromEntry(FileEntry f, FileId id) =
	case contains(keys(f),id) {
		True =>
			case lookupUnsafe(f,id) {
				Content(s) => makeMaybeEitherValue(True,id,Content(s)); // leaf
				Entries(e) => makeMaybeEitherValue(False,id,Entries(e)); // leaf
			};
		False => 
			case f {
				InsertAssoc(Pair(i,Content(_)),fm) => findFromEntry(fm,id);
				InsertAssoc(Pair(i,Entries(g)),fm) => 
						case findFromEntry(g,id) {
							Nothing => findFromEntry(fm,id); //next path
							r => qualify(r,i);
						};
				EmptyMap => Nothing; // end of listing
			};	 
	};
	
// prefix id of 'r' with 'path'
def Maybe<Either<File,Directory>> qualify(Maybe<Either<File,Directory>> r, FileId path) =
	case r {
		Just(h) =>
			let (FileId hi) = makePath(path,getFileId(h)) in
			let (FileContent hc) = getFileContent(h) in
			case h {
				Left(_) => makeMaybeEitherValue(True,hi,hc);
				Right(_) => makeMaybeEitherValue(False,hi,hc);
			}; 
		Nothing => Nothing;
	};
	
def Maybe<Either<File,Directory>> makeMaybeEitherValue(Bool isfile, FileId id, FileContent c) =
	case isfile {
		True => Just(Left(Pair(id,c)));
		_ => Just(Right(Pair(id,c)));
	};

def Bool hasQualifiedEntriesInList(Directory d, List<String> qualified) =
	case snd(d) { Entries(e) => hasQualifiedEntryInList(e,qualified); };
	
def Bool hasQualifiedEntryInList(FileEntry f, List<String> qualified) = 
	isJust(getFromEntryList(f,qualified));
	
// find a file given its fully qualified path	
def Bool hasQualifiedEntriesIn(Directory d, FileId qualified) = 
	case snd(d) { Entries(e) => hasQualifiedEntry(e,qualified); };
	
def Bool hasQualifiedEntry(FileEntry f, FileId qualified) = 
	isJust(getFromEntry(f,qualified));

// get content at the specified fully qualified path
// content may be the size of a file at the specified fully qualified path
// or the set of files (filename-size pairs) contained in the directory at 
// the specified fully qualified path
def Maybe<FileContent> getFromEntryIn(Directory d, FileId qualified) =
	getFromEntryInList(d, split(qualified,fileSep()));

def Maybe<FileContent> getFromEntryInList(Directory d, List<String> qualified) = 
	case snd(d) { 
		Entries(e) => 
			case fst(d) == rootId() {
				True => getFromEntryList(e,qualified); //root id '0' is disregard
				_ => getFromEntryList(InsertAssoc(d,EmptyMap),qualified); 
			};
	};

// get the content (if it exists) from a fully qualified path
def Maybe<FileContent> getFromEntry(FileEntry entry, FileId qualified) = 
	getFromEntryList(entry, split(qualified,fileSep()));

def Maybe<FileContent> getFromEntryList(FileEntry entry, List<String> paths) = 
	if length(paths) <= 0 then Nothing
	else if ~contains(keys(entry),head(paths)) then Nothing
		 else let (FileContent cc) = lookupUnsafe(entry,head(paths)) in
			  if length(tail(paths)) == 0 then Just(cc) // at node
			  else case cc {
						// qualified is of form 'a/b/...' 
						// but at this level 'a' is a file and not a directory
						Content(_) => Nothing; 
						// else we are on the right track
						// go to the subdirectory
						Entries(e) => getFromEntryList(e,tail(paths));
			   		};  
	
def Directory updateDirWithContent(Directory d, FileId i, FileContent c) = updateDirWith(d,makeContent(Pair(i,c)));
def Directory updateDirWithContents(Directory d, Map<FileId,FileContent> contents) =
	case contents {
		EmptyMap => d;
		InsertAssoc(Pair(i,c),cs) => updateDirWithContents(updateDirWithContent(d,i,c),cs);
	};

// Update a directory with a file (a file is a pair of full qualified path and size)
def Directory updateDirWithFile(Directory d, File f) = updateDirWith(d,Left(f));

// Update a directory with a directory
def Directory updateDirWithDir(Directory d, Directory f) = updateDirWith(d,Right(f));

// Update a directory with either a directory or a file
// COSTABS ANNOTATION
[d >= 0][f>=0][result() >=0][result() <= d+2*f+1]
def Directory updateDirWith(Directory d, Either<File,Directory> f) = case snd(d) { Entries(e) => Pair(fst(d),Entries(updateFile(e,f))); };

def FileEntry updateFile(FileEntry fe, Either<File,Directory> f) = 
	updateFile1(fe,getFileContent(f),deroot(split(getFileId(f),fileSep())));
	
def FileEntry updateFile1(FileEntry fe, FileContent c, List<String> path) =
	case path {
		Nil => fe;
		Cons(p,Nil) => put(fe,p,c);
		Cons(p,ps) =>
			case contains(keys(fe),p) {
				True => 
					case lookupUnsafe(fe,p) {
						Entries(dc) => put(fe,p,Entries(updateFile1(dc,c,ps))); //dir
						_ => put(fe,p,create(ps,c));  //file 
					};
				False => put(fe,p,create(ps,c));
			}; 
	}; 

def FileContent create(List<String> path, FileContent c) =
	case path {
		Cons(p,Nil) => Entries(InsertAssoc(Pair(p,c),EmptyMap));
		Cons(p,ps) => Entries(InsertAssoc(Pair(p,create(ps,c)),EmptyMap));
	};
	
	
//apply all changes from th upto and include id to d 
//histories must be in accending order [(1,c1),(2,c2),...,(n,cn)]
def Directory applyChanges(Directory d, TransactionHistories th, TransactionId id) =
	case th {
		Nil => d;
		Cons(x,xs) => 
			case fst(x) <= id {
				True => applyChanges(updateDirWithContents(d,snd(x)),xs,id);
				False => d;
			};
	};