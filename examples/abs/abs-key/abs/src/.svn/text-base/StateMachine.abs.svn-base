module ReplicationSystem.Environment.StateMachine;

export *;

import * from ReplicationSystem.Environment.Files;

data State = 
	Start | WaitToBoot | Booting | 
	WaitToReplicate| WorkOnReplicate | End |
	ManyWaitToReplicate(Schedule) | 
	ManyWorkOnReplicate(Schedule) | 
	ManyEnd(Schedule);
	
def String stateToString(State s) =
	case s {
		Start => "Start";
		WaitToBoot => "WaitToBoot";
		Booting => "Booting";
		WaitToReplicate => "WaitToReplicate";
		WorkOnReplicate => "WorkOnReplicate"; 
		End => "End";
	}; 
	
type StateMachine = Map<State,Set<State>>;	
type ManyState = Map<Schedule, State>;
	
def Map<State,Set<State>> stateMachine() =
	let (Pair<State,Set<State>> start) = Pair(Start, set[WaitToBoot]) in
	let (Pair<State,Set<State>> waitToBoot) = Pair(WaitToBoot,	set[Booting,End]) in
	let (Pair<State,Set<State>> booting) = Pair(Booting, set[WaitToBoot,WaitToReplicate,End]) in
	let (Pair<State,Set<State>> waitToReplicate) = Pair(WaitToReplicate, set[WaitToBoot,WorkOnReplicate,End]) in
	let (Pair<State,Set<State>> workOnReplicate) = Pair(WorkOnReplicate, set[WaitToBoot,WaitToReplicate,End]) in
	map[start,waitToBoot,booting,waitToReplicate,workOnReplicate];
	
def Map<State,Set<State>> concurrentStateMachine() =
	let (Pair<State,Set<State>> start) = Pair(Start, set[WaitToBoot]) in
	let (Pair<State,Set<State>> waitToBoot) = Pair(WaitToBoot, set[Booting,End]) in
	let (Pair<State,Set<State>> booting) = Pair(Booting, set[WaitToBoot,WaitToReplicate,End]) in
	map[start,waitToBoot,booting];

def Map<Schedule,State> setWaitToReplicate(Set<Schedule> ss) =
	case ss {
		EmptySet => EmptyMap;
		Insert(x,xs) => InsertAssoc(Pair(x,ManyWaitToReplicate(x)),setWaitToReplicate(xs));
	};
	
def Map<State,Set<State>> makeManyStates(Schedules sched) =
	case sched {
		EmptySet => EmptyMap;
		Insert(x,xs) =>	
			InsertAssoc(
				Pair(ManyWaitToReplicate(x),set[ManyWorkOnReplicate(x),ManyEnd(x)]),
				InsertAssoc(
					Pair(ManyWorkOnReplicate(x),set[ManyWaitToReplicate(x),ManyEnd(x)]),
					makeManyStates(xs)));
	};