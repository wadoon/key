module ReplicationSystem.Server.ConnectionThread;

export ConnectionThreadImpl;

import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.ReplicationSnapshot.Interfaces;

import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Server.Interfaces;

import * from ReplicationSystem.Schedulers;
import * from ReplicationSystem.Server.SyncServerAcceptor;

[COG]  
class ConnectionThreadImpl(
		[Far] ClientJob job, 
		[Far] SyncServer server, 
		Int id) implements ConnectionThread {

	//@ invariant server != null; 
	//@ invariant job != null;

	SyncServerClientCoordinator coord;
	Maybe<Command> cmd = Nothing;
	Schedules schedules = EmptySet;
	
	//@ requires this.schedules != EmptySet;
    //@ requires this.coord != null;
	//@ ensures contains(this.coord.thread, this); 
	//@ ensures size(this.coord.thread) == size(\old(this.coord.thread)) + 1;  
    //@ ensures server.getReplicationSnapshot().getIndexingId() >=
	//@				 \old(server.getReplicationSnapshot().getIndexingId());
	ReplicationSnapshot startReplicationUpdate() {
		// register and refresh snapshot
		Fut<Unit> rp = coord!startReplicationUpdate(this); await rp?;
		
		Fut<ReplicationSnapshot> sp = server!getReplicationSnapshot();
		return sp.get;
	}
	
	//@ ensures ! contains(this.coord.thread, this); 
	//@ ensures contains(\old(this.coord.thread), this) ==> 
	//@				size(this.coord.thread) == size(\old(this.coord.thread)) - 1 &&
    //@			! contains(\old(this.coord.thread), this) ==> 
	//@				size(this.coord.thread) == size(\old(this.coord.thread));
    Unit finishReplicationUpdate() {
		Fut<Unit> rp = this.coord!finishReplicationUpdate(this); await rp?;
	}
	
	//If cmd is to send specific schedule (not just ListSchedule)
	//then all files in all replication items (ServerReplicationItem) must be
	//transferred to SyncClient via ClientJob
	//@ ensures cmd != Nothing && cmd != Just(ListSchedule) ==> 
	//@		(\forall ServerReplicationItem item; 
	//@			contains(lookupDefault(server.snapshot.data, ssname(fromJust(cmd)), EmptySet), item) ==>
	//@				(\forall File f; 
	//@					 hasQualifiedEntry(item.entry, fst(f)) && 
	//@					 isFile(getFromEntry(item.entry, fst(f))) &&
	//@					 content(getFromEntry(item.entry, fst(f))) == fileContent(f) ==>
	//@					 	lookup(job.map, fst(f)) != Nothing &&
	//@					 	lookupUnsafe(job.map, fst(f)) != Nothing &&
	//@					 	fromJust(lookupUnsafe(job.map, fst(f))) == fileContent(f)));
	//@					 
	Unit run() {
		Fut<SyncServerClientCoordinator> c = server!getCoordinator(); await c?;
		this.coord = c.get;
		
		// wait for client's command
		await this.cmd != Nothing;
		
		// Send schedules
		schedules = this.sendSchedule();
		
		if (cmd != Just(ListSchedule)) {
			// Get replication items
			ReplicationSnapshot snapshot = this.startReplicationUpdate();
			
			Fut<TransactionId> idf = snapshot!getIndexingId(); await idf?;
			TransactionId tid = idf.get;
			
			Fut<Bool> b = job!registerReplicationItems(tid); await b?;
			Bool register = b.get;
			
			Set<Set<File>> filesets = EmptySet;
			if (register) {
				Fut<Set<ServerReplicationItem>> nis = snapshot!getItems(ssname(fromJust(cmd)));	
				await nis?; Set<ServerReplicationItem> newitems = nis.get;
				filesets = this.registerItems(newitems);
			}
			
			// start snapshot
			Fut<Unit> rp = this.job!command(StartSnapShot); await rp?;
			
			//@ decreasing size(filesets);
			while (hasNext(filesets)) {
				Pair<Set<Set<File>>,Set<File>> nfs = next(filesets);
				filesets = fst(nfs);
				Set<File> fileset = snd(nfs); 
				this.transferItems(fileset);
			}
			
			// end snapshot		
			rp = this.job!command(EndSnapShot); await rp?;
			
			// tidy up
			this.finishReplicationUpdate();
		}
	}
	
	// send one or more schedules to client job
	//@ requires cmd != Nothing;
	//@ ensures fromJust(cmd) != ListSchedule ==> size(\result) == 1;
	//@ ensures this.job.ss == Just(\result);
	Schedules sendSchedule() {
		assert isJust(cmd);
		Schedules results = EmptySet;
		if (cmd == Just(ListSchedule)) {
			Fut<Schedules> ssf = server!listSchedules();
			await ssf?; results = ssf.get;
		} else { 
			Fut<Schedule> ssf = server!getSchedule(ssname(fromJust(cmd)));
			await ssf?; Schedule s = ssf.get;
			results = Insert(s,results);
		}
		Fut<Unit> rp = this.job!receiveSchedule(results); await rp?;
		return results;
	}
	
	ClientId forClient() {
		Fut<ClientId> id = job!forClient();
		return id.get;
	}
	
	Unit command(Command c) { 
		this.cmd = Just(c); 
	}
	
	/*
	 * Register replication items with client 
	 * Returns a set of files to be replicated
	 */
	//@ assignable \nothing;
	//@ ensures (\forall Set<File> fs; contains(\result, fs) ==>
	//@				(\forall File f; contains(fs, f) ==> (\exists ServerReplicationItem item; 
	//@					contains(items, item) && hasQualifiedEntry(item.entry, fst(f)))));
	//@ ensures (\forall ServerReplicationItem item; contains(items, item) ==>
	//@				(\exists Set<File> fs; contains(\result, fs) &&
	//@					(\exists File f; contains(fs, f) && hasQualifiedEntry(item.entry, fst(f)))));  
	Set<Set<File>> registerItems(Set<ServerReplicationItem> items) {
		Set<Set<File>> regs = EmptySet;	
	
		//iterate over possible check points
		while (hasNext(items)) {
			Pair<Set<ServerReplicationItem>,ServerReplicationItem> nis = next(items);
			items = fst(nis);
			ServerReplicationItem item = snd(nis);

			// For now convert to a set
			// will convert it into directory
			Fut<FileEntry> entryf = item!getContents(); await entryf?;
			FileEntry entry = entryf.get;
			
			Set<File> result = EmptySet;
			Set<FileId> ids = getFileIdFromEntries1(entry);
			while (hasNext(ids)) {
				Pair<Set<FileId>,FileId> nids = next(ids);
				FileId id = snd(nids);
				Maybe<FileContent> content = getFromEntry(entry,id);
				result = Insert(Pair(id,fromJust(content)),result);
				ids = fst(nids);
			}
			
			regs = Insert(result,regs);
		}
		
		return regs;
	}
	
	//@ assignable job;
	//@ ensures \forall File f; contains(fileset, f) ==>
	//@		(lookupDefault(job.map, fst(f), Nothing) != Nothing && 
	//@		 lookupUnsafe(job.map, fst(f)) != Nothing &&
	//@		 fromJust(lookupUnsafe(job.map, fst(f))) == filecontent(f);
	Unit transferItems(Set<File> fileset) {
		while (hasNext(fileset)) {
			Pair<Set<File>,File> nf = next(fileset); 
			fileset = fst(nf);
			File file = snd(nf);
			FileSize tsize = fileContent(file);
			
			Fut<Unit> rp = job!command(AppendSearchFile); await rp?;
			Fut<Maybe<FileSize>> fs = job!processFile(nameToPath(fst(file))); await fs?;
			Maybe<FileSize> content = fs.get;
			
			FileSize size = 0;
			if (isJust(content)) { 
				size = fromJust(content);
			}
			
			if (size > tsize) {
				rp = job!command(OverwriteFile);
				await rp?;
				rp = job!processContent(file);
				await rp?;
			} else {
				// find out how much is still need to be replicated
				if (tsize - size > 0) {
					rp = job!command(ContinueFile);
					await rp?;
					
					file = file(fst(file),tsize - size);
					rp = job!processContent(file);
					await rp?;
				} else {
					rp = job!command(SkipFile);
					await rp?;
				}
			}

		}
		Fut<Unit> rp = job!command(EndSearchFile); await rp?;
	}
}