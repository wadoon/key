module ReplicationSystem.Client;

export *;

import * from ReplicationSystem.Environment.DataTypes;
import * from ReplicationSystem.Environment.Files;
import * from ReplicationSystem.Environment.StateMachine;

import * from ReplicationSystem.Client.Interfaces;
import * from ReplicationSystem.Interfaces;
import * from ReplicationSystem.Server.Interfaces;
import * from ReplicationSystem.Environment.Interfaces;

import * from ReplicationSystem.Environment.DataBases;
import * from ReplicationSystem.Client.ClientJob;
import * from Replication.Network;
import * from ReplicationSystem.Schedulers;

// Implementation of SyncClient 
// Java class com.fredhopper.application.SyncClient
[COG]
class SyncClientImpl(
	[Final] Int maxJobs, 
	[Final] ClientId id) implements InternalClient, ClientConnector {
	
	StateMachine machine = stateMachine();
	State state = Start;
	
	Network network;
	SyncServerAcceptor acceptor;
	ClientDataBase db;
	
	Bool shutDown = False;
	Bool next = False;
	Set<ClientJob> jobRecords = EmptySet;
	
	//measurement
	List<ClientJob> jobHistories = Nil;
	List<JobData> jobDatas = Nil;
	List<Schedule> hit = Nil;
	List<Schedule> missed = Nil;
	
	String currentState = "";
	Int currentTransactionId = -1;
	
	{
		// initialize the client side data base
		db = new DataBaseImpl();
	}
	
	[Atomic]
	Int jobCount() {
		return length(jobHistories);
	}
	
	Unit scheduleJob(JobType jb, Schedule schedule) {
		// wait for its time to be initiated
		// and the next available slot
		this.waitFor(schedule);
		
		// only proceed if a shutdown 
		// request has not been made.
		if (~shutDown) {
			// block subsequent onces
			this.setNext(schedule);
			this.makeJob(jb,schedule);
			hit = Cons(schedule,hit);
		} else {
			//record those schedules that are missed
			missed = Cons(schedule,missed);
		}
		
	}
	
	Unit setNext(Schedule schedule) {
		next = False;
	}
	
	Unit waitFor(Schedule schedule) {
		await next || shutDown;
	}
	
	Unit makeJob(JobType jb, Schedule schedule) {
		ClientJob job = new cog ClientJobImpl(maxJobs,this,jb,schedule,length(jobHistories));
		job!executeJob();
			
		jobHistories = Cons(job,jobHistories);
		jobRecords = Insert(job,jobRecords);
	}
	
	Unit finishJob(ClientJob job) {
		jobRecords = remove(jobRecords,job);
	}
	
	Unit nextJob() {
		next = True;
	}
	
	ClientId getId() {
		return id;
	}
	
	Bool isShutdownRequested() {
		return shutDown;
	}
	
	Unit requestShutDown() {
		shutDown = True;
		await jobRecords == EmptySet;
		if (network != null) network!shutDown(this);
	}
		
	SyncServerAcceptor getAcceptor() {
		return acceptor;
	}
	
	Unit run() {
		// Makes a transition
		this.becomesState(WaitToBoot);
		
		// wait for acceptor to be ready
		await acceptor != null;
			
		// starts a boot job
		this.makeJob(Boot,NoSchedule);
	}
	
	ClientDataBase getClientDataBase() {
		return db;
	}
	
	DataBase getDataBase() {
		return db;
	}
	
	Unit becomesState(State state) {
		Set<State> tos = lookupDefault(machine,this.state,EmptySet);
		assert tos != EmptySet; // this is an end state
		assert contains(tos,state); // cannot proceed to specified state
		this.state = state;	
	}
	
	Unit setAcceptor([Far] SyncServerAcceptor acc) {
		acceptor = acc;
	}
	
	Unit setNetwork(Network network) {
		this.network = network;
	}
	
	Unit waitToBoot() { 
		this.becomesState(WaitToBoot);
	}
	
	Unit boot() { 
		this.becomesState(Booting);
	}
	
	Unit start() { 
		this.becomesState(Booting);
	}
	
	Unit waitToReplicate() { 
		this.becomesState(WaitToReplicate);
	}
	
	Unit replicate() { 
		this.becomesState(WorkOnReplicate);
	}
	
	Unit end() { 
		this.becomesState(End);
		this!requestShutDown();
	}
	
		
}