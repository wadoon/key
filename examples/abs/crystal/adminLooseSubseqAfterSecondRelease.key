// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2009 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
// Input file for KeY standalone prover version 0.497

\absSource ".";

\module "CV";
\class "Adm";

\functions{

  Seq some{true}(Seq);

}

\predicates {

   looseSubseq(Seq, Seq);
  
}

\programVariables {
	CV.AdmI this;
	String s;
}

\rules {

  looseSubseqBase {
      \schemaVar \term Seq seq;
      
      \find (looseSubseq(seqEmpty, seq)) 
      \replacewith(true)

      \heuristics (concrete)
  };


  looseSubseqLenSubSmallerThanLenSeq1 {
      \schemaVar \term Seq seq;
      \schemaVar \term Seq sub;

      \find (looseSubseq(sub, seq) ==>) 
      \add(seqLen(sub) <= seqLen(seq) ==>)
  };

  looseSubseqLenSubSmallerThanLenSeq2 {
      \schemaVar \term Seq seq;
      \schemaVar \term Seq sub;

      \find (==> looseSubseq(sub, seq)) 
      \replacewith(==> \if (seqLen(sub) <= seqLen(seq)) \then (looseSubseq(sub, seq))
      		       \else (false) )

  };

  looseSubseqDefStep {
      \schemaVar \term Seq sub;
      \schemaVar \term Seq seq;
      
      \find (looseSubseq(sub, seq)) 
      \replacewith(seqLen(sub) <= seqLen(seq) & 
                   \if (sub = seqEmpty) \then (true)
                   \else (
		      \if (any::seqGet(sub, seqLen(sub)-1) = any::seqGet(seq, seqLen(seq)-1))
      		      \then (looseSubseq(seqSub(sub, 0, seqLen(sub)-2), seqSub(seq, 0, seqLen(seq)-2)))
      		      \else (looseSubseq(sub, seqSub(seq, 0, seqLen(seq)-2))))
		   )

  };



}


\problem {
\forall ABSAnyInterface concreteCaller;\forall ABSAnyInterface concreteProf;\forall Future concreteFutureD;\forall Future concreteFutureU;\forall Future concreteFutureU2;\forall Seq newHistory;
(

\forall Future d; \forall any cv;(
   HistoryLabel::seqGet(history, seqLen(history) - 1 ) =  compEv(this, d, CV.AdmI::req, cv) 
   ->
   \exists ABSAnyInterface c;\exists ABSAnyInterface p;\exists Future u;\exists Future u2;(
   	   looseSubseq(seqConcat(seqSingleton(invocREv(c, this, d, CV.AdmI::req, seqEmpty)), 
                       seqConcat(seqSingleton(invocEv(this, p, u, CV.ProfI::ask, seqEmpty)), 
   		       seqConcat(seqSingleton(compREv(this, u, u2)),
		       seqConcat(seqSingleton(compREv(this, u2, cv)),
		       seqSingleton(compEv(this, d, CV.AdmI::req, cv)))))), history)
   )
  )


->
{history:=seqConcat(history, seqSingleton(invocREv(concreteCaller, this, concreteFutureD, CV.AdmI::req, seqEmpty)))}

{history:=seqConcat(history, seqSingleton(invocEv(this, concreteProf, concreteFutureU, CV.ProfI::ask, seqEmpty)))}

{history:=seqConcat(history, newHistory)}(
  wfHist(history) -> (
    {history:=seqConcat(history, seqSingleton(compREv(this, concreteFutureU, concreteFutureU2)))}
       \forall Future d; \forall any cv;(
       	       HistoryLabel::seqGet(history, seqLen(history) - 1 ) =  compEv(this, d, CV.AdmI::req, cv) 
   	       ->
   	       \exists ABSAnyInterface c;\exists ABSAnyInterface p;\exists Future u;\exists Future u2;(
   	       	       looseSubseq(seqConcat(seqSingleton(invocREv(c, this, d, CV.AdmI::req, seqEmpty)), 
                          seqConcat(seqSingleton(invocEv(this, p, u, CV.ProfI::ask, seqEmpty)), 
   		       	  seqConcat(seqSingleton(compREv(this, u, u2)),
		       	  seqConcat(seqSingleton(compREv(this, u2, cv)),
		       	  seqSingleton(compEv(this, d, CV.AdmI::req, cv)))))), history)
   	       )
       )
  )
)
)
}


