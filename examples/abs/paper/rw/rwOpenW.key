// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2009 Universitaet Karlsruhe, Germany
//                         Universitaet Koblenz-Landau, Germany
//                         Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
// Input file for KeY standalone prover version 0.497

\absSource ".";

\module "RW";
\class "RWController";

\functions{

//  Seq some{true}(Seq);
  Seq Readers(Seq);
  Seq getWriters(Seq/*History*/);
}

\predicates {
   containsWriter(Seq, any, any);
   looseSubseq(Seq, Seq);
}

\programVariables {
//   RW.RWinterface this;
//   ABS.StdLib.Fut future;
//   ABS.StdLib.Unit result;
}

\rules {

  // getWriter
  getWritersForEmptyHistory {

      \find (getWriters(seqEmpty))
      \replacewith(seqEmpty)
      \heuristics (concrete)

  };

  getWritersForSingleton {
      \schemaVar \term HistoryLabel ev;

      \find (getWriters(seqSingleton(ev)))
      \replacewith(\if (!isCompletionEv(ev) | !getMethod(ev) = RW.RWinterface::openW#RW.CallerI) 
      		   \then ( seqEmpty ) 
		   \else ( 
		      seqSingleton(getCaller(getInvocationReactionEventForFuture(history, getFuture(ev))))
		   ) ) 
      \heuristics (simplify)

  };


  getWritersDependencies {
      \schemaVar \term Seq historySV;
      \schemaVar \term HistoryLabel ev;
      \find (getWriters(seqConcat(historySV, seqSingleton(ev))))
      \replacewith(\if (!isCompletionEv(ev) & !isInvocationREv(ev)) 
      		   \then ( getWriters(historySV) ) 
		   \else ( getWriters(seqConcat(historySV, seqSingleton(ev))) ) )
  };

/*  getWritersForConcate {
      \schemaVar \term Seq historySV1, historySV2;
      \schemaVar \term HistoryLabel ev;
      \find (getWriters(seqConcat(historySV1, historySV2)))
      \replacewith(seqConcat(getWriters(historySV1), getWriters(historySV2)))
      \heuristics(simplify_enlarging) 
  };

  getWritersLength {
      \schemaVar \term Seq historySV1, historySV2;
      \find (seqLen(getWriters(seqConcat(historySV1, historySV2))))
      \replacewith(seqLen(getWriters(historySV1)) + seqLen(getWriters(historySV2)))

      \heuristics (simplify)
  };
*/

  looseSubseqBase {
      \schemaVar \term Seq seq;
      
      \find (looseSubseq(seqEmpty, seq)) 
      \replacewith(true)

      \heuristics (concrete)
  };


  looseSubseqLenSubSmallerThanLenSeq1 {
      \schemaVar \term Seq seq;
      \schemaVar \term Seq sub;

      \find (looseSubseq(sub, seq) ==>) 
      \add(seqLen(sub) <= seqLen(seq) ==>)
  };

  looseSubseqLenSubSmallerThanLenSeq2 {
      \schemaVar \term Seq seq;
      \schemaVar \term Seq sub;

      \find (==> looseSubseq(sub, seq)) 
      \replacewith(==> \if (seqLen(sub) <= seqLen(seq)) \then (looseSubseq(sub, seq))
      		       \else (false) )

  };

  looseSubseqDefStep {
      \schemaVar \term Seq sub;
      \schemaVar \term Seq seq;
      
      \find (looseSubseq(sub, seq)) 
      \replacewith(seqLen(sub) <= seqLen(seq) & 
                   \if (sub = seqEmpty) \then (true)
                   \else (
		      \if (any::seqGet(sub, seqLen(sub)-1) = any::seqGet(seq, seqLen(seq)-1))
      		      \then (looseSubseq(seqSub(sub, 0, seqLen(sub)-2), seqSub(seq, 0, seqLen(seq)-2)))
      		      \else (looseSubseq(sub, seqSub(seq, 0, seqLen(seq)-2))))
		   )

  };

/*  ourPre {
    \schemaVar \term Seq historySV;
    \schemaVar \term Heap heapSV;
    \schemaVar \term any callee, caller;
    \find (Pre(historySV, heapSV, callee))
    \replacewith(caller = getCaller(getInvocationReactionEventForFuture(history, future)))
  };*/

  writersDef {
    \schemaVar \term Seq history;
    \schemaVar \term any self, writer;
    \schemaVar \variables HistoryLabel ev, laterEv;
    \schemaVar \variables int i;

    \find (containsWriter(history, self, writer))
    \varcond(\notFreeIn(laterEv, history, self, writer), 
             \notFreeIn(ev, history, self, writer),
             \notFreeIn(i, history, self, writer))
    \replacewith(
      \if(\exists ev;(isCompletionEv(ev)         & 
                  containsEvent(ev, history) & 
                  getMethod(ev) = RW.RWinterface::openW#RW.CallerI & 
                  writer = getCaller(getInvocationReactionEventForFuture(history, getFuture(ev))) &
                  \forall i;\forall laterEv;(seqIndexOf(history, ev) < i & i<seqLen(history) &  laterEv=HistoryLabel::seqGet(history, i) ->
                                   (!isCompletionEv(laterEv) | getMethod(laterEv) != RW.RWinterface::closeW#RW.CallerI))))
      \then (true) \else (writer = null)
    )
  };


/*  getWritersDef {
    \schemaVar \term Seq history;
    \schemaVar \term any self, writer;
    \schemaVar \variables HistoryLabel ev, laterEv;
    \schemaVar \variables int i;

    \find (getWriters(history))
    \varcond(\notFreeIn(laterEv, history, self, writer), 
             \notFreeIn(ev, history, self, writer),
             \notFreeIn(i, history, self, writer))
    \replacewith(
    seqDef{int j;}(
      \if(\exists ev;(isCompletionEv(ev) & 
                      containsEvent(ev, history) & 
                      getMethod(ev) = RW.RWinterface::openW#RW.CallerI & 
                      writer = getCaller(getInvocationReactionEventForFuture(history, getFuture(ev))) &
                      \forall \forall laterEv;(seqIndexOf(history, ev) < i & i<seqLen(history) &  laterEv=HistoryLabel::seqGet(history, i) ->
                                   (!isCompletionEv(laterEv) | getMethod(laterEv) != RW.RWinterface::closeW#RW.CallerI))))
      \then (singleton(getCaller(getInvocationReactionEventForFuture(history, getFuture(ev))))) 
      \else (emptySeq)
    )
  };*/


}

\chooseContract
